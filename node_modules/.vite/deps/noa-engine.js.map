{
  "version": 3,
  "sources": ["../../../../../node_modules/events/events.js", "../../../../../node_modules/gl-vec3/epsilon.js", "../../../../../node_modules/gl-vec3/create.js", "../../../../../node_modules/gl-vec3/clone.js", "../../../../../node_modules/gl-vec3/fromValues.js", "../../../../../node_modules/gl-vec3/normalize.js", "../../../../../node_modules/gl-vec3/dot.js", "../../../../../node_modules/gl-vec3/angle.js", "../../../../../node_modules/gl-vec3/copy.js", "../../../../../node_modules/gl-vec3/set.js", "../../../../../node_modules/gl-vec3/equals.js", "../../../../../node_modules/gl-vec3/exactEquals.js", "../../../../../node_modules/gl-vec3/add.js", "../../../../../node_modules/gl-vec3/subtract.js", "../../../../../node_modules/gl-vec3/sub.js", "../../../../../node_modules/gl-vec3/multiply.js", "../../../../../node_modules/gl-vec3/mul.js", "../../../../../node_modules/gl-vec3/divide.js", "../../../../../node_modules/gl-vec3/div.js", "../../../../../node_modules/gl-vec3/min.js", "../../../../../node_modules/gl-vec3/max.js", "../../../../../node_modules/gl-vec3/floor.js", "../../../../../node_modules/gl-vec3/ceil.js", "../../../../../node_modules/gl-vec3/round.js", "../../../../../node_modules/gl-vec3/scale.js", "../../../../../node_modules/gl-vec3/scaleAndAdd.js", "../../../../../node_modules/gl-vec3/distance.js", "../../../../../node_modules/gl-vec3/dist.js", "../../../../../node_modules/gl-vec3/squaredDistance.js", "../../../../../node_modules/gl-vec3/sqrDist.js", "../../../../../node_modules/gl-vec3/length.js", "../../../../../node_modules/gl-vec3/len.js", "../../../../../node_modules/gl-vec3/squaredLength.js", "../../../../../node_modules/gl-vec3/sqrLen.js", "../../../../../node_modules/gl-vec3/negate.js", "../../../../../node_modules/gl-vec3/inverse.js", "../../../../../node_modules/gl-vec3/cross.js", "../../../../../node_modules/gl-vec3/lerp.js", "../../../../../node_modules/gl-vec3/random.js", "../../../../../node_modules/gl-vec3/transformMat4.js", "../../../../../node_modules/gl-vec3/transformMat3.js", "../../../../../node_modules/gl-vec3/transformQuat.js", "../../../../../node_modules/gl-vec3/rotateX.js", "../../../../../node_modules/gl-vec3/rotateY.js", "../../../../../node_modules/gl-vec3/rotateZ.js", "../../../../../node_modules/gl-vec3/forEach.js", "../../../../../node_modules/gl-vec3/index.js", "../../../../../node_modules/iota-array/iota.js", "../../../../../node_modules/ndarray/node_modules/is-buffer/index.js", "../../../../../node_modules/ndarray/ndarray.js", "../../../../../node_modules/fast-voxel-raycast/index.js", "../../../../../node_modules/voxel-aabb-sweep/index.js", "../../../../../node_modules/ent-comp/src/dataStore.js", "../../../../../node_modules/ent-comp/src/ECS.js", "../../../../../node_modules/bit-twiddle/twiddle.js", "../../../../../node_modules/dup/dup.js", "../../../../../node_modules/is-buffer/index.js", "../../../../../node_modules/@jpweeks/typedarray-pool/pool.js", "../../../../../node_modules/box-intersect/lib/sort.js", "../../../../../node_modules/box-intersect/lib/sweep.js", "../../../../../node_modules/box-intersect/lib/brute.js", "../../../../../node_modules/box-intersect/lib/partition.js", "../../../../../node_modules/box-intersect/lib/median.js", "../../../../../node_modules/box-intersect/lib/intersect.js", "../../../../../node_modules/box-intersect/index.js", "../../../../../node_modules/noa-engine/src/lib/shims.js", "../../../../../node_modules/noa-engine/src/index.js", "../../../../../node_modules/game-inputs/src/inputs.js", "../../../../../node_modules/game-inputs/package.json", "../../../../../node_modules/noa-engine/src/lib/inputs.js", "../../../../../node_modules/noa-engine/src/lib/container.js", "../../../../../node_modules/micro-game-shell/src/micro-game-shell.js", "../../../../../node_modules/noa-engine/src/lib/camera.js", "../../../../../node_modules/gl-matrix/esm/common.js", "../../../../../node_modules/gl-matrix/esm/mat3.js", "../../../../../node_modules/gl-matrix/esm/vec3.js", "../../../../../node_modules/gl-matrix/esm/vec4.js", "../../../../../node_modules/gl-matrix/esm/quat.js", "../../../../../node_modules/gl-matrix/esm/vec2.js", "../../../../../node_modules/aabb-3d/src/index.ts", "../../../../../node_modules/noa-engine/src/lib/entities.js", "../../../../../node_modules/noa-engine/src/components/position.js", "../../../../../node_modules/noa-engine/src/components/physics.js", "../../../../../node_modules/noa-engine/src/components/collideEntities.js", "../../../../../node_modules/noa-engine/src/components/collideTerrain.js", "../../../../../node_modules/noa-engine/src/components/fadeOnZoom.js", "../../../../../node_modules/noa-engine/src/components/followsEntity.js", "../../../../../node_modules/noa-engine/src/components/mesh.js", "../../../../../node_modules/noa-engine/src/components/movement.js", "../../../../../node_modules/noa-engine/src/components/receivesInputs.js", "../../../../../node_modules/noa-engine/src/components/shadow.js", "../../../../../dev/core/src/Meshes/Builders/discBuilder.ts", "../../../../../dev/core/src/Meshes/instancedMesh.ts", "../../../../../node_modules/noa-engine/src/components/smoothCamera.js", "../../../../../node_modules/noa-engine/src/lib/util.js", "../../../../../dev/core/src/Meshes/thinInstanceMesh.ts", "../../../../../node_modules/noa-engine/src/lib/objectMesher.js", "../../../../../node_modules/noa-engine/src/lib/terrainMesher.js", "../../../../../dev/core/src/Maths/math.size.ts", "../../../../../dev/core/src/Materials/Textures/thinTexture.ts", "../../../../../dev/core/src/Materials/Textures/baseTexture.ts", "../../../../../dev/core/src/Misc/copyTools.ts", "../../../../../dev/core/src/Materials/Textures/texture.ts", "../../../../../dev/core/src/Materials/materialPluginManager.ts", "../../../../../dev/core/src/Materials/materialPluginBase.ts", "../../../../../dev/core/src/Engines/Extensions/engine.rawTexture.ts", "../../../../../dev/core/src/Materials/Textures/rawTexture2DArray.ts", "../../../../../node_modules/noa-engine/src/lib/terrainMaterials.js", "../../../../../node_modules/noa-engine/src/lib/registry.js", "../../../../../node_modules/noa-engine/src/lib/rendering.js", "../../../../../dev/core/src/Culling/Octrees/octreeBlock.ts", "../../../../../dev/core/src/Culling/Octrees/octree.ts", "../../../../../dev/core/src/Culling/ray.ts", "../../../../../dev/core/src/Culling/Octrees/octreeSceneComponent.ts", "../../../../../node_modules/noa-engine/src/lib/sceneOctreeManager.js", "../../../../../dev/core/src/Cameras/targetCamera.ts", "../../../../../dev/core/src/Cameras/cameraInputsManager.ts", "../../../../../dev/core/src/Cameras/Inputs/freeCameraKeyboardMoveInput.ts", "../../../../../dev/core/src/Cameras/Inputs/freeCameraMouseInput.ts", "../../../../../dev/core/src/Cameras/Inputs/BaseCameraMouseWheelInput.ts", "../../../../../dev/core/src/Cameras/Inputs/freeCameraMouseWheelInput.ts", "../../../../../dev/core/src/Cameras/Inputs/freeCameraTouchInput.ts", "../../../../../dev/core/src/Cameras/freeCameraInputsManager.ts", "../../../../../dev/core/src/Cameras/freeCamera.ts", "../../../../../dev/core/src/Lights/light.ts", "../../../../../dev/core/src/Lights/shadowLight.ts", "../../../../../dev/core/src/Lights/directionalLight.ts", "../../../../../dev/core/src/Materials/prePassConfiguration.ts", "../../../../../dev/core/src/Materials/materialDefines.ts", "../../../../../dev/core/src/Materials/pushMaterial.ts", "../../../../../dev/core/src/Materials/materialFlags.ts", "../../../../../dev/core/src/Shaders/ShadersInclude/decalFragmentDeclaration.ts", "../../../../../dev/core/src/Shaders/ShadersInclude/defaultFragmentDeclaration.ts", "../../../../../dev/core/src/Shaders/ShadersInclude/sceneUboDeclaration.ts", "../../../../../dev/core/src/Shaders/ShadersInclude/meshUboDeclaration.ts", "../../../../../dev/core/src/Shaders/ShadersInclude/defaultUboDeclaration.ts", "../../../../../dev/core/src/Shaders/ShadersInclude/prePassDeclaration.ts", "../../../../../dev/core/src/Shaders/ShadersInclude/oitDeclaration.ts", "../../../../../dev/core/src/Shaders/ShadersInclude/mainUVVaryingDeclaration.ts", "../../../../../dev/core/src/Shaders/ShadersInclude/helperFunctions.ts", "../../../../../dev/core/src/Shaders/ShadersInclude/lightFragmentDeclaration.ts", "../../../../../dev/core/src/Shaders/ShadersInclude/lightUboDeclaration.ts", "../../../../../dev/core/src/Shaders/ShadersInclude/lightsFragmentFunctions.ts", "../../../../../dev/core/src/Shaders/ShadersInclude/shadowsFragmentFunctions.ts", "../../../../../dev/core/src/Shaders/ShadersInclude/samplerFragmentDeclaration.ts", "../../../../../dev/core/src/Shaders/ShadersInclude/fresnelFunction.ts", "../../../../../dev/core/src/Shaders/ShadersInclude/reflectionFunction.ts", "../../../../../dev/core/src/Shaders/ShadersInclude/imageProcessingDeclaration.ts", "../../../../../dev/core/src/Shaders/ShadersInclude/imageProcessingFunctions.ts", "../../../../../dev/core/src/Shaders/ShadersInclude/bumpFragmentMainFunctions.ts", "../../../../../dev/core/src/Shaders/ShadersInclude/bumpFragmentFunctions.ts", "../../../../../dev/core/src/Shaders/ShadersInclude/clipPlaneFragmentDeclaration.ts", "../../../../../dev/core/src/Shaders/ShadersInclude/logDepthDeclaration.ts", "../../../../../dev/core/src/Shaders/ShadersInclude/fogFragmentDeclaration.ts", "../../../../../dev/core/src/Shaders/ShadersInclude/clipPlaneFragment.ts", "../../../../../dev/core/src/Shaders/ShadersInclude/bumpFragment.ts", "../../../../../dev/core/src/Shaders/ShadersInclude/decalFragment.ts", "../../../../../dev/core/src/Shaders/ShadersInclude/depthPrePass.ts", "../../../../../dev/core/src/Shaders/ShadersInclude/lightFragment.ts", "../../../../../dev/core/src/Shaders/ShadersInclude/logDepthFragment.ts", "../../../../../dev/core/src/Shaders/ShadersInclude/fogFragment.ts", "../../../../../dev/core/src/Shaders/ShadersInclude/oitFragment.ts", "../../../../../dev/core/src/Shaders/default.fragment.ts", "../../../../../dev/core/src/Shaders/ShadersInclude/decalVertexDeclaration.ts", "../../../../../dev/core/src/Shaders/ShadersInclude/defaultVertexDeclaration.ts", "../../../../../dev/core/src/Shaders/ShadersInclude/uvAttributeDeclaration.ts", "../../../../../dev/core/src/Shaders/ShadersInclude/bonesDeclaration.ts", "../../../../../dev/core/src/Shaders/ShadersInclude/bakedVertexAnimationDeclaration.ts", "../../../../../dev/core/src/Shaders/ShadersInclude/instancesDeclaration.ts", "../../../../../dev/core/src/Shaders/ShadersInclude/prePassVertexDeclaration.ts", "../../../../../dev/core/src/Shaders/ShadersInclude/samplerVertexDeclaration.ts", "../../../../../dev/core/src/Shaders/ShadersInclude/bumpVertexDeclaration.ts", "../../../../../dev/core/src/Shaders/ShadersInclude/clipPlaneVertexDeclaration.ts", "../../../../../dev/core/src/Shaders/ShadersInclude/fogVertexDeclaration.ts", "../../../../../dev/core/src/Shaders/ShadersInclude/lightVxFragmentDeclaration.ts", "../../../../../dev/core/src/Shaders/ShadersInclude/lightVxUboDeclaration.ts", "../../../../../dev/core/src/Shaders/ShadersInclude/morphTargetsVertexGlobalDeclaration.ts", "../../../../../dev/core/src/Shaders/ShadersInclude/morphTargetsVertexDeclaration.ts", "../../../../../dev/core/src/Shaders/ShadersInclude/morphTargetsVertexGlobal.ts", "../../../../../dev/core/src/Shaders/ShadersInclude/morphTargetsVertex.ts", "../../../../../dev/core/src/Shaders/ShadersInclude/instancesVertex.ts", "../../../../../dev/core/src/Shaders/ShadersInclude/bonesVertex.ts", "../../../../../dev/core/src/Shaders/ShadersInclude/bakedVertexAnimation.ts", "../../../../../dev/core/src/Shaders/ShadersInclude/prePassVertex.ts", "../../../../../dev/core/src/Shaders/ShadersInclude/uvVariableDeclaration.ts", "../../../../../dev/core/src/Shaders/ShadersInclude/samplerVertexImplementation.ts", "../../../../../dev/core/src/Shaders/ShadersInclude/bumpVertex.ts", "../../../../../dev/core/src/Shaders/ShadersInclude/clipPlaneVertex.ts", "../../../../../dev/core/src/Shaders/ShadersInclude/fogVertex.ts", "../../../../../dev/core/src/Shaders/ShadersInclude/shadowsVertex.ts", "../../../../../dev/core/src/Shaders/ShadersInclude/vertexColorMixing.ts", "../../../../../dev/core/src/Shaders/ShadersInclude/pointCloudVertex.ts", "../../../../../dev/core/src/Shaders/ShadersInclude/logDepthVertex.ts", "../../../../../dev/core/src/Shaders/default.vertex.ts", "../../../../../dev/core/src/Materials/effectFallbacks.ts", "../../../../../dev/core/src/Materials/material.detailMapConfiguration.ts", "../../../../../dev/core/src/Materials/standardMaterial.ts", "../../../../../dev/core/src/Materials/shaderMaterial.ts", "../../../../../dev/core/src/Shaders/color.fragment.ts", "../../../../../dev/core/src/Shaders/color.vertex.ts", "../../../../../dev/core/src/Meshes/linesMesh.ts", "../../../../../dev/core/src/Meshes/Builders/linesBuilder.ts", "../../../../../dev/core/src/Meshes/Builders/planeBuilder.ts", "../../../../../node_modules/voxel-physics-engine/src/index.js", "../../../../../node_modules/voxel-physics-engine/src/rigidBody.js", "../../../../../node_modules/noa-engine/src/lib/physics.js", "../../../../../node_modules/noa-engine/src/lib/world.js", "../../../../../node_modules/noa-engine/src/lib/chunk.js", "../../../../../node_modules/noa-engine/package.json"],
  "sourcesContent": ["// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      checkListener(listener);\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nfunction once(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function errorListener(err) {\n      emitter.removeListener(name, resolver);\n      reject(err);\n    }\n\n    function resolver() {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error', errorListener);\n      }\n      resolve([].slice.call(arguments));\n    };\n\n    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });\n    if (name !== 'error') {\n      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });\n    }\n  });\n}\n\nfunction addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n  if (typeof emitter.on === 'function') {\n    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\n  }\n}\n\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags.once) {\n      emitter.once(name, listener);\n    } else {\n      emitter.on(name, listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    // EventTarget does not have `error` event semantics like Node\n    // EventEmitters, we do not listen for `error` events here.\n    emitter.addEventListener(name, function wrapListener(arg) {\n      // IE does not have builtin `{ once: true }` support so we\n      // have to do it manually.\n      if (flags.once) {\n        emitter.removeEventListener(name, wrapListener);\n      }\n      listener(arg);\n    });\n  } else {\n    throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n  }\n}\n", "module.exports = 0.000001\n", "module.exports = create;\n\n/**\n * Creates a new, empty vec3\n *\n * @returns {vec3} a new 3D vector\n */\nfunction create() {\n    var out = new Float32Array(3)\n    out[0] = 0\n    out[1] = 0\n    out[2] = 0\n    return out\n}", "module.exports = clone;\n\n/**\n * Creates a new vec3 initialized with values from an existing vector\n *\n * @param {vec3} a vector to clone\n * @returns {vec3} a new 3D vector\n */\nfunction clone(a) {\n    var out = new Float32Array(3)\n    out[0] = a[0]\n    out[1] = a[1]\n    out[2] = a[2]\n    return out\n}", "module.exports = fromValues;\n\n/**\n * Creates a new vec3 initialized with the given values\n *\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @returns {vec3} a new 3D vector\n */\nfunction fromValues(x, y, z) {\n    var out = new Float32Array(3)\n    out[0] = x\n    out[1] = y\n    out[2] = z\n    return out\n}", "module.exports = normalize;\n\n/**\n * Normalize a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a vector to normalize\n * @returns {vec3} out\n */\nfunction normalize(out, a) {\n    var x = a[0],\n        y = a[1],\n        z = a[2]\n    var len = x*x + y*y + z*z\n    if (len > 0) {\n        //TODO: evaluate use of glm_invsqrt here?\n        len = 1 / Math.sqrt(len)\n        out[0] = a[0] * len\n        out[1] = a[1] * len\n        out[2] = a[2] * len\n    }\n    return out\n}", "module.exports = dot;\n\n/**\n * Calculates the dot product of two vec3's\n *\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {Number} dot product of a and b\n */\nfunction dot(a, b) {\n    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2]\n}", "module.exports = angle\n\nvar fromValues = require('./fromValues')\nvar normalize = require('./normalize')\nvar dot = require('./dot')\n\n/**\n * Get the angle between two 3D vectors\n * @param {vec3} a The first operand\n * @param {vec3} b The second operand\n * @returns {Number} The angle in radians\n */\nfunction angle(a, b) {\n    var tempA = fromValues(a[0], a[1], a[2])\n    var tempB = fromValues(b[0], b[1], b[2])\n \n    normalize(tempA, tempA)\n    normalize(tempB, tempB)\n \n    var cosine = dot(tempA, tempB)\n\n    if(cosine > 1.0){\n        return 0\n    } else {\n        return Math.acos(cosine)\n    }     \n}\n", "module.exports = copy;\n\n/**\n * Copy the values from one vec3 to another\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the source vector\n * @returns {vec3} out\n */\nfunction copy(out, a) {\n    out[0] = a[0]\n    out[1] = a[1]\n    out[2] = a[2]\n    return out\n}", "module.exports = set;\n\n/**\n * Set the components of a vec3 to the given values\n *\n * @param {vec3} out the receiving vector\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @returns {vec3} out\n */\nfunction set(out, x, y, z) {\n    out[0] = x\n    out[1] = y\n    out[2] = z\n    return out\n}", "module.exports = equals\n\nvar EPSILON = require('./epsilon')\n\n/**\n * Returns whether or not the vectors have approximately the same elements in the same position.\n *\n * @param {vec3} a The first vector.\n * @param {vec3} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\nfunction equals(a, b) {\n  var a0 = a[0]\n  var a1 = a[1]\n  var a2 = a[2]\n  var b0 = b[0]\n  var b1 = b[1]\n  var b2 = b[2]\n  return (Math.abs(a0 - b0) <= EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&\n          Math.abs(a1 - b1) <= EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&\n          Math.abs(a2 - b2) <= EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)))\n}\n", "module.exports = exactEquals\n\n/**\n * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)\n *\n * @param {vec3} a The first vector.\n * @param {vec3} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\nfunction exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2]\n}\n", "module.exports = add;\n\n/**\n * Adds two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */\nfunction add(out, a, b) {\n    out[0] = a[0] + b[0]\n    out[1] = a[1] + b[1]\n    out[2] = a[2] + b[2]\n    return out\n}", "module.exports = subtract;\n\n/**\n * Subtracts vector b from vector a\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */\nfunction subtract(out, a, b) {\n    out[0] = a[0] - b[0]\n    out[1] = a[1] - b[1]\n    out[2] = a[2] - b[2]\n    return out\n}", "module.exports = require('./subtract')\n", "module.exports = multiply;\n\n/**\n * Multiplies two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */\nfunction multiply(out, a, b) {\n    out[0] = a[0] * b[0]\n    out[1] = a[1] * b[1]\n    out[2] = a[2] * b[2]\n    return out\n}", "module.exports = require('./multiply')\n", "module.exports = divide;\n\n/**\n * Divides two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */\nfunction divide(out, a, b) {\n    out[0] = a[0] / b[0]\n    out[1] = a[1] / b[1]\n    out[2] = a[2] / b[2]\n    return out\n}", "module.exports = require('./divide')\n", "module.exports = min;\n\n/**\n * Returns the minimum of two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */\nfunction min(out, a, b) {\n    out[0] = Math.min(a[0], b[0])\n    out[1] = Math.min(a[1], b[1])\n    out[2] = Math.min(a[2], b[2])\n    return out\n}", "module.exports = max;\n\n/**\n * Returns the maximum of two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */\nfunction max(out, a, b) {\n    out[0] = Math.max(a[0], b[0])\n    out[1] = Math.max(a[1], b[1])\n    out[2] = Math.max(a[2], b[2])\n    return out\n}", "module.exports = floor\n\n/**\n * Math.floor the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a vector to floor\n * @returns {vec3} out\n */\nfunction floor(out, a) {\n  out[0] = Math.floor(a[0])\n  out[1] = Math.floor(a[1])\n  out[2] = Math.floor(a[2])\n  return out\n}\n", "module.exports = ceil\n\n/**\n * Math.ceil the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a vector to ceil\n * @returns {vec3} out\n */\nfunction ceil(out, a) {\n  out[0] = Math.ceil(a[0])\n  out[1] = Math.ceil(a[1])\n  out[2] = Math.ceil(a[2])\n  return out\n}\n", "module.exports = round\n\n/**\n * Math.round the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a vector to round\n * @returns {vec3} out\n */\nfunction round(out, a) {\n  out[0] = Math.round(a[0])\n  out[1] = Math.round(a[1])\n  out[2] = Math.round(a[2])\n  return out\n}\n", "module.exports = scale;\n\n/**\n * Scales a vec3 by a scalar number\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the vector to scale\n * @param {Number} b amount to scale the vector by\n * @returns {vec3} out\n */\nfunction scale(out, a, b) {\n    out[0] = a[0] * b\n    out[1] = a[1] * b\n    out[2] = a[2] * b\n    return out\n}", "module.exports = scaleAndAdd;\n\n/**\n * Adds two vec3's after scaling the second operand by a scalar value\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @param {Number} scale the amount to scale b by before adding\n * @returns {vec3} out\n */\nfunction scaleAndAdd(out, a, b, scale) {\n    out[0] = a[0] + (b[0] * scale)\n    out[1] = a[1] + (b[1] * scale)\n    out[2] = a[2] + (b[2] * scale)\n    return out\n}", "module.exports = distance;\n\n/**\n * Calculates the euclidian distance between two vec3's\n *\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {Number} distance between a and b\n */\nfunction distance(a, b) {\n    var x = b[0] - a[0],\n        y = b[1] - a[1],\n        z = b[2] - a[2]\n    return Math.sqrt(x*x + y*y + z*z)\n}", "module.exports = require('./distance')\n", "module.exports = squaredDistance;\n\n/**\n * Calculates the squared euclidian distance between two vec3's\n *\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {Number} squared distance between a and b\n */\nfunction squaredDistance(a, b) {\n    var x = b[0] - a[0],\n        y = b[1] - a[1],\n        z = b[2] - a[2]\n    return x*x + y*y + z*z\n}", "module.exports = require('./squaredDistance')\n", "module.exports = length;\n\n/**\n * Calculates the length of a vec3\n *\n * @param {vec3} a vector to calculate length of\n * @returns {Number} length of a\n */\nfunction length(a) {\n    var x = a[0],\n        y = a[1],\n        z = a[2]\n    return Math.sqrt(x*x + y*y + z*z)\n}", "module.exports = require('./length')\n", "module.exports = squaredLength;\n\n/**\n * Calculates the squared length of a vec3\n *\n * @param {vec3} a vector to calculate squared length of\n * @returns {Number} squared length of a\n */\nfunction squaredLength(a) {\n    var x = a[0],\n        y = a[1],\n        z = a[2]\n    return x*x + y*y + z*z\n}", "module.exports = require('./squaredLength')\n", "module.exports = negate;\n\n/**\n * Negates the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a vector to negate\n * @returns {vec3} out\n */\nfunction negate(out, a) {\n    out[0] = -a[0]\n    out[1] = -a[1]\n    out[2] = -a[2]\n    return out\n}", "module.exports = inverse;\n\n/**\n * Returns the inverse of the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a vector to invert\n * @returns {vec3} out\n */\nfunction inverse(out, a) {\n  out[0] = 1.0 / a[0]\n  out[1] = 1.0 / a[1]\n  out[2] = 1.0 / a[2]\n  return out\n}", "module.exports = cross;\n\n/**\n * Computes the cross product of two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */\nfunction cross(out, a, b) {\n    var ax = a[0], ay = a[1], az = a[2],\n        bx = b[0], by = b[1], bz = b[2]\n\n    out[0] = ay * bz - az * by\n    out[1] = az * bx - ax * bz\n    out[2] = ax * by - ay * bx\n    return out\n}", "module.exports = lerp;\n\n/**\n * Performs a linear interpolation between two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @param {Number} t interpolation amount between the two inputs\n * @returns {vec3} out\n */\nfunction lerp(out, a, b, t) {\n    var ax = a[0],\n        ay = a[1],\n        az = a[2]\n    out[0] = ax + t * (b[0] - ax)\n    out[1] = ay + t * (b[1] - ay)\n    out[2] = az + t * (b[2] - az)\n    return out\n}", "module.exports = random;\n\n/**\n * Generates a random vector with the given scale\n *\n * @param {vec3} out the receiving vector\n * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned\n * @returns {vec3} out\n */\nfunction random(out, scale) {\n    scale = scale || 1.0\n\n    var r = Math.random() * 2.0 * Math.PI\n    var z = (Math.random() * 2.0) - 1.0\n    var zScale = Math.sqrt(1.0-z*z) * scale\n\n    out[0] = Math.cos(r) * zScale\n    out[1] = Math.sin(r) * zScale\n    out[2] = z * scale\n    return out\n}", "module.exports = transformMat4;\n\n/**\n * Transforms the vec3 with a mat4.\n * 4th vector component is implicitly '1'\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the vector to transform\n * @param {mat4} m matrix to transform with\n * @returns {vec3} out\n */\nfunction transformMat4(out, a, m) {\n    var x = a[0], y = a[1], z = a[2],\n        w = m[3] * x + m[7] * y + m[11] * z + m[15]\n    w = w || 1.0\n    out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w\n    out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w\n    out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w\n    return out\n}", "module.exports = transformMat3;\n\n/**\n * Transforms the vec3 with a mat3.\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the vector to transform\n * @param {mat4} m the 3x3 matrix to transform with\n * @returns {vec3} out\n */\nfunction transformMat3(out, a, m) {\n    var x = a[0], y = a[1], z = a[2]\n    out[0] = x * m[0] + y * m[3] + z * m[6]\n    out[1] = x * m[1] + y * m[4] + z * m[7]\n    out[2] = x * m[2] + y * m[5] + z * m[8]\n    return out\n}", "module.exports = transformQuat;\n\n/**\n * Transforms the vec3 with a quat\n *\n * Note: the quaternion must be a unit quaternion (|q| = 1) in\n * order for this operation to be valid.\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the vector to transform\n * @param {quat} q unit quaternion to transform with\n * @returns {vec3} out\n */\nfunction transformQuat(out, a, q) {\n    // Fast Vector Rotation using Quaternions by Robert Eisele\n    // https://raw.org/proof/vector-rotation-using-quaternions/\n\n    var x = a[0], y = a[1], z = a[2],\n        qx = q[0], qy = q[1], qz = q[2], qw = q[3]\n\n    // t = q x v\n    var tx = qy * z - qz * y\n    var ty = qz * x - qx * z\n    var tz = qx * y - qy * x\n\n    // t = 2t\n    tx *= 2\n    ty *= 2\n    tz *= 2\n\n    // v + w t + q x t\n    out[0] = x + qw * tx + qy * tz - qz * ty\n    out[1] = y + qw * ty + qz * tx - qx * tz\n    out[2] = z + qw * tz + qx * ty - qy * tx\n\n    return out\n}\n", "module.exports = rotateX;\n\n/**\n * Rotate a 3D vector around the x-axis\n * @param {vec3} out The receiving vec3\n * @param {vec3} a The vec3 point to rotate\n * @param {vec3} b The origin of the rotation\n * @param {Number} c The angle of rotation\n * @returns {vec3} out\n */\nfunction rotateX(out, a, b, c){\n    var by = b[1]\n    var bz = b[2]\n\n    // Translate point to the origin\n    var py = a[1] - by\n    var pz = a[2] - bz\n\n    var sc = Math.sin(c)\n    var cc = Math.cos(c)\n\n    // perform rotation and translate to correct position\n    out[0] = a[0]\n    out[1] = by + py * cc - pz * sc\n    out[2] = bz + py * sc + pz * cc\n\n    return out\n}\n", "module.exports = rotateY;\n\n/**\n * Rotate a 3D vector around the y-axis\n * @param {vec3} out The receiving vec3\n * @param {vec3} a The vec3 point to rotate\n * @param {vec3} b The origin of the rotation\n * @param {Number} c The angle of rotation\n * @returns {vec3} out\n */\nfunction rotateY(out, a, b, c){\n    var bx = b[0]\n    var bz = b[2]\n\n    // translate point to the origin\n    var px = a[0] - bx\n    var pz = a[2] - bz\n    \n    var sc = Math.sin(c)\n    var cc = Math.cos(c)\n  \n    // perform rotation and translate to correct position\n    out[0] = bx + pz * sc + px * cc\n    out[1] = a[1]\n    out[2] = bz + pz * cc - px * sc\n  \n    return out\n}\n", "module.exports = rotateZ;\n\n/**\n * Rotate a 3D vector around the z-axis\n * @param {vec3} out The receiving vec3\n * @param {vec3} a The vec3 point to rotate\n * @param {vec3} b The origin of the rotation\n * @param {Number} c The angle of rotation\n * @returns {vec3} out\n */\nfunction rotateZ(out, a, b, c){\n    var bx = b[0]\n    var by = b[1]\n\n    //Translate point to the origin\n    var px = a[0] - bx\n    var py = a[1] - by\n  \n    var sc = Math.sin(c)\n    var cc = Math.cos(c)\n\n    // perform rotation and translate to correct position\n    out[0] = bx + px * cc - py * sc\n    out[1] = by + px * sc + py * cc\n    out[2] = a[2]\n  \n    return out\n}\n", "module.exports = forEach;\n\nvar vec = require('./create')()\n\n/**\n * Perform some operation over an array of vec3s.\n *\n * @param {Array} a the array of vectors to iterate over\n * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed\n * @param {Number} offset Number of elements to skip at the beginning of the array\n * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array\n * @param {Function} fn Function to call for each vector in the array\n * @param {Object} [arg] additional argument to pass to fn\n * @returns {Array} a\n * @function\n */\nfunction forEach(a, stride, offset, count, fn, arg) {\n        var i, l\n        if(!stride) {\n            stride = 3\n        }\n\n        if(!offset) {\n            offset = 0\n        }\n        \n        if(count) {\n            l = Math.min((count * stride) + offset, a.length)\n        } else {\n            l = a.length\n        }\n\n        for(i = offset; i < l; i += stride) {\n            vec[0] = a[i] \n            vec[1] = a[i+1] \n            vec[2] = a[i+2]\n            fn(vec, vec, arg)\n            a[i] = vec[0] \n            a[i+1] = vec[1] \n            a[i+2] = vec[2]\n        }\n        \n        return a\n}", "module.exports = {\n  EPSILON: require('./epsilon')\n  , create: require('./create')\n  , clone: require('./clone')\n  , angle: require('./angle')\n  , fromValues: require('./fromValues')\n  , copy: require('./copy')\n  , set: require('./set')\n  , equals: require('./equals')\n  , exactEquals: require('./exactEquals')\n  , add: require('./add')\n  , subtract: require('./subtract')\n  , sub: require('./sub')\n  , multiply: require('./multiply')\n  , mul: require('./mul')\n  , divide: require('./divide')\n  , div: require('./div')\n  , min: require('./min')\n  , max: require('./max')\n  , floor: require('./floor')\n  , ceil: require('./ceil')\n  , round: require('./round')\n  , scale: require('./scale')\n  , scaleAndAdd: require('./scaleAndAdd')\n  , distance: require('./distance')\n  , dist: require('./dist')\n  , squaredDistance: require('./squaredDistance')\n  , sqrDist: require('./sqrDist')\n  , length: require('./length')\n  , len: require('./len')\n  , squaredLength: require('./squaredLength')\n  , sqrLen: require('./sqrLen')\n  , negate: require('./negate')\n  , inverse: require('./inverse')\n  , normalize: require('./normalize')\n  , dot: require('./dot')\n  , cross: require('./cross')\n  , lerp: require('./lerp')\n  , random: require('./random')\n  , transformMat4: require('./transformMat4')\n  , transformMat3: require('./transformMat3')\n  , transformQuat: require('./transformQuat')\n  , rotateX: require('./rotateX')\n  , rotateY: require('./rotateY')\n  , rotateZ: require('./rotateZ')\n  , forEach: require('./forEach')\n}\n", "\"use strict\"\n\nfunction iota(n) {\n  var result = new Array(n)\n  for(var i=0; i<n; ++i) {\n    result[i] = i\n  }\n  return result\n}\n\nmodule.exports = iota", "/*!\n * Determine if an object is a Buffer\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n\n// The _isBuffer check is for Safari 5-7 support, because it's missing\n// Object.prototype.constructor. Remove this eventually\nmodule.exports = function (obj) {\n  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)\n}\n\nfunction isBuffer (obj) {\n  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)\n}\n\n// For Node v0.10 support. Remove this eventually.\nfunction isSlowBuffer (obj) {\n  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))\n}\n", "var iota = require(\"iota-array\")\nvar isBuffer = require(\"is-buffer\")\n\nvar hasTypedArrays  = ((typeof Float64Array) !== \"undefined\")\n\nfunction compare1st(a, b) {\n  return a[0] - b[0]\n}\n\nfunction order() {\n  var stride = this.stride\n  var terms = new Array(stride.length)\n  var i\n  for(i=0; i<terms.length; ++i) {\n    terms[i] = [Math.abs(stride[i]), i]\n  }\n  terms.sort(compare1st)\n  var result = new Array(terms.length)\n  for(i=0; i<result.length; ++i) {\n    result[i] = terms[i][1]\n  }\n  return result\n}\n\nfunction compileConstructor(dtype, dimension) {\n  var className = [\"View\", dimension, \"d\", dtype].join(\"\")\n  if(dimension < 0) {\n    className = \"View_Nil\" + dtype\n  }\n  var useGetters = (dtype === \"generic\")\n\n  if(dimension === -1) {\n    //Special case for trivial arrays\n    var code =\n      \"function \"+className+\"(a){this.data=a;};\\\nvar proto=\"+className+\".prototype;\\\nproto.dtype='\"+dtype+\"';\\\nproto.index=function(){return -1};\\\nproto.size=0;\\\nproto.dimension=-1;\\\nproto.shape=proto.stride=proto.order=[];\\\nproto.lo=proto.hi=proto.transpose=proto.step=\\\nfunction(){return new \"+className+\"(this.data);};\\\nproto.get=proto.set=function(){};\\\nproto.pick=function(){return null};\\\nreturn function construct_\"+className+\"(a){return new \"+className+\"(a);}\"\n    var procedure = new Function(code)\n    return procedure()\n  } else if(dimension === 0) {\n    //Special case for 0d arrays\n    var code =\n      \"function \"+className+\"(a,d) {\\\nthis.data = a;\\\nthis.offset = d\\\n};\\\nvar proto=\"+className+\".prototype;\\\nproto.dtype='\"+dtype+\"';\\\nproto.index=function(){return this.offset};\\\nproto.dimension=0;\\\nproto.size=1;\\\nproto.shape=\\\nproto.stride=\\\nproto.order=[];\\\nproto.lo=\\\nproto.hi=\\\nproto.transpose=\\\nproto.step=function \"+className+\"_copy() {\\\nreturn new \"+className+\"(this.data,this.offset)\\\n};\\\nproto.pick=function \"+className+\"_pick(){\\\nreturn TrivialArray(this.data);\\\n};\\\nproto.valueOf=proto.get=function \"+className+\"_get(){\\\nreturn \"+(useGetters ? \"this.data.get(this.offset)\" : \"this.data[this.offset]\")+\n\"};\\\nproto.set=function \"+className+\"_set(v){\\\nreturn \"+(useGetters ? \"this.data.set(this.offset,v)\" : \"this.data[this.offset]=v\")+\"\\\n};\\\nreturn function construct_\"+className+\"(a,b,c,d){return new \"+className+\"(a,d)}\"\n    var procedure = new Function(\"TrivialArray\", code)\n    return procedure(CACHED_CONSTRUCTORS[dtype][0])\n  }\n\n  var code = [\"'use strict'\"]\n\n  //Create constructor for view\n  var indices = iota(dimension)\n  var args = indices.map(function(i) { return \"i\"+i })\n  var index_str = \"this.offset+\" + indices.map(function(i) {\n        return \"this.stride[\" + i + \"]*i\" + i\n      }).join(\"+\")\n  var shapeArg = indices.map(function(i) {\n      return \"b\"+i\n    }).join(\",\")\n  var strideArg = indices.map(function(i) {\n      return \"c\"+i\n    }).join(\",\")\n  code.push(\n    \"function \"+className+\"(a,\" + shapeArg + \",\" + strideArg + \",d){this.data=a\",\n      \"this.shape=[\" + shapeArg + \"]\",\n      \"this.stride=[\" + strideArg + \"]\",\n      \"this.offset=d|0}\",\n    \"var proto=\"+className+\".prototype\",\n    \"proto.dtype='\"+dtype+\"'\",\n    \"proto.dimension=\"+dimension)\n\n  //view.size:\n  code.push(\"Object.defineProperty(proto,'size',{get:function \"+className+\"_size(){\\\nreturn \"+indices.map(function(i) { return \"this.shape[\"+i+\"]\" }).join(\"*\"),\n\"}})\")\n\n  //view.order:\n  if(dimension === 1) {\n    code.push(\"proto.order=[0]\")\n  } else {\n    code.push(\"Object.defineProperty(proto,'order',{get:\")\n    if(dimension < 4) {\n      code.push(\"function \"+className+\"_order(){\")\n      if(dimension === 2) {\n        code.push(\"return (Math.abs(this.stride[0])>Math.abs(this.stride[1]))?[1,0]:[0,1]}})\")\n      } else if(dimension === 3) {\n        code.push(\n\"var s0=Math.abs(this.stride[0]),s1=Math.abs(this.stride[1]),s2=Math.abs(this.stride[2]);\\\nif(s0>s1){\\\nif(s1>s2){\\\nreturn [2,1,0];\\\n}else if(s0>s2){\\\nreturn [1,2,0];\\\n}else{\\\nreturn [1,0,2];\\\n}\\\n}else if(s0>s2){\\\nreturn [2,0,1];\\\n}else if(s2>s1){\\\nreturn [0,1,2];\\\n}else{\\\nreturn [0,2,1];\\\n}}})\")\n      }\n    } else {\n      code.push(\"ORDER})\")\n    }\n  }\n\n  //view.set(i0, ..., v):\n  code.push(\n\"proto.set=function \"+className+\"_set(\"+args.join(\",\")+\",v){\")\n  if(useGetters) {\n    code.push(\"return this.data.set(\"+index_str+\",v)}\")\n  } else {\n    code.push(\"return this.data[\"+index_str+\"]=v}\")\n  }\n\n  //view.get(i0, ...):\n  code.push(\"proto.get=function \"+className+\"_get(\"+args.join(\",\")+\"){\")\n  if(useGetters) {\n    code.push(\"return this.data.get(\"+index_str+\")}\")\n  } else {\n    code.push(\"return this.data[\"+index_str+\"]}\")\n  }\n\n  //view.index:\n  code.push(\n    \"proto.index=function \"+className+\"_index(\", args.join(), \"){return \"+index_str+\"}\")\n\n  //view.hi():\n  code.push(\"proto.hi=function \"+className+\"_hi(\"+args.join(\",\")+\"){return new \"+className+\"(this.data,\"+\n    indices.map(function(i) {\n      return [\"(typeof i\",i,\"!=='number'||i\",i,\"<0)?this.shape[\", i, \"]:i\", i,\"|0\"].join(\"\")\n    }).join(\",\")+\",\"+\n    indices.map(function(i) {\n      return \"this.stride[\"+i + \"]\"\n    }).join(\",\")+\",this.offset)}\")\n\n  //view.lo():\n  var a_vars = indices.map(function(i) { return \"a\"+i+\"=this.shape[\"+i+\"]\" })\n  var c_vars = indices.map(function(i) { return \"c\"+i+\"=this.stride[\"+i+\"]\" })\n  code.push(\"proto.lo=function \"+className+\"_lo(\"+args.join(\",\")+\"){var b=this.offset,d=0,\"+a_vars.join(\",\")+\",\"+c_vars.join(\",\"))\n  for(var i=0; i<dimension; ++i) {\n    code.push(\n\"if(typeof i\"+i+\"==='number'&&i\"+i+\">=0){\\\nd=i\"+i+\"|0;\\\nb+=c\"+i+\"*d;\\\na\"+i+\"-=d}\")\n  }\n  code.push(\"return new \"+className+\"(this.data,\"+\n    indices.map(function(i) {\n      return \"a\"+i\n    }).join(\",\")+\",\"+\n    indices.map(function(i) {\n      return \"c\"+i\n    }).join(\",\")+\",b)}\")\n\n  //view.step():\n  code.push(\"proto.step=function \"+className+\"_step(\"+args.join(\",\")+\"){var \"+\n    indices.map(function(i) {\n      return \"a\"+i+\"=this.shape[\"+i+\"]\"\n    }).join(\",\")+\",\"+\n    indices.map(function(i) {\n      return \"b\"+i+\"=this.stride[\"+i+\"]\"\n    }).join(\",\")+\",c=this.offset,d=0,ceil=Math.ceil\")\n  for(var i=0; i<dimension; ++i) {\n    code.push(\n\"if(typeof i\"+i+\"==='number'){\\\nd=i\"+i+\"|0;\\\nif(d<0){\\\nc+=b\"+i+\"*(a\"+i+\"-1);\\\na\"+i+\"=ceil(-a\"+i+\"/d)\\\n}else{\\\na\"+i+\"=ceil(a\"+i+\"/d)\\\n}\\\nb\"+i+\"*=d\\\n}\")\n  }\n  code.push(\"return new \"+className+\"(this.data,\"+\n    indices.map(function(i) {\n      return \"a\" + i\n    }).join(\",\")+\",\"+\n    indices.map(function(i) {\n      return \"b\" + i\n    }).join(\",\")+\",c)}\")\n\n  //view.transpose():\n  var tShape = new Array(dimension)\n  var tStride = new Array(dimension)\n  for(var i=0; i<dimension; ++i) {\n    tShape[i] = \"a[i\"+i+\"]\"\n    tStride[i] = \"b[i\"+i+\"]\"\n  }\n  code.push(\"proto.transpose=function \"+className+\"_transpose(\"+args+\"){\"+\n    args.map(function(n,idx) { return n + \"=(\" + n + \"===undefined?\" + idx + \":\" + n + \"|0)\"}).join(\";\"),\n    \"var a=this.shape,b=this.stride;return new \"+className+\"(this.data,\"+tShape.join(\",\")+\",\"+tStride.join(\",\")+\",this.offset)}\")\n\n  //view.pick():\n  code.push(\"proto.pick=function \"+className+\"_pick(\"+args+\"){var a=[],b=[],c=this.offset\")\n  for(var i=0; i<dimension; ++i) {\n    code.push(\"if(typeof i\"+i+\"==='number'&&i\"+i+\">=0){c=(c+this.stride[\"+i+\"]*i\"+i+\")|0}else{a.push(this.shape[\"+i+\"]);b.push(this.stride[\"+i+\"])}\")\n  }\n  code.push(\"var ctor=CTOR_LIST[a.length+1];return ctor(this.data,a,b,c)}\")\n\n  //Add return statement\n  code.push(\"return function construct_\"+className+\"(data,shape,stride,offset){return new \"+className+\"(data,\"+\n    indices.map(function(i) {\n      return \"shape[\"+i+\"]\"\n    }).join(\",\")+\",\"+\n    indices.map(function(i) {\n      return \"stride[\"+i+\"]\"\n    }).join(\",\")+\",offset)}\")\n\n  //Compile procedure\n  var procedure = new Function(\"CTOR_LIST\", \"ORDER\", code.join(\"\\n\"))\n  return procedure(CACHED_CONSTRUCTORS[dtype], order)\n}\n\nfunction arrayDType(data) {\n  if(isBuffer(data)) {\n    return \"buffer\"\n  }\n  if(hasTypedArrays) {\n    switch(Object.prototype.toString.call(data)) {\n      case \"[object Float64Array]\":\n        return \"float64\"\n      case \"[object Float32Array]\":\n        return \"float32\"\n      case \"[object Int8Array]\":\n        return \"int8\"\n      case \"[object Int16Array]\":\n        return \"int16\"\n      case \"[object Int32Array]\":\n        return \"int32\"\n      case \"[object Uint8Array]\":\n        return \"uint8\"\n      case \"[object Uint16Array]\":\n        return \"uint16\"\n      case \"[object Uint32Array]\":\n        return \"uint32\"\n      case \"[object Uint8ClampedArray]\":\n        return \"uint8_clamped\"\n      case \"[object BigInt64Array]\":\n        return \"bigint64\"\n      case \"[object BigUint64Array]\":\n        return \"biguint64\"\n    }\n  }\n  if(Array.isArray(data)) {\n    return \"array\"\n  }\n  return \"generic\"\n}\n\nvar CACHED_CONSTRUCTORS = {\n  \"float32\":[],\n  \"float64\":[],\n  \"int8\":[],\n  \"int16\":[],\n  \"int32\":[],\n  \"uint8\":[],\n  \"uint16\":[],\n  \"uint32\":[],\n  \"array\":[],\n  \"uint8_clamped\":[],\n  \"bigint64\": [],\n  \"biguint64\": [],\n  \"buffer\":[],\n  \"generic\":[]\n}\n\n;(function() {\n  for(var id in CACHED_CONSTRUCTORS) {\n    CACHED_CONSTRUCTORS[id].push(compileConstructor(id, -1))\n  }\n});\n\nfunction wrappedNDArrayCtor(data, shape, stride, offset) {\n  if(data === undefined) {\n    var ctor = CACHED_CONSTRUCTORS.array[0]\n    return ctor([])\n  } else if(typeof data === \"number\") {\n    data = [data]\n  }\n  if(shape === undefined) {\n    shape = [ data.length ]\n  }\n  var d = shape.length\n  if(stride === undefined) {\n    stride = new Array(d)\n    for(var i=d-1, sz=1; i>=0; --i) {\n      stride[i] = sz\n      sz *= shape[i]\n    }\n  }\n  if(offset === undefined) {\n    offset = 0\n    for(var i=0; i<d; ++i) {\n      if(stride[i] < 0) {\n        offset -= (shape[i]-1)*stride[i]\n      }\n    }\n  }\n  var dtype = arrayDType(data)\n  var ctor_list = CACHED_CONSTRUCTORS[dtype]\n  while(ctor_list.length <= d+1) {\n    ctor_list.push(compileConstructor(dtype, ctor_list.length-1))\n  }\n  var ctor = ctor_list[d+1]\n  return ctor(data, shape, stride, offset)\n}\n\nmodule.exports = wrappedNDArrayCtor\n", "\"use strict\"\n\nfunction traceRay_impl( getVoxel,\n\tpx, py, pz,\n\tdx, dy, dz,\n\tmax_d, hit_pos, hit_norm) {\n\t\n\t// consider raycast vector to be parametrized by t\n\t//   vec = [px,py,pz] + t * [dx,dy,dz]\n\t\n\t// algo below is as described by this paper:\n\t// http://www.cse.chalmers.se/edu/year/2010/course/TDA361/grid.pdf\n\t\n\tvar t = 0.0\n\t\t, floor = Math.floor\n\t\t, ix = floor(px) | 0\n\t\t, iy = floor(py) | 0\n\t\t, iz = floor(pz) | 0\n\n\t\t, stepx = (dx > 0) ? 1 : -1\n\t\t, stepy = (dy > 0) ? 1 : -1\n\t\t, stepz = (dz > 0) ? 1 : -1\n\t\t\n\t// dx,dy,dz are already normalized\n\t\t, txDelta = Math.abs(1 / dx)\n\t\t, tyDelta = Math.abs(1 / dy)\n\t\t, tzDelta = Math.abs(1 / dz)\n\n\t\t, xdist = (stepx > 0) ? (ix + 1 - px) : (px - ix)\n\t\t, ydist = (stepy > 0) ? (iy + 1 - py) : (py - iy)\n\t\t, zdist = (stepz > 0) ? (iz + 1 - pz) : (pz - iz)\n\t\t\n\t// location of nearest voxel boundary, in units of t \n\t\t, txMax = (txDelta < Infinity) ? txDelta * xdist : Infinity\n\t\t, tyMax = (tyDelta < Infinity) ? tyDelta * ydist : Infinity\n\t\t, tzMax = (tzDelta < Infinity) ? tzDelta * zdist : Infinity\n\n\t\t, steppedIndex = -1\n\t\n\t// main loop along raycast vector\n\twhile (t <= max_d) {\n\t\t\n\t\t// exit check\n\t\tvar b = getVoxel(ix, iy, iz)\n\t\tif (b) {\n\t\t\tif (hit_pos) {\n\t\t\t\thit_pos[0] = px + t * dx\n\t\t\t\thit_pos[1] = py + t * dy\n\t\t\t\thit_pos[2] = pz + t * dz\n\t\t\t}\n\t\t\tif (hit_norm) {\n\t\t\t\thit_norm[0] = hit_norm[1] = hit_norm[2] = 0\n\t\t\t\tif (steppedIndex === 0) hit_norm[0] = -stepx\n\t\t\t\tif (steppedIndex === 1) hit_norm[1] = -stepy\n\t\t\t\tif (steppedIndex === 2) hit_norm[2] = -stepz\n\t\t\t}\n\t\t\treturn b\n\t\t}\n\t\t\n\t\t// advance t to next nearest voxel boundary\n\t\tif (txMax < tyMax) {\n\t\t\tif (txMax < tzMax) {\n\t\t\t\tix += stepx\n\t\t\t\tt = txMax\n\t\t\t\ttxMax += txDelta\n\t\t\t\tsteppedIndex = 0\n\t\t\t} else {\n\t\t\t\tiz += stepz\n\t\t\t\tt = tzMax\n\t\t\t\ttzMax += tzDelta\n\t\t\t\tsteppedIndex = 2\n\t\t\t}\n\t\t} else {\n\t\t\tif (tyMax < tzMax) {\n\t\t\t\tiy += stepy\n\t\t\t\tt = tyMax\n\t\t\t\ttyMax += tyDelta\n\t\t\t\tsteppedIndex = 1\n\t\t\t} else {\n\t\t\t\tiz += stepz\n\t\t\t\tt = tzMax\n\t\t\t\ttzMax += tzDelta\n\t\t\t\tsteppedIndex = 2\n\t\t\t}\n\t\t}\n\n\t}\n\t\n\t// no voxel hit found\n\tif (hit_pos) {\n\t\thit_pos[0] = px + t * dx\n\t\thit_pos[1] = py + t * dy\n\t\thit_pos[2] = pz + t * dz\n\t}\n\tif (hit_norm) {\n\t\thit_norm[0] = hit_norm[1] = hit_norm[2] = 0\n\t}\n\n\treturn 0\n\n}\n\n\n// conform inputs\n\nfunction traceRay(getVoxel, origin, direction, max_d, hit_pos, hit_norm) {\n\tvar px = +origin[0]\n\t\t, py = +origin[1]\n\t\t, pz = +origin[2]\n\t\t, dx = +direction[0]\n\t\t, dy = +direction[1]\n\t\t, dz = +direction[2]\n\t\t, ds = Math.sqrt(dx * dx + dy * dy + dz * dz)\n\n\tif (ds === 0) {\n\t\tthrow new Error(\"Can't raycast along a zero vector\")\n\t}\n\n\tdx /= ds\n\tdy /= ds\n\tdz /= ds\n\tif (typeof (max_d) === \"undefined\") {\n\t\tmax_d = 64.0\n\t} else {\n\t\tmax_d = +max_d\n\t}\n\treturn traceRay_impl(getVoxel, px, py, pz, dx, dy, dz, max_d, hit_pos, hit_norm)\n}\n\nmodule.exports = traceRay", "'use strict'\n\n\n// reused array instances\n\nvar tr_arr = []\nvar ldi_arr = []\nvar tri_arr = []\nvar step_arr = []\nvar tDelta_arr = []\nvar tNext_arr = []\nvar vec_arr = []\nvar normed_arr = []\nvar base_arr = []\nvar max_arr = []\nvar left_arr = []\nvar result_arr = []\n\n\n\n// core implementation:\n\nfunction sweep_impl(getVoxel, callback, vec, base, max, epsilon) {\n\n    // consider algo as a raycast along the AABB's leading corner\n    // as raycast enters each new voxel, iterate in 2D over the AABB's \n    // leading face in that axis looking for collisions\n    // \n    // original raycast implementation: https://github.com/andyhall/fast-voxel-raycast\n    // original raycast paper: http://www.cse.chalmers.se/edu/year/2010/course/TDA361/grid.pdf\n\n    var tr = tr_arr\n    var ldi = ldi_arr\n    var tri = tri_arr\n    var step = step_arr\n    var tDelta = tDelta_arr\n    var tNext = tNext_arr\n    var normed = normed_arr\n\n    var floor = Math.floor\n    var cumulative_t = 0.0\n    var t = 0.0\n    var max_t = 0.0\n    var axis = 0\n    var i = 0\n\n\n    // init for the current sweep vector and take first step\n    initSweep()\n    if (max_t === 0) return 0\n\n    axis = stepForward()\n\n    // loop along raycast vector\n    while (t <= max_t) {\n\n        // sweeps over leading face of AABB\n        if (checkCollision(axis)) {\n            // calls the callback and decides whether to continue\n            var done = handleCollision()\n            if (done) return cumulative_t\n        }\n\n        axis = stepForward()\n    }\n\n    // reached the end of the vector unobstructed, finish and exit\n    cumulative_t += max_t\n    for (i = 0; i < 3; i++) {\n        base[i] += vec[i]\n        max[i] += vec[i]\n    }\n    return cumulative_t\n\n\n\n\n\n    // low-level implementations of each step:\n    function initSweep() {\n\n        // parametrization t along raycast\n        t = 0.0\n        max_t = Math.sqrt(vec[0] * vec[0] + vec[1] * vec[1] + vec[2] * vec[2])\n        if (max_t === 0) return\n        for (var i = 0; i < 3; i++) {\n            var dir = (vec[i] >= 0)\n            step[i] = dir ? 1 : -1\n            // trailing / trailing edge coords\n            var lead = dir ? max[i] : base[i]\n            tr[i] = dir ? base[i] : max[i]\n            // int values of lead/trail edges\n            ldi[i] = leadEdgeToInt(lead, step[i])\n            tri[i] = trailEdgeToInt(tr[i], step[i])\n            // normed vector\n            normed[i] = vec[i] / max_t\n            // distance along t required to move one voxel in each axis\n            tDelta[i] = Math.abs(1 / normed[i])\n            // location of nearest voxel boundary, in units of t \n            var dist = dir ? (ldi[i] + 1 - lead) : (lead - ldi[i])\n            tNext[i] = (tDelta[i] < Infinity) ? tDelta[i] * dist : Infinity\n        }\n\n    }\n\n\n    // check for collisions - iterate over the leading face on the advancing axis\n\n    function checkCollision(i_axis) {\n        var stepx = step[0]\n        var x0 = (i_axis === 0) ? ldi[0] : tri[0]\n        var x1 = ldi[0] + stepx\n\n        var stepy = step[1]\n        var y0 = (i_axis === 1) ? ldi[1] : tri[1]\n        var y1 = ldi[1] + stepy\n\n        var stepz = step[2]\n        var z0 = (i_axis === 2) ? ldi[2] : tri[2]\n        var z1 = ldi[2] + stepz\n\n        // var j_axis = (i_axis + 1) % 3\n        // var k_axis = (i_axis + 2) % 3\n        // var s = ['x', 'y', 'z'][i_axis]\n        // var js = ['x', 'y', 'z'][j_axis]\n        // var ks = ['x', 'y', 'z'][k_axis]\n        // var i0 = [x0, y0, z0][i_axis]\n        // var j0 = [x0, y0, z0][j_axis]\n        // var k0 = [x0, y0, z0][k_axis]\n        // var i1 = [x1 - stepx, y1 - stepy, z1 - stepz][i_axis]\n        // var j1 = [x1 - stepx, y1 - stepy, z1 - stepz][j_axis]\n        // var k1 = [x1 - stepx, y1 - stepy, z1 - stepz][k_axis]\n        // console.log('=== step', s, 'to', i0, '   sweep', js, j0 + ',' + j1, '   ', ks, k0 + ',' + k1)\n\n        for (var x = x0; x != x1; x += stepx) {\n            for (var y = y0; y != y1; y += stepy) {\n                for (var z = z0; z != z1; z += stepz) {\n                    if (getVoxel(x, y, z)) return true\n                }\n            }\n        }\n        return false\n    }\n\n\n    // on collision - call the callback and return or set up for the next sweep\n\n    function handleCollision() {\n\n        // set up for callback\n        cumulative_t += t\n        var dir = step[axis]\n\n        // vector moved so far, and left to move\n        var done = t / max_t\n        var left = left_arr\n        for (i = 0; i < 3; i++) {\n            var dv = vec[i] * done\n            base[i] += dv\n            max[i] += dv\n            left[i] = vec[i] - dv\n        }\n\n        // set leading edge of stepped axis exactly to voxel boundary\n        // else we'll sometimes rounding error beyond it\n        if (dir > 0) {\n            max[axis] = Math.round(max[axis])\n        } else {\n            base[axis] = Math.round(base[axis])\n        }\n        \n        // call back to let client update the \"left to go\" vector\n        var res = callback(cumulative_t, axis, dir, left)\n\n        // bail out out on truthy response\n        if (res) return true\n\n        // init for new sweep along vec\n        for (i = 0; i < 3; i++) vec[i] = left[i]\n        initSweep()\n        if (max_t === 0) return true // no vector left\n\n        return false\n    }\n\n\n    // advance to next voxel boundary, and return which axis was stepped\n\n    function stepForward() {\n        var axis = (tNext[0] < tNext[1]) ?\n            ((tNext[0] < tNext[2]) ? 0 : 2) :\n            ((tNext[1] < tNext[2]) ? 1 : 2)\n        var dt = tNext[axis] - t\n        t = tNext[axis]\n        ldi[axis] += step[axis]\n        tNext[axis] += tDelta[axis]\n        for (i = 0; i < 3; i++) {\n            tr[i] += dt * normed[i]\n            tri[i] = trailEdgeToInt(tr[i], step[i])\n        }\n\n        return axis\n    }\n\n\n\n    function leadEdgeToInt(coord, step) {\n        return floor(coord - step * epsilon)\n    }\n    function trailEdgeToInt(coord, step) {\n        return floor(coord + step * epsilon)\n    }\n\n}\n\n\n\n\n\n// conform inputs\n\nfunction sweep(getVoxel, box, dir, callback, noTranslate, epsilon) {\n\n    var vec = vec_arr\n    var base = base_arr\n    var max = max_arr\n    var result = result_arr\n\n    // init parameter float arrays\n    for (var i = 0; i < 3; i++) {\n        vec[i] = +dir[i]\n        max[i] = +box.max[i]\n        base[i] = +box.base[i]\n    }\n\n    if (!epsilon) epsilon = 1e-10\n\n    // run sweep implementation\n    var dist = sweep_impl(getVoxel, callback, vec, base, max, epsilon)\n\n    // translate box by distance needed to updated base value\n    if (!noTranslate) {\n        for (i = 0; i < 3; i++) {\n            result[i] = (dir[i] > 0) ? max[i] - box.max[i] : base[i] - box.base[i]\n        }\n        box.translate(result)\n    }\n\n    // return value is total distance moved (not necessarily magnitude of [end]-[start])\n    return dist\n}\n\nmodule.exports = sweep\n\n", "\n\n/*\n * \n *      Encapsulates (mostly) a collection of objects, \n *      exposed both as a hash and as an array\n *      _map maps hash id to list index\n * \n *      Note this is a dumb store, it doesn't check any inputs at all.\n *      It also assumes every stored data object is stored like:\n *          dataStore.add(37, {__id:37} )\n * \n*/\n\n\nmodule.exports = class DataStore {\n\n    constructor() {\n        this.list = []\n        this.hash = {}\n        this._map = {}\n        this._pendingRemovals = []\n    }\n\n\n    // add a new state object\n    add(id, stateObject) {\n        if (typeof this._map[id] === 'number') {\n            // this happens if id is removed/readded without flushing\n            var index = this._map[id]\n            this.hash[id] = stateObject\n            this.list[index] = stateObject\n        } else {\n            this._map[id] = this.list.length\n            this.hash[id] = stateObject\n            this.list.push(stateObject)\n        }\n    }\n\n\n    // remove - nulls the state object, actual removal comes later\n    remove(id) {\n        var index = this._map[id]\n        this.hash[id] = null\n        this.list[index] = null\n        this._pendingRemovals.push(id)\n    }\n\n\n    // just sever references\n    dispose() {\n        this.list = null\n        this.hash = null\n        this._map = null\n        this._pendingRemovals.length = 0\n    }\n\n\n    // deletes removed objects from data structures\n    flush() {\n        for (var i = 0; i < this._pendingRemovals.length; i++) {\n            var id = this._pendingRemovals[i]\n            // removal might have been reversed, or already handled\n            if (this.hash[id] !== null) continue\n            removeElement(this, id)\n        }\n        this._pendingRemovals.length = 0\n    }\n\n}\n\n\n/*\n * \n *      actual remove / cleanup logic, fixes up data structures after removal\n * \n * \n*/\n\n\nfunction removeElement(data, id) {\n    // current location of this element in the list\n    var index = data._map[id]\n    // for hash and map, just delete by id\n    delete data.hash[id]\n    delete data._map[id]\n    // now splice - either by popping or by swapping with final element\n    if (index === data.list.length - 1) {\n        data.list.pop()\n    } else {\n        // swap last item with the one we're removing\n        var swapped = data.list.pop()\n        data.list[index] = swapped\n        // need to fix _map for swapped item\n        if (swapped === null || swapped[0] === null) {\n            // slowest but rarest case - swapped item is ALSO pending removal\n            var prevIndex = data.list.length\n            for (var swapID in data._map) {\n                if (data._map[swapID] === prevIndex) {\n                    data._map[swapID] = index\n                    return\n                }\n            }\n        } else {\n            var swappedID = swapped.__id || swapped[0].__id\n            data._map[swappedID] = index\n        }\n    }\n}\n\n\n", "\nmodule.exports = ECS\nvar DataStore = require('./dataStore')\n\n\n\n/*!\n * ent-comp: a light, *fast* Entity Component System in JS\n * @url      github.com/fenomas/ent-comp\n * @author   Andy Hall <andy@fenomas.com>\n * @license  MIT\n*/\n\n\n\n/**\n * Constructor for a new entity-component-system manager.\n * \n * ```js\n * var ECS = require('ent-comp')\n * var ecs = new ECS()\n * ```\n * @class\n * @constructor\n * @exports ECS\n * @typicalname ecs\n*/\n\nfunction ECS() {\n\tvar self = this\n\n\t/** \n\t * Hash of component definitions. Also aliased to `comps`.\n\t * \n\t * ```js\n\t * var comp = { name: 'foo' }\n\t * ecs.createComponent(comp)\n\t * ecs.components['foo'] === comp  // true\n\t * ecs.comps['foo']                // same\n\t * ```\n\t*/\n\tthis.components = {}\n\tthis.comps = this.components\n\n\n\n\t/*\n\t * \n\t * \t\tinternal properties:\n\t * \n\t*/\n\n\tvar components = this.components\n\n\t// counter for entity IDs\n\tvar UID = 1\n\n\t// Storage for all component state data:\n\t// storage['component-name'] = DataStore instance\n\tvar storage = {}\n\n\t// flat arrays of names of components with systems\n\tvar systems = []\n\tvar renderSystems = []\n\n\t// flags and arrays for deferred cleanup of removed stuff\n\tvar deferrals = {\n\t\ttimeout: false,\n\t\tremovals: [],\n\t\tmultiComps: [],\n\t}\n\n\t// expose references to internals for debugging or hacking\n\tthis._storage = storage\n\tthis._systems = systems\n\tthis._renderSystems = renderSystems\n\n\n\n\n\n\t/*\n\t * \n\t * \n\t * \t\t\t\tPublic API\n\t * \n\t * \n\t*/\n\n\n\n\n\t/**\n\t * Creates a new entity id (currently just an incrementing integer).\n\t * \n\t * Optionally takes a list of component names to add to the entity (with default state data).\n\t * \n\t * ```js\n\t * var id1 = ecs.createEntity()\n\t * var id2 = ecs.createEntity([ 'some-component', 'other-component' ])\n\t * ```\n\t*/\n\tthis.createEntity = function (compList) {\n\t\tvar id = UID++\n\t\tif (Array.isArray(compList)) {\n\t\t\tcompList.forEach(compName => self.addComponent(id, compName))\n\t\t}\n\t\treturn id\n\t}\n\n\n\n\t/**\n\t * Deletes an entity, which in practice means removing all its components.\n\t * \n\t * ```js\n\t * ecs.deleteEntity(id)\n\t * ```\n\t*/\n\tthis.deleteEntity = function (entID) {\n\t\t// loop over all components and maybe remove them\n\t\t// this avoids needing to keep a list of components-per-entity\n\t\tObject.keys(storage).forEach(compName => {\n\t\t\tvar data = storage[compName]\n\t\t\tif (data.hash[entID]) {\n\t\t\t\tremoveComponent(entID, compName)\n\t\t\t}\n\t\t})\n\t\treturn self\n\t}\n\n\n\n\n\n\n\n\t/**\n\t * Creates a new component from a definition object. \n\t * The definition must have a `name`; all other properties are optional.\n\t * \n\t * Returns the component name, to make it easy to grab when the component\n\t * is being `require`d from a module.\n\t * \n\t * ```js\n\t * var comp = {\n\t * \t name: 'some-unique-string',\n\t * \t state: {},\n\t * \t order: 99,\n\t * \t multi: false,\n\t * \t onAdd:        (id, state) => { },\n\t * \t onRemove:     (id, state) => { },\n\t * \t system:       (dt, states) => { },\n\t * \t renderSystem: (dt, states) => { },\n\t * }\n\t * \n\t * var name = ecs.createComponent( comp )\n\t * // name == 'some-unique-string'\n\t * ```\n\t * \n\t * Note the `multi` flag - for components where this is true, a given \n\t * entity can have multiple state objects for that component.\n\t * For multi-components, APIs that would normally return a state object \n\t * (like `getState`) will instead return an array of them.\n\t*/\n\tthis.createComponent = function (compDefn) {\n\t\tif (!compDefn) throw new Error('Missing component definition')\n\t\tvar name = compDefn.name\n\t\tif (!name) throw new Error('Component definition must have a name property.')\n\t\tif (typeof name !== 'string') throw new Error('Component name must be a string.')\n\t\tif (name === '') throw new Error('Component name must be a non-empty string.')\n\t\tif (storage[name]) throw new Error(`Component ${name} already exists.`)\n\n\t\t// rebuild definition object for monomorphism\n\t\tvar internalDef = {}\n\t\tinternalDef.name = name\n\t\tinternalDef.multi = !!compDefn.multi\n\t\tinternalDef.order = isNaN(compDefn.order) ? 99 : compDefn.order\n\t\tinternalDef.state = compDefn.state || {}\n\t\tinternalDef.onAdd = compDefn.onAdd || null\n\t\tinternalDef.onRemove = compDefn.onRemove || null\n\t\tinternalDef.system = compDefn.system || null\n\t\tinternalDef.renderSystem = compDefn.renderSystem || null\n\n\t\tcomponents[name] = internalDef\n\t\tstorage[name] = new DataStore()\n\t\tstorage[name]._pendingMultiCleanup = false\n\t\tstorage[name]._multiCleanupIDs = (internalDef.multi) ? [] : null\n\n\t\tif (internalDef.system) {\n\t\t\tsystems.push(name)\n\t\t\tsystems.sort((a, b) => components[a].order - components[b].order)\n\t\t}\n\t\tif (internalDef.renderSystem) {\n\t\t\trenderSystems.push(name)\n\t\t\trenderSystems.sort((a, b) => components[a].order - components[b].order)\n\t\t}\n\n\t\treturn name\n\t}\n\n\n\n\n\n\n\t/**\n\t * Overwrites an existing component with a new definition object, which\n\t * must have the same `name` property as the component it overwrites.\n\t * Otherwise identical to `createComponent`\n\t * \n\t * ```js\n\t *   ecs.createComponent({\n\t *     name: 'foo',\n\t *     state: { aaa: 0 },\n\t *   })\n\t *   ecs.addComponent(myEntity, 'foo')\n\t *   ecs.getState(myEntity, 'foo').aaa = 123\n\t *   \n\t *   ecs.overwriteComponent('foo', {\n\t *\t   name: 'foo',\n\t *\t   state: { bbb: 456 },\n\t *\t })\n\t *   ecs.getState(myEntity, 'foo')  // { aaa:123, bbb:456 }\n\t * ```\n\t * \n\t*/\n\tthis.overwriteComponent = function (compName, compDefn) {\n\t\tvar def = components[compName]\n\t\tif (!def) throw new Error(`Unknown component: ${compName}`)\n\t\tif (!compDefn) throw new Error('Missing component definition')\n\t\tif (def.name !== compDefn.name) throw new Error('Overwriting component must use the same name property.')\n\n\t\t// rebuild definition object for monomorphism\n\t\tvar internalDef = {}\n\t\tinternalDef.name = compName\n\t\tinternalDef.multi = !!compDefn.multi\n\t\tinternalDef.order = isNaN(compDefn.order) ? 99 : compDefn.order\n\t\tinternalDef.state = compDefn.state || {}\n\t\tinternalDef.onAdd = compDefn.onAdd || null\n\t\tinternalDef.onRemove = compDefn.onRemove || null\n\t\tinternalDef.system = compDefn.system || null\n\t\tinternalDef.renderSystem = compDefn.renderSystem || null\n\n\t\t// overwrite internal references to old component def\n\t\tcomponents[compName] = internalDef\n\t\tstorage[compName]._pendingMultiCleanup = false\n\t\tstorage[compName]._multiCleanupIDs = (internalDef.multi) ? [] : null\n\n\t\tvar si = systems.indexOf(compName)\n\t\tif (internalDef.system && si < 0) systems.push(compName)\n\t\tif (!internalDef.system && si >= 0) systems.splice(si, 1)\n\t\tsystems.sort((a, b) => components[a].order - components[b].order)\n\n\t\tvar ri = renderSystems.indexOf(compName)\n\t\tif (internalDef.renderSystem && ri < 0) renderSystems.push(compName)\n\t\tif (!internalDef.renderSystem && ri >= 0) renderSystems.splice(ri, 1)\n\t\trenderSystems.sort((a, b) => components[a].order - components[b].order)\n\n\t\t// for any existing entities with the component,\n\t\t// add any default state properties they're missing\n\t\tvar baseState = internalDef.state\n\t\tthis.getStatesList(compName).forEach(state => {\n\t\t\tfor (var key in baseState) {\n\t\t\t\tif (!(key in state)) state[key] = baseState[key]\n\t\t\t}\n\t\t\t// also call the new comp's add handler, if any\n\t\t\tif (internalDef.onAdd) internalDef.onAdd(state.__id, state)\n\t\t})\n\n\n\t\treturn compName\n\t}\n\n\n\n\n\n\n\n\t/**\n\t * Deletes the component definition with the given name. \n\t * First removes the component from all entities that have it.\n\t * \n\t * **Note:** This API shouldn't be necessary in most real-world usage - \n\t * you should set up all your components during init and then leave them be.\n\t * But it's useful if, say, you receive an ECS from another library and \n\t * you need to replace its components.\n\t * \n\t * ```js\n\t * ecs.deleteComponent( 'some-component' )\n\t * ```\n\t*/\n\tthis.deleteComponent = function (compName) {\n\t\tvar data = storage[compName]\n\t\tif (!data) throw new Error(`Unknown component: ${compName}`)\n\n\t\tdata.flush()\n\t\tdata.list.forEach(obj => {\n\t\t\tif (!obj) return\n\t\t\tvar id = obj.__id || obj[0].__id\n\t\t\tremoveComponent(id, compName)\n\t\t})\n\n\t\tvar i = systems.indexOf(compName)\n\t\tvar j = renderSystems.indexOf(compName)\n\t\tif (i > -1) systems.splice(i, 1)\n\t\tif (j > -1) renderSystems.splice(j, 1)\n\n\t\tstorage[compName].dispose()\n\t\tdelete storage[compName]\n\t\tdelete components[compName]\n\n\t\treturn self\n\t}\n\n\n\n\n\t/**\n\t * Adds a component to an entity, optionally initializing the state object.\n\t * \n\t * ```js\n\t * ecs.createComponent({\n\t * \tname: 'foo',\n\t * \tstate: { val: 1 }\n\t * })\n\t * ecs.addComponent(id1, 'foo')             // use default state\n\t * ecs.addComponent(id2, 'foo', { val:2 })  // pass in state data\n\t * ```\n\t*/\n\tthis.addComponent = function (entID, compName, state) {\n\t\tvar def = components[compName]\n\t\tvar data = storage[compName]\n\t\tif (!data) throw new Error(`Unknown component: ${compName}.`)\n\n\t\t// treat adding an existing (non-multi-) component as an error\n\t\tif (data.hash[entID] && !def.multi) {\n\t\t\tthrow new Error(`Entity ${entID} already has component: ${compName}.`)\n\t\t}\n\n\t\t// create new component state object for this entity\n\t\tvar newState = Object.assign({}, { __id: entID }, def.state, state)\n\n\t\t// just in case passed-in state object had an __id property\n\t\tnewState.__id = entID\n\n\t\t// add to data store - for multi components, may already be present\n\t\tif (def.multi) {\n\t\t\tvar statesArr = data.hash[entID]\n\t\t\tif (!statesArr) {\n\t\t\t\tstatesArr = []\n\t\t\t\tdata.add(entID, statesArr)\n\t\t\t}\n\t\t\tstatesArr.push(newState)\n\t\t} else {\n\t\t\tdata.add(entID, newState)\n\t\t}\n\n\t\t// call handler and return\n\t\tif (def.onAdd) def.onAdd(entID, newState)\n\n\t\treturn this\n\t}\n\n\n\n\t/**\n\t * Checks if an entity has a component.\n\t * \n\t * ```js\n\t * ecs.addComponent(id, 'foo')\n\t * ecs.hasComponent(id, 'foo')       // true\n\t * ```\n\t*/\n\n\tthis.hasComponent = function (entID, compName) {\n\t\tvar data = storage[compName]\n\t\tif (!data) throw new Error(`Unknown component: ${compName}.`)\n\t\treturn !!data.hash[entID]\n\t}\n\n\n\n\n\n\t/**\n\t * Removes a component from an entity, triggering the component's \n\t * `onRemove` handler, and then deleting any state data.\n\t * \n\t * ```js\n\t * ecs.removeComponent(id, 'foo')\n\t * ecs.hasComponent(id, 'foo')     \t // false\n\t * ```\n\t*/\n\tthis.removeComponent = function (entID, compName) {\n\t\tvar data = storage[compName]\n\t\tif (!data) throw new Error(`Unknown component: ${compName}.`)\n\n\t\t// removal implementations at end\n\t\tremoveComponent(entID, compName)\n\n\t\treturn self\n\t}\n\n\n\n\n\n\t/**\n\t * Get the component state for a given entity.\n\t * It will automatically have an `__id` property for the entity id.\n\t * \n\t * ```js\n\t * ecs.createComponent({\n\t * \tname: 'foo',\n\t * \tstate: { val: 0 }\n\t * })\n\t * ecs.addComponent(id, 'foo')\n\t * ecs.getState(id, 'foo').val       // 0\n\t * ecs.getState(id, 'foo').__id      // equals id\n\t * ```\n\t*/\n\n\tthis.getState = function (entID, compName) {\n\t\tvar data = storage[compName]\n\t\tif (!data) throw new Error(`Unknown component: ${compName}.`)\n\t\treturn data.hash[entID]\n\t}\n\n\n\n\n\t/**\n\t * Get an array of state objects for every entity with the given component. \n\t * Each one will have an `__id` property for the entity id it refers to.\n\t * Don't add or remove elements from the returned list!\n\t * \n\t * ```js\n\t * var arr = ecs.getStatesList('foo')\n\t * // returns something shaped like:\n\t * //   [\n\t * //     {__id:0, x:1},\n\t * //     {__id:7, x:2},\n\t * //   ]\n\t * ```  \n\t*/\n\n\tthis.getStatesList = function (compName) {\n\t\tvar data = storage[compName]\n\t\tif (!data) throw new Error(`Unknown component: ${compName}.`)\n\t\tdoDeferredCleanup(data)\n\t\treturn data.list\n\t}\n\n\n\n\n\t/**\n\t * Makes a `getState`-like accessor bound to a given component. \n\t * The accessor is faster than `getState`, so you may want to create \n\t * an accessor for any component you'll be accessing a lot.\n\t * \n\t * ```js\n\t * ecs.createComponent({\n\t * \tname: 'size',\n\t * \tstate: { val: 0 }\n\t * })\n\t * var getEntitySize = ecs.getStateAccessor('size')\n\t * // ...\n\t * ecs.addComponent(id, 'size', { val:123 })\n\t * getEntitySize(id).val      // 123\n\t * ```  \n\t*/\n\n\tthis.getStateAccessor = function (compName) {\n\t\tif (!storage[compName]) throw new Error(`Unknown component: ${compName}.`)\n\t\tvar hash = storage[compName].hash\n\t\treturn (id) => hash[id]\n\t}\n\n\n\n\n\t/**\n\t * Makes a `hasComponent`-like accessor function bound to a given component. \n\t * The accessor is much faster than `hasComponent`.\n\t * \n\t * ```js\n\t * ecs.createComponent({\n\t * \tname: 'foo',\n\t * })\n\t * var hasFoo = ecs.getComponentAccessor('foo')\n\t * // ...\n\t * ecs.addComponent(id, 'foo')\n\t * hasFoo(id) // true\n\t * ```  \n\t*/\n\n\tthis.getComponentAccessor = function (compName) {\n\t\tif (!storage[compName]) throw new Error(`Unknown component: ${compName}.`)\n\t\tvar hash = storage[compName].hash\n\t\treturn (id) => !!hash[id]\n\t}\n\n\n\n\n\n\t/**\n\t * Tells the ECS that a game tick has occurred, causing component \n\t * `system` functions to get called.\n\t * \n\t * The optional parameter simply gets passed to the system functions. \n\t * It's meant to be a timestep, but can be used (or not used) as you like.    \n\t * \n\t * If components have an `order` property, they'll get called in that order\n\t * (lowest to highest). Component order defaults to `99`.\n\t * ```js\n\t * ecs.createComponent({\n\t * \tname: foo,\n\t * \torder: 1,\n\t * \tsystem: function(dt, states) {\n\t * \t\t// states is the same array you'd get from #getStatesList()\n\t * \t\tstates.forEach(state => {\n\t * \t\t\tconsole.log('Entity ID: ', state.__id)\n\t * \t\t})\n\t * \t}\n\t * })\n\t * ecs.tick(30) // triggers log statements\n\t * ```\n\t*/\n\n\tthis.tick = function (dt) {\n\t\tdoDeferredCleanup()\n\t\tfor (var i = 0; i < systems.length; i++) {\n\t\t\tvar compName = systems[i]\n\t\t\tvar comp = components[compName]\n\t\t\tvar data = storage[compName]\n\t\t\tcomp.system(dt, data.list)\n\t\t\tdoDeferredCleanup()\n\t\t}\n\t\treturn self\n\t}\n\n\n\n\t/**\n\t * Functions exactly like `tick`, but calls `renderSystem` functions.\n\t * this effectively gives you a second set of systems that are \n\t * called with separate timing, in case you want to \n\t * [tick and render in separate loops](http://gafferongames.com/game-physics/fix-your-timestep/)\n\t * (which you should!).\n\t * \n\t * ```js\n\t * ecs.createComponent({\n\t * \tname: foo,\n\t * \torder: 5,\n\t * \trenderSystem: function(dt, states) {\n\t * \t\t// states is the same array you'd get from #getStatesList()\n\t * \t}\n\t * })\n\t * ecs.render(1000/60)\n\t * ```\n\t*/\n\n\tthis.render = function (dt) {\n\t\tdoDeferredCleanup()\n\t\tfor (var i = 0; i < renderSystems.length; i++) {\n\t\t\tvar compName = renderSystems[i]\n\t\t\tvar comp = components[compName]\n\t\t\tvar data = storage[compName]\n\t\t\tcomp.renderSystem(dt, data.list)\n\t\t\tdoDeferredCleanup()\n\t\t}\n\t\treturn self\n\t}\n\n\n\n\n\t/**\n\t * Removes one particular instance of a multi-component.\n\t * To avoid breaking loops, the relevant state object will get nulled\n\t * immediately, and spliced from the states array later when safe \n\t * (after the current tick/render/animationFrame).\n\t * \n\t * ```js\n\t * // where component 'foo' is a multi-component\n\t * ecs.getState(id, 'foo')   // [ state1, state2, state3 ]\n\t * ecs.removeMultiComponent(id, 'foo', 1)\n\t * ecs.getState(id, 'foo')   // [ state1, null, state3 ]\n\t * // one JS event loop later...\n\t * ecs.getState(id, 'foo')   // [ state1, state3 ]\n\t * ```\n\t */\n\tthis.removeMultiComponent = function (entID, compName, index) {\n\t\tvar def = components[compName]\n\t\tvar data = storage[compName]\n\t\tif (!data) throw new Error(`Unknown component: ${compName}.`)\n\t\tif (!def.multi) throw new Error('removeMultiComponent called on non-multi component')\n\n\t\t// removal implementations at end\n\t\tremoveMultiCompElement(entID, def, data, index)\n\n\t\treturn self\n\t}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\t/*\n\t * \n\t * \n\t *\t\tinternal implementations of remove/delete operations\n\t * \t\ta bit hairy due to deferred cleanup, etc.\n\t * \n\t * \n\t*/\n\n\n\t// remove given component from an entity\n\tfunction removeComponent(entID, compName) {\n\t\tvar def = components[compName]\n\t\tvar data = storage[compName]\n\n\t\t// fail silently on all cases where removal target isn't present,\n\t\t// since multiple pieces of logic often remove/delete simultaneously\n\t\tvar state = data.hash[entID]\n\t\tif (!state) return\n\n\t\t// null out data now, so overlapped remove events won't fire\n\t\tdata.remove(entID)\n\n\t\t// call onRemove handler - on each instance for multi components\n\t\tif (def.onRemove) {\n\t\t\tif (def.multi) {\n\t\t\t\tstate.forEach(state => {\n\t\t\t\t\tif (state) def.onRemove(entID, state)\n\t\t\t\t})\n\t\t\t\tstate.length = 0\n\t\t\t} else {\n\t\t\t\tdef.onRemove(entID, state)\n\t\t\t}\n\t\t}\n\n\t\tdeferrals.removals.push(data)\n\t\tpingDeferrals()\n\t}\n\n\n\t// remove one state from a multi component\n\tfunction removeMultiCompElement(entID, def, data, index) {\n\t\t// if statesArr isn't present there's no work or cleanup to do\n\t\tvar statesArr = data.hash[entID]\n\t\tif (!statesArr) return\n\n\t\t// as above, ignore cases where removal target doesn't exist\n\t\tvar state = statesArr[index]\n\t\tif (!state) return\n\n\t\t// null out element and fire event\n\t\tstatesArr[index] = null\n\t\tif (def.onRemove) def.onRemove(entID, state)\n\n\t\tdeferrals.multiComps.push({ entID, data })\n\t\tpingDeferrals()\n\t}\n\n\n\n\n\n\n\n\t// rigging\n\tfunction pingDeferrals() {\n\t\tif (deferrals.timeout) return\n\t\tdeferrals.timeout = true\n\t\tsetTimeout(deferralHandler, 1)\n\t}\n\n\tfunction deferralHandler() {\n\t\tdeferrals.timeout = false\n\t\tdoDeferredCleanup()\n\t}\n\n\n\t/*\n\t * \n\t *\t\tgeneral handling for deferred data cleanup\n\t * \t\t\t- removes null states if component is multi\n\t * \t\t\t- removes null entries from component dataStore\n\t * \t\tshould be called at safe times - not during state loops\n\t * \n\t*/\n\n\tfunction doDeferredCleanup() {\n\t\tif (deferrals.multiComps.length) {\n\t\t\tdeferredMultiCompCleanup(deferrals.multiComps)\n\t\t}\n\t\tif (deferrals.removals.length) {\n\t\t\tdeferredComponentCleanup(deferrals.removals)\n\t\t}\n\t}\n\n\t// removes null elements from multi-comp state arrays\n\tfunction deferredMultiCompCleanup(list) {\n\t\tfor (var i = 0; i < list.length; i++) {\n\t\t\tvar { entID, data } = list[i]\n\t\t\tvar statesArr = data.hash[entID]\n\t\t\tif (!statesArr) continue\n\t\t\tfor (var j = 0; j < statesArr.length; j++) {\n\t\t\t\tif (statesArr[j]) continue\n\t\t\t\tstatesArr.splice(j, 1)\n\t\t\t\tj--\n\t\t\t}\n\t\t\t// if this leaves the states list empty, remove the whole component\n\t\t\tif (statesArr.length === 0) {\n\t\t\t\tdata.remove(entID)\n\t\t\t\tdeferrals.removals.push(data)\n\t\t\t}\n\t\t}\n\t\tlist.length = 0\n\t}\n\n\t// flushes dataStore after components have been removed\n\tfunction deferredComponentCleanup(list) {\n\t\tfor (var i = 0; i < list.length; i++) {\n\t\t\tvar data = list[i]\n\t\t\tdata.flush()\n\t\t}\n\t\tlist.length = 0\n\t}\n\n\n\n}\n\n", "/**\n * Bit twiddling hacks for JavaScript.\n *\n * Author: Mikola Lysenko\n *\n * Ported from Stanford bit twiddling hack library:\n *    http://graphics.stanford.edu/~seander/bithacks.html\n */\n\n\"use strict\"; \"use restrict\";\n\n//Number of bits in an integer\nvar INT_BITS = 32;\n\n//Constants\nexports.INT_BITS  = INT_BITS;\nexports.INT_MAX   =  0x7fffffff;\nexports.INT_MIN   = -1<<(INT_BITS-1);\n\n//Returns -1, 0, +1 depending on sign of x\nexports.sign = function(v) {\n  return (v > 0) - (v < 0);\n}\n\n//Computes absolute value of integer\nexports.abs = function(v) {\n  var mask = v >> (INT_BITS-1);\n  return (v ^ mask) - mask;\n}\n\n//Computes minimum of integers x and y\nexports.min = function(x, y) {\n  return y ^ ((x ^ y) & -(x < y));\n}\n\n//Computes maximum of integers x and y\nexports.max = function(x, y) {\n  return x ^ ((x ^ y) & -(x < y));\n}\n\n//Checks if a number is a power of two\nexports.isPow2 = function(v) {\n  return !(v & (v-1)) && (!!v);\n}\n\n//Computes log base 2 of v\nexports.log2 = function(v) {\n  var r, shift;\n  r =     (v > 0xFFFF) << 4; v >>>= r;\n  shift = (v > 0xFF  ) << 3; v >>>= shift; r |= shift;\n  shift = (v > 0xF   ) << 2; v >>>= shift; r |= shift;\n  shift = (v > 0x3   ) << 1; v >>>= shift; r |= shift;\n  return r | (v >> 1);\n}\n\n//Computes log base 10 of v\nexports.log10 = function(v) {\n  return  (v >= 1000000000) ? 9 : (v >= 100000000) ? 8 : (v >= 10000000) ? 7 :\n          (v >= 1000000) ? 6 : (v >= 100000) ? 5 : (v >= 10000) ? 4 :\n          (v >= 1000) ? 3 : (v >= 100) ? 2 : (v >= 10) ? 1 : 0;\n}\n\n//Counts number of bits\nexports.popCount = function(v) {\n  v = v - ((v >>> 1) & 0x55555555);\n  v = (v & 0x33333333) + ((v >>> 2) & 0x33333333);\n  return ((v + (v >>> 4) & 0xF0F0F0F) * 0x1010101) >>> 24;\n}\n\n//Counts number of trailing zeros\nfunction countTrailingZeros(v) {\n  var c = 32;\n  v &= -v;\n  if (v) c--;\n  if (v & 0x0000FFFF) c -= 16;\n  if (v & 0x00FF00FF) c -= 8;\n  if (v & 0x0F0F0F0F) c -= 4;\n  if (v & 0x33333333) c -= 2;\n  if (v & 0x55555555) c -= 1;\n  return c;\n}\nexports.countTrailingZeros = countTrailingZeros;\n\n//Rounds to next power of 2\nexports.nextPow2 = function(v) {\n  v += v === 0;\n  --v;\n  v |= v >>> 1;\n  v |= v >>> 2;\n  v |= v >>> 4;\n  v |= v >>> 8;\n  v |= v >>> 16;\n  return v + 1;\n}\n\n//Rounds down to previous power of 2\nexports.prevPow2 = function(v) {\n  v |= v >>> 1;\n  v |= v >>> 2;\n  v |= v >>> 4;\n  v |= v >>> 8;\n  v |= v >>> 16;\n  return v - (v>>>1);\n}\n\n//Computes parity of word\nexports.parity = function(v) {\n  v ^= v >>> 16;\n  v ^= v >>> 8;\n  v ^= v >>> 4;\n  v &= 0xf;\n  return (0x6996 >>> v) & 1;\n}\n\nvar REVERSE_TABLE = new Array(256);\n\n(function(tab) {\n  for(var i=0; i<256; ++i) {\n    var v = i, r = i, s = 7;\n    for (v >>>= 1; v; v >>>= 1) {\n      r <<= 1;\n      r |= v & 1;\n      --s;\n    }\n    tab[i] = (r << s) & 0xff;\n  }\n})(REVERSE_TABLE);\n\n//Reverse bits in a 32 bit word\nexports.reverse = function(v) {\n  return  (REVERSE_TABLE[ v         & 0xff] << 24) |\n          (REVERSE_TABLE[(v >>> 8)  & 0xff] << 16) |\n          (REVERSE_TABLE[(v >>> 16) & 0xff] << 8)  |\n           REVERSE_TABLE[(v >>> 24) & 0xff];\n}\n\n//Interleave bits of 2 coordinates with 16 bits.  Useful for fast quadtree codes\nexports.interleave2 = function(x, y) {\n  x &= 0xFFFF;\n  x = (x | (x << 8)) & 0x00FF00FF;\n  x = (x | (x << 4)) & 0x0F0F0F0F;\n  x = (x | (x << 2)) & 0x33333333;\n  x = (x | (x << 1)) & 0x55555555;\n\n  y &= 0xFFFF;\n  y = (y | (y << 8)) & 0x00FF00FF;\n  y = (y | (y << 4)) & 0x0F0F0F0F;\n  y = (y | (y << 2)) & 0x33333333;\n  y = (y | (y << 1)) & 0x55555555;\n\n  return x | (y << 1);\n}\n\n//Extracts the nth interleaved component\nexports.deinterleave2 = function(v, n) {\n  v = (v >>> n) & 0x55555555;\n  v = (v | (v >>> 1))  & 0x33333333;\n  v = (v | (v >>> 2))  & 0x0F0F0F0F;\n  v = (v | (v >>> 4))  & 0x00FF00FF;\n  v = (v | (v >>> 16)) & 0x000FFFF;\n  return (v << 16) >> 16;\n}\n\n\n//Interleave bits of 3 coordinates, each with 10 bits.  Useful for fast octree codes\nexports.interleave3 = function(x, y, z) {\n  x &= 0x3FF;\n  x  = (x | (x<<16)) & 4278190335;\n  x  = (x | (x<<8))  & 251719695;\n  x  = (x | (x<<4))  & 3272356035;\n  x  = (x | (x<<2))  & 1227133513;\n\n  y &= 0x3FF;\n  y  = (y | (y<<16)) & 4278190335;\n  y  = (y | (y<<8))  & 251719695;\n  y  = (y | (y<<4))  & 3272356035;\n  y  = (y | (y<<2))  & 1227133513;\n  x |= (y << 1);\n  \n  z &= 0x3FF;\n  z  = (z | (z<<16)) & 4278190335;\n  z  = (z | (z<<8))  & 251719695;\n  z  = (z | (z<<4))  & 3272356035;\n  z  = (z | (z<<2))  & 1227133513;\n  \n  return x | (z << 2);\n}\n\n//Extracts nth interleaved component of a 3-tuple\nexports.deinterleave3 = function(v, n) {\n  v = (v >>> n)       & 1227133513;\n  v = (v | (v>>>2))   & 3272356035;\n  v = (v | (v>>>4))   & 251719695;\n  v = (v | (v>>>8))   & 4278190335;\n  v = (v | (v>>>16))  & 0x3FF;\n  return (v<<22)>>22;\n}\n\n//Computes next combination in colexicographic order (this is mistakenly called nextPermutation on the bit twiddling hacks page)\nexports.nextCombination = function(v) {\n  var t = v | (v - 1);\n  return (t + 1) | (((~t & -~t) - 1) >>> (countTrailingZeros(v) + 1));\n}\n\n", "\"use strict\"\n\nfunction dupe_array(count, value, i) {\n  var c = count[i]|0\n  if(c <= 0) {\n    return []\n  }\n  var result = new Array(c), j\n  if(i === count.length-1) {\n    for(j=0; j<c; ++j) {\n      result[j] = value\n    }\n  } else {\n    for(j=0; j<c; ++j) {\n      result[j] = dupe_array(count, value, i+1)\n    }\n  }\n  return result\n}\n\nfunction dupe_number(count, value) {\n  var result, i\n  result = new Array(count)\n  for(i=0; i<count; ++i) {\n    result[i] = value\n  }\n  return result\n}\n\nfunction dupe(count, value) {\n  if(typeof value === \"undefined\") {\n    value = 0\n  }\n  switch(typeof count) {\n    case \"number\":\n      if(count > 0) {\n        return dupe_number(count|0, value)\n      }\n    break\n    case \"object\":\n      if(typeof (count.length) === \"number\") {\n        return dupe_array(count, value, 0)\n      }\n    break\n  }\n  return []\n}\n\nmodule.exports = dupe", "/*!\n * Determine if an object is a Buffer\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n\nmodule.exports = function isBuffer (obj) {\n  return obj != null && obj.constructor != null &&\n    typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)\n}\n", "'use strict'\n\nvar bits = require('bit-twiddle')\nvar dup = require('dup')\nvar isBuffer = require('is-buffer')\n\n//Legacy pool support\nif(!global.__TYPEDARRAY_POOL) {\n  global.__TYPEDARRAY_POOL = {\n      UINT8   : dup([32, 0])\n    , UINT16  : dup([32, 0])\n    , UINT32  : dup([32, 0])\n    , INT8    : dup([32, 0])\n    , INT16   : dup([32, 0])\n    , INT32   : dup([32, 0])\n    , FLOAT   : dup([32, 0])\n    , DOUBLE  : dup([32, 0])\n    , DATA    : dup([32, 0])\n    , UINT8C  : dup([32, 0])\n    , BUFFER  : dup([32, 0])\n  }\n}\n\nvar hasUint8C = (typeof Uint8ClampedArray) !== 'undefined'\nvar POOL = global.__TYPEDARRAY_POOL\n\n//Upgrade pool\nif(!POOL.UINT8C) {\n  POOL.UINT8C = dup([32, 0])\n}\nif(!POOL.BUFFER) {\n  POOL.BUFFER = dup([32, 0])\n}\n\n//New technique: Only allocate from ArrayBufferView and Buffer\nvar DATA    = POOL.DATA\n  , BUFFER  = POOL.BUFFER\n\nexports.free = function free(array) {\n  if(isBuffer(array)) {\n    BUFFER[bits.log2(array.length)].push(array)\n  } else {\n    if(Object.prototype.toString.call(array) !== '[object ArrayBuffer]') {\n      array = array.buffer\n    }\n    if(!array) {\n      return\n    }\n    var n = array.length || array.byteLength\n    var log_n = bits.log2(n)|0\n    DATA[log_n].push(array)\n  }\n}\n\nfunction freeArrayBuffer(buffer) {\n  if(!buffer) {\n    return\n  }\n  var n = buffer.length || buffer.byteLength\n  var log_n = bits.log2(n)\n  DATA[log_n].push(buffer)\n}\n\nfunction freeTypedArray(array) {\n  freeArrayBuffer(array.buffer)\n}\n\nexports.freeUint8 =\nexports.freeUint16 =\nexports.freeUint32 =\nexports.freeInt8 =\nexports.freeInt16 =\nexports.freeInt32 =\nexports.freeFloat32 = \nexports.freeFloat =\nexports.freeFloat64 = \nexports.freeDouble = \nexports.freeUint8Clamped = \nexports.freeDataView = freeTypedArray\n\nexports.freeArrayBuffer = freeArrayBuffer\n\nexports.freeBuffer = function freeBuffer(array) {\n  BUFFER[bits.log2(array.length)].push(array)\n}\n\nexports.malloc = function malloc(n, dtype) {\n  if(dtype === undefined || dtype === 'arraybuffer') {\n    return mallocArrayBuffer(n)\n  } else {\n    switch(dtype) {\n      case 'uint8':\n        return mallocUint8(n)\n      case 'uint16':\n        return mallocUint16(n)\n      case 'uint32':\n        return mallocUint32(n)\n      case 'int8':\n        return mallocInt8(n)\n      case 'int16':\n        return mallocInt16(n)\n      case 'int32':\n        return mallocInt32(n)\n      case 'float':\n      case 'float32':\n        return mallocFloat(n)\n      case 'double':\n      case 'float64':\n        return mallocDouble(n)\n      case 'uint8_clamped':\n        return mallocUint8Clamped(n)\n      case 'buffer':\n        throw 'Buffer not supported'\n      case 'data':\n      case 'dataview':\n        return mallocDataView(n)\n\n      default:\n        return null\n    }\n  }\n  return null\n}\n\nfunction mallocArrayBuffer(n) {\n  var n = bits.nextPow2(n)\n  var log_n = bits.log2(n)\n  var d = DATA[log_n]\n  if(d.length > 0) {\n    return d.pop()\n  }\n  return new ArrayBuffer(n)\n}\nexports.mallocArrayBuffer = mallocArrayBuffer\n\nfunction mallocUint8(n) {\n  return new Uint8Array(mallocArrayBuffer(n), 0, n)\n}\nexports.mallocUint8 = mallocUint8\n\nfunction mallocUint16(n) {\n  return new Uint16Array(mallocArrayBuffer(2*n), 0, n)\n}\nexports.mallocUint16 = mallocUint16\n\nfunction mallocUint32(n) {\n  return new Uint32Array(mallocArrayBuffer(4*n), 0, n)\n}\nexports.mallocUint32 = mallocUint32\n\nfunction mallocInt8(n) {\n  return new Int8Array(mallocArrayBuffer(n), 0, n)\n}\nexports.mallocInt8 = mallocInt8\n\nfunction mallocInt16(n) {\n  return new Int16Array(mallocArrayBuffer(2*n), 0, n)\n}\nexports.mallocInt16 = mallocInt16\n\nfunction mallocInt32(n) {\n  return new Int32Array(mallocArrayBuffer(4*n), 0, n)\n}\nexports.mallocInt32 = mallocInt32\n\nfunction mallocFloat(n) {\n  return new Float32Array(mallocArrayBuffer(4*n), 0, n)\n}\nexports.mallocFloat32 = exports.mallocFloat = mallocFloat\n\nfunction mallocDouble(n) {\n  return new Float64Array(mallocArrayBuffer(8*n), 0, n)\n}\nexports.mallocFloat64 = exports.mallocDouble = mallocDouble\n\nfunction mallocUint8Clamped(n) {\n  if(hasUint8C) {\n    return new Uint8ClampedArray(mallocArrayBuffer(n), 0, n)\n  } else {\n    return mallocUint8(n)\n  }\n}\nexports.mallocUint8Clamped = mallocUint8Clamped\n\nfunction mallocDataView(n) {\n  return new DataView(mallocArrayBuffer(n), 0, n)\n}\nexports.mallocDataView = mallocDataView\n\nexports.clearCache = function clearCache() {\n  for(var i=0; i<32; ++i) {\n    POOL.UINT8[i].length = 0\n    POOL.UINT16[i].length = 0\n    POOL.UINT32[i].length = 0\n    POOL.INT8[i].length = 0\n    POOL.INT16[i].length = 0\n    POOL.INT32[i].length = 0\n    POOL.FLOAT[i].length = 0\n    POOL.DOUBLE[i].length = 0\n    POOL.UINT8C[i].length = 0\n    DATA[i].length = 0\n    BUFFER[i].length = 0\n  }\n}", "'use strict';\n\n//This code is extracted from ndarray-sort\n//It is inlined here as a temporary workaround\n\nmodule.exports = wrapper;\n\nvar INSERT_SORT_CUTOFF = 32\n\nfunction wrapper(data, n0) {\n  if (n0 <= 4*INSERT_SORT_CUTOFF) {\n    insertionSort(0, n0 - 1, data);\n  } else {\n    quickSort(0, n0 - 1, data);\n  }\n}\n\nfunction insertionSort(left, right, data) {\n  var ptr = 2*(left+1)\n  for(var i=left+1; i<=right; ++i) {\n    var a = data[ptr++]\n    var b = data[ptr++]\n    var j = i\n    var jptr = ptr-2\n    while(j-- > left) {\n      var x = data[jptr-2]\n      var y = data[jptr-1]\n      if(x < a) {\n        break\n      } else if(x === a && y < b) {\n        break\n      }\n      data[jptr]   = x\n      data[jptr+1] = y\n      jptr -= 2\n    }\n    data[jptr]   = a\n    data[jptr+1] = b\n  }\n}\n\nfunction swap(i, j, data) {\n  i *= 2\n  j *= 2\n  var x = data[i]\n  var y = data[i+1]\n  data[i] = data[j]\n  data[i+1] = data[j+1]\n  data[j] = x\n  data[j+1] = y\n}\n\nfunction move(i, j, data) {\n  i *= 2\n  j *= 2\n  data[i] = data[j]\n  data[i+1] = data[j+1]\n}\n\nfunction rotate(i, j, k, data) {\n  i *= 2\n  j *= 2\n  k *= 2\n  var x = data[i]\n  var y = data[i+1]\n  data[i] = data[j]\n  data[i+1] = data[j+1]\n  data[j] = data[k]\n  data[j+1] = data[k+1]\n  data[k] = x\n  data[k+1] = y\n}\n\nfunction shufflePivot(i, j, px, py, data) {\n  i *= 2\n  j *= 2\n  data[i] = data[j]\n  data[j] = px\n  data[i+1] = data[j+1]\n  data[j+1] = py\n}\n\nfunction compare(i, j, data) {\n  i *= 2\n  j *= 2\n  var x = data[i],\n      y = data[j]\n  if(x < y) {\n    return false\n  } else if(x === y) {\n    return data[i+1] > data[j+1]\n  }\n  return true\n}\n\nfunction comparePivot(i, y, b, data) {\n  i *= 2\n  var x = data[i]\n  if(x < y) {\n    return true\n  } else if(x === y) {\n    return data[i+1] < b\n  }\n  return false\n}\n\nfunction quickSort(left, right, data) {\n  var sixth = (right - left + 1) / 6 | 0, \n      index1 = left + sixth, \n      index5 = right - sixth, \n      index3 = left + right >> 1, \n      index2 = index3 - sixth, \n      index4 = index3 + sixth, \n      el1 = index1, \n      el2 = index2, \n      el3 = index3, \n      el4 = index4, \n      el5 = index5, \n      less = left + 1, \n      great = right - 1, \n      tmp = 0\n  if(compare(el1, el2, data)) {\n    tmp = el1\n    el1 = el2\n    el2 = tmp\n  }\n  if(compare(el4, el5, data)) {\n    tmp = el4\n    el4 = el5\n    el5 = tmp\n  }\n  if(compare(el1, el3, data)) {\n    tmp = el1\n    el1 = el3\n    el3 = tmp\n  }\n  if(compare(el2, el3, data)) {\n    tmp = el2\n    el2 = el3\n    el3 = tmp\n  }\n  if(compare(el1, el4, data)) {\n    tmp = el1\n    el1 = el4\n    el4 = tmp\n  }\n  if(compare(el3, el4, data)) {\n    tmp = el3\n    el3 = el4\n    el4 = tmp\n  }\n  if(compare(el2, el5, data)) {\n    tmp = el2\n    el2 = el5\n    el5 = tmp\n  }\n  if(compare(el2, el3, data)) {\n    tmp = el2\n    el2 = el3\n    el3 = tmp\n  }\n  if(compare(el4, el5, data)) {\n    tmp = el4\n    el4 = el5\n    el5 = tmp\n  }\n\n  var pivot1X = data[2*el2]\n  var pivot1Y = data[2*el2+1]\n  var pivot2X = data[2*el4]\n  var pivot2Y = data[2*el4+1]\n\n  var ptr0 = 2 * el1;\n  var ptr2 = 2 * el3;\n  var ptr4 = 2 * el5;\n  var ptr5 = 2 * index1;\n  var ptr6 = 2 * index3;\n  var ptr7 = 2 * index5;\n  for (var i1 = 0; i1 < 2; ++i1) {\n    var x = data[ptr0+i1];\n    var y = data[ptr2+i1];\n    var z = data[ptr4+i1];\n    data[ptr5+i1] = x;\n    data[ptr6+i1] = y;\n    data[ptr7+i1] = z;\n  }\n\n  move(index2, left, data)\n  move(index4, right, data)\n  for (var k = less; k <= great; ++k) {\n    if (comparePivot(k, pivot1X, pivot1Y, data)) {\n      if (k !== less) {\n        swap(k, less, data)\n      }\n      ++less;\n    } else {\n      if (!comparePivot(k, pivot2X, pivot2Y, data)) {\n        while (true) {\n          if (!comparePivot(great, pivot2X, pivot2Y, data)) {\n            if (--great < k) {\n              break;\n            }\n            continue;\n          } else {\n            if (comparePivot(great, pivot1X, pivot1Y, data)) {\n              rotate(k, less, great, data)\n              ++less;\n              --great;\n            } else {\n              swap(k, great, data)\n              --great;\n            }\n            break;\n          }\n        }\n      }\n    }\n  }\n  shufflePivot(left, less-1, pivot1X, pivot1Y, data)\n  shufflePivot(right, great+1, pivot2X, pivot2Y, data)\n  if (less - 2 - left <= INSERT_SORT_CUTOFF) {\n    insertionSort(left, less - 2, data);\n  } else {\n    quickSort(left, less - 2, data);\n  }\n  if (right - (great + 2) <= INSERT_SORT_CUTOFF) {\n    insertionSort(great + 2, right, data);\n  } else {\n    quickSort(great + 2, right, data);\n  }\n  if (great - less <= INSERT_SORT_CUTOFF) {\n    insertionSort(less, great, data);\n  } else {\n    quickSort(less, great, data);\n  }\n}", "'use strict'\n\nmodule.exports = {\n  init:           sqInit,\n  sweepBipartite: sweepBipartite,\n  sweepComplete:  sweepComplete,\n  scanBipartite:  scanBipartite,\n  scanComplete:   scanComplete\n}\n\nvar pool  = require('@jpweeks/typedarray-pool')\nvar bits  = require('bit-twiddle')\nvar isort = require('./sort')\n\n//Flag for blue\nvar BLUE_FLAG = (1<<28)\n\n//1D sweep event queue stuff (use pool to save space)\nvar INIT_CAPACITY      = 1024\nvar RED_SWEEP_QUEUE    = pool.mallocInt32(INIT_CAPACITY)\nvar RED_SWEEP_INDEX    = pool.mallocInt32(INIT_CAPACITY)\nvar BLUE_SWEEP_QUEUE   = pool.mallocInt32(INIT_CAPACITY)\nvar BLUE_SWEEP_INDEX   = pool.mallocInt32(INIT_CAPACITY)\nvar COMMON_SWEEP_QUEUE = pool.mallocInt32(INIT_CAPACITY)\nvar COMMON_SWEEP_INDEX = pool.mallocInt32(INIT_CAPACITY)\nvar SWEEP_EVENTS       = pool.mallocDouble(INIT_CAPACITY * 8)\n\n//Reserves memory for the 1D sweep data structures\nfunction sqInit(count) {\n  var rcount = bits.nextPow2(count)\n  if(RED_SWEEP_QUEUE.length < rcount) {\n    pool.free(RED_SWEEP_QUEUE)\n    RED_SWEEP_QUEUE = pool.mallocInt32(rcount)\n  }\n  if(RED_SWEEP_INDEX.length < rcount) {\n    pool.free(RED_SWEEP_INDEX)\n    RED_SWEEP_INDEX = pool.mallocInt32(rcount)\n  }\n  if(BLUE_SWEEP_QUEUE.length < rcount) {\n    pool.free(BLUE_SWEEP_QUEUE)\n    BLUE_SWEEP_QUEUE = pool.mallocInt32(rcount)\n  }\n  if(BLUE_SWEEP_INDEX.length < rcount) {\n    pool.free(BLUE_SWEEP_INDEX)\n    BLUE_SWEEP_INDEX = pool.mallocInt32(rcount)\n  }\n  if(COMMON_SWEEP_QUEUE.length < rcount) {\n    pool.free(COMMON_SWEEP_QUEUE)\n    COMMON_SWEEP_QUEUE = pool.mallocInt32(rcount)\n  }\n  if(COMMON_SWEEP_INDEX.length < rcount) {\n    pool.free(COMMON_SWEEP_INDEX)\n    COMMON_SWEEP_INDEX = pool.mallocInt32(rcount)\n  }\n  var eventLength = 8 * rcount\n  if(SWEEP_EVENTS.length < eventLength) {\n    pool.free(SWEEP_EVENTS)\n    SWEEP_EVENTS = pool.mallocDouble(eventLength)\n  }\n}\n\n//Remove an item from the active queue in O(1)\nfunction sqPop(queue, index, count, item) {\n  var idx = index[item]\n  var top = queue[count-1]\n  queue[idx] = top\n  index[top] = idx\n}\n\n//Insert an item into the active queue in O(1)\nfunction sqPush(queue, index, count, item) {\n  queue[count] = item\n  index[item]  = count\n}\n\n//Recursion base case: use 1D sweep algorithm\nfunction sweepBipartite(\n    d, visit,\n    redStart,  redEnd, red, redIndex,\n    blueStart, blueEnd, blue, blueIndex) {\n\n  //store events as pairs [coordinate, idx]\n  //\n  //  red create:  -(idx+1)\n  //  red destroy: idx\n  //  blue create: -(idx+BLUE_FLAG)\n  //  blue destroy: idx+BLUE_FLAG\n  //\n  var ptr      = 0\n  var elemSize = 2*d\n  var istart   = d-1\n  var iend     = elemSize-1\n\n  for(var i=redStart; i<redEnd; ++i) {\n    var idx = redIndex[i]\n    var redOffset = elemSize*i\n    SWEEP_EVENTS[ptr++] = red[redOffset+istart]\n    SWEEP_EVENTS[ptr++] = -(idx+1)\n    SWEEP_EVENTS[ptr++] = red[redOffset+iend]\n    SWEEP_EVENTS[ptr++] = idx\n  }\n\n  for(var i=blueStart; i<blueEnd; ++i) {\n    var idx = blueIndex[i]+BLUE_FLAG\n    var blueOffset = elemSize*i\n    SWEEP_EVENTS[ptr++] = blue[blueOffset+istart]\n    SWEEP_EVENTS[ptr++] = -idx\n    SWEEP_EVENTS[ptr++] = blue[blueOffset+iend]\n    SWEEP_EVENTS[ptr++] = idx\n  }\n\n  //process events from left->right\n  var n = ptr >>> 1\n  isort(SWEEP_EVENTS, n)\n  \n  var redActive  = 0\n  var blueActive = 0\n  for(var i=0; i<n; ++i) {\n    var e = SWEEP_EVENTS[2*i+1]|0\n    if(e >= BLUE_FLAG) {\n      //blue destroy event\n      e = (e-BLUE_FLAG)|0\n      sqPop(BLUE_SWEEP_QUEUE, BLUE_SWEEP_INDEX, blueActive--, e)\n    } else if(e >= 0) {\n      //red destroy event\n      sqPop(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive--, e)\n    } else if(e <= -BLUE_FLAG) {\n      //blue create event\n      e = (-e-BLUE_FLAG)|0\n      for(var j=0; j<redActive; ++j) {\n        var retval = visit(RED_SWEEP_QUEUE[j], e)\n        if(retval !== void 0) {\n          return retval\n        }\n      }\n      sqPush(BLUE_SWEEP_QUEUE, BLUE_SWEEP_INDEX, blueActive++, e)\n    } else {\n      //red create event\n      e = (-e-1)|0\n      for(var j=0; j<blueActive; ++j) {\n        var retval = visit(e, BLUE_SWEEP_QUEUE[j])\n        if(retval !== void 0) {\n          return retval\n        }\n      }\n      sqPush(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive++, e)\n    }\n  }\n}\n\n//Complete sweep\nfunction sweepComplete(d, visit, \n  redStart, redEnd, red, redIndex,\n  blueStart, blueEnd, blue, blueIndex) {\n\n  var ptr      = 0\n  var elemSize = 2*d\n  var istart   = d-1\n  var iend     = elemSize-1\n\n  for(var i=redStart; i<redEnd; ++i) {\n    var idx = (redIndex[i]+1)<<1\n    var redOffset = elemSize*i\n    SWEEP_EVENTS[ptr++] = red[redOffset+istart]\n    SWEEP_EVENTS[ptr++] = -idx\n    SWEEP_EVENTS[ptr++] = red[redOffset+iend]\n    SWEEP_EVENTS[ptr++] = idx\n  }\n\n  for(var i=blueStart; i<blueEnd; ++i) {\n    var idx = (blueIndex[i]+1)<<1\n    var blueOffset = elemSize*i\n    SWEEP_EVENTS[ptr++] = blue[blueOffset+istart]\n    SWEEP_EVENTS[ptr++] = (-idx)|1\n    SWEEP_EVENTS[ptr++] = blue[blueOffset+iend]\n    SWEEP_EVENTS[ptr++] = idx|1\n  }\n\n  //process events from left->right\n  var n = ptr >>> 1\n  isort(SWEEP_EVENTS, n)\n  \n  var redActive    = 0\n  var blueActive   = 0\n  var commonActive = 0\n  for(var i=0; i<n; ++i) {\n    var e     = SWEEP_EVENTS[2*i+1]|0\n    var color = e&1\n    if(i < n-1 && (e>>1) === (SWEEP_EVENTS[2*i+3]>>1)) {\n      color = 2\n      i += 1\n    }\n    \n    if(e < 0) {\n      //Create event\n      var id = -(e>>1) - 1\n\n      //Intersect with common\n      for(var j=0; j<commonActive; ++j) {\n        var retval = visit(COMMON_SWEEP_QUEUE[j], id)\n        if(retval !== void 0) {\n          return retval\n        }\n      }\n\n      if(color !== 0) {\n        //Intersect with red\n        for(var j=0; j<redActive; ++j) {\n          var retval = visit(RED_SWEEP_QUEUE[j], id)\n          if(retval !== void 0) {\n            return retval\n          }\n        }\n      }\n\n      if(color !== 1) {\n        //Intersect with blue\n        for(var j=0; j<blueActive; ++j) {\n          var retval = visit(BLUE_SWEEP_QUEUE[j], id)\n          if(retval !== void 0) {\n            return retval\n          }\n        }\n      }\n\n      if(color === 0) {\n        //Red\n        sqPush(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive++, id)\n      } else if(color === 1) {\n        //Blue\n        sqPush(BLUE_SWEEP_QUEUE, BLUE_SWEEP_INDEX, blueActive++, id)\n      } else if(color === 2) {\n        //Both\n        sqPush(COMMON_SWEEP_QUEUE, COMMON_SWEEP_INDEX, commonActive++, id)\n      }\n    } else {\n      //Destroy event\n      var id = (e>>1) - 1\n      if(color === 0) {\n        //Red\n        sqPop(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive--, id)\n      } else if(color === 1) {\n        //Blue\n        sqPop(BLUE_SWEEP_QUEUE, BLUE_SWEEP_INDEX, blueActive--, id)\n      } else if(color === 2) {\n        //Both\n        sqPop(COMMON_SWEEP_QUEUE, COMMON_SWEEP_INDEX, commonActive--, id)\n      }\n    }\n  }\n}\n\n//Sweep and prune/scanline algorithm:\n//  Scan along axis, detect intersections\n//  Brute force all boxes along axis\nfunction scanBipartite(\n  d, axis, visit, flip,\n  redStart,  redEnd, red, redIndex,\n  blueStart, blueEnd, blue, blueIndex) {\n  \n  var ptr      = 0\n  var elemSize = 2*d\n  var istart   = axis\n  var iend     = axis+d\n\n  var redShift  = 1\n  var blueShift = 1\n  if(flip) {\n    blueShift = BLUE_FLAG\n  } else {\n    redShift  = BLUE_FLAG\n  }\n\n  for(var i=redStart; i<redEnd; ++i) {\n    var idx = i + redShift\n    var redOffset = elemSize*i\n    SWEEP_EVENTS[ptr++] = red[redOffset+istart]\n    SWEEP_EVENTS[ptr++] = -idx\n    SWEEP_EVENTS[ptr++] = red[redOffset+iend]\n    SWEEP_EVENTS[ptr++] = idx\n  }\n  for(var i=blueStart; i<blueEnd; ++i) {\n    var idx = i + blueShift\n    var blueOffset = elemSize*i\n    SWEEP_EVENTS[ptr++] = blue[blueOffset+istart]\n    SWEEP_EVENTS[ptr++] = -idx\n  }\n\n  //process events from left->right\n  var n = ptr >>> 1\n  isort(SWEEP_EVENTS, n)\n  \n  var redActive    = 0\n  for(var i=0; i<n; ++i) {\n    var e = SWEEP_EVENTS[2*i+1]|0\n    if(e < 0) {\n      var idx   = -e\n      var isRed = false\n      if(idx >= BLUE_FLAG) {\n        isRed = !flip\n        idx -= BLUE_FLAG \n      } else {\n        isRed = !!flip\n        idx -= 1\n      }\n      if(isRed) {\n        sqPush(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive++, idx)\n      } else {\n        var blueId  = blueIndex[idx]\n        var bluePtr = elemSize * idx\n        \n        var b0 = blue[bluePtr+axis+1]\n        var b1 = blue[bluePtr+axis+1+d]\n\nred_loop:\n        for(var j=0; j<redActive; ++j) {\n          var oidx   = RED_SWEEP_QUEUE[j]\n          var redPtr = elemSize * oidx\n\n          if(b1 < red[redPtr+axis+1] || \n             red[redPtr+axis+1+d] < b0) {\n            continue\n          }\n\n          for(var k=axis+2; k<d; ++k) {\n            if(blue[bluePtr + k + d] < red[redPtr + k] || \n               red[redPtr + k + d] < blue[bluePtr + k]) {\n              continue red_loop\n            }\n          }\n\n          var redId  = redIndex[oidx]\n          var retval\n          if(flip) {\n            retval = visit(blueId, redId)\n          } else {\n            retval = visit(redId, blueId)\n          }\n          if(retval !== void 0) {\n            return retval \n          }\n        }\n      }\n    } else {\n      sqPop(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive--, e - redShift)\n    }\n  }\n}\n\nfunction scanComplete(\n  d, axis, visit,\n  redStart,  redEnd, red, redIndex,\n  blueStart, blueEnd, blue, blueIndex) {\n\n  var ptr      = 0\n  var elemSize = 2*d\n  var istart   = axis\n  var iend     = axis+d\n\n  for(var i=redStart; i<redEnd; ++i) {\n    var idx = i + BLUE_FLAG\n    var redOffset = elemSize*i\n    SWEEP_EVENTS[ptr++] = red[redOffset+istart]\n    SWEEP_EVENTS[ptr++] = -idx\n    SWEEP_EVENTS[ptr++] = red[redOffset+iend]\n    SWEEP_EVENTS[ptr++] = idx\n  }\n  for(var i=blueStart; i<blueEnd; ++i) {\n    var idx = i + 1\n    var blueOffset = elemSize*i\n    SWEEP_EVENTS[ptr++] = blue[blueOffset+istart]\n    SWEEP_EVENTS[ptr++] = -idx\n  }\n\n  //process events from left->right\n  var n = ptr >>> 1\n  isort(SWEEP_EVENTS, n)\n  \n  var redActive    = 0\n  for(var i=0; i<n; ++i) {\n    var e = SWEEP_EVENTS[2*i+1]|0\n    if(e < 0) {\n      var idx   = -e\n      if(idx >= BLUE_FLAG) {\n        RED_SWEEP_QUEUE[redActive++] = idx - BLUE_FLAG\n      } else {\n        idx -= 1\n        var blueId  = blueIndex[idx]\n        var bluePtr = elemSize * idx\n\n        var b0 = blue[bluePtr+axis+1]\n        var b1 = blue[bluePtr+axis+1+d]\n\nred_loop:\n        for(var j=0; j<redActive; ++j) {\n          var oidx   = RED_SWEEP_QUEUE[j]\n          var redId  = redIndex[oidx]\n\n          if(redId === blueId) {\n            break\n          }\n\n          var redPtr = elemSize * oidx\n          if(b1 < red[redPtr+axis+1] || \n            red[redPtr+axis+1+d] < b0) {\n            continue\n          }\n          for(var k=axis+2; k<d; ++k) {\n            if(blue[bluePtr + k + d] < red[redPtr + k] || \n               red[redPtr + k + d]   < blue[bluePtr + k]) {\n              continue red_loop\n            }\n          }\n\n          var retval = visit(redId, blueId)\n          if(retval !== void 0) {\n            return retval \n          }\n        }\n      }\n    } else {\n      var idx = e - BLUE_FLAG\n      for(var j=redActive-1; j>=0; --j) {\n        if(RED_SWEEP_QUEUE[j] === idx) {\n          for(var k=j+1; k<redActive; ++k) {\n            RED_SWEEP_QUEUE[k-1] = RED_SWEEP_QUEUE[k]\n          }\n          break\n        }\n      }\n      --redActive\n    }\n  }\n}", "'use strict'\n\nvar DIMENSION   = 'd'\nvar AXIS        = 'ax'\nvar VISIT       = 'vv'\nvar FLIP        = 'fp'\n\nvar ELEM_SIZE   = 'es'\n\nvar RED_START   = 'rs'\nvar RED_END     = 're'\nvar RED_BOXES   = 'rb'\nvar RED_INDEX   = 'ri'\nvar RED_PTR     = 'rp'\n\nvar BLUE_START  = 'bs'\nvar BLUE_END    = 'be'\nvar BLUE_BOXES  = 'bb'\nvar BLUE_INDEX  = 'bi'\nvar BLUE_PTR    = 'bp'\n\nvar RETVAL      = 'rv'\n\nvar INNER_LABEL = 'Q'\n\nvar ARGS = [\n  DIMENSION,\n  AXIS,\n  VISIT,\n  RED_START,\n  RED_END,\n  RED_BOXES,\n  RED_INDEX,\n  BLUE_START,\n  BLUE_END,\n  BLUE_BOXES,\n  BLUE_INDEX\n]\n\nfunction generateBruteForce(redMajor, flip, full) {\n  var funcName = 'bruteForce' + \n    (redMajor ? 'Red' : 'Blue') + \n    (flip ? 'Flip' : '') +\n    (full ? 'Full' : '')\n\n  var code = ['function ', funcName, '(', ARGS.join(), '){',\n    'var ', ELEM_SIZE, '=2*', DIMENSION, ';']\n\n  var redLoop = \n    'for(var i=' + RED_START + ',' + RED_PTR + '=' + ELEM_SIZE + '*' + RED_START + ';' +\n        'i<' + RED_END +';' +\n        '++i,' + RED_PTR + '+=' + ELEM_SIZE + '){' +\n        'var x0=' + RED_BOXES + '[' + AXIS + '+' + RED_PTR + '],' +\n            'x1=' + RED_BOXES + '[' + AXIS + '+' + RED_PTR + '+' + DIMENSION + '],' +\n            'xi=' + RED_INDEX + '[i];'\n\n  var blueLoop = \n    'for(var j=' + BLUE_START + ',' + BLUE_PTR + '=' + ELEM_SIZE + '*' + BLUE_START + ';' +\n        'j<' + BLUE_END + ';' +\n        '++j,' + BLUE_PTR + '+=' + ELEM_SIZE + '){' +\n        'var y0=' + BLUE_BOXES + '[' + AXIS + '+' + BLUE_PTR + '],' +\n            (full ? 'y1=' + BLUE_BOXES + '[' + AXIS + '+' + BLUE_PTR + '+' + DIMENSION + '],' : '') +\n            'yi=' + BLUE_INDEX + '[j];'\n\n  if(redMajor) {\n    code.push(redLoop, INNER_LABEL, ':', blueLoop)\n  } else {\n    code.push(blueLoop, INNER_LABEL, ':', redLoop)\n  }\n\n  if(full) {\n    code.push('if(y1<x0||x1<y0)continue;')\n  } else if(flip) {\n    code.push('if(y0<=x0||x1<y0)continue;')\n  } else {\n    code.push('if(y0<x0||x1<y0)continue;')\n  }\n\n  code.push('for(var k='+AXIS+'+1;k<'+DIMENSION+';++k){'+\n    'var r0='+RED_BOXES+'[k+'+RED_PTR+'],'+\n        'r1='+RED_BOXES+'[k+'+DIMENSION+'+'+RED_PTR+'],'+\n        'b0='+BLUE_BOXES+'[k+'+BLUE_PTR+'],'+\n        'b1='+BLUE_BOXES+'[k+'+DIMENSION+'+'+BLUE_PTR+'];'+\n      'if(r1<b0||b1<r0)continue ' + INNER_LABEL + ';}' +\n      'var ' + RETVAL + '=' + VISIT + '(')\n\n  if(flip) {\n    code.push('yi,xi')\n  } else {\n    code.push('xi,yi')\n  }\n\n  code.push(');if(' + RETVAL + '!==void 0)return ' + RETVAL + ';}}}')\n\n  return {\n    name: funcName, \n    code: code.join('')\n  }\n}\n\nfunction bruteForcePlanner(full) {\n  var funcName = 'bruteForce' + (full ? 'Full' : 'Partial')\n  var prefix = []\n  var fargs = ARGS.slice()\n  if(!full) {\n    fargs.splice(3, 0, FLIP)\n  }\n\n  var code = ['function ' + funcName + '(' + fargs.join() + '){']\n\n  function invoke(redMajor, flip) {\n    var res = generateBruteForce(redMajor, flip, full)\n    prefix.push(res.code)\n    code.push('return ' + res.name + '(' + ARGS.join() + ');')\n  }\n\n  code.push('if(' + RED_END + '-' + RED_START + '>' +\n                    BLUE_END + '-' + BLUE_START + '){')\n\n  if(full) {\n    invoke(true, false)\n    code.push('}else{')\n    invoke(false, false)\n  } else {\n    code.push('if(' + FLIP + '){')\n    invoke(true, true)\n    code.push('}else{')\n    invoke(true, false)\n    code.push('}}else{if(' + FLIP + '){')\n    invoke(false, true)\n    code.push('}else{')\n    invoke(false, false)\n    code.push('}')\n  }\n  code.push('}}return ' + funcName)\n\n  var codeStr = prefix.join('') + code.join('')\n  var proc = new Function(codeStr)\n  return proc()\n}\n\n\nexports.partial = bruteForcePlanner(false)\nexports.full    = bruteForcePlanner(true)", "'use strict'\n\nmodule.exports = genPartition\n\nvar code = 'for(var j=2*a,k=j*c,l=k,m=c,n=b,o=a+b,p=c;d>p;++p,k+=j){var _;if($)if(m===p)m+=1,l+=j;else{for(var s=0;j>s;++s){var t=e[k+s];e[k+s]=e[l],e[l++]=t}var u=f[p];f[p]=f[m],f[m++]=u}}return m'\n\nfunction genPartition(predicate, args) {\n  var fargs ='abcdef'.split('').concat(args)\n  var reads = []\n  if(predicate.indexOf('lo') >= 0) {\n    reads.push('lo=e[k+n]')\n  }\n  if(predicate.indexOf('hi') >= 0) {\n    reads.push('hi=e[k+o]')\n  }\n  fargs.push(\n    code.replace('_', reads.join())\n        .replace('$', predicate))\n  return Function.apply(void 0, fargs)\n}", "'use strict'\n\nmodule.exports = findMedian\n\nvar genPartition = require('./partition')\n\nvar partitionStartLessThan = genPartition('lo<p0', ['p0'])\n\nvar PARTITION_THRESHOLD = 8   //Cut off for using insertion sort in findMedian\n\n//Base case for median finding:  Use insertion sort\nfunction insertionSort(d, axis, start, end, boxes, ids) {\n  var elemSize = 2 * d\n  var boxPtr = elemSize * (start+1) + axis\n  for(var i=start+1; i<end; ++i, boxPtr+=elemSize) {\n    var x = boxes[boxPtr]\n    for(var j=i, ptr=elemSize*(i-1); \n        j>start && boxes[ptr+axis] > x; \n        --j, ptr-=elemSize) {\n      //Swap\n      var aPtr = ptr\n      var bPtr = ptr+elemSize\n      for(var k=0; k<elemSize; ++k, ++aPtr, ++bPtr) {\n        var y = boxes[aPtr]\n        boxes[aPtr] = boxes[bPtr]\n        boxes[bPtr] = y\n      }\n      var tmp = ids[j]\n      ids[j] = ids[j-1]\n      ids[j-1] = tmp\n    }\n  }\n}\n\n//Find median using quick select algorithm\n//  takes O(n) time with high probability\nfunction findMedian(d, axis, start, end, boxes, ids) {\n  if(end <= start+1) {\n    return start\n  }\n\n  var lo       = start\n  var hi       = end\n  var mid      = ((end + start) >>> 1)\n  var elemSize = 2*d\n  var pivot    = mid\n  var value    = boxes[elemSize*mid+axis]\n  \n  while(lo < hi) {\n    if(hi - lo < PARTITION_THRESHOLD) {\n      insertionSort(d, axis, lo, hi, boxes, ids)\n      value = boxes[elemSize*mid+axis]\n      break\n    }\n    \n    //Select pivot using median-of-3\n    var count  = hi - lo\n    var pivot0 = (Math.random()*count+lo)|0\n    var value0 = boxes[elemSize*pivot0 + axis]\n    var pivot1 = (Math.random()*count+lo)|0\n    var value1 = boxes[elemSize*pivot1 + axis]\n    var pivot2 = (Math.random()*count+lo)|0\n    var value2 = boxes[elemSize*pivot2 + axis]\n    if(value0 <= value1) {\n      if(value2 >= value1) {\n        pivot = pivot1\n        value = value1\n      } else if(value0 >= value2) {\n        pivot = pivot0\n        value = value0\n      } else {\n        pivot = pivot2\n        value = value2\n      }\n    } else {\n      if(value1 >= value2) {\n        pivot = pivot1\n        value = value1\n      } else if(value2 >= value0) {\n        pivot = pivot0\n        value = value0\n      } else {\n        pivot = pivot2\n        value = value2\n      }\n    }\n\n    //Swap pivot to end of array\n    var aPtr = elemSize * (hi-1)\n    var bPtr = elemSize * pivot\n    for(var i=0; i<elemSize; ++i, ++aPtr, ++bPtr) {\n      var x = boxes[aPtr]\n      boxes[aPtr] = boxes[bPtr]\n      boxes[bPtr] = x\n    }\n    var y = ids[hi-1]\n    ids[hi-1] = ids[pivot]\n    ids[pivot] = y\n\n    //Partition using pivot\n    pivot = partitionStartLessThan(\n      d, axis, \n      lo, hi-1, boxes, ids,\n      value)\n\n    //Swap pivot back\n    var aPtr = elemSize * (hi-1)\n    var bPtr = elemSize * pivot\n    for(var i=0; i<elemSize; ++i, ++aPtr, ++bPtr) {\n      var x = boxes[aPtr]\n      boxes[aPtr] = boxes[bPtr]\n      boxes[bPtr] = x\n    }\n    var y = ids[hi-1]\n    ids[hi-1] = ids[pivot]\n    ids[pivot] = y\n\n    //Swap pivot to last pivot\n    if(mid < pivot) {\n      hi = pivot-1\n      while(lo < hi && \n        boxes[elemSize*(hi-1)+axis] === value) {\n        hi -= 1\n      }\n      hi += 1\n    } else if(pivot < mid) {\n      lo = pivot + 1\n      while(lo < hi &&\n        boxes[elemSize*lo+axis] === value) {\n        lo += 1\n      }\n    } else {\n      break\n    }\n  }\n\n  //Make sure pivot is at start\n  return partitionStartLessThan(\n    d, axis, \n    start, mid, boxes, ids,\n    boxes[elemSize*mid+axis])\n}", "'use strict'\n\nmodule.exports = boxIntersectIter\n\nvar pool = require('@jpweeks/typedarray-pool')\nvar bits = require('bit-twiddle')\nvar bruteForce = require('./brute')\nvar bruteForcePartial = bruteForce.partial\nvar bruteForceFull = bruteForce.full\nvar sweep = require('./sweep')\nvar findMedian = require('./median')\nvar genPartition = require('./partition')\n\n//Twiddle parameters\nvar BRUTE_FORCE_CUTOFF    = 128       //Cut off for brute force search\nvar SCAN_CUTOFF           = (1<<22)   //Cut off for two way scan\nvar SCAN_COMPLETE_CUTOFF  = (1<<22)  \n\n//Partition functions\nvar partitionInteriorContainsInterval = genPartition(\n  '!(lo>=p0)&&!(p1>=hi)', \n  ['p0', 'p1'])\n\nvar partitionStartEqual = genPartition(\n  'lo===p0',\n  ['p0'])\n\nvar partitionStartLessThan = genPartition(\n  'lo<p0',\n  ['p0'])\n\nvar partitionEndLessThanEqual = genPartition(\n  'hi<=p0',\n  ['p0'])\n\nvar partitionContainsPoint = genPartition(\n  'lo<=p0&&p0<=hi',\n  ['p0'])\n\nvar partitionContainsPointProper = genPartition(\n  'lo<p0&&p0<=hi',\n  ['p0'])\n\n//Frame size for iterative loop\nvar IFRAME_SIZE = 6\nvar DFRAME_SIZE = 2\n\n//Data for box statck\nvar INIT_CAPACITY = 1024\nvar BOX_ISTACK  = pool.mallocInt32(INIT_CAPACITY)\nvar BOX_DSTACK  = pool.mallocDouble(INIT_CAPACITY)\n\n//Initialize iterative loop queue\nfunction iterInit(d, count) {\n  var levels = (8 * bits.log2(count+1) * (d+1))|0\n  var maxInts = bits.nextPow2(IFRAME_SIZE*levels)\n  if(BOX_ISTACK.length < maxInts) {\n    pool.free(BOX_ISTACK)\n    BOX_ISTACK = pool.mallocInt32(maxInts)\n  }\n  var maxDoubles = bits.nextPow2(DFRAME_SIZE*levels)\n  if(BOX_DSTACK.length < maxDoubles) {\n    pool.free(BOX_DSTACK)\n    BOX_DSTACK = pool.mallocDouble(maxDoubles)\n  }\n}\n\n//Append item to queue\nfunction iterPush(ptr,\n  axis, \n  redStart, redEnd, \n  blueStart, blueEnd, \n  state, \n  lo, hi) {\n\n  var iptr = IFRAME_SIZE * ptr\n  BOX_ISTACK[iptr]   = axis\n  BOX_ISTACK[iptr+1] = redStart\n  BOX_ISTACK[iptr+2] = redEnd\n  BOX_ISTACK[iptr+3] = blueStart\n  BOX_ISTACK[iptr+4] = blueEnd\n  BOX_ISTACK[iptr+5] = state\n\n  var dptr = DFRAME_SIZE * ptr\n  BOX_DSTACK[dptr]   = lo\n  BOX_DSTACK[dptr+1] = hi\n}\n\n//Special case:  Intersect single point with list of intervals\nfunction onePointPartial(\n  d, axis, visit, flip,\n  redStart, redEnd, red, redIndex,\n  blueOffset, blue, blueId) {\n\n  var elemSize = 2 * d\n  var bluePtr  = blueOffset * elemSize\n  var blueX    = blue[bluePtr + axis]\n\nred_loop:\n  for(var i=redStart, redPtr=redStart*elemSize; i<redEnd; ++i, redPtr+=elemSize) {\n    var r0 = red[redPtr+axis]\n    var r1 = red[redPtr+axis+d]\n    if(blueX < r0 || r1 < blueX) {\n      continue\n    }\n    if(flip && blueX === r0) {\n      continue\n    }\n    var redId = redIndex[i]\n    for(var j=axis+1; j<d; ++j) {\n      var r0 = red[redPtr+j]\n      var r1 = red[redPtr+j+d]\n      var b0 = blue[bluePtr+j]\n      var b1 = blue[bluePtr+j+d]\n      if(r1 < b0 || b1 < r0) {\n        continue red_loop\n      }\n    }\n    var retval\n    if(flip) {\n      retval = visit(blueId, redId)\n    } else {\n      retval = visit(redId, blueId)\n    }\n    if(retval !== void 0) {\n      return retval\n    }\n  }\n}\n\n//Special case:  Intersect one point with list of intervals\nfunction onePointFull(\n  d, axis, visit,\n  redStart, redEnd, red, redIndex,\n  blueOffset, blue, blueId) {\n\n  var elemSize = 2 * d\n  var bluePtr  = blueOffset * elemSize\n  var blueX    = blue[bluePtr + axis]\n\nred_loop:\n  for(var i=redStart, redPtr=redStart*elemSize; i<redEnd; ++i, redPtr+=elemSize) {\n    var redId = redIndex[i]\n    if(redId === blueId) {\n      continue\n    }\n    var r0 = red[redPtr+axis]\n    var r1 = red[redPtr+axis+d]\n    if(blueX < r0 || r1 < blueX) {\n      continue\n    }\n    for(var j=axis+1; j<d; ++j) {\n      var r0 = red[redPtr+j]\n      var r1 = red[redPtr+j+d]\n      var b0 = blue[bluePtr+j]\n      var b1 = blue[bluePtr+j+d]\n      if(r1 < b0 || b1 < r0) {\n        continue red_loop\n      }\n    }\n    var retval = visit(redId, blueId)\n    if(retval !== void 0) {\n      return retval\n    }\n  }\n}\n\n//The main box intersection routine\nfunction boxIntersectIter(\n  d, visit, initFull,\n  xSize, xBoxes, xIndex,\n  ySize, yBoxes, yIndex) {\n\n  //Reserve memory for stack\n  iterInit(d, xSize + ySize)\n\n  var top  = 0\n  var elemSize = 2 * d\n  var retval\n\n  iterPush(top++,\n      0,\n      0, xSize,\n      0, ySize,\n      initFull ? 16 : 0, \n      -Infinity, Infinity)\n  if(!initFull) {\n    iterPush(top++,\n      0,\n      0, ySize,\n      0, xSize,\n      1, \n      -Infinity, Infinity)\n  }\n\n  while(top > 0) {\n    top  -= 1\n\n    var iptr = top * IFRAME_SIZE\n    var axis      = BOX_ISTACK[iptr]\n    var redStart  = BOX_ISTACK[iptr+1]\n    var redEnd    = BOX_ISTACK[iptr+2]\n    var blueStart = BOX_ISTACK[iptr+3]\n    var blueEnd   = BOX_ISTACK[iptr+4]\n    var state     = BOX_ISTACK[iptr+5]\n\n    var dptr = top * DFRAME_SIZE\n    var lo        = BOX_DSTACK[dptr]\n    var hi        = BOX_DSTACK[dptr+1]\n\n    //Unpack state info\n    var flip      = (state & 1)\n    var full      = !!(state & 16)\n\n    //Unpack indices\n    var red       = xBoxes\n    var redIndex  = xIndex\n    var blue      = yBoxes\n    var blueIndex = yIndex\n    if(flip) {\n      red         = yBoxes\n      redIndex    = yIndex\n      blue        = xBoxes\n      blueIndex   = xIndex\n    }\n\n    if(state & 2) {\n      redEnd = partitionStartLessThan(\n        d, axis,\n        redStart, redEnd, red, redIndex,\n        hi)\n      if(redStart >= redEnd) {\n        continue\n      }\n    }\n    if(state & 4) {\n      redStart = partitionEndLessThanEqual(\n        d, axis,\n        redStart, redEnd, red, redIndex,\n        lo)\n      if(redStart >= redEnd) {\n        continue\n      }\n    }\n    \n    var redCount  = redEnd  - redStart\n    var blueCount = blueEnd - blueStart\n\n    if(full) {\n      if(d * redCount * (redCount + blueCount) < SCAN_COMPLETE_CUTOFF) {\n        retval = sweep.scanComplete(\n          d, axis, visit, \n          redStart, redEnd, red, redIndex,\n          blueStart, blueEnd, blue, blueIndex)\n        if(retval !== void 0) {\n          return retval\n        }\n        continue\n      }\n    } else {\n      if(d * Math.min(redCount, blueCount) < BRUTE_FORCE_CUTOFF) {\n        //If input small, then use brute force\n        retval = bruteForcePartial(\n            d, axis, visit, flip,\n            redStart,  redEnd,  red,  redIndex,\n            blueStart, blueEnd, blue, blueIndex)\n        if(retval !== void 0) {\n          return retval\n        }\n        continue\n      } else if(d * redCount * blueCount < SCAN_CUTOFF) {\n        //If input medium sized, then use sweep and prune\n        retval = sweep.scanBipartite(\n          d, axis, visit, flip, \n          redStart, redEnd, red, redIndex,\n          blueStart, blueEnd, blue, blueIndex)\n        if(retval !== void 0) {\n          return retval\n        }\n        continue\n      }\n    }\n    \n    //First, find all red intervals whose interior contains (lo,hi)\n    var red0 = partitionInteriorContainsInterval(\n      d, axis, \n      redStart, redEnd, red, redIndex,\n      lo, hi)\n\n    //Lower dimensional case\n    if(redStart < red0) {\n\n      if(d * (red0 - redStart) < BRUTE_FORCE_CUTOFF) {\n        //Special case for small inputs: use brute force\n        retval = bruteForceFull(\n          d, axis+1, visit,\n          redStart, red0, red, redIndex,\n          blueStart, blueEnd, blue, blueIndex)\n        if(retval !== void 0) {\n          return retval\n        }\n      } else if(axis === d-2) {\n        if(flip) {\n          retval = sweep.sweepBipartite(\n            d, visit,\n            blueStart, blueEnd, blue, blueIndex,\n            redStart, red0, red, redIndex)\n        } else {\n          retval = sweep.sweepBipartite(\n            d, visit,\n            redStart, red0, red, redIndex,\n            blueStart, blueEnd, blue, blueIndex)\n        }\n        if(retval !== void 0) {\n          return retval\n        }\n      } else {\n        iterPush(top++,\n          axis+1,\n          redStart, red0,\n          blueStart, blueEnd,\n          flip,\n          -Infinity, Infinity)\n        iterPush(top++,\n          axis+1,\n          blueStart, blueEnd,\n          redStart, red0,\n          flip^1,\n          -Infinity, Infinity)\n      }\n    }\n\n    //Divide and conquer phase\n    if(red0 < redEnd) {\n\n      //Cut blue into 3 parts:\n      //\n      //  Points < mid point\n      //  Points = mid point\n      //  Points > mid point\n      //\n      var blue0 = findMedian(\n        d, axis, \n        blueStart, blueEnd, blue, blueIndex)\n      var mid = blue[elemSize * blue0 + axis]\n      var blue1 = partitionStartEqual(\n        d, axis,\n        blue0, blueEnd, blue, blueIndex,\n        mid)\n\n      //Right case\n      if(blue1 < blueEnd) {\n        iterPush(top++,\n          axis,\n          red0, redEnd,\n          blue1, blueEnd,\n          (flip|4) + (full ? 16 : 0),\n          mid, hi)\n      }\n\n      //Left case\n      if(blueStart < blue0) {\n        iterPush(top++,\n          axis,\n          red0, redEnd,\n          blueStart, blue0,\n          (flip|2) + (full ? 16 : 0),\n          lo, mid)\n      }\n\n      //Center case (the hard part)\n      if(blue0 + 1 === blue1) {\n        //Optimization: Range with exactly 1 point, use a brute force scan\n        if(full) {\n          retval = onePointFull(\n            d, axis, visit,\n            red0, redEnd, red, redIndex,\n            blue0, blue, blueIndex[blue0])\n        } else {\n          retval = onePointPartial(\n            d, axis, visit, flip,\n            red0, redEnd, red, redIndex,\n            blue0, blue, blueIndex[blue0])\n        }\n        if(retval !== void 0) {\n          return retval\n        }\n      } else if(blue0 < blue1) {\n        var red1\n        if(full) {\n          //If full intersection, need to handle special case\n          red1 = partitionContainsPoint(\n            d, axis,\n            red0, redEnd, red, redIndex,\n            mid)\n          if(red0 < red1) {\n            var redX = partitionStartEqual(\n              d, axis,\n              red0, red1, red, redIndex,\n              mid)\n            if(axis === d-2) {\n              //Degenerate sweep intersection:\n              //  [red0, redX] with [blue0, blue1]\n              if(red0 < redX) {\n                retval = sweep.sweepComplete(\n                  d, visit,\n                  red0, redX, red, redIndex,\n                  blue0, blue1, blue, blueIndex)\n                if(retval !== void 0) {\n                  return retval\n                }\n              }\n\n              //Normal sweep intersection:\n              //  [redX, red1] with [blue0, blue1]\n              if(redX < red1) {\n                retval = sweep.sweepBipartite(\n                  d, visit,\n                  redX, red1, red, redIndex,\n                  blue0, blue1, blue, blueIndex)\n                if(retval !== void 0) {\n                  return retval\n                }\n              }\n            } else {\n              if(red0 < redX) {\n                iterPush(top++,\n                  axis+1,\n                  red0, redX,\n                  blue0, blue1,\n                  16,\n                  -Infinity, Infinity)\n              }\n              if(redX < red1) {\n                iterPush(top++,\n                  axis+1,\n                  redX, red1,\n                  blue0, blue1,\n                  0,\n                  -Infinity, Infinity)\n                iterPush(top++,\n                  axis+1,\n                  blue0, blue1,\n                  redX, red1,\n                  1,\n                  -Infinity, Infinity)\n              }\n            }\n          }\n        } else {\n          if(flip) {\n            red1 = partitionContainsPointProper(\n              d, axis,\n              red0, redEnd, red, redIndex,\n              mid)\n          } else {\n            red1 = partitionContainsPoint(\n              d, axis,\n              red0, redEnd, red, redIndex,\n              mid)\n          }\n          if(red0 < red1) {\n            if(axis === d-2) {\n              if(flip) {\n                retval = sweep.sweepBipartite(\n                  d, visit,\n                  blue0, blue1, blue, blueIndex,\n                  red0, red1, red, redIndex)\n              } else {\n                retval = sweep.sweepBipartite(\n                  d, visit,\n                  red0, red1, red, redIndex,\n                  blue0, blue1, blue, blueIndex)\n              }\n            } else {\n              iterPush(top++,\n                axis+1,\n                red0, red1,\n                blue0, blue1,\n                flip,\n                -Infinity, Infinity)\n              iterPush(top++,\n                axis+1,\n                blue0, blue1,\n                red0, red1,\n                flip^1,\n                -Infinity, Infinity)\n            }\n          }\n        }\n      }\n    }\n  }\n}", "'use strict'\n\nmodule.exports = boxIntersectWrapper\n\nvar pool = require('@jpweeks/typedarray-pool')\nvar sweep = require('./lib/sweep')\nvar boxIntersectIter = require('./lib/intersect')\n\nfunction boxEmpty(d, box) {\n  for(var j=0; j<d; ++j) {\n    if(!(box[j] <= box[j+d])) {\n      return true\n    }\n  }\n  return false\n}\n\n//Unpack boxes into a flat typed array, remove empty boxes\nfunction convertBoxes(boxes, d, data, ids) {\n  var ptr = 0\n  var count = 0\n  for(var i=0, n=boxes.length; i<n; ++i) {\n    var b = boxes[i]\n    if(boxEmpty(d, b)) {\n      continue\n    }\n    for(var j=0; j<2*d; ++j) {\n      data[ptr++] = b[j]\n    }\n    ids[count++] = i\n  }\n  return count\n}\n\n//Perform type conversions, check bounds\nfunction boxIntersect(red, blue, visit, full) {\n  var n = red.length\n  var m = blue.length\n\n  //If either array is empty, then we can skip this whole thing\n  if(n <= 0 || m <= 0) {\n    return\n  }\n\n  //Compute dimension, if it is 0 then we skip\n  var d = (red[0].length)>>>1\n  if(d <= 0) {\n    return\n  }\n\n  var retval\n\n  //Convert red boxes\n  var redList  = pool.mallocDouble(2*d*n)\n  var redIds   = pool.mallocInt32(n)\n  n = convertBoxes(red, d, redList, redIds)\n\n  if(n > 0) {\n    if(d === 1 && full) {\n      //Special case: 1d complete\n      sweep.init(n)\n      retval = sweep.sweepComplete(\n        d, visit, \n        0, n, redList, redIds,\n        0, n, redList, redIds)\n    } else {\n\n      //Convert blue boxes\n      var blueList = pool.mallocDouble(2*d*m)\n      var blueIds  = pool.mallocInt32(m)\n      m = convertBoxes(blue, d, blueList, blueIds)\n\n      if(m > 0) {\n        sweep.init(n+m)\n\n        if(d === 1) {\n          //Special case: 1d bipartite\n          retval = sweep.sweepBipartite(\n            d, visit, \n            0, n, redList,  redIds,\n            0, m, blueList, blueIds)\n        } else {\n          //General case:  d>1\n          retval = boxIntersectIter(\n            d, visit,    full,\n            n, redList,  redIds,\n            m, blueList, blueIds)\n        }\n\n        pool.free(blueList)\n        pool.free(blueIds)\n      }\n    }\n\n    pool.free(redList)\n    pool.free(redIds)\n  }\n\n  return retval\n}\n\n\nvar RESULT\n\nfunction appendItem(i,j) {\n  RESULT.push([i,j])\n}\n\nfunction intersectFullArray(x) {\n  RESULT = []\n  boxIntersect(x, x, appendItem, true)\n  return RESULT\n}\n\nfunction intersectBipartiteArray(x, y) {\n  RESULT = []\n  boxIntersect(x, y, appendItem, false)\n  return RESULT\n}\n\n//User-friendly wrapper, handle full input and no-visitor cases\nfunction boxIntersectWrapper(arg0, arg1, arg2) {\n  var result\n  switch(arguments.length) {\n    case 1:\n      return intersectFullArray(arg0)\n    case 2:\n      if(typeof arg1 === 'function') {\n        return boxIntersect(arg0, arg0, arg1, true)\n      } else {\n        return intersectBipartiteArray(arg0, arg1)\n      }\n    case 3:\n      return boxIntersect(arg0, arg1, arg2, false)\n    default:\n      throw new Error('box-intersect: Invalid arguments')\n  }\n}", "\n/**\n * This works around some old node-style code in a\n * dependency of box-intersect.\n*/\nif (window && !window['global']) {\n    window['global'] = window.globalThis || {}\n}\n\n", "\n/*!\n * noa: an experimental voxel game engine.\n * @url      github.com/fenomas/noa\n * @author   Andy Hall <andy@fenomas.com>\n * @license  MIT\n */\n\nimport './lib/shims'\n\nimport { EventEmitter } from 'events'\nimport vec3 from 'gl-vec3'\nimport ndarray from 'ndarray'\nimport raycast from 'fast-voxel-raycast'\n\nimport { Inputs } from './lib/inputs'\nimport { Container } from './lib/container'\nimport { Camera } from './lib/camera'\nimport { Entities } from './lib/entities'\nimport { ObjectMesher } from './lib/objectMesher'\nimport { TerrainMesher } from './lib/terrainMesher'\nimport { Registry } from './lib/registry'\nimport { Rendering } from './lib/rendering'\nimport { Physics } from './lib/physics'\nimport { World } from './lib/world'\nimport { locationHasher } from './lib/util'\nimport { makeProfileHook } from './lib/util'\n\n\nimport packageJSON from '../package.json'\nvar version = packageJSON.version\n\n\n\n// profile every N ticks/renders\nvar PROFILE = 0\nvar PROFILE_RENDER = 0\n\n\nvar defaultOptions = {\n    debug: false,\n    silent: false,\n    silentBabylon: false,\n    playerHeight: 1.8,\n    playerWidth: 0.6,\n    playerStart: [0, 10, 0],\n    playerAutoStep: false,\n    playerShadowComponent: true,\n    tickRate: 30,           // ticks per second\n    maxRenderRate: 0,       // max FPS, 0 for uncapped \n    blockTestDistance: 10,\n    stickyPointerLock: true,\n    dragCameraOutsidePointerLock: true,\n    stickyFullscreen: false,\n    skipDefaultHighlighting: false,\n    originRebaseDistance: 25,\n}\n\n\n/**\n * Main engine class.  \n * Takes an object full of optional settings as a parameter.\n * \n * ```js\n * import { Engine } from 'noa-engine'\n * var noa = new Engine({\n *    debug: false,\n * })\n * ```\n * \n * Note that the options object is also passed to noa's \n * child modules ({@link Rendering}, {@link Container}, etc).\n * See docs for each module for their options.\n * \n*/\n\nexport class Engine extends EventEmitter {\n\n    /**\n     * The core Engine constructor uses the following options:\n     * \n     * ```js\n     * var defaultOptions = {\n     *    debug: false,\n     *    silent: false,\n     *    playerHeight: 1.8,\n     *    playerWidth: 0.6,\n     *    playerStart: [0, 10, 0],\n     *    playerAutoStep: false,\n     *    playerShadowComponent: true,\n     *    tickRate: 30,           // ticks per second\n     *    maxRenderRate: 0,       // max FPS, 0 for uncapped \n     *    blockTestDistance: 10,\n     *    stickyPointerLock: true,\n     *    dragCameraOutsidePointerLock: true,\n     *    stickyFullscreen: false,\n     *    skipDefaultHighlighting: false,\n     *    originRebaseDistance: 25,\n     * }\n     * ```\n     * \n     * **Events:**\n     *  + `tick => (dt)`  \n     *    Tick update, `dt` is (fixed) tick duration in ms\n     *  + `beforeRender => (dt)`  \n     *    `dt` is the time (in ms) since the most recent tick\n     *  + `afterRender => (dt)`  \n     *    `dt` is the time (in ms) since the most recent tick\n     *  + `targetBlockChanged => (blockInfo)`  \n     *    Emitted each time the user's targeted world block changes\n     *  + `addingTerrainMesh => (mesh)`  \n     *    Alerts client about a terrain mesh being added to the scene\n     *  + `removingTerrainMesh => (mesh)`  \n     *    Alerts client before a terrain mesh is removed.\n    */\n    constructor(opts = {}) {\n        super()\n        opts = Object.assign({}, defaultOptions, opts)\n\n        /** Version string, e.g. `\"0.25.4\"` */\n        this.version = version\n        if (!opts.silent) {\n            var debugstr = (opts.debug) ? ' (debug)' : ''\n            console.log(`noa-engine v${this.version}${debugstr}`)\n        }\n\n        /** @internal */\n        this._paused = false\n\n        /** @internal */\n        this._originRebaseDistance = opts.originRebaseDistance\n\n        // world origin offset, used throughout engine for origin rebasing\n        /** @internal */\n        this.worldOriginOffset = [0, 0, 0]\n\n        // how far engine is into the current tick. Updated each render.\n        /** @internal */\n        this.positionInCurrentTick = 0\n\n        /** \n         * String identifier for the current world. \n         * It's safe to ignore this if your game has only one level/world. \n        */\n        this.worldName = 'default'\n\n        /**\n         * Multiplier for how fast time moves. Setting this to a value other than \n         * `1` will make the game speed up or slow down. This can significantly \n         * affect how core systems behave (particularly physics!).\n        */\n        this.timeScale = 1\n\n        /** Child module for managing the game's container, canvas, etc. */\n        this.container = new Container(this, opts)\n\n        /** The game's tick rate (number of ticks per second) \n         * @type {number}\n         * @readonly \n        */\n        this.tickRate = this.container._shell.tickRate\n        Object.defineProperty(this, 'tickRate', {\n            get: () => this.container._shell.tickRate\n        })\n\n        /** The game's max framerate (use `0` for uncapped)\n         * @type {number}\n         */\n        this.maxRenderRate = this.container._shell.maxRenderRate\n        Object.defineProperty(this, 'maxRenderRate', {\n            get: () => this.container._shell.maxRenderRate,\n            set: (v) => { this.container._shell.maxRenderRate = v || 0 },\n        })\n\n\n        /** Manages key and mouse input bindings */\n        this.inputs = new Inputs(this, opts, this.container.element)\n\n        /** A registry where voxel/material properties are managed */\n        this.registry = new Registry(this, opts)\n\n        /** Manages the world, chunks, and all voxel data */\n        this.world = new World(this, opts)\n\n        var _consoleLog = console.log\n        if (opts.silentBabylon) console.log = () => { }\n\n        /** Rendering manager */\n        this.rendering = new Rendering(this, opts, this.container.canvas)\n\n        if (opts.silentBabylon) console.log = _consoleLog\n\n        /** Physics engine - solves collisions, properties, etc. */\n        this.physics = new Physics(this, opts)\n\n        /** Entity manager / Entity Component System (ECS) */\n        this.entities = new Entities(this, opts)\n\n        /** Alias to `noa.entities` */\n        this.ents = this.entities\n        var ents = this.entities\n\n        /** Entity id for the player entity */\n        this.playerEntity = ents.add(\n            opts.playerStart, // starting location\n            opts.playerWidth, opts.playerHeight,\n            null, null, // no mesh for now, no meshOffset, \n            true, opts.playerShadowComponent,\n        )\n\n        // make player entity it collide with terrain and other entities\n        ents.addComponent(this.playerEntity, ents.names.collideTerrain)\n        ents.addComponent(this.playerEntity, ents.names.collideEntities)\n\n        // adjust default physics parameters\n        var body = ents.getPhysics(this.playerEntity).body\n        body.gravityMultiplier = 2 // less floaty\n        body.autoStep = opts.playerAutoStep // auto step onto blocks\n\n        // input component - sets entity's movement state from key inputs\n        ents.addComponent(this.playerEntity, ents.names.receivesInputs)\n\n        // add a component to make player mesh fade out when zooming in\n        ents.addComponent(this.playerEntity, ents.names.fadeOnZoom)\n\n        // movement component - applies movement forces\n        ents.addComponent(this.playerEntity, ents.names.movement, {\n            airJumps: 1\n        })\n\n        /** Manages the game's camera, view angle, sensitivity, etc. */\n        this.camera = new Camera(this, opts)\n\n        /** How far to check for a solid voxel the player is currently looking at \n         * @type {number}\n        */\n        this.blockTestDistance = opts.blockTestDistance\n\n        /** \n         * Callback to determine which voxels can be targeted. \n         * Defaults to a solidity check, but can be overridden with arbitrary logic.\n         * @type {(blockID: number) => boolean} \n        */\n        this.blockTargetIdCheck = this.registry.getBlockSolidity\n\n        /** \n         * Dynamically updated object describing the currently targeted block.\n         * @type {null | { \n         *      blockID:number,\n         *      position: number[],\n         *      normal: number[],\n         *      adjacent: number[],\n         * }} \n        */\n        this.targetedBlock = null\n\n        // add a default block highlighting function\n        if (!opts.skipDefaultHighlighting) {\n            // the default listener, defined onto noa in case people want to remove it later\n            this.defaultBlockHighlightFunction = (tgt) => {\n                if (tgt) {\n                    this.rendering.highlightBlockFace(true, tgt.position, tgt.normal)\n                } else {\n                    this.rendering.highlightBlockFace(false)\n                }\n            }\n            this.on('targetBlockChanged', this.defaultBlockHighlightFunction)\n        }\n\n\n        /*\n         *\n         *      Various internals...\n         *\n        */\n\n        /** @internal */\n        this._terrainMesher = new TerrainMesher(this)\n\n        /** @internal */\n        this._objectMesher = new ObjectMesher(this)\n\n        /** @internal */\n        this._targetedBlockDat = {\n            blockID: 0,\n            position: vec3.create(),\n            normal: vec3.create(),\n            adjacent: vec3.create(),\n        }\n\n        /** @internal */\n        this._prevTargetHash = 0\n\n\n        /** @internal */\n        this._pickPos = vec3.create()\n\n        /** @internal */\n        this._pickResult = {\n            _localPosition: vec3.create(),\n            position: [0, 0, 0],\n            normal: [0, 0, 0],\n        }\n\n\n\n\n\n        // temp hacks for development\n        if (opts.debug) {\n            // expose often-used classes\n            /** @internal */\n            this.vec3 = vec3\n            /** @internal */\n            this.ndarray = ndarray\n            // gameplay tweaks\n            ents.getMovement(1).airJumps = 999\n            // decorate window while making TS happy\n            var win = /** @type {any} */ (window)\n            win.noa = this\n            win.vec3 = vec3\n            win.ndarray = ndarray\n            win.scene = this.rendering.scene\n        }\n\n        // add hooks to throw helpful errors when using deprecated methods\n        deprecateStuff(this)\n    }\n\n\n\n    /*\n     *\n     *\n     *              Core Engine APIs\n     *\n     *\n    */\n\n    /**\n     * Tick function, called by container module at a fixed timestep. \n     * Clients should not normally need to call this manually.\n     * @internal\n    */\n\n    tick(dt) {\n        dt *= this.timeScale || 1\n\n        // note dt is a fixed value, not an observed delay\n        if (this._paused) {\n            if (this.world.worldGenWhilePaused) this.world.tick()\n            return\n        }\n        profile_hook('start')\n        checkWorldOffset(this)\n        this.world.tick() // chunk creation/removal\n        profile_hook('world')\n        if (!this.world.playerChunkLoaded) {\n            // when waiting on worldgen, just tick the meshing queue and exit\n            this.rendering.tick(dt)\n            return\n        }\n        this.physics.tick(dt) // iterates physics\n        profile_hook('physics')\n        this._objectMesher.tick() // rebuild objects if needed\n        this.rendering.tick(dt) // does deferred chunk meshing\n        profile_hook('rendering')\n        updateBlockTargets(this) // finds targeted blocks, and highlights one if needed\n        profile_hook('targets')\n        this.entities.tick(dt) // runs all entity systems\n        profile_hook('entities')\n        this.emit('tick', dt)\n        profile_hook('tick event')\n        profile_hook('end')\n        // clear accumulated scroll inputs (mouseMove is cleared on render)\n        var pst = this.inputs.pointerState\n        pst.scrollx = pst.scrolly = pst.scrollz = 0\n    }\n\n\n\n\n    /**\n     * Render function, called every animation frame. Emits #beforeRender(dt), #afterRender(dt) \n     * where dt is the time in ms *since the last tick*.\n     * Clients should not normally need to call this manually.\n     * @internal\n    */\n    render(dt, framePart) {\n        dt *= this.timeScale || 1\n\n        // note: framePart is how far we are into the current tick\n        // dt is the *actual* time (ms) since last render, for\n        // animating things that aren't tied to game tick rate\n\n        // frame position - for rendering movement between ticks\n        this.positionInCurrentTick = framePart\n\n        // when paused, just optionally ping worldgen, then exit\n        if (this._paused) {\n            if (this.world.worldGenWhilePaused) this.world.render()\n            return\n        }\n\n        profile_hook_render('start')\n\n        // rotate camera per user inputs - specific rules for this in `camera`\n        this.camera.applyInputsToCamera()\n        profile_hook_render('init')\n\n        // brief run through meshing queue\n        this.world.render()\n        profile_hook_render('meshing')\n\n        // entity render systems\n        this.camera.updateBeforeEntityRenderSystems()\n        this.entities.render(dt)\n        this.camera.updateAfterEntityRenderSystems()\n        profile_hook_render('entities')\n\n        // events and render\n        this.emit('beforeRender', dt)\n        profile_hook_render('before render')\n\n        this.rendering.render()\n        this.rendering.postRender()\n        profile_hook_render('render')\n\n        this.emit('afterRender', dt)\n        profile_hook_render('after render')\n        profile_hook_render('end')\n\n        // clear accumulated mouseMove inputs (scroll inputs cleared on render)\n        this.inputs.pointerState.dx = this.inputs.pointerState.dy = 0\n    }\n\n\n\n\n    /** Pausing the engine will also stop render/tick events, etc. */\n    setPaused(paused = false) {\n        this._paused = !!paused\n        // when unpausing, clear any built-up mouse inputs\n        if (!paused) {\n            this.inputs.pointerState.dx = this.inputs.pointerState.dy = 0\n        }\n    }\n\n    /** \n     * Get the voxel ID at the specified position\n    */\n    getBlock(x, y = 0, z = 0) {\n        if (x.length) return this.world.getBlockID(x[0], x[1], x[2])\n        return this.world.getBlockID(x, y, z)\n    }\n\n    /** \n     * Sets the voxel ID at the specified position. \n     * Does not check whether any entities are in the way! \n     */\n    setBlock(id, x, y = 0, z = 0) {\n        if (x.length) return this.world.setBlockID(id, x[0], x[1], x[2])\n        return this.world.setBlockID(id, x, y, z)\n    }\n\n    /**\n     * Adds a block, unless there's an entity in the way.\n    */\n    addBlock(id, x, y = 0, z = 0) {\n        // add a new terrain block, if nothing blocks the terrain there\n        if (x.length) {\n            if (this.entities.isTerrainBlocked(x[0], x[1], x[2])) return\n            this.world.setBlockID(id, x[0], x[1], x[2])\n            return id\n        } else {\n            if (this.entities.isTerrainBlocked(x, y, z)) return\n            this.world.setBlockID(id, x, y, z)\n            return id\n        }\n    }\n\n\n\n\n\n\n\n    /*\n     *              Rebasing local <-> global coords\n    */\n\n\n    /** \n     * Precisely converts a world position to the current internal \n     * local frame of reference.\n     * \n     * See `/docs/positions.md` for more info.\n     * \n     * Params: \n     *  * `global`: input position in global coords\n     *  * `globalPrecise`: (optional) sub-voxel offset to the global position\n     *  * `local`: output array which will receive the result\n     */\n    globalToLocal(global, globalPrecise, local) {\n        var off = this.worldOriginOffset\n        if (globalPrecise) {\n            for (var i = 0; i < 3; i++) {\n                var coord = global[i] - off[i]\n                coord += globalPrecise[i]\n                local[i] = coord\n            }\n            return local\n        } else {\n            return vec3.subtract(local, global, off)\n        }\n    }\n\n    /** \n     * Precisely converts a world position to the current internal \n     * local frame of reference.\n     * \n     * See `/docs/positions.md` for more info.\n     * \n     * Params: \n     *  * `local`: input array of local coords\n     *  * `global`: output array which receives the result\n     *  * `globalPrecise`: (optional) sub-voxel offset to the output global position\n     * \n     * If both output arrays are passed in, `global` will get int values and \n     * `globalPrecise` will get fractional parts. If only one array is passed in,\n     * `global` will get the whole output position.\n    */\n    localToGlobal(local, global, globalPrecise = null) {\n        var off = this.worldOriginOffset\n        if (globalPrecise) {\n            for (var i = 0; i < 3; i++) {\n                var floored = Math.floor(local[i])\n                global[i] = floored + off[i]\n                globalPrecise[i] = local[i] - floored\n            }\n            return global\n        } else {\n            return vec3.add(global, local, off)\n        }\n    }\n\n\n\n\n    /*\n     *              Picking / raycasting\n    */\n\n    /**\n     * Raycast through the world, returning a result object for any non-air block\n     * \n     * See `/docs/positions.md` for info on working with precise positions.\n     * \n     * @param {number[]} pos where to pick from (default: player's eye pos)\n     * @param {number[]} dir direction to pick along (default: camera vector)\n     * @param {number} dist pick distance (default: `noa.blockTestDistance`)\n     * @param {(id:number) => boolean} blockTestFunction which voxel IDs can be picked (default: any solid voxel)\n    */\n    pick(pos = null, dir = null, dist = -1, blockTestFunction = null) {\n        if (dist === 0) return null\n        // input position to local coords, if any\n        var pickPos = this._pickPos\n        if (pos) {\n            this.globalToLocal(pos, null, pickPos)\n            pos = pickPos\n        }\n        return this._localPick(pos, dir, dist, blockTestFunction)\n    }\n\n\n    /**\n     * @internal\n     * Do a raycast in local coords. \n     * See `/docs/positions.md` for more info.\n     * @param {number[]} pos where to pick from (default: player's eye pos)\n     * @param {number[]} dir direction to pick along (default: camera vector)\n     * @param {number} dist pick distance (default: `noa.blockTestDistance`)\n     * @param {(id:number) => boolean} blockTestFunction which voxel IDs can be picked (default: any solid voxel)\n     * @returns { null | {\n     *      position: number[],\n     *      normal: number[],\n     *      _localPosition: number[],\n     * }}\n     */\n    _localPick(pos = null, dir = null, dist = -1, blockTestFunction = null) {\n        // do a raycast in local coords - result obj will be in global coords\n        if (dist === 0) return null\n        var testFn = blockTestFunction || this.registry.getBlockSolidity\n        var world = this.world\n        var off = this.worldOriginOffset\n        var testVoxel = function (x, y, z) {\n            var id = world.getBlockID(x + off[0], y + off[1], z + off[2])\n            return testFn(id)\n        }\n        if (!pos) pos = this.camera._localGetTargetPosition()\n        dir = dir || this.camera.getDirection()\n        dist = dist || -1\n        if (dist < 0) dist = this.blockTestDistance\n        var result = this._pickResult\n        var rpos = result._localPosition\n        var rnorm = result.normal\n        var hit = raycast(testVoxel, pos, dir, dist, rpos, rnorm)\n        if (!hit) return null\n        // position is right on a voxel border - adjust it so that flooring works reliably\n        // adjust along normal direction, i.e. away from the block struck\n        vec3.scaleAndAdd(rpos, rpos, rnorm, 0.01)\n        // add global result\n        this.localToGlobal(rpos, result.position)\n        return result\n    }\n\n}\n\n\n\n/*\n * \n * \n * \n *                  INTERNAL HELPERS\n * \n * \n * \n * \n*/\n\n\n\n\n/*\n *\n *      rebase world origin offset around the player if necessary\n *\n*/\nfunction checkWorldOffset(noa) {\n    var lpos = noa.ents.getPositionData(noa.playerEntity)._localPosition\n    var cutoff = noa._originRebaseDistance\n    if (vec3.sqrLen(lpos) < cutoff * cutoff) return\n    var delta = []\n    for (var i = 0; i < 3; i++) {\n        delta[i] = Math.floor(lpos[i])\n        noa.worldOriginOffset[i] += delta[i]\n    }\n    noa.rendering._rebaseOrigin(delta)\n    noa.entities._rebaseOrigin(delta)\n    noa._objectMesher._rebaseOrigin(delta)\n}\n\n\n\n\n\n// Each frame, by default pick along the player's view vector \n// and tell rendering to highlight the struck block face\nfunction updateBlockTargets(noa) {\n    var newhash = 0\n    var blockIdFn = noa.blockTargetIdCheck || noa.registry.getBlockSolidity\n    var result = noa._localPick(null, null, null, blockIdFn)\n    if (result) {\n        var dat = noa._targetedBlockDat\n        // pick stops just shy of voxel boundary, so floored pos is the adjacent voxel\n        vec3.floor(dat.adjacent, result.position)\n        vec3.copy(dat.normal, result.normal)\n        vec3.subtract(dat.position, dat.adjacent, dat.normal)\n        dat.blockID = noa.world.getBlockID(dat.position[0], dat.position[1], dat.position[2])\n        noa.targetedBlock = dat\n        // arbitrary hash so we know when the targeted blockID/pos/face changes\n        var pos = dat.position, norm = dat.normal\n        var x = locationHasher(pos[0] + dat.blockID, pos[1], pos[2])\n        x ^= locationHasher(norm[0], norm[1] + dat.blockID, norm[2])\n        newhash = x\n    } else {\n        noa.targetedBlock = null\n    }\n    if (newhash != noa._prevTargetHash) {\n        noa.emit('targetBlockChanged', noa.targetedBlock)\n        noa._prevTargetHash = newhash\n    }\n}\n\n\n\n/*\n * \n *  add some hooks for guidance on removed APIs\n * \n */\n\nfunction deprecateStuff(noa) {\n    var ver = `0.27`\n    var dep = (loc, name, msg) => {\n        var throwFn = () => { throw `This property changed in ${ver} - ${msg}` }\n        Object.defineProperty(loc, name, { get: throwFn, set: throwFn })\n    }\n    dep(noa, 'getPlayerEyePosition', 'to get the camera/player offset see API docs for `noa.camera.cameraTarget`')\n    dep(noa, 'setPlayerEyePosition', 'to set the camera/player offset see API docs for `noa.camera.cameraTarget`')\n    dep(noa, 'getPlayerPosition', 'use `noa.ents.getPosition(noa.playerEntity)` or similar')\n    dep(noa, 'getCameraVector', 'use `noa.camera.getDirection`')\n    dep(noa, 'getPlayerMesh', 'use `noa.ents.getMeshData(noa.playerEntity).mesh` or similar')\n    dep(noa, 'playerBody', 'use `noa.ents.getPhysicsBody(noa.playerEntity)`')\n    dep(noa.rendering, 'zoomDistance', 'use `noa.camera.zoomDistance`')\n    dep(noa.rendering, '_currentZoom', 'use `noa.camera.currentZoom`')\n    dep(noa.rendering, '_cameraZoomSpeed', 'use `noa.camera.zoomSpeed`')\n    dep(noa.rendering, 'getCameraVector', 'use `noa.camera.getDirection`')\n    dep(noa.rendering, 'getCameraPosition', 'use `noa.camera.getLocalPosition`')\n    dep(noa.rendering, 'getCameraRotation', 'use `noa.camera.heading` and `noa.camera.pitch`')\n    dep(noa.rendering, 'setCameraRotation', 'to customize camera behavior see API docs for `noa.camera`')\n    ver = '0.28'\n    dep(noa.rendering, 'makeMeshInstance', 'removed, use Babylon\\'s `mesh.createInstance`')\n    dep(noa.world, '_maxChunksPendingCreation', 'use `maxChunksPendingCreation` (no \"_\")')\n    dep(noa.world, '_maxChunksPendingMeshing', 'use `maxChunksPendingMeshing` (no \"_\")')\n    dep(noa.world, '_maxProcessingPerTick', 'use `maxProcessingPerTick` (no \"_\")')\n    dep(noa.world, '_maxProcessingPerRender', 'use `maxProcessingPerRender` (no \"_\")')\n    ver = '0.29'\n    dep(noa, '_constants', 'removed, voxel IDs are no longer packed with bit flags')\n    ver = '0.30'\n    dep(noa, '_tickRate', 'tickRate is now at `noa.tickRate`')\n    dep(noa.container, '_tickRate', 'tickRate is now at `noa.tickRate`')\n    ver = '0.31'\n    dep(noa.world, 'chunkSize', 'effectively an internal, so changed to `_chunkSize`')\n    dep(noa.world, 'chunkAddDistance', 'set this with `noa.world.setAddRemoveDistance`')\n    dep(noa.world, 'chunkRemoveDistance', 'set this with `noa.world.setAddRemoveDistance`')\n    ver = '0.33'\n    dep(noa.rendering, 'postMaterialCreationHook', 'Removed - use mesh post-creation hook instead`')\n}\n\n\n\nvar profile_hook = (PROFILE > 0) ?\n    makeProfileHook(PROFILE, 'tick   ') : () => { }\nvar profile_hook_render = (PROFILE_RENDER > 0) ?\n    makeProfileHook(PROFILE_RENDER, 'render ') : () => { }\n", "\nimport { EventEmitter } from 'events'\n\nimport packageJSON from '../package.json'\nvar version = packageJSON.version\n\n\nfunction DefaultOptions() {\n    this.preventDefaults = false\n    this.stopPropagation = false\n    this.allowContextMenu = false\n    this.disabled = false\n}\n\n\nexport class GameInputs {\n\n    /**\n     *   Simple inputs manager to abstract key/mouse inputs.\n     * \n     * @param {HTMLElement} domElement\n     * @param {DefaultOptions} options\n    */\n\n    constructor(domElement, options) {\n        this.version = version\n        var opts = Object.assign({}, new DefaultOptions(), options || {})\n\n        // settings\n        /** The HTMLElement that `inputs` is bound to. */\n        this.element = domElement || document\n        /** When true, all key events with bindings will call `preventDefaults`. */\n        this.preventDefaults = !!opts.preventDefaults\n        /** When true, all key events with bindings will call `stopPropagation`. */\n        this.stopPropagation = !!opts.stopPropagation\n        /** When this is false, the context menu will be prevented from opening if there is a binding to the right mouse button. */\n        this.allowContextMenu = !!opts.allowContextMenu\n        /** When disabled, no binding events will fire. */\n        this.disabled = !!opts.disabled\n\n        /** \n         * Optional filter function. Useful if you want to, e.g., \n         * ignore a key binding if ctrl/alt are pressed, but allow that\n         * same binding if it originated from a mouse event.\n         * @param {KeyboardEvent & MouseEvent} ev\n         * @param {string} bindingName\n        */\n        this.filterEvents = (ev, bindingName) => true\n\n        // emitters\n        /** \n         * Event emitter for binding **press** events.  \n         * The original mouse or key event will be passed as an argument.\n        */\n        this.down = new EventEmitter()\n        /** \n         * Event emitter for binding **release** events.  \n         * The original mouse or key event will be passed as an argument.\n         */\n        this.up = new EventEmitter()\n\n        /** \n         * The boolean state of whether each binding is currently pressed.\n         * \n         * `inputs.state['move-left'] // true if a bound key is pressed`\n         * @type {{ [key:string]: boolean }} \n        */\n        this.state = {}\n\n        /** \n         * Numeric counters representing accumulated pointer/scroll inputs \n         * since the last time `tick` was called.\n        */\n        this.pointerState = {\n            dx: 0,\n            dy: 0,\n            scrollx: 0,\n            scrolly: 0,\n            scrollz: 0,\n        }\n\n        /** \n         * How many times each binding has been **pressed** \n         * since the last time `tick` was called.\n         * @type {{ [key:string]: number }} \n        */\n        this.pressCount = {}\n\n        /** \n         * How many times each binding has been **released** \n         * since the last time `tick` was called.\n         * @type {{ [key:string]: number }} \n        */\n        this.releaseCount = {}\n\n\n\n        // internal state\n        /** @private @type {{ [key:string]: string[] }}   code -> [...binding names] */\n        this._keyBindmap = {}\n        /** @private @type {{ [key:string]: boolean }} code -> isDown */\n        this._keyStates = {}\n        /** @private @type {{ [key:string]: number }}  bindingName -> currCt */\n        this._bindPressCount = {}\n        /** @private */\n        this._touches = { lastX: 0, lastY: 0, currID: null }\n\n        /** @private For a macOs bug workaround */\n        this._pressedDuringMeta = {}\n\n        // register for ALL THE dom events\n        if (document.readyState !== 'loading') {\n            initEvents(this)\n        } else {\n            document.addEventListener('DOMContentLoaded', ev => {\n                initEvents(this)\n            }, { once: true })\n        }\n    }\n\n\n    /**\n     * Binds one or more physical keys to an arbitrary binding name.\n     * Key strings should align to `KeyboardEvent.code` strings - \n     * e.g. `KeyA`, `ArrowDown`, etc.\n     * \n     * `inputs.bind('move-player-left', 'KeyW', 'ArrowLeft')\n     * \n     * @param {string} bindingName \n     * @param {...string} keys \n     */\n    bind(bindingName, ...keys) {\n        keys.forEach(code => {\n            var bindings = this._keyBindmap[code] || []\n            if (bindings.includes(bindingName)) return\n            bindings.push(bindingName)\n            this._keyBindmap[code] = bindings\n        })\n        this.state[bindingName] = !!this.state[bindingName]\n        this.pressCount[bindingName] = this.pressCount[bindingName] || 0\n        this.releaseCount[bindingName] = this.releaseCount[bindingName] || 0\n    }\n\n\n    /**\n     * Removes all key bindings for a given binding name.\n     * \n     * `inputs.unbind('move-player-left')\n     */\n    unbind(bindingName) {\n        for (var code in this._keyBindmap) {\n            var bindings = this._keyBindmap[code]\n            var i = bindings.indexOf(bindingName)\n            if (i > -1) { bindings.splice(i, 1) }\n        }\n    }\n\n    /**\n     * Returns a copy of all existing bindings, in the format:\n     * ```js\n     *   {\n     *      bindingName: [ keyCode1, keyCode2, ... ]\n     *      ...\n     *   }\n     * ```\n     */\n    getBindings() {\n        var res = {}\n        for (var code in this._keyBindmap) {\n            var bindings = this._keyBindmap[code]\n            bindings.forEach(bindingName => {\n                res[bindingName] = res[bindingName] || []\n                res[bindingName].push(code)\n            })\n        }\n        return res\n    }\n\n\n    /**\n     * Tick function - clears out all cumulative counters\n    */\n    tick() {\n        zeroAllProperties(this.pointerState)\n        zeroAllProperties(this.pressCount)\n        zeroAllProperties(this.releaseCount)\n    }\n}\n\nfunction zeroAllProperties(obj) {\n    for (var key in obj) obj[key] = 0\n}\n\n\n\n\n\n\n/*\n *\n *   PRIVATE FUNCTIONS\n *\n*/\n\n/** @param {GameInputs} inputs */\nfunction initEvents(inputs) {\n    // keys\n    window.addEventListener('keydown', onKeyEvent.bind(null, inputs, true), false)\n    window.addEventListener('keyup', onKeyEvent.bind(null, inputs, false), false)\n\n    // pointer/mouse events\n    var pointerOpts = { passive: true }\n    if (window.PointerEvent) {\n        inputs.element.addEventListener(\"pointerdown\", onPointerEvent.bind(null, inputs, true), pointerOpts)\n        window.document.addEventListener(\"pointerup\", onPointerEvent.bind(null, inputs, false), pointerOpts)\n        inputs.element.addEventListener(\"pointermove\", onPointerMove.bind(null, inputs), pointerOpts)\n    } else {\n        inputs.element.addEventListener(\"mousedown\", onPointerEvent.bind(null, inputs, true), pointerOpts)\n        window.document.addEventListener(\"mouseup\", onPointerEvent.bind(null, inputs, false), pointerOpts)\n        inputs.element.addEventListener(\"mousemove\", onPointerMove.bind(null, inputs), pointerOpts)\n    }\n    inputs.element.addEventListener(\"wheel\", onWheelEvent.bind(null, inputs), pointerOpts)\n    inputs.element.addEventListener(\"contextmenu\", onContextMenu.bind(null, inputs), false)\n\n    // doc-level blur event for edge cases\n    window.addEventListener(\"blur\", onWindowBlur.bind(null, inputs), false)\n}\n\n\n\n\n\n/*\n *\n *\n *      INTERNALS - DOM EVENT HANDLERS\n *\n *\n*/\n\nfunction onKeyEvent(inputs, nowDown, ev) {\n    handleKeyEvent(ev.code, nowDown, inputs, ev)\n    workaroundMacBug(nowDown, inputs, ev)\n}\n\nfunction onPointerEvent(inputs, nowDown, ev) {\n    // if pointer events supported, only track the first\n    if ('pointerId' in ev) {\n        if (nowDown) {\n            if (inputs._touches.currID !== null) return\n            inputs._touches.currID = ev.pointerId\n        } else {\n            if (inputs._touches.currID !== ev.pointerId) return\n            inputs._touches.currID = null\n        }\n    }\n    var button = ('button' in ev) ? (ev.button + 1) : 1\n    handleKeyEvent('Mouse' + button, nowDown, inputs, ev)\n    return false\n}\n\nfunction onPointerMove(inputs, ev) {\n    // if a touch exists, ignore movement of other touches\n    if ('pointerId' in ev && inputs._touches.currID !== null) {\n        if (inputs._touches.currID !== ev.pointerId) return\n    }\n    // fire no events, just expose the state data\n    var dx = ev.movementX || ev.mozMovementX || 0,\n        dy = ev.movementY || ev.mozMovementY || 0\n    inputs.pointerState.dx += dx\n    inputs.pointerState.dy += dy\n}\n\n\n\n\n/*\n * \n *      mousewheel / scroll handling...\n * \n */\n\nfunction onWheelEvent(inputs, ev) {\n    var scale = 1\n    switch (ev.deltaMode) {\n        case 0: scale = 1; break  // Pixel\n        case 1: scale = 12; break  // Line\n        case 2:  // page\n            // TODO: investigate when this happens, what correct handling is\n            scale = inputs.element.clientHeight || window.innerHeight\n            break\n    }\n    // accumulate state\n    inputs.pointerState.scrollx += (ev.deltaX || 0) * scale\n    inputs.pointerState.scrolly += (ev.deltaY || 0) * scale\n    inputs.pointerState.scrollz += (ev.deltaZ || 0) * scale\n}\n\n\n/*\n *\n *          Edge cases...\n *\n*/\n\nfunction onContextMenu(inputs, ev) {\n    if (!inputs.allowContextMenu) {\n        ev.preventDefault()\n        return false\n    }\n}\n\nfunction onWindowBlur(inputs) {\n    // at least some browsers handle mouse events correctly here\n    // but not keys, so on window blur simulate a keyUp for all pressed keys\n    // there may be a better way to handle this someday..\n    for (var code in inputs._keyStates) {\n        if (!inputs._keyStates[code]) continue\n        if (/^Mouse\\d/.test(code)) continue\n        handleKeyEvent(code, false, inputs, {\n            code: code,\n            note: `This is a mocked KeyboardEvent made by the 'game-inputs' module`,\n            preventDefault: () => { },\n            stopPropagation: () => { },\n        })\n    }\n}\n\n\n\n\n/*\n *\n *\n *          FINAL KEY BIND HANDLING\n *\n *\n*/\n\n// tracks the state/counts of individual physical keys\nfunction handleKeyEvent(code, nowDown, inputs, ev) {\n    var bindings = inputs._keyBindmap[code]\n    if (!bindings) return\n\n    // if the key state has changed, handle the event for all bindings\n    var prevState = inputs._keyStates[code]\n    if (XOR(prevState, nowDown)) {\n        inputs._keyStates[code] = nowDown\n        bindings.forEach(bindingName => {\n            // allow client to filter events if applicable\n            var allow = (inputs.filterEvents) ?\n                inputs.filterEvents(ev, bindingName) : true\n            if (!allow) return\n            // finally emit the event\n            handleBindingEvent(bindingName, nowDown, inputs, ev)\n        })\n    }\n\n    // prevent/stop only for non-mouse events\n    if (!('button' in ev)) {\n        if (inputs.preventDefaults && !ev.defaultPrevented) {\n            ev.preventDefault()\n        }\n        if (inputs.stopPropagation) ev.stopPropagation()\n    }\n\n}\n\n\n// tracks the state/counts of virtual bindings\nfunction handleBindingEvent(bindingName, pressed, inputs, ev) {\n    // externally, track *cumulative* press/release counts\n    var counter = (pressed) ? inputs.pressCount : inputs.releaseCount\n    counter[bindingName] = (counter[bindingName] || 0) + 1\n    // internally, track *current* press count (to handle overlapping keybinds)\n    var ct = inputs._bindPressCount[bindingName] || 0\n    ct += pressed ? 1 : -1\n    if (ct < 0) { ct = 0 } // shouldn't happen\n    inputs._bindPressCount[bindingName] = ct\n\n    // emit event if binding's state has changed\n    var currstate = inputs.state[bindingName]\n    if (XOR(currstate, ct)) {\n        inputs.state[bindingName] = (ct > 0)\n        var emitter = pressed ? inputs.down : inputs.up\n        if (!inputs.disabled) emitter.emit(bindingName, ev)\n    }\n}\n\n\n\n\n/*\n *\n *\n *    HELPERS\n *\n *\n*/\n\n\n// how is this not part of Javascript?\nfunction XOR(a, b) {\n    return a ? !b : b\n}\n\n\n/*\n *\n *\n *    MEHHHH\n *\n *\n*/\n\n\nfunction workaroundMacBug(down, inputs, ev) {\n    var isMeta = /^Meta/.test(ev.code)\n    if (ev.metaKey && !isMeta && down) {\n        // remember any key codes that were pressed while meta is down \n        inputs._pressedDuringMeta[ev.code] = true\n    } else if (isMeta && !down) {\n        // when meta released, maybe issue keyUps for them\n        for (var code in inputs._pressedDuringMeta) {\n            if (!inputs._keyStates[code]) continue\n            if (/^Mouse\\d/.test(code)) continue\n            handleKeyEvent(code, false, inputs, {\n                code: code,\n                note: `This is a mocked KeyboardEvent made by the 'game-inputs' module`,\n                preventDefault: () => { },\n                stopPropagation: () => { },\n            })\n        }\n        inputs._pressedDuringMeta = {}\n    }\n}\n\n\n", "{\n    \"name\": \"game-inputs\",\n    \"version\": \"0.8.0\",\n    \"description\": \"Simple library to abstract key/mouse events for games.\",\n    \"main\": \"src/inputs.js\",\n    \"typings\": \"dist/src/inputs.d.ts\",\n    \"files\": [\n        \"/src\",\n        \"/dist\"\n    ],\n    \"scripts\": {\n        \"start\": \"cd docs/ && webpack serve\",\n        \"build\": \"tsc; cd docs/ && webpack\"\n    },\n    \"author\": \"Andy Hall\",\n    \"license\": \"ISC\",\n    \"keywords\": [\n        \"game\",\n        \"inputs\",\n        \"key\",\n        \"mouse\",\n        \"events\"\n    ],\n    \"dependencies\": {\n        \"events\": \"^3.3.0\"\n    },\n    \"repository\": {\n        \"type\": \"git\",\n        \"url\": \"https://github.com/fenomas/game-inputs\"\n    },\n    \"bugs\": {\n        \"url\": \"https://github.com/fenomas/game-inputs/issues\"\n    }\n}\n", "\nimport { GameInputs } from 'game-inputs'\n\nvar defaultOptions = {\n    preventDefaults: false,\n    stopPropagation: false,\n    allowContextMenu: false,\n}\n\nvar defaultBindings = {\n    \"forward\": [\"KeyW\", \"ArrowUp\"],\n    \"backward\": [\"KeyS\", \"ArrowDown\"],\n    \"left\": [\"KeyA\", \"ArrowLeft\"],\n    \"right\": [\"KeyD\", \"ArrowRight\"],\n    \"fire\": \"Mouse1\",\n    \"mid-fire\": [\"Mouse2\", \"KeyQ\"],\n    \"alt-fire\": [\"Mouse3\", \"KeyE\"],\n    \"jump\": \"Space\",\n}\n\n/**\n * `noa.inputs` - Handles key and mouse input bindings.\n * \n * This module extends \n * [game-inputs](https://github.com/fenomas/game-inputs),\n * so turn on \"Inherited\" to see its APIs here, or view the base module \n * for full docs.\n * \n * This module uses the following default options (from the options\n * object passed to the {@link Engine}):\n * \n * ```js\n *   defaultBindings: {\n *     \"forward\":  [\"KeyW\", \"ArrowUp\"],\n *     \"backward\": [\"KeyS\", \"ArrowDown\"],\n *     \"left\":     [\"KeyA\", \"ArrowLeft\"],\n *     \"right\":    [\"KeyD\", \"ArrowRight\"],\n *     \"fire\":     \"Mouse1\",\n *     \"mid-fire\": [\"Mouse2\", \"KeyQ\"],\n *     \"alt-fire\": [\"Mouse3\", \"KeyE\"],\n *     \"jump\":     \"Space\",\n *   }\n * ```\n */\n\nexport class Inputs extends GameInputs {\n\n    /** @internal */\n    constructor(noa, opts, element) {\n        opts = Object.assign({}, defaultOptions, opts)\n        super(element, opts)\n\n        var b = opts.bindings || defaultBindings\n        for (var name in b) {\n            var keys = Array.isArray(b[name]) ? b[name] : [b[name]]\n            this.bind(name, ...keys)\n        }\n    }\n}\n\n", "\nimport { EventEmitter } from 'events'\nimport { MicroGameShell } from 'micro-game-shell'\n\n\n\n\n\n/**\n * `noa.container` - manages the game's HTML container element, canvas, \n * fullscreen, pointerLock, and so on.\n * \n * This module wraps `micro-game-shell`, which does most of the implementation.\n * \n * **Events**\n *  + `DOMready => ()`  \n *    Relays the browser DOMready event, after noa does some initialization\n *  + `gainedPointerLock => ()`  \n *    Fires when the game container gains pointerlock.\n *  + `lostPointerLock => ()`  \n *    Fires when the game container loses pointerlock.\n */\n\nexport class Container extends EventEmitter {\n\n    /** @internal */\n    constructor(noa, opts) {\n        super()\n        opts = opts || {}\n\n        /** \n         * @internal\n         * @type {import('../index').Engine}\n        */\n        this.noa = noa\n\n        /** The game's DOM element container */\n        var domEl = opts.domElement || null\n        if (typeof domEl === 'string') {\n            domEl = document.querySelector(domEl)\n        }\n        this.element = domEl || createContainerDiv()\n\n        /** The `canvas` element that the game will draw into */\n        this.canvas = getOrCreateCanvas(this.element)\n        doCanvasBugfix(noa, this.canvas) // grumble...\n\n\n        /** Whether the browser supports pointerLock. @readonly */\n        this.supportsPointerLock = false\n\n        /** Whether the user's pointer is within the game area. @readonly */\n        this.pointerInGame = false\n\n        /** Whether the game is focused. @readonly */\n        this.isFocused = !!document.hasFocus()\n\n        /** Gets the current state of pointerLock. @readonly */\n        this.hasPointerLock = false\n\n\n\n        // shell manages tick/render rates, and pointerlock/fullscreen\n        var pollTime = 10\n        /** @internal */\n        this._shell = new MicroGameShell(this.element, pollTime)\n        this._shell.tickRate = opts.tickRate\n        this._shell.maxRenderRate = opts.maxRenderRate\n        this._shell.stickyPointerLock = opts.stickyPointerLock\n        this._shell.stickyFullscreen = opts.stickyFullscreen\n        this._shell.maxTickTime = 50\n\n\n\n        // core timing events\n        this._shell.onTick = noa.tick.bind(noa)\n        this._shell.onRender = noa.render.bind(noa)\n\n        // shell listeners\n        this._shell.onPointerLockChanged = (hasPL) => {\n            this.hasPointerLock = hasPL\n            this.emit((hasPL) ? 'gainedPointerLock' : 'lostPointerLock')\n            // this works around a Firefox bug where no mouse-in event \n            // gets issued after starting pointerlock\n            if (hasPL) this.pointerInGame = true\n        }\n\n        // catch and relay domReady event\n        this._shell.onInit = () => {\n            this._shell.onResize = noa.rendering.resize.bind(noa.rendering)\n            // listeners to track when game has focus / pointer\n            detectPointerLock(this)\n            this.element.addEventListener('mouseenter', () => { this.pointerInGame = true })\n            this.element.addEventListener('mouseleave', () => { this.pointerInGame = false })\n            window.addEventListener('focus', () => { this.isFocused = true })\n            window.addEventListener('blur', () => { this.isFocused = false })\n            // catch edge cases for initial states\n            var onFirstMousedown = () => {\n                this.pointerInGame = true\n                this.isFocused = true\n                this.element.removeEventListener('mousedown', onFirstMousedown)\n            }\n            this.element.addEventListener('mousedown', onFirstMousedown)\n            // emit for engine core\n            this.emit('DOMready')\n            // done and remove listener\n            this._shell.onInit = null\n        }\n    }\n\n\n    /*\n     *\n     *\n     *              PUBLIC API \n     *\n     *\n    */\n\n    /** @internal */\n    appendTo(htmlElement) {\n        this.element.appendChild(htmlElement)\n    }\n\n    /** \n     * Sets whether `noa` should try to acquire or release pointerLock\n    */\n    setPointerLock(lock = false) {\n        // not sure if this will work robustly\n        this._shell.pointerLock = !!lock\n    }\n}\n\n\n\n/*\n *\n *\n *              INTERNALS\n *\n *\n*/\n\n\nfunction createContainerDiv() {\n    // based on github.com/mikolalysenko/game-shell - makeDefaultContainer()\n    var container = document.createElement(\"div\")\n    container.tabIndex = 1\n    container.style.position = \"fixed\"\n    container.style.left = \"0px\"\n    container.style.right = \"0px\"\n    container.style.top = \"0px\"\n    container.style.bottom = \"0px\"\n    container.style.height = \"100%\"\n    container.style.overflow = \"hidden\"\n    document.body.appendChild(container)\n    document.body.style.overflow = \"hidden\" //Prevent bounce\n    document.body.style.height = \"100%\"\n    container.id = 'noa-container'\n    return container\n}\n\n\nfunction getOrCreateCanvas(el) {\n    // based on github.com/stackgl/gl-now - default canvas\n    var canvas = el.querySelector('canvas')\n    if (!canvas) {\n        canvas = document.createElement('canvas')\n        canvas.style.position = \"absolute\"\n        canvas.style.left = \"0px\"\n        canvas.style.top = \"0px\"\n        canvas.style.height = \"100%\"\n        canvas.style.width = \"100%\"\n        canvas.id = 'noa-canvas'\n        el.insertBefore(canvas, el.firstChild)\n    }\n    return canvas\n}\n\n\n// set up stuff to detect pointer lock support.\n// Needlessly complex because Chrome/Android claims to support but doesn't.\n// For now, just feature detect, but assume no support if a touch event occurs\n// TODO: see if this makes sense on hybrid touch/mouse devices\nfunction detectPointerLock(self) {\n    var lockElementExists =\n        ('pointerLockElement' in document) ||\n        ('mozPointerLockElement' in document) ||\n        ('webkitPointerLockElement' in document)\n    if (lockElementExists) {\n        self.supportsPointerLock = true\n        var listener = function (e) {\n            self.supportsPointerLock = false\n            document.removeEventListener(e.type, listener)\n        }\n        document.addEventListener('touchmove', listener)\n    }\n}\n\n\n/**\n * This works around a weird bug that seems to be chrome/mac only?\n * Without this, the page sometimes initializes with the canva\n * zoomed into its lower left quadrant. \n * Resizing the canvas fixes the issue (also: resizing page, changing zoom...)\n */\nfunction doCanvasBugfix(noa, canvas) {\n    var ct = 0\n    var fixCanvas = () => {\n        var w = canvas.width\n        canvas.width = w + 1\n        canvas.width = w\n        if (ct++ > 10) noa.off('beforeRender', fixCanvas)\n    }\n    noa.on('beforeRender', fixCanvas)\n}\n", "\n\n\n/*\n * \n * \n *      base class and API\n * \n * \n*/\n\nexport class MicroGameShell {\n\n    constructor(domElement = null, pollTime = 10) {\n\n        /** When true, the shell will try to acquire pointerlock on click events */\n        this.stickyPointerLock = false\n        /** When true, the shell will try to acquire fullscreen on click events */\n        this.stickyFullscreen = false\n\n        /** Desired tick events per second */\n        this.tickRate = 30\n        /** Upper limit for render events per second - `0` means uncapped */\n        this.maxRenderRate = 0\n        /** Max time spent issuing tick events when behind schedule. If the shell spends this long on tick events, it will discard all pending ticks to catch up. */\n        this.maxTickTime = 100\n\n\n        /** Check or set whether the DOM element has pointerlock */\n        this.pointerLock = false\n        /** Check or set whether the DOM element has fullscreen */\n        this.fullscreen = false\n\n        /**\n         * Tick event handler.\n         * @param {number} dt: tick duration (ms) - this is a fixed value based on the tick rate, not the observed time elapsed\n         */\n        this.onTick = function (dt) { }\n\n        /**\n         * Render event handler.\n         * @param {number} dt: elapsed time (ms) since previous render event\n         * @param {number} framePart: fraction (0..1) corresponding to how much of the current tick has elapsed\n         * @param {number} tickDur: tick duration (ms)\n         */\n        this.onRender = function (dt, framePart, tickDur) { }\n\n\n        /** This event fires once after shell initializes. */\n        this.onInit = function () { }\n        /** This event fires when the domElement's window resizes */\n        this.onResize = function () { }\n        /** This event fires when pointerlock is gained or lost */\n        this.onPointerLockChanged = function (hasPL = false) { }\n        /** This event fires when fullscreen is gained or lost */\n        this.onFullscreenChanged = function (hasFS = false) { }\n        /** This event fires when a pointerLock error occurs */\n        this.onPointerLockError = function (err) { }\n\n\n\n        // hide internals in a data object\n        this._data = new Data(pollTime)\n\n        // init\n        domReady(() => {\n            setupTimers(this)\n            setupDomElement(this, domElement)\n            this.onInit()\n        })\n    }\n}\n\n\n// internal data structure\nfunction Data(pollTime = 10) {\n    this.nowObject = performance || Date\n    this.pollTime = pollTime\n    this.renderAccum = 0\n    this.lastTickStarted = 0\n    this.lastFrameStarted = 0\n    this.lastRenderStarted = 0\n    this.avgTickTime = 2\n    this.frameCB = null\n    this.intervalCB = null\n    this.intervalID = -1\n}\n\n\n\n\n\n\n\n/*\n * \n *      tick- and render events\n * \n*/\n\n/** @param {MicroGameShell} shell */\nfunction setupTimers(shell) {\n    var dat = shell._data\n    var now = dat.nowObject.now()\n    dat.lastTickStarted = now\n    dat.lastFrameStarted = now\n    dat.lastRenderStarted = now\n\n    dat.frameCB = () => frameHandler(shell)\n    dat.intervalCB = () => intervalHandler(shell)\n    requestAnimationFrame(dat.frameCB)\n\n    if (dat.pollTime > 0) {\n        dat.intervalID = setInterval(dat.intervalCB, dat.pollTime)\n    }\n}\n\n\n\n\n/** \n * RAF handler - triggers render events\n * @param {MicroGameShell} shell\n*/\nfunction frameHandler(shell) {\n    var dat = shell._data\n    requestAnimationFrame(dat.frameCB)\n    // first catch up on ticks if we're behind schedule\n    intervalHandler(shell)\n    // now decide whether to do a render, if rate is capped\n    var now = dat.nowObject.now()\n    var dt = now - dat.lastFrameStarted\n    dat.lastFrameStarted = now\n    if (shell.maxRenderRate > 0) {\n        dat.renderAccum += dt\n        var frameDur = 1000 / shell.maxRenderRate\n        if (dat.renderAccum < frameDur) return\n        dat.renderAccum -= frameDur\n        // don't save up more than one pending frame\n        if (dat.renderAccum > frameDur) dat.renderAccum = frameDur\n    }\n    // issue the render event\n    var renderDt = now - dat.lastRenderStarted\n    dat.lastRenderStarted = now\n    var tickDur = 1000 / shell.tickRate\n    var framePart = (now - dat.lastTickStarted) / tickDur\n    if (framePart < 0) framePart = 0\n\n    // issue render, and optimistically schedule lookahead interval handler\n    shell.onRender(renderDt, framePart, tickDur)\n    setTimeout(intervalHandler, 0, shell, true)\n}\n\n\n\n\n/** \n * setInterval handler - triggers tick events\n * @param {MicroGameShell} shell\n*/\nfunction intervalHandler(shell, lookAhead = false) {\n    var dat = shell._data\n    var now = dat.nowObject.now()\n    // decide base and cutoff times until which we issue ticks\n    var tickUntil = now\n    if (lookAhead) tickUntil += dat.avgTickTime\n    var cutoffTime = now + shell.maxTickTime\n    if (!(cutoffTime > now)) cutoffTime = now + 1\n    var tickDur = 1000 / shell.tickRate\n\n    // issue ticks until we're up to date or out of time\n    while (dat.lastTickStarted + tickDur < tickUntil) {\n        shell.onTick(tickDur)\n        dat.lastTickStarted += tickDur\n        var after = dat.nowObject.now()\n        dat.avgTickTime = runningAverage(dat.avgTickTime, after - now)\n\n        // and track the approx processing time, and close loop\n        now = after\n        if (now > cutoffTime) {\n            dat.lastTickStarted = now\n            return\n        }\n    }\n}\n\n\n\n\n\n\n\n/*\n * \n *      DOM element and sticky fullscreen/pointerlock\n * \n*/\n\nfunction setupDomElement(shell, el) {\n    if (!el) return\n    var hasPL = false\n    var hasFS = false\n\n    var setPL = (want) => {\n        hasPL = (el === document.pointerLockElement)\n        if (!!want === hasPL) return\n        if (want) {\n            // chrome returns a promise here, others don't\n            var res = el.requestPointerLock()\n            if (res && res.catch) res.catch(err => {\n                // error already handled in `pointerlockerror`\n            })\n        } else {\n            document.exitPointerLock()\n        }\n    }\n    var setFS = (want) => {\n        hasFS = (el === document.fullscreenElement)\n        if (!!want === hasFS) return\n        if (want) {\n            if (el.requestFullscreen) {\n                el.requestFullscreen()\n            } else if (el.webkitRequestFullscreen) {\n                el.webkitRequestFullscreen()\n            }\n        } else {\n            if (document.exitFullscreen) {\n                document.exitFullscreen()\n            } else if (document['webkitExitFullscreen']) {\n                document['webkitExitFullscreen']()\n            }\n        }\n    }\n\n    // track whether we actually have PL/FS, and send events\n    document.addEventListener('pointerlockchange', ev => {\n        hasPL = (el === document.pointerLockElement)\n        shell.onPointerLockChanged(hasPL)\n    })\n    document.addEventListener('fullscreenchange', ev => {\n        hasFS = (el === document.fullscreenElement)\n        shell.onFullscreenChanged(hasFS)\n    })\n    document.addEventListener('pointerlockerror', err => {\n        hasPL = (el === document.pointerLockElement)\n        shell.onPointerLockError(err)\n    })\n\n\n    // decorate shell with getter/setters that request FS/PL\n    Object.defineProperty(shell, 'pointerLock', {\n        get: () => hasPL,\n        set: setPL,\n    })\n    Object.defineProperty(shell, 'fullscreen', {\n        get: () => hasFS,\n        set: setFS,\n    })\n\n\n    // stickiness via click handler\n    el.addEventListener('click', ev => {\n        if (shell.stickyPointerLock) setPL(true)\n        if (shell.stickyFullscreen) setFS(true)\n    })\n\n\n    // resize events via ResizeObserver\n    var resizeHandler = () => shell.onResize()\n    if (window.ResizeObserver) {\n        var observer = new ResizeObserver(resizeHandler)\n        observer.observe(el)\n    } else {\n        window.addEventListener('resize', resizeHandler)\n    }\n}\n\n\n\n\n\n/*\n * \n *      util \n * \n*/\n\nfunction runningAverage(avg, newVal) {\n    // squash effects of large one-off spikes\n    if (newVal > avg * 4) newVal = avg * 4\n    if (newVal < avg * 0.25) newVal = avg * 0.25\n    return 0.9 * avg + 0.1 * newVal\n}\n\nfunction domReady(fn) {\n    if (document.readyState === 'loading') {\n        var handler = () => {\n            document.removeEventListener('readystatechange', handler)\n            fn()\n        }\n        document.addEventListener('readystatechange', handler)\n    } else {\n        setTimeout(fn, 0)\n    }\n}\n", "\nimport vec3 from 'gl-vec3'\nimport aabb from 'aabb-3d'\nimport sweep from 'voxel-aabb-sweep'\n\n\n\n// default options\nfunction CameraDefaults() {\n    this.inverseX = false\n    this.inverseY = false\n    this.sensitivityMult = 1\n    this.sensitivityMultOutsidePointerlock = 0\n    this.sensitivityX = 10\n    this.sensitivityY = 10\n    this.initialZoom = 0\n    this.zoomSpeed = 0.2\n}\n\n\n// locals\nvar tempVectors = [\n    vec3.create(),\n    vec3.create(),\n    vec3.create(),\n]\nvar originVector = vec3.create()\n\n\n/**\n * `noa.camera` - manages the camera, its position and direction, \n * mouse sensitivity, and so on.\n * \n * This module uses the following default options (from the options\n * object passed to the {@link Engine}):\n * ```js\n * var defaults = {\n *     inverseX: false,\n *     inverseY: false,\n *     sensitivityX: 10,\n *     sensitivityY: 10,\n *     initialZoom: 0,\n *     zoomSpeed: 0.2,\n * }\n * ```\n*/\n\nexport class Camera {\n\n    /** \n     * @internal \n     * @param {import('../index').Engine} noa\n     * @param {Partial.<CameraDefaults>} opts\n    */\n    constructor(noa, opts) {\n        opts = Object.assign({}, new CameraDefaults, opts)\n        this.noa = noa\n\n        /** Horizontal mouse sensitivity. Same scale as Overwatch (typical values around `5..10`) */\n        this.sensitivityX = +opts.sensitivityX\n\n        /** Vertical mouse sensitivity. Same scale as Overwatch (typical values around `5..10`) */\n        this.sensitivityY = +opts.sensitivityY\n\n        /** Mouse look inverse (horizontal) */\n        this.inverseX = !!opts.inverseX\n\n        /** Mouse look inverse (vertical) */\n        this.inverseY = !!opts.inverseY\n\n        /** \n         * Multiplier for temporarily altering mouse sensitivity.\n         * Set this to `0` to temporarily disable camera controls.\n        */\n        this.sensitivityMult = opts.sensitivityMult\n\n        /** \n         * Multiplier for altering mouse sensitivity when pointerlock\n         * is not active - default of `0` means no camera movement.\n         * Note this setting is ignored if pointerLock isn't supported.\n         */\n        this.sensitivityMultOutsidePointerlock = opts.sensitivityMultOutsidePointerlock\n\n        /** \n         * Camera yaw angle. \n         * Returns the camera's rotation angle around the vertical axis. \n         * Range: `0..2`  \n         * This value is writeable, but it's managed by the engine and \n         * will be overwritten each frame.\n        */\n        this.heading = 0\n\n        /** Camera pitch angle. \n         * Returns the camera's up/down rotation angle. The pitch angle is \n         * clamped by a small epsilon, such that the camera never quite \n         * points perfectly up or down.  \n         * Range: `-/2../2`.  \n         * This value is writeable, but it's managed by the engine and \n         * will be overwritten each frame.\n        */\n        this.pitch = 0\n\n        /** \n         * Entity ID of a special entity that exists for the camera to point at.\n         * \n         * By default this entity follows the player entity, so you can \n         * change the player's eye height by changing the `follow` component's offset:\n         * ```js\n         * var followState = noa.ents.getState(noa.camera.cameraTarget, 'followsEntity')\n         * followState.offset[1] = 0.9 * myPlayerHeight\n         * ```\n         * \n         * For customized camera controls you can change the follow \n         * target to some other entity, or override the behavior entirely:\n         * ```js\n         * // make cameraTarget stop following the player\n         * noa.ents.removeComponent(noa.camera.cameraTarget, 'followsEntity')\n         * // control cameraTarget position directly (or whatever..)\n         * noa.ents.setPosition(noa.camera.cameraTarget, [x,y,z])\n         * ```\n        */\n        this.cameraTarget = this.noa.ents.createEntity(['position'])\n\n        // make the camera follow the cameraTarget entity\n        var eyeOffset = 0.9 * noa.ents.getPositionData(noa.playerEntity).height\n        noa.ents.addComponent(this.cameraTarget, 'followsEntity', {\n            entity: noa.playerEntity,\n            offset: [0, eyeOffset, 0],\n        })\n\n        /** How far back the camera should be from the player's eye position */\n        this.zoomDistance = opts.initialZoom\n\n        /** How quickly the camera moves to its `zoomDistance` (0..1) */\n        this.zoomSpeed = opts.zoomSpeed\n\n        /** Current actual zoom distance. This differs from `zoomDistance` when\n         * the camera is in the process of moving towards the desired distance, \n         * or when it's obstructed by solid terrain behind the player.\n         * This value will get overwritten each tick, but you may want to write to it\n         * when overriding the camera zoom speed.\n        */\n        this.currentZoom = opts.initialZoom\n\n        /** @internal */\n        this._dirVector = vec3.fromValues(0, 0, 1)\n    }\n\n\n\n\n    /*\n     * \n     * \n     *          API\n     * \n     * \n    */\n\n\n    /*\n     *      Local position functions for high precision\n    */\n    /** @internal */\n    _localGetTargetPosition() {\n        var pdat = this.noa.ents.getPositionData(this.cameraTarget)\n        var pos = tempVectors[0]\n        return vec3.copy(pos, pdat._renderPosition)\n    }\n    /** @internal */\n    _localGetPosition() {\n        var loc = this._localGetTargetPosition()\n        if (this.currentZoom === 0) return loc\n        return vec3.scaleAndAdd(loc, loc, this._dirVector, -this.currentZoom)\n    }\n\n\n\n    /**\n     * Returns the camera's current target position - i.e. the player's \n     * eye position. When the camera is zoomed all the way in, \n     * this returns the same location as `camera.getPosition()`.\n    */\n    getTargetPosition() {\n        var loc = this._localGetTargetPosition()\n        var globalCamPos = tempVectors[1]\n        return this.noa.localToGlobal(loc, globalCamPos)\n    }\n\n\n    /**\n     * Returns the current camera position (read only)\n    */\n    getPosition() {\n        var loc = this._localGetPosition()\n        var globalCamPos = tempVectors[2]\n        return this.noa.localToGlobal(loc, globalCamPos)\n    }\n\n\n    /**\n     * Returns the camera direction vector (read only)\n    */\n    getDirection() {\n        return this._dirVector\n    }\n\n\n\n\n    /*\n     * \n     * \n     * \n     *          internals below\n     * \n     * \n     * \n    */\n\n\n\n    /**\n     * Called before render, if mouseLock etc. is applicable.\n     * Applies current mouse x/y inputs to the camera angle and zoom\n     * @internal\n    */\n\n    applyInputsToCamera() {\n\n        // conditional changes to mouse sensitivity\n        var senseMult = this.sensitivityMult\n        if (this.noa.container.supportsPointerLock) {\n            if (!this.noa.container.hasPointerLock) {\n                senseMult *= this.sensitivityMultOutsidePointerlock\n            }\n        }\n        if (senseMult === 0) return\n\n        // dx/dy from input state\n        var pointerState = this.noa.inputs.pointerState\n        bugFix(pointerState) // TODO: REMOVE EVENTUALLY    \n\n        // convert to rads, using (sens * 0.0066 deg/pixel), like Overwatch\n        var conv = 0.0066 * Math.PI / 180\n        var dx = pointerState.dx * this.sensitivityX * senseMult * conv\n        var dy = pointerState.dy * this.sensitivityY * senseMult * conv\n        if (this.inverseX) dx = -dx\n        if (this.inverseY) dy = -dy\n\n        // normalize/clamp angles, update direction vector\n        var twopi = 2 * Math.PI\n        this.heading += (dx < 0) ? dx + twopi : dx\n        if (this.heading > twopi) this.heading -= twopi\n        var maxPitch = Math.PI / 2 - 0.001\n        this.pitch = Math.max(-maxPitch, Math.min(maxPitch, this.pitch + dy))\n\n        vec3.set(this._dirVector, 0, 0, 1)\n        var dir = this._dirVector\n        var origin = originVector\n        vec3.rotateX(dir, dir, origin, this.pitch)\n        vec3.rotateY(dir, dir, origin, this.heading)\n    }\n\n\n\n    /**\n     *  Called before all renders, pre- and post- entity render systems\n     * @internal\n    */\n    updateBeforeEntityRenderSystems() {\n        // zoom update\n        this.currentZoom += (this.zoomDistance - this.currentZoom) * this.zoomSpeed\n    }\n\n    /** @internal */\n    updateAfterEntityRenderSystems() {\n        // clamp camera zoom not to clip into solid terrain\n        var maxZoom = cameraObstructionDistance(this)\n        if (this.currentZoom > maxZoom) this.currentZoom = maxZoom\n    }\n\n}\n\n\n\n\n/*\n *  check for obstructions behind camera by sweeping back an AABB\n*/\n\nfunction cameraObstructionDistance(self) {\n    if (!self._sweepBox) {\n        self._sweepBox = new aabb([0, 0, 0], [0.2, 0.2, 0.2])\n        self._sweepGetVoxel = self.noa.world.getBlockSolidity.bind(self.noa.world)\n        self._sweepVec = vec3.create()\n        self._sweepHit = () => true\n    }\n    var pos = vec3.copy(self._sweepVec, self._localGetTargetPosition())\n    vec3.add(pos, pos, self.noa.worldOriginOffset)\n    for (var i = 0; i < 3; i++) pos[i] -= 0.1\n    self._sweepBox.setPosition(pos)\n    var dist = Math.max(self.zoomDistance, self.currentZoom) + 0.1\n    vec3.scale(self._sweepVec, self.getDirection(), -dist)\n    return sweep(self._sweepGetVoxel, self._sweepBox, self._sweepVec, self._sweepHit, true)\n}\n\n\n\n\n\n\n// workaround for this Chrome 63 + Win10 bug\n// https://bugs.chromium.org/p/chromium/issues/detail?id=781182\n// later updated to also address: https://github.com/fenomas/noa/issues/153\nfunction bugFix(pointerState) {\n    var dx = pointerState.dx\n    var dy = pointerState.dy\n    var badx = (Math.abs(dx) > 400 && Math.abs(dx / lastx) > 4)\n    var bady = (Math.abs(dy) > 400 && Math.abs(dy / lasty) > 4)\n    if (badx || bady) {\n        pointerState.dx = lastx\n        pointerState.dy = lasty\n        lastx = (lastx + dx) / 2\n        lasty = (lasty + dy) / 2\n    } else {\n        lastx = dx || 1\n        lasty = dy || 1\n    }\n}\n\nvar lastx = 0\nvar lasty = 0\n", "/**\n * Common utilities\n * @module glMatrix\n */\n\n// Configuration Constants\nexport var EPSILON = 0.000001;\nexport var ARRAY_TYPE = typeof Float32Array !== \"undefined\" ? Float32Array : Array;\nexport var RANDOM = Math.random;\nexport var ANGLE_ORDER = \"zyx\";\n\n/**\n * Symmetric round\n * see https://www.npmjs.com/package/round-half-up-symmetric#user-content-detailed-background\n *\n * @param {Number} a value to round\n */\nexport function round(a) {\n  if (a >= 0) return Math.round(a);\n  return a % 0.5 === 0 ? Math.floor(a) : Math.round(a);\n}\n\n/**\n * Sets the type of array used when creating new vectors and matrices\n *\n * @param {Float32ArrayConstructor | ArrayConstructor} type Array type, such as Float32Array or Array\n */\nexport function setMatrixArrayType(type) {\n  ARRAY_TYPE = type;\n}\nvar degree = Math.PI / 180;\nvar radian = 180 / Math.PI;\n\n/**\n * Convert Degree To Radian\n *\n * @param {Number} a Angle in Degrees\n */\nexport function toRadian(a) {\n  return a * degree;\n}\n\n/**\n * Convert Radian To Degree\n *\n * @param {Number} a Angle in Radians\n */\nexport function toDegree(a) {\n  return a * radian;\n}\n\n/**\n * Tests whether or not the arguments have approximately the same value, within an absolute\n * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less\n * than or equal to 1.0, and a relative tolerance is used for larger values)\n *\n * @param {Number} a          The first number to test.\n * @param {Number} b          The second number to test.\n * @param {Number} tolerance  Absolute or relative tolerance (default glMatrix.EPSILON)\n * @returns {Boolean} True if the numbers are approximately equal, false otherwise.\n */\nexport function equals(a, b) {\n  var tolerance = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : EPSILON;\n  return Math.abs(a - b) <= tolerance * Math.max(1, Math.abs(a), Math.abs(b));\n}", "import * as glMatrix from \"./common.js\";\n\n/**\n * 3x3 Matrix\n * @module mat3\n */\n\n/**\n * Creates a new identity mat3\n *\n * @returns {mat3} a new 3x3 matrix\n */\nexport function create() {\n  var out = new glMatrix.ARRAY_TYPE(9);\n  if (glMatrix.ARRAY_TYPE != Float32Array) {\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n    out[5] = 0;\n    out[6] = 0;\n    out[7] = 0;\n  }\n  out[0] = 1;\n  out[4] = 1;\n  out[8] = 1;\n  return out;\n}\n\n/**\n * Copies the upper-left 3x3 values into the given mat3.\n *\n * @param {mat3} out the receiving 3x3 matrix\n * @param {ReadonlyMat4} a   the source 4x4 matrix\n * @returns {mat3} out\n */\nexport function fromMat4(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[4];\n  out[4] = a[5];\n  out[5] = a[6];\n  out[6] = a[8];\n  out[7] = a[9];\n  out[8] = a[10];\n  return out;\n}\n\n/**\n * Creates a new mat3 initialized with values from an existing matrix\n *\n * @param {ReadonlyMat3} a matrix to clone\n * @returns {mat3} a new 3x3 matrix\n */\nexport function clone(a) {\n  var out = new glMatrix.ARRAY_TYPE(9);\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  out[4] = a[4];\n  out[5] = a[5];\n  out[6] = a[6];\n  out[7] = a[7];\n  out[8] = a[8];\n  return out;\n}\n\n/**\n * Copy the values from one mat3 to another\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the source matrix\n * @returns {mat3} out\n */\nexport function copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  out[4] = a[4];\n  out[5] = a[5];\n  out[6] = a[6];\n  out[7] = a[7];\n  out[8] = a[8];\n  return out;\n}\n\n/**\n * Create a new mat3 with the given values\n *\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\n * @param {Number} m02 Component in column 0, row 2 position (index 2)\n * @param {Number} m10 Component in column 1, row 0 position (index 3)\n * @param {Number} m11 Component in column 1, row 1 position (index 4)\n * @param {Number} m12 Component in column 1, row 2 position (index 5)\n * @param {Number} m20 Component in column 2, row 0 position (index 6)\n * @param {Number} m21 Component in column 2, row 1 position (index 7)\n * @param {Number} m22 Component in column 2, row 2 position (index 8)\n * @returns {mat3} A new mat3\n */\nexport function fromValues(m00, m01, m02, m10, m11, m12, m20, m21, m22) {\n  var out = new glMatrix.ARRAY_TYPE(9);\n  out[0] = m00;\n  out[1] = m01;\n  out[2] = m02;\n  out[3] = m10;\n  out[4] = m11;\n  out[5] = m12;\n  out[6] = m20;\n  out[7] = m21;\n  out[8] = m22;\n  return out;\n}\n\n/**\n * Set the components of a mat3 to the given values\n *\n * @param {mat3} out the receiving matrix\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\n * @param {Number} m02 Component in column 0, row 2 position (index 2)\n * @param {Number} m10 Component in column 1, row 0 position (index 3)\n * @param {Number} m11 Component in column 1, row 1 position (index 4)\n * @param {Number} m12 Component in column 1, row 2 position (index 5)\n * @param {Number} m20 Component in column 2, row 0 position (index 6)\n * @param {Number} m21 Component in column 2, row 1 position (index 7)\n * @param {Number} m22 Component in column 2, row 2 position (index 8)\n * @returns {mat3} out\n */\nexport function set(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {\n  out[0] = m00;\n  out[1] = m01;\n  out[2] = m02;\n  out[3] = m10;\n  out[4] = m11;\n  out[5] = m12;\n  out[6] = m20;\n  out[7] = m21;\n  out[8] = m22;\n  return out;\n}\n\n/**\n * Set a mat3 to the identity matrix\n *\n * @param {mat3} out the receiving matrix\n * @returns {mat3} out\n */\nexport function identity(out) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 1;\n  out[5] = 0;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 1;\n  return out;\n}\n\n/**\n * Transpose the values of a mat3\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the source matrix\n * @returns {mat3} out\n */\nexport function transpose(out, a) {\n  // If we are transposing ourselves we can skip a few steps but have to cache some values\n  if (out === a) {\n    var a01 = a[1],\n      a02 = a[2],\n      a12 = a[5];\n    out[1] = a[3];\n    out[2] = a[6];\n    out[3] = a01;\n    out[5] = a[7];\n    out[6] = a02;\n    out[7] = a12;\n  } else {\n    out[0] = a[0];\n    out[1] = a[3];\n    out[2] = a[6];\n    out[3] = a[1];\n    out[4] = a[4];\n    out[5] = a[7];\n    out[6] = a[2];\n    out[7] = a[5];\n    out[8] = a[8];\n  }\n  return out;\n}\n\n/**\n * Inverts a mat3\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the source matrix\n * @returns {mat3 | null} out, or null if source matrix is not invertible\n */\nexport function invert(out, a) {\n  var a00 = a[0],\n    a01 = a[1],\n    a02 = a[2];\n  var a10 = a[3],\n    a11 = a[4],\n    a12 = a[5];\n  var a20 = a[6],\n    a21 = a[7],\n    a22 = a[8];\n  var b01 = a22 * a11 - a12 * a21;\n  var b11 = -a22 * a10 + a12 * a20;\n  var b21 = a21 * a10 - a11 * a20;\n\n  // Calculate the determinant\n  var det = a00 * b01 + a01 * b11 + a02 * b21;\n  if (!det) {\n    return null;\n  }\n  det = 1.0 / det;\n  out[0] = b01 * det;\n  out[1] = (-a22 * a01 + a02 * a21) * det;\n  out[2] = (a12 * a01 - a02 * a11) * det;\n  out[3] = b11 * det;\n  out[4] = (a22 * a00 - a02 * a20) * det;\n  out[5] = (-a12 * a00 + a02 * a10) * det;\n  out[6] = b21 * det;\n  out[7] = (-a21 * a00 + a01 * a20) * det;\n  out[8] = (a11 * a00 - a01 * a10) * det;\n  return out;\n}\n\n/**\n * Calculates the adjugate of a mat3\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the source matrix\n * @returns {mat3} out\n */\nexport function adjoint(out, a) {\n  var a00 = a[0],\n    a01 = a[1],\n    a02 = a[2];\n  var a10 = a[3],\n    a11 = a[4],\n    a12 = a[5];\n  var a20 = a[6],\n    a21 = a[7],\n    a22 = a[8];\n  out[0] = a11 * a22 - a12 * a21;\n  out[1] = a02 * a21 - a01 * a22;\n  out[2] = a01 * a12 - a02 * a11;\n  out[3] = a12 * a20 - a10 * a22;\n  out[4] = a00 * a22 - a02 * a20;\n  out[5] = a02 * a10 - a00 * a12;\n  out[6] = a10 * a21 - a11 * a20;\n  out[7] = a01 * a20 - a00 * a21;\n  out[8] = a00 * a11 - a01 * a10;\n  return out;\n}\n\n/**\n * Calculates the determinant of a mat3\n *\n * @param {ReadonlyMat3} a the source matrix\n * @returns {Number} determinant of a\n */\nexport function determinant(a) {\n  var a00 = a[0],\n    a01 = a[1],\n    a02 = a[2];\n  var a10 = a[3],\n    a11 = a[4],\n    a12 = a[5];\n  var a20 = a[6],\n    a21 = a[7],\n    a22 = a[8];\n  return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);\n}\n\n/**\n * Multiplies two mat3's\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the first operand\n * @param {ReadonlyMat3} b the second operand\n * @returns {mat3} out\n */\nexport function multiply(out, a, b) {\n  var a00 = a[0],\n    a01 = a[1],\n    a02 = a[2];\n  var a10 = a[3],\n    a11 = a[4],\n    a12 = a[5];\n  var a20 = a[6],\n    a21 = a[7],\n    a22 = a[8];\n  var b00 = b[0],\n    b01 = b[1],\n    b02 = b[2];\n  var b10 = b[3],\n    b11 = b[4],\n    b12 = b[5];\n  var b20 = b[6],\n    b21 = b[7],\n    b22 = b[8];\n  out[0] = b00 * a00 + b01 * a10 + b02 * a20;\n  out[1] = b00 * a01 + b01 * a11 + b02 * a21;\n  out[2] = b00 * a02 + b01 * a12 + b02 * a22;\n  out[3] = b10 * a00 + b11 * a10 + b12 * a20;\n  out[4] = b10 * a01 + b11 * a11 + b12 * a21;\n  out[5] = b10 * a02 + b11 * a12 + b12 * a22;\n  out[6] = b20 * a00 + b21 * a10 + b22 * a20;\n  out[7] = b20 * a01 + b21 * a11 + b22 * a21;\n  out[8] = b20 * a02 + b21 * a12 + b22 * a22;\n  return out;\n}\n\n/**\n * Translate a mat3 by the given vector\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the matrix to translate\n * @param {ReadonlyVec2} v vector to translate by\n * @returns {mat3} out\n */\nexport function translate(out, a, v) {\n  var a00 = a[0],\n    a01 = a[1],\n    a02 = a[2],\n    a10 = a[3],\n    a11 = a[4],\n    a12 = a[5],\n    a20 = a[6],\n    a21 = a[7],\n    a22 = a[8],\n    x = v[0],\n    y = v[1];\n  out[0] = a00;\n  out[1] = a01;\n  out[2] = a02;\n  out[3] = a10;\n  out[4] = a11;\n  out[5] = a12;\n  out[6] = x * a00 + y * a10 + a20;\n  out[7] = x * a01 + y * a11 + a21;\n  out[8] = x * a02 + y * a12 + a22;\n  return out;\n}\n\n/**\n * Rotates a mat3 by the given angle\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat3} out\n */\nexport function rotate(out, a, rad) {\n  var a00 = a[0],\n    a01 = a[1],\n    a02 = a[2],\n    a10 = a[3],\n    a11 = a[4],\n    a12 = a[5],\n    a20 = a[6],\n    a21 = a[7],\n    a22 = a[8],\n    s = Math.sin(rad),\n    c = Math.cos(rad);\n  out[0] = c * a00 + s * a10;\n  out[1] = c * a01 + s * a11;\n  out[2] = c * a02 + s * a12;\n  out[3] = c * a10 - s * a00;\n  out[4] = c * a11 - s * a01;\n  out[5] = c * a12 - s * a02;\n  out[6] = a20;\n  out[7] = a21;\n  out[8] = a22;\n  return out;\n}\n\n/**\n * Scales the mat3 by the dimensions in the given vec2\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the matrix to scale\n * @param {ReadonlyVec2} v the vec2 to scale the matrix by\n * @returns {mat3} out\n **/\nexport function scale(out, a, v) {\n  var x = v[0],\n    y = v[1];\n  out[0] = x * a[0];\n  out[1] = x * a[1];\n  out[2] = x * a[2];\n  out[3] = y * a[3];\n  out[4] = y * a[4];\n  out[5] = y * a[5];\n  out[6] = a[6];\n  out[7] = a[7];\n  out[8] = a[8];\n  return out;\n}\n\n/**\n * Creates a matrix from a vector translation\n * This is equivalent to (but much faster than):\n *\n *     mat3.identity(dest);\n *     mat3.translate(dest, dest, vec);\n *\n * @param {mat3} out mat3 receiving operation result\n * @param {ReadonlyVec2} v Translation vector\n * @returns {mat3} out\n */\nexport function fromTranslation(out, v) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 1;\n  out[5] = 0;\n  out[6] = v[0];\n  out[7] = v[1];\n  out[8] = 1;\n  return out;\n}\n\n/**\n * Creates a matrix from a given angle\n * This is equivalent to (but much faster than):\n *\n *     mat3.identity(dest);\n *     mat3.rotate(dest, dest, rad);\n *\n * @param {mat3} out mat3 receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat3} out\n */\nexport function fromRotation(out, rad) {\n  var s = Math.sin(rad),\n    c = Math.cos(rad);\n  out[0] = c;\n  out[1] = s;\n  out[2] = 0;\n  out[3] = -s;\n  out[4] = c;\n  out[5] = 0;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 1;\n  return out;\n}\n\n/**\n * Creates a matrix from a vector scaling\n * This is equivalent to (but much faster than):\n *\n *     mat3.identity(dest);\n *     mat3.scale(dest, dest, vec);\n *\n * @param {mat3} out mat3 receiving operation result\n * @param {ReadonlyVec2} v Scaling vector\n * @returns {mat3} out\n */\nexport function fromScaling(out, v) {\n  out[0] = v[0];\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = v[1];\n  out[5] = 0;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 1;\n  return out;\n}\n\n/**\n * Copies the values from a mat2d into a mat3\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat2d} a the matrix to copy\n * @returns {mat3} out\n **/\nexport function fromMat2d(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = 0;\n  out[3] = a[2];\n  out[4] = a[3];\n  out[5] = 0;\n  out[6] = a[4];\n  out[7] = a[5];\n  out[8] = 1;\n  return out;\n}\n\n/**\n * Calculates a 3x3 matrix from the given quaternion\n *\n * @param {mat3} out mat3 receiving operation result\n * @param {ReadonlyQuat} q Quaternion to create matrix from\n *\n * @returns {mat3} out\n */\nexport function fromQuat(out, q) {\n  var x = q[0],\n    y = q[1],\n    z = q[2],\n    w = q[3];\n  var x2 = x + x;\n  var y2 = y + y;\n  var z2 = z + z;\n  var xx = x * x2;\n  var yx = y * x2;\n  var yy = y * y2;\n  var zx = z * x2;\n  var zy = z * y2;\n  var zz = z * z2;\n  var wx = w * x2;\n  var wy = w * y2;\n  var wz = w * z2;\n  out[0] = 1 - yy - zz;\n  out[3] = yx - wz;\n  out[6] = zx + wy;\n  out[1] = yx + wz;\n  out[4] = 1 - xx - zz;\n  out[7] = zy - wx;\n  out[2] = zx - wy;\n  out[5] = zy + wx;\n  out[8] = 1 - xx - yy;\n  return out;\n}\n\n/**\n * Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix\n *\n * @param {mat3} out mat3 receiving operation result\n * @param {ReadonlyMat4} a Mat4 to derive the normal matrix from\n *\n * @returns {mat3} out\n */\nexport function normalFromMat4(out, a) {\n  var a00 = a[0],\n    a01 = a[1],\n    a02 = a[2],\n    a03 = a[3];\n  var a10 = a[4],\n    a11 = a[5],\n    a12 = a[6],\n    a13 = a[7];\n  var a20 = a[8],\n    a21 = a[9],\n    a22 = a[10],\n    a23 = a[11];\n  var a30 = a[12],\n    a31 = a[13],\n    a32 = a[14],\n    a33 = a[15];\n  var b00 = a00 * a11 - a01 * a10;\n  var b01 = a00 * a12 - a02 * a10;\n  var b02 = a00 * a13 - a03 * a10;\n  var b03 = a01 * a12 - a02 * a11;\n  var b04 = a01 * a13 - a03 * a11;\n  var b05 = a02 * a13 - a03 * a12;\n  var b06 = a20 * a31 - a21 * a30;\n  var b07 = a20 * a32 - a22 * a30;\n  var b08 = a20 * a33 - a23 * a30;\n  var b09 = a21 * a32 - a22 * a31;\n  var b10 = a21 * a33 - a23 * a31;\n  var b11 = a22 * a33 - a23 * a32;\n\n  // Calculate the determinant\n  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n  if (!det) {\n    return null;\n  }\n  det = 1.0 / det;\n  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;\n  out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;\n  out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;\n  out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;\n  out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;\n  out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;\n  out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;\n  out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;\n  out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;\n  return out;\n}\n\n/**\n * Generates a 2D projection matrix with the given bounds\n *\n * @param {mat3} out mat3 frustum matrix will be written into\n * @param {number} width Width of your gl context\n * @param {number} height Height of gl context\n * @returns {mat3} out\n */\nexport function projection(out, width, height) {\n  out[0] = 2 / width;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = -2 / height;\n  out[5] = 0;\n  out[6] = -1;\n  out[7] = 1;\n  out[8] = 1;\n  return out;\n}\n\n/**\n * Returns a string representation of a mat3\n *\n * @param {ReadonlyMat3} a matrix to represent as a string\n * @returns {String} string representation of the matrix\n */\nexport function str(a) {\n  return \"mat3(\" + a[0] + \", \" + a[1] + \", \" + a[2] + \", \" + a[3] + \", \" + a[4] + \", \" + a[5] + \", \" + a[6] + \", \" + a[7] + \", \" + a[8] + \")\";\n}\n\n/**\n * Returns Frobenius norm of a mat3\n *\n * @param {ReadonlyMat3} a the matrix to calculate Frobenius norm of\n * @returns {Number} Frobenius norm\n */\nexport function frob(a) {\n  return Math.sqrt(a[0] * a[0] + a[1] * a[1] + a[2] * a[2] + a[3] * a[3] + a[4] * a[4] + a[5] * a[5] + a[6] * a[6] + a[7] * a[7] + a[8] * a[8]);\n}\n\n/**\n * Adds two mat3's\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the first operand\n * @param {ReadonlyMat3} b the second operand\n * @returns {mat3} out\n */\nexport function add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  out[3] = a[3] + b[3];\n  out[4] = a[4] + b[4];\n  out[5] = a[5] + b[5];\n  out[6] = a[6] + b[6];\n  out[7] = a[7] + b[7];\n  out[8] = a[8] + b[8];\n  return out;\n}\n\n/**\n * Subtracts matrix b from matrix a\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the first operand\n * @param {ReadonlyMat3} b the second operand\n * @returns {mat3} out\n */\nexport function subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  out[3] = a[3] - b[3];\n  out[4] = a[4] - b[4];\n  out[5] = a[5] - b[5];\n  out[6] = a[6] - b[6];\n  out[7] = a[7] - b[7];\n  out[8] = a[8] - b[8];\n  return out;\n}\n\n/**\n * Multiply each element of the matrix by a scalar.\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the matrix to scale\n * @param {Number} b amount to scale the matrix's elements by\n * @returns {mat3} out\n */\nexport function multiplyScalar(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  out[3] = a[3] * b;\n  out[4] = a[4] * b;\n  out[5] = a[5] * b;\n  out[6] = a[6] * b;\n  out[7] = a[7] * b;\n  out[8] = a[8] * b;\n  return out;\n}\n\n/**\n * Adds two mat3's after multiplying each element of the second operand by a scalar value.\n *\n * @param {mat3} out the receiving vector\n * @param {ReadonlyMat3} a the first operand\n * @param {ReadonlyMat3} b the second operand\n * @param {Number} scale the amount to scale b's elements by before adding\n * @returns {mat3} out\n */\nexport function multiplyScalarAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  out[2] = a[2] + b[2] * scale;\n  out[3] = a[3] + b[3] * scale;\n  out[4] = a[4] + b[4] * scale;\n  out[5] = a[5] + b[5] * scale;\n  out[6] = a[6] + b[6] * scale;\n  out[7] = a[7] + b[7] * scale;\n  out[8] = a[8] + b[8] * scale;\n  return out;\n}\n\n/**\n * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)\n *\n * @param {ReadonlyMat3} a The first matrix.\n * @param {ReadonlyMat3} b The second matrix.\n * @returns {Boolean} True if the matrices are equal, false otherwise.\n */\nexport function exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8];\n}\n\n/**\n * Returns whether or not the matrices have approximately the same elements in the same position.\n *\n * @param {ReadonlyMat3} a The first matrix.\n * @param {ReadonlyMat3} b The second matrix.\n * @returns {Boolean} True if the matrices are equal, false otherwise.\n */\nexport function equals(a, b) {\n  var a0 = a[0],\n    a1 = a[1],\n    a2 = a[2],\n    a3 = a[3],\n    a4 = a[4],\n    a5 = a[5],\n    a6 = a[6],\n    a7 = a[7],\n    a8 = a[8];\n  var b0 = b[0],\n    b1 = b[1],\n    b2 = b[2],\n    b3 = b[3],\n    b4 = b[4],\n    b5 = b[5],\n    b6 = b[6],\n    b7 = b[7],\n    b8 = b[8];\n  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a8), Math.abs(b8));\n}\n\n/**\n * Alias for {@link mat3.multiply}\n * @function\n */\nexport var mul = multiply;\n\n/**\n * Alias for {@link mat3.subtract}\n * @function\n */\nexport var sub = subtract;", "import * as glMatrix from \"./common.js\";\n\n/**\n * 3 Dimensional Vector\n * @module vec3\n */\n\n/**\n * Creates a new, empty vec3\n *\n * @returns {vec3} a new 3D vector\n */\nexport function create() {\n  var out = new glMatrix.ARRAY_TYPE(3);\n  if (glMatrix.ARRAY_TYPE != Float32Array) {\n    out[0] = 0;\n    out[1] = 0;\n    out[2] = 0;\n  }\n  return out;\n}\n\n/**\n * Creates a new vec3 initialized with values from an existing vector\n *\n * @param {ReadonlyVec3} a vector to clone\n * @returns {vec3} a new 3D vector\n */\nexport function clone(a) {\n  var out = new glMatrix.ARRAY_TYPE(3);\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  return out;\n}\n\n/**\n * Calculates the length of a vec3\n *\n * @param {ReadonlyVec3} a vector to calculate length of\n * @returns {Number} length of a\n */\nexport function length(a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  return Math.sqrt(x * x + y * y + z * z);\n}\n\n/**\n * Creates a new vec3 initialized with the given values\n *\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @returns {vec3} a new 3D vector\n */\nexport function fromValues(x, y, z) {\n  var out = new glMatrix.ARRAY_TYPE(3);\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  return out;\n}\n\n/**\n * Copy the values from one vec3 to another\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the source vector\n * @returns {vec3} out\n */\nexport function copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  return out;\n}\n\n/**\n * Set the components of a vec3 to the given values\n *\n * @param {vec3} out the receiving vector\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @returns {vec3} out\n */\nexport function set(out, x, y, z) {\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  return out;\n}\n\n/**\n * Adds two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\nexport function add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  return out;\n}\n\n/**\n * Subtracts vector b from vector a\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\nexport function subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  return out;\n}\n\n/**\n * Multiplies two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\nexport function multiply(out, a, b) {\n  out[0] = a[0] * b[0];\n  out[1] = a[1] * b[1];\n  out[2] = a[2] * b[2];\n  return out;\n}\n\n/**\n * Divides two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\nexport function divide(out, a, b) {\n  out[0] = a[0] / b[0];\n  out[1] = a[1] / b[1];\n  out[2] = a[2] / b[2];\n  return out;\n}\n\n/**\n * Math.ceil the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to ceil\n * @returns {vec3} out\n */\nexport function ceil(out, a) {\n  out[0] = Math.ceil(a[0]);\n  out[1] = Math.ceil(a[1]);\n  out[2] = Math.ceil(a[2]);\n  return out;\n}\n\n/**\n * Math.floor the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to floor\n * @returns {vec3} out\n */\nexport function floor(out, a) {\n  out[0] = Math.floor(a[0]);\n  out[1] = Math.floor(a[1]);\n  out[2] = Math.floor(a[2]);\n  return out;\n}\n\n/**\n * Returns the minimum of two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\nexport function min(out, a, b) {\n  out[0] = Math.min(a[0], b[0]);\n  out[1] = Math.min(a[1], b[1]);\n  out[2] = Math.min(a[2], b[2]);\n  return out;\n}\n\n/**\n * Returns the maximum of two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\nexport function max(out, a, b) {\n  out[0] = Math.max(a[0], b[0]);\n  out[1] = Math.max(a[1], b[1]);\n  out[2] = Math.max(a[2], b[2]);\n  return out;\n}\n\n/**\n * symmetric round the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to round\n * @returns {vec3} out\n */\nexport function round(out, a) {\n  out[0] = glMatrix.round(a[0]);\n  out[1] = glMatrix.round(a[1]);\n  out[2] = glMatrix.round(a[2]);\n  return out;\n}\n\n/**\n * Scales a vec3 by a scalar number\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the vector to scale\n * @param {Number} b amount to scale the vector by\n * @returns {vec3} out\n */\nexport function scale(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  return out;\n}\n\n/**\n * Adds two vec3's after scaling the second operand by a scalar value\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @param {Number} scale the amount to scale b by before adding\n * @returns {vec3} out\n */\nexport function scaleAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  out[2] = a[2] + b[2] * scale;\n  return out;\n}\n\n/**\n * Calculates the euclidian distance between two vec3's\n *\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {Number} distance between a and b\n */\nexport function distance(a, b) {\n  var x = b[0] - a[0];\n  var y = b[1] - a[1];\n  var z = b[2] - a[2];\n  return Math.sqrt(x * x + y * y + z * z);\n}\n\n/**\n * Calculates the squared euclidian distance between two vec3's\n *\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {Number} squared distance between a and b\n */\nexport function squaredDistance(a, b) {\n  var x = b[0] - a[0];\n  var y = b[1] - a[1];\n  var z = b[2] - a[2];\n  return x * x + y * y + z * z;\n}\n\n/**\n * Calculates the squared length of a vec3\n *\n * @param {ReadonlyVec3} a vector to calculate squared length of\n * @returns {Number} squared length of a\n */\nexport function squaredLength(a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  return x * x + y * y + z * z;\n}\n\n/**\n * Negates the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to negate\n * @returns {vec3} out\n */\nexport function negate(out, a) {\n  out[0] = -a[0];\n  out[1] = -a[1];\n  out[2] = -a[2];\n  return out;\n}\n\n/**\n * Returns the inverse of the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to invert\n * @returns {vec3} out\n */\nexport function inverse(out, a) {\n  out[0] = 1.0 / a[0];\n  out[1] = 1.0 / a[1];\n  out[2] = 1.0 / a[2];\n  return out;\n}\n\n/**\n * Normalize a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to normalize\n * @returns {vec3} out\n */\nexport function normalize(out, a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  var len = x * x + y * y + z * z;\n  if (len > 0) {\n    //TODO: evaluate use of glm_invsqrt here?\n    len = 1 / Math.sqrt(len);\n  }\n  out[0] = a[0] * len;\n  out[1] = a[1] * len;\n  out[2] = a[2] * len;\n  return out;\n}\n\n/**\n * Calculates the dot product of two vec3's\n *\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {Number} dot product of a and b\n */\nexport function dot(a, b) {\n  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];\n}\n\n/**\n * Computes the cross product of two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\nexport function cross(out, a, b) {\n  var ax = a[0],\n    ay = a[1],\n    az = a[2];\n  var bx = b[0],\n    by = b[1],\n    bz = b[2];\n  out[0] = ay * bz - az * by;\n  out[1] = az * bx - ax * bz;\n  out[2] = ax * by - ay * bx;\n  return out;\n}\n\n/**\n * Performs a linear interpolation between two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {vec3} out\n */\nexport function lerp(out, a, b, t) {\n  var ax = a[0];\n  var ay = a[1];\n  var az = a[2];\n  out[0] = ax + t * (b[0] - ax);\n  out[1] = ay + t * (b[1] - ay);\n  out[2] = az + t * (b[2] - az);\n  return out;\n}\n\n/**\n * Performs a spherical linear interpolation between two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {vec3} out\n */\nexport function slerp(out, a, b, t) {\n  var angle = Math.acos(Math.min(Math.max(dot(a, b), -1), 1));\n  var sinTotal = Math.sin(angle);\n  var ratioA = Math.sin((1 - t) * angle) / sinTotal;\n  var ratioB = Math.sin(t * angle) / sinTotal;\n  out[0] = ratioA * a[0] + ratioB * b[0];\n  out[1] = ratioA * a[1] + ratioB * b[1];\n  out[2] = ratioA * a[2] + ratioB * b[2];\n  return out;\n}\n\n/**\n * Performs a hermite interpolation with two control points\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @param {ReadonlyVec3} c the third operand\n * @param {ReadonlyVec3} d the fourth operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {vec3} out\n */\nexport function hermite(out, a, b, c, d, t) {\n  var factorTimes2 = t * t;\n  var factor1 = factorTimes2 * (2 * t - 3) + 1;\n  var factor2 = factorTimes2 * (t - 2) + t;\n  var factor3 = factorTimes2 * (t - 1);\n  var factor4 = factorTimes2 * (3 - 2 * t);\n  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;\n  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;\n  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;\n  return out;\n}\n\n/**\n * Performs a bezier interpolation with two control points\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @param {ReadonlyVec3} c the third operand\n * @param {ReadonlyVec3} d the fourth operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {vec3} out\n */\nexport function bezier(out, a, b, c, d, t) {\n  var inverseFactor = 1 - t;\n  var inverseFactorTimesTwo = inverseFactor * inverseFactor;\n  var factorTimes2 = t * t;\n  var factor1 = inverseFactorTimesTwo * inverseFactor;\n  var factor2 = 3 * t * inverseFactorTimesTwo;\n  var factor3 = 3 * factorTimes2 * inverseFactor;\n  var factor4 = factorTimes2 * t;\n  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;\n  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;\n  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;\n  return out;\n}\n\n/**\n * Generates a random vector with the given scale\n *\n * @param {vec3} out the receiving vector\n * @param {Number} [scale] Length of the resulting vector. If omitted, a unit vector will be returned\n * @returns {vec3} out\n */\nexport function random(out, scale) {\n  scale = scale === undefined ? 1.0 : scale;\n  var r = glMatrix.RANDOM() * 2.0 * Math.PI;\n  var z = glMatrix.RANDOM() * 2.0 - 1.0;\n  var zScale = Math.sqrt(1.0 - z * z) * scale;\n  out[0] = Math.cos(r) * zScale;\n  out[1] = Math.sin(r) * zScale;\n  out[2] = z * scale;\n  return out;\n}\n\n/**\n * Transforms the vec3 with a mat4.\n * 4th vector component is implicitly '1'\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the vector to transform\n * @param {ReadonlyMat4} m matrix to transform with\n * @returns {vec3} out\n */\nexport function transformMat4(out, a, m) {\n  var x = a[0],\n    y = a[1],\n    z = a[2];\n  var w = m[3] * x + m[7] * y + m[11] * z + m[15];\n  w = w || 1.0;\n  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;\n  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;\n  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;\n  return out;\n}\n\n/**\n * Transforms the vec3 with a mat3.\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the vector to transform\n * @param {ReadonlyMat3} m the 3x3 matrix to transform with\n * @returns {vec3} out\n */\nexport function transformMat3(out, a, m) {\n  var x = a[0],\n    y = a[1],\n    z = a[2];\n  out[0] = x * m[0] + y * m[3] + z * m[6];\n  out[1] = x * m[1] + y * m[4] + z * m[7];\n  out[2] = x * m[2] + y * m[5] + z * m[8];\n  return out;\n}\n\n/**\n * Transforms the vec3 with a quat\n * Can also be used for dual quaternions. (Multiply it with the real part)\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the vector to transform\n * @param {ReadonlyQuat} q normalized quaternion to transform with\n * @returns {vec3} out\n */\nexport function transformQuat(out, a, q) {\n  // Fast Vector Rotation using Quaternions by Robert Eisele\n  // https://raw.org/proof/vector-rotation-using-quaternions/\n\n  var qx = q[0],\n    qy = q[1],\n    qz = q[2],\n    qw = q[3];\n  var vx = a[0],\n    vy = a[1],\n    vz = a[2];\n\n  // t = q x v\n  var tx = qy * vz - qz * vy;\n  var ty = qz * vx - qx * vz;\n  var tz = qx * vy - qy * vx;\n\n  // t = 2t\n  tx = tx + tx;\n  ty = ty + ty;\n  tz = tz + tz;\n\n  // v + w t + q x t\n  out[0] = vx + qw * tx + qy * tz - qz * ty;\n  out[1] = vy + qw * ty + qz * tx - qx * tz;\n  out[2] = vz + qw * tz + qx * ty - qy * tx;\n  return out;\n}\n\n/**\n * Rotate a 3D vector around the x-axis\n * @param {vec3} out The receiving vec3\n * @param {ReadonlyVec3} a The vec3 point to rotate\n * @param {ReadonlyVec3} b The origin of the rotation\n * @param {Number} rad The angle of rotation in radians\n * @returns {vec3} out\n */\nexport function rotateX(out, a, b, rad) {\n  var p = [],\n    r = [];\n  //Translate point to the origin\n  p[0] = a[0] - b[0];\n  p[1] = a[1] - b[1];\n  p[2] = a[2] - b[2];\n\n  //perform rotation\n  r[0] = p[0];\n  r[1] = p[1] * Math.cos(rad) - p[2] * Math.sin(rad);\n  r[2] = p[1] * Math.sin(rad) + p[2] * Math.cos(rad);\n\n  //translate to correct position\n  out[0] = r[0] + b[0];\n  out[1] = r[1] + b[1];\n  out[2] = r[2] + b[2];\n  return out;\n}\n\n/**\n * Rotate a 3D vector around the y-axis\n * @param {vec3} out The receiving vec3\n * @param {ReadonlyVec3} a The vec3 point to rotate\n * @param {ReadonlyVec3} b The origin of the rotation\n * @param {Number} rad The angle of rotation in radians\n * @returns {vec3} out\n */\nexport function rotateY(out, a, b, rad) {\n  var p = [],\n    r = [];\n  //Translate point to the origin\n  p[0] = a[0] - b[0];\n  p[1] = a[1] - b[1];\n  p[2] = a[2] - b[2];\n\n  //perform rotation\n  r[0] = p[2] * Math.sin(rad) + p[0] * Math.cos(rad);\n  r[1] = p[1];\n  r[2] = p[2] * Math.cos(rad) - p[0] * Math.sin(rad);\n\n  //translate to correct position\n  out[0] = r[0] + b[0];\n  out[1] = r[1] + b[1];\n  out[2] = r[2] + b[2];\n  return out;\n}\n\n/**\n * Rotate a 3D vector around the z-axis\n * @param {vec3} out The receiving vec3\n * @param {ReadonlyVec3} a The vec3 point to rotate\n * @param {ReadonlyVec3} b The origin of the rotation\n * @param {Number} rad The angle of rotation in radians\n * @returns {vec3} out\n */\nexport function rotateZ(out, a, b, rad) {\n  var p = [],\n    r = [];\n  //Translate point to the origin\n  p[0] = a[0] - b[0];\n  p[1] = a[1] - b[1];\n  p[2] = a[2] - b[2];\n\n  //perform rotation\n  r[0] = p[0] * Math.cos(rad) - p[1] * Math.sin(rad);\n  r[1] = p[0] * Math.sin(rad) + p[1] * Math.cos(rad);\n  r[2] = p[2];\n\n  //translate to correct position\n  out[0] = r[0] + b[0];\n  out[1] = r[1] + b[1];\n  out[2] = r[2] + b[2];\n  return out;\n}\n\n/**\n * Get the angle between two 3D vectors\n * @param {ReadonlyVec3} a The first operand\n * @param {ReadonlyVec3} b The second operand\n * @returns {Number} The angle in radians\n */\nexport function angle(a, b) {\n  var ax = a[0],\n    ay = a[1],\n    az = a[2],\n    bx = b[0],\n    by = b[1],\n    bz = b[2],\n    mag = Math.sqrt((ax * ax + ay * ay + az * az) * (bx * bx + by * by + bz * bz)),\n    cosine = mag && dot(a, b) / mag;\n  return Math.acos(Math.min(Math.max(cosine, -1), 1));\n}\n\n/**\n * Set the components of a vec3 to zero\n *\n * @param {vec3} out the receiving vector\n * @returns {vec3} out\n */\nexport function zero(out) {\n  out[0] = 0.0;\n  out[1] = 0.0;\n  out[2] = 0.0;\n  return out;\n}\n\n/**\n * Returns a string representation of a vector\n *\n * @param {ReadonlyVec3} a vector to represent as a string\n * @returns {String} string representation of the vector\n */\nexport function str(a) {\n  return \"vec3(\" + a[0] + \", \" + a[1] + \", \" + a[2] + \")\";\n}\n\n/**\n * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)\n *\n * @param {ReadonlyVec3} a The first vector.\n * @param {ReadonlyVec3} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\nexport function exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];\n}\n\n/**\n * Returns whether or not the vectors have approximately the same elements in the same position.\n *\n * @param {ReadonlyVec3} a The first vector.\n * @param {ReadonlyVec3} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\nexport function equals(a, b) {\n  var a0 = a[0],\n    a1 = a[1],\n    a2 = a[2];\n  var b0 = b[0],\n    b1 = b[1],\n    b2 = b[2];\n  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2));\n}\n\n/**\n * Alias for {@link vec3.subtract}\n * @function\n */\nexport var sub = subtract;\n\n/**\n * Alias for {@link vec3.multiply}\n * @function\n */\nexport var mul = multiply;\n\n/**\n * Alias for {@link vec3.divide}\n * @function\n */\nexport var div = divide;\n\n/**\n * Alias for {@link vec3.distance}\n * @function\n */\nexport var dist = distance;\n\n/**\n * Alias for {@link vec3.squaredDistance}\n * @function\n */\nexport var sqrDist = squaredDistance;\n\n/**\n * Alias for {@link vec3.length}\n * @function\n */\nexport var len = length;\n\n/**\n * Alias for {@link vec3.squaredLength}\n * @function\n */\nexport var sqrLen = squaredLength;\n\n/**\n * Perform some operation over an array of vec3s.\n *\n * @param {Array} a the array of vectors to iterate over\n * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed\n * @param {Number} offset Number of elements to skip at the beginning of the array\n * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array\n * @param {Function} fn Function to call for each vector in the array\n * @param {Object} [arg] additional argument to pass to fn\n * @returns {Array} a\n * @function\n */\nexport var forEach = function () {\n  var vec = create();\n  return function (a, stride, offset, count, fn, arg) {\n    var i, l;\n    if (!stride) {\n      stride = 3;\n    }\n    if (!offset) {\n      offset = 0;\n    }\n    if (count) {\n      l = Math.min(count * stride + offset, a.length);\n    } else {\n      l = a.length;\n    }\n    for (i = offset; i < l; i += stride) {\n      vec[0] = a[i];\n      vec[1] = a[i + 1];\n      vec[2] = a[i + 2];\n      fn(vec, vec, arg);\n      a[i] = vec[0];\n      a[i + 1] = vec[1];\n      a[i + 2] = vec[2];\n    }\n    return a;\n  };\n}();", "import * as glMatrix from \"./common.js\";\n\n/**\n * 4 Dimensional Vector\n * @module vec4\n */\n\n/**\n * Creates a new, empty vec4\n *\n * @returns {vec4} a new 4D vector\n */\nexport function create() {\n  var out = new glMatrix.ARRAY_TYPE(4);\n  if (glMatrix.ARRAY_TYPE != Float32Array) {\n    out[0] = 0;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n  }\n  return out;\n}\n\n/**\n * Creates a new vec4 initialized with values from an existing vector\n *\n * @param {ReadonlyVec4} a vector to clone\n * @returns {vec4} a new 4D vector\n */\nexport function clone(a) {\n  var out = new glMatrix.ARRAY_TYPE(4);\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  return out;\n}\n\n/**\n * Creates a new vec4 initialized with the given values\n *\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @param {Number} w W component\n * @returns {vec4} a new 4D vector\n */\nexport function fromValues(x, y, z, w) {\n  var out = new glMatrix.ARRAY_TYPE(4);\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  out[3] = w;\n  return out;\n}\n\n/**\n * Copy the values from one vec4 to another\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the source vector\n * @returns {vec4} out\n */\nexport function copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  return out;\n}\n\n/**\n * Set the components of a vec4 to the given values\n *\n * @param {vec4} out the receiving vector\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @param {Number} w W component\n * @returns {vec4} out\n */\nexport function set(out, x, y, z, w) {\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  out[3] = w;\n  return out;\n}\n\n/**\n * Adds two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {vec4} out\n */\nexport function add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  out[3] = a[3] + b[3];\n  return out;\n}\n\n/**\n * Subtracts vector b from vector a\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {vec4} out\n */\nexport function subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  out[3] = a[3] - b[3];\n  return out;\n}\n\n/**\n * Multiplies two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {vec4} out\n */\nexport function multiply(out, a, b) {\n  out[0] = a[0] * b[0];\n  out[1] = a[1] * b[1];\n  out[2] = a[2] * b[2];\n  out[3] = a[3] * b[3];\n  return out;\n}\n\n/**\n * Divides two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {vec4} out\n */\nexport function divide(out, a, b) {\n  out[0] = a[0] / b[0];\n  out[1] = a[1] / b[1];\n  out[2] = a[2] / b[2];\n  out[3] = a[3] / b[3];\n  return out;\n}\n\n/**\n * Math.ceil the components of a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a vector to ceil\n * @returns {vec4} out\n */\nexport function ceil(out, a) {\n  out[0] = Math.ceil(a[0]);\n  out[1] = Math.ceil(a[1]);\n  out[2] = Math.ceil(a[2]);\n  out[3] = Math.ceil(a[3]);\n  return out;\n}\n\n/**\n * Math.floor the components of a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a vector to floor\n * @returns {vec4} out\n */\nexport function floor(out, a) {\n  out[0] = Math.floor(a[0]);\n  out[1] = Math.floor(a[1]);\n  out[2] = Math.floor(a[2]);\n  out[3] = Math.floor(a[3]);\n  return out;\n}\n\n/**\n * Returns the minimum of two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {vec4} out\n */\nexport function min(out, a, b) {\n  out[0] = Math.min(a[0], b[0]);\n  out[1] = Math.min(a[1], b[1]);\n  out[2] = Math.min(a[2], b[2]);\n  out[3] = Math.min(a[3], b[3]);\n  return out;\n}\n\n/**\n * Returns the maximum of two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {vec4} out\n */\nexport function max(out, a, b) {\n  out[0] = Math.max(a[0], b[0]);\n  out[1] = Math.max(a[1], b[1]);\n  out[2] = Math.max(a[2], b[2]);\n  out[3] = Math.max(a[3], b[3]);\n  return out;\n}\n\n/**\n * symmetric round the components of a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a vector to round\n * @returns {vec4} out\n */\nexport function round(out, a) {\n  out[0] = glMatrix.round(a[0]);\n  out[1] = glMatrix.round(a[1]);\n  out[2] = glMatrix.round(a[2]);\n  out[3] = glMatrix.round(a[3]);\n  return out;\n}\n\n/**\n * Scales a vec4 by a scalar number\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the vector to scale\n * @param {Number} b amount to scale the vector by\n * @returns {vec4} out\n */\nexport function scale(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  out[3] = a[3] * b;\n  return out;\n}\n\n/**\n * Adds two vec4's after scaling the second operand by a scalar value\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @param {Number} scale the amount to scale b by before adding\n * @returns {vec4} out\n */\nexport function scaleAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  out[2] = a[2] + b[2] * scale;\n  out[3] = a[3] + b[3] * scale;\n  return out;\n}\n\n/**\n * Calculates the euclidian distance between two vec4's\n *\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {Number} distance between a and b\n */\nexport function distance(a, b) {\n  var x = b[0] - a[0];\n  var y = b[1] - a[1];\n  var z = b[2] - a[2];\n  var w = b[3] - a[3];\n  return Math.sqrt(x * x + y * y + z * z + w * w);\n}\n\n/**\n * Calculates the squared euclidian distance between two vec4's\n *\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {Number} squared distance between a and b\n */\nexport function squaredDistance(a, b) {\n  var x = b[0] - a[0];\n  var y = b[1] - a[1];\n  var z = b[2] - a[2];\n  var w = b[3] - a[3];\n  return x * x + y * y + z * z + w * w;\n}\n\n/**\n * Calculates the length of a vec4\n *\n * @param {ReadonlyVec4} a vector to calculate length of\n * @returns {Number} length of a\n */\nexport function length(a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  var w = a[3];\n  return Math.sqrt(x * x + y * y + z * z + w * w);\n}\n\n/**\n * Calculates the squared length of a vec4\n *\n * @param {ReadonlyVec4} a vector to calculate squared length of\n * @returns {Number} squared length of a\n */\nexport function squaredLength(a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  var w = a[3];\n  return x * x + y * y + z * z + w * w;\n}\n\n/**\n * Negates the components of a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a vector to negate\n * @returns {vec4} out\n */\nexport function negate(out, a) {\n  out[0] = -a[0];\n  out[1] = -a[1];\n  out[2] = -a[2];\n  out[3] = -a[3];\n  return out;\n}\n\n/**\n * Returns the inverse of the components of a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a vector to invert\n * @returns {vec4} out\n */\nexport function inverse(out, a) {\n  out[0] = 1.0 / a[0];\n  out[1] = 1.0 / a[1];\n  out[2] = 1.0 / a[2];\n  out[3] = 1.0 / a[3];\n  return out;\n}\n\n/**\n * Normalize a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a vector to normalize\n * @returns {vec4} out\n */\nexport function normalize(out, a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  var w = a[3];\n  var len = x * x + y * y + z * z + w * w;\n  if (len > 0) {\n    len = 1 / Math.sqrt(len);\n  }\n  out[0] = x * len;\n  out[1] = y * len;\n  out[2] = z * len;\n  out[3] = w * len;\n  return out;\n}\n\n/**\n * Calculates the dot product of two vec4's\n *\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @returns {Number} dot product of a and b\n */\nexport function dot(a, b) {\n  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];\n}\n\n/**\n * Returns the cross-product of three vectors in a 4-dimensional space\n *\n * @param {ReadonlyVec4} out the receiving vector\n * @param {ReadonlyVec4} u the first vector\n * @param {ReadonlyVec4} v the second vector\n * @param {ReadonlyVec4} w the third vector\n * @returns {vec4} result\n */\nexport function cross(out, u, v, w) {\n  var A = v[0] * w[1] - v[1] * w[0],\n    B = v[0] * w[2] - v[2] * w[0],\n    C = v[0] * w[3] - v[3] * w[0],\n    D = v[1] * w[2] - v[2] * w[1],\n    E = v[1] * w[3] - v[3] * w[1],\n    F = v[2] * w[3] - v[3] * w[2];\n  var G = u[0];\n  var H = u[1];\n  var I = u[2];\n  var J = u[3];\n  out[0] = H * F - I * E + J * D;\n  out[1] = -(G * F) + I * C - J * B;\n  out[2] = G * E - H * C + J * A;\n  out[3] = -(G * D) + H * B - I * A;\n  return out;\n}\n\n/**\n * Performs a linear interpolation between two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the first operand\n * @param {ReadonlyVec4} b the second operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {vec4} out\n */\nexport function lerp(out, a, b, t) {\n  var ax = a[0];\n  var ay = a[1];\n  var az = a[2];\n  var aw = a[3];\n  out[0] = ax + t * (b[0] - ax);\n  out[1] = ay + t * (b[1] - ay);\n  out[2] = az + t * (b[2] - az);\n  out[3] = aw + t * (b[3] - aw);\n  return out;\n}\n\n/**\n * Generates a random vector with the given scale\n *\n * @param {vec4} out the receiving vector\n * @param {Number} [scale] Length of the resulting vector. If omitted, a unit vector will be returned\n * @returns {vec4} out\n */\nexport function random(out, scale) {\n  scale = scale === undefined ? 1.0 : scale;\n\n  // Marsaglia, George. Choosing a Point from the Surface of a\n  // Sphere. Ann. Math. Statist. 43 (1972), no. 2, 645--646.\n  // http://projecteuclid.org/euclid.aoms/1177692644;\n  var v1, v2, v3, v4;\n  var s1, s2;\n  var rand;\n  rand = glMatrix.RANDOM();\n  v1 = rand * 2 - 1;\n  v2 = (4 * glMatrix.RANDOM() - 2) * Math.sqrt(rand * -rand + rand);\n  s1 = v1 * v1 + v2 * v2;\n  rand = glMatrix.RANDOM();\n  v3 = rand * 2 - 1;\n  v4 = (4 * glMatrix.RANDOM() - 2) * Math.sqrt(rand * -rand + rand);\n  s2 = v3 * v3 + v4 * v4;\n  var d = Math.sqrt((1 - s1) / s2);\n  out[0] = scale * v1;\n  out[1] = scale * v2;\n  out[2] = scale * v3 * d;\n  out[3] = scale * v4 * d;\n  return out;\n}\n\n/**\n * Transforms the vec4 with a mat4.\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the vector to transform\n * @param {ReadonlyMat4} m matrix to transform with\n * @returns {vec4} out\n */\nexport function transformMat4(out, a, m) {\n  var x = a[0],\n    y = a[1],\n    z = a[2],\n    w = a[3];\n  out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;\n  out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;\n  out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;\n  out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;\n  return out;\n}\n\n/**\n * Transforms the vec4 with a quat\n *\n * @param {vec4} out the receiving vector\n * @param {ReadonlyVec4} a the vector to transform\n * @param {ReadonlyQuat} q normalized quaternion to transform with\n * @returns {vec4} out\n */\nexport function transformQuat(out, a, q) {\n  // Fast Vector Rotation using Quaternions by Robert Eisele\n  // https://raw.org/proof/vector-rotation-using-quaternions/\n\n  var qx = q[0],\n    qy = q[1],\n    qz = q[2],\n    qw = q[3];\n  var vx = a[0],\n    vy = a[1],\n    vz = a[2];\n\n  // t = q x v\n  var tx = qy * vz - qz * vy;\n  var ty = qz * vx - qx * vz;\n  var tz = qx * vy - qy * vx;\n\n  // t = 2t\n  tx = tx + tx;\n  ty = ty + ty;\n  tz = tz + tz;\n\n  // v + w t + q x t\n  out[0] = vx + qw * tx + qy * tz - qz * ty;\n  out[1] = vy + qw * ty + qz * tx - qx * tz;\n  out[2] = vz + qw * tz + qx * ty - qy * tx;\n  out[3] = a[3];\n  return out;\n}\n\n/**\n * Set the components of a vec4 to zero\n *\n * @param {vec4} out the receiving vector\n * @returns {vec4} out\n */\nexport function zero(out) {\n  out[0] = 0.0;\n  out[1] = 0.0;\n  out[2] = 0.0;\n  out[3] = 0.0;\n  return out;\n}\n\n/**\n * Returns a string representation of a vector\n *\n * @param {ReadonlyVec4} a vector to represent as a string\n * @returns {String} string representation of the vector\n */\nexport function str(a) {\n  return \"vec4(\" + a[0] + \", \" + a[1] + \", \" + a[2] + \", \" + a[3] + \")\";\n}\n\n/**\n * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)\n *\n * @param {ReadonlyVec4} a The first vector.\n * @param {ReadonlyVec4} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\nexport function exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];\n}\n\n/**\n * Returns whether or not the vectors have approximately the same elements in the same position.\n *\n * @param {ReadonlyVec4} a The first vector.\n * @param {ReadonlyVec4} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\nexport function equals(a, b) {\n  var a0 = a[0],\n    a1 = a[1],\n    a2 = a[2],\n    a3 = a[3];\n  var b0 = b[0],\n    b1 = b[1],\n    b2 = b[2],\n    b3 = b[3];\n  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3));\n}\n\n/**\n * Alias for {@link vec4.subtract}\n * @function\n */\nexport var sub = subtract;\n\n/**\n * Alias for {@link vec4.multiply}\n * @function\n */\nexport var mul = multiply;\n\n/**\n * Alias for {@link vec4.divide}\n * @function\n */\nexport var div = divide;\n\n/**\n * Alias for {@link vec4.distance}\n * @function\n */\nexport var dist = distance;\n\n/**\n * Alias for {@link vec4.squaredDistance}\n * @function\n */\nexport var sqrDist = squaredDistance;\n\n/**\n * Alias for {@link vec4.length}\n * @function\n */\nexport var len = length;\n\n/**\n * Alias for {@link vec4.squaredLength}\n * @function\n */\nexport var sqrLen = squaredLength;\n\n/**\n * Perform some operation over an array of vec4s.\n *\n * @param {Array} a the array of vectors to iterate over\n * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed\n * @param {Number} offset Number of elements to skip at the beginning of the array\n * @param {Number} count Number of vec4s to iterate over. If 0 iterates over entire array\n * @param {Function} fn Function to call for each vector in the array\n * @param {Object} [arg] additional argument to pass to fn\n * @returns {Array} a\n * @function\n */\nexport var forEach = function () {\n  var vec = create();\n  return function (a, stride, offset, count, fn, arg) {\n    var i, l;\n    if (!stride) {\n      stride = 4;\n    }\n    if (!offset) {\n      offset = 0;\n    }\n    if (count) {\n      l = Math.min(count * stride + offset, a.length);\n    } else {\n      l = a.length;\n    }\n    for (i = offset; i < l; i += stride) {\n      vec[0] = a[i];\n      vec[1] = a[i + 1];\n      vec[2] = a[i + 2];\n      vec[3] = a[i + 3];\n      fn(vec, vec, arg);\n      a[i] = vec[0];\n      a[i + 1] = vec[1];\n      a[i + 2] = vec[2];\n      a[i + 3] = vec[3];\n    }\n    return a;\n  };\n}();", "import * as glMatrix from \"./common.js\";\nimport * as mat3 from \"./mat3.js\";\nimport * as vec3 from \"./vec3.js\";\nimport * as vec4 from \"./vec4.js\";\n\n/**\n * Quaternion in the format XYZW\n * @module quat\n */\n\n/**\n * Creates a new identity quat\n *\n * @returns {quat} a new quaternion\n */\nexport function create() {\n  var out = new glMatrix.ARRAY_TYPE(4);\n  if (glMatrix.ARRAY_TYPE != Float32Array) {\n    out[0] = 0;\n    out[1] = 0;\n    out[2] = 0;\n  }\n  out[3] = 1;\n  return out;\n}\n\n/**\n * Set a quat to the identity quaternion\n *\n * @param {quat} out the receiving quaternion\n * @returns {quat} out\n */\nexport function identity(out) {\n  out[0] = 0;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 1;\n  return out;\n}\n\n/**\n * Sets a quat from the given angle and rotation axis,\n * then returns it.\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyVec3} axis the axis around which to rotate\n * @param {Number} rad the angle in radians\n * @returns {quat} out\n **/\nexport function setAxisAngle(out, axis, rad) {\n  rad = rad * 0.5;\n  var s = Math.sin(rad);\n  out[0] = s * axis[0];\n  out[1] = s * axis[1];\n  out[2] = s * axis[2];\n  out[3] = Math.cos(rad);\n  return out;\n}\n\n/**\n * Gets the rotation axis and angle for a given\n *  quaternion. If a quaternion is created with\n *  setAxisAngle, this method will return the same\n *  values as providied in the original parameter list\n *  OR functionally equivalent values.\n * Example: The quaternion formed by axis [0, 0, 1] and\n *  angle -90 is the same as the quaternion formed by\n *  [0, 0, 1] and 270. This method favors the latter.\n * @param  {vec3} out_axis  Vector receiving the axis of rotation\n * @param  {ReadonlyQuat} q     Quaternion to be decomposed\n * @return {Number}     Angle, in radians, of the rotation\n */\nexport function getAxisAngle(out_axis, q) {\n  var rad = Math.acos(q[3]) * 2.0;\n  var s = Math.sin(rad / 2.0);\n  if (s > glMatrix.EPSILON) {\n    out_axis[0] = q[0] / s;\n    out_axis[1] = q[1] / s;\n    out_axis[2] = q[2] / s;\n  } else {\n    // If s is zero, return any axis (no rotation - axis does not matter)\n    out_axis[0] = 1;\n    out_axis[1] = 0;\n    out_axis[2] = 0;\n  }\n  return rad;\n}\n\n/**\n * Gets the angular distance between two unit quaternions\n *\n * @param  {ReadonlyQuat} a     Origin unit quaternion\n * @param  {ReadonlyQuat} b     Destination unit quaternion\n * @return {Number}     Angle, in radians, between the two quaternions\n */\nexport function getAngle(a, b) {\n  var dotproduct = dot(a, b);\n  return Math.acos(2 * dotproduct * dotproduct - 1);\n}\n\n/**\n * Multiplies two quat's\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a the first operand\n * @param {ReadonlyQuat} b the second operand\n * @returns {quat} out\n */\nexport function multiply(out, a, b) {\n  var ax = a[0],\n    ay = a[1],\n    az = a[2],\n    aw = a[3];\n  var bx = b[0],\n    by = b[1],\n    bz = b[2],\n    bw = b[3];\n  out[0] = ax * bw + aw * bx + ay * bz - az * by;\n  out[1] = ay * bw + aw * by + az * bx - ax * bz;\n  out[2] = az * bw + aw * bz + ax * by - ay * bx;\n  out[3] = aw * bw - ax * bx - ay * by - az * bz;\n  return out;\n}\n\n/**\n * Rotates a quaternion by the given angle about the X axis\n *\n * @param {quat} out quat receiving operation result\n * @param {ReadonlyQuat} a quat to rotate\n * @param {number} rad angle (in radians) to rotate\n * @returns {quat} out\n */\nexport function rotateX(out, a, rad) {\n  rad *= 0.5;\n  var ax = a[0],\n    ay = a[1],\n    az = a[2],\n    aw = a[3];\n  var bx = Math.sin(rad),\n    bw = Math.cos(rad);\n  out[0] = ax * bw + aw * bx;\n  out[1] = ay * bw + az * bx;\n  out[2] = az * bw - ay * bx;\n  out[3] = aw * bw - ax * bx;\n  return out;\n}\n\n/**\n * Rotates a quaternion by the given angle about the Y axis\n *\n * @param {quat} out quat receiving operation result\n * @param {ReadonlyQuat} a quat to rotate\n * @param {number} rad angle (in radians) to rotate\n * @returns {quat} out\n */\nexport function rotateY(out, a, rad) {\n  rad *= 0.5;\n  var ax = a[0],\n    ay = a[1],\n    az = a[2],\n    aw = a[3];\n  var by = Math.sin(rad),\n    bw = Math.cos(rad);\n  out[0] = ax * bw - az * by;\n  out[1] = ay * bw + aw * by;\n  out[2] = az * bw + ax * by;\n  out[3] = aw * bw - ay * by;\n  return out;\n}\n\n/**\n * Rotates a quaternion by the given angle about the Z axis\n *\n * @param {quat} out quat receiving operation result\n * @param {ReadonlyQuat} a quat to rotate\n * @param {number} rad angle (in radians) to rotate\n * @returns {quat} out\n */\nexport function rotateZ(out, a, rad) {\n  rad *= 0.5;\n  var ax = a[0],\n    ay = a[1],\n    az = a[2],\n    aw = a[3];\n  var bz = Math.sin(rad),\n    bw = Math.cos(rad);\n  out[0] = ax * bw + ay * bz;\n  out[1] = ay * bw - ax * bz;\n  out[2] = az * bw + aw * bz;\n  out[3] = aw * bw - az * bz;\n  return out;\n}\n\n/**\n * Calculates the W component of a quat from the X, Y, and Z components.\n * Assumes that quaternion is 1 unit in length.\n * Any existing W component will be ignored.\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a quat to calculate W component of\n * @returns {quat} out\n */\nexport function calculateW(out, a) {\n  var x = a[0],\n    y = a[1],\n    z = a[2];\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  out[3] = Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));\n  return out;\n}\n\n/**\n * Calculate the exponential of a unit quaternion.\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a quat to calculate the exponential of\n * @returns {quat} out\n */\nexport function exp(out, a) {\n  var x = a[0],\n    y = a[1],\n    z = a[2],\n    w = a[3];\n  var r = Math.sqrt(x * x + y * y + z * z);\n  var et = Math.exp(w);\n  var s = r > 0 ? et * Math.sin(r) / r : 0;\n  out[0] = x * s;\n  out[1] = y * s;\n  out[2] = z * s;\n  out[3] = et * Math.cos(r);\n  return out;\n}\n\n/**\n * Calculate the natural logarithm of a unit quaternion.\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a quat to calculate the exponential of\n * @returns {quat} out\n */\nexport function ln(out, a) {\n  var x = a[0],\n    y = a[1],\n    z = a[2],\n    w = a[3];\n  var r = Math.sqrt(x * x + y * y + z * z);\n  var t = r > 0 ? Math.atan2(r, w) / r : 0;\n  out[0] = x * t;\n  out[1] = y * t;\n  out[2] = z * t;\n  out[3] = 0.5 * Math.log(x * x + y * y + z * z + w * w);\n  return out;\n}\n\n/**\n * Calculate the scalar power of a unit quaternion.\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a quat to calculate the exponential of\n * @param {Number} b amount to scale the quaternion by\n * @returns {quat} out\n */\nexport function pow(out, a, b) {\n  ln(out, a);\n  scale(out, out, b);\n  exp(out, out);\n  return out;\n}\n\n/**\n * Performs a spherical linear interpolation between two quat\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a the first operand\n * @param {ReadonlyQuat} b the second operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {quat} out\n */\nexport function slerp(out, a, b, t) {\n  // benchmarks:\n  //    http://jsperf.com/quaternion-slerp-implementations\n  var ax = a[0],\n    ay = a[1],\n    az = a[2],\n    aw = a[3];\n  var bx = b[0],\n    by = b[1],\n    bz = b[2],\n    bw = b[3];\n  var omega, cosom, sinom, scale0, scale1;\n\n  // calc cosine\n  cosom = ax * bx + ay * by + az * bz + aw * bw;\n  // adjust signs (if necessary)\n  if (cosom < 0.0) {\n    cosom = -cosom;\n    bx = -bx;\n    by = -by;\n    bz = -bz;\n    bw = -bw;\n  }\n  // calculate coefficients\n  if (1.0 - cosom > glMatrix.EPSILON) {\n    // standard case (slerp)\n    omega = Math.acos(cosom);\n    sinom = Math.sin(omega);\n    scale0 = Math.sin((1.0 - t) * omega) / sinom;\n    scale1 = Math.sin(t * omega) / sinom;\n  } else {\n    // \"from\" and \"to\" quaternions are very close\n    //  ... so we can do a linear interpolation\n    scale0 = 1.0 - t;\n    scale1 = t;\n  }\n  // calculate final values\n  out[0] = scale0 * ax + scale1 * bx;\n  out[1] = scale0 * ay + scale1 * by;\n  out[2] = scale0 * az + scale1 * bz;\n  out[3] = scale0 * aw + scale1 * bw;\n  return out;\n}\n\n/**\n * Generates a random unit quaternion\n *\n * @param {quat} out the receiving quaternion\n * @returns {quat} out\n */\nexport function random(out) {\n  // Implementation of http://planning.cs.uiuc.edu/node198.html\n  // TODO: Calling random 3 times is probably not the fastest solution\n  var u1 = glMatrix.RANDOM();\n  var u2 = glMatrix.RANDOM();\n  var u3 = glMatrix.RANDOM();\n  var sqrt1MinusU1 = Math.sqrt(1 - u1);\n  var sqrtU1 = Math.sqrt(u1);\n  out[0] = sqrt1MinusU1 * Math.sin(2.0 * Math.PI * u2);\n  out[1] = sqrt1MinusU1 * Math.cos(2.0 * Math.PI * u2);\n  out[2] = sqrtU1 * Math.sin(2.0 * Math.PI * u3);\n  out[3] = sqrtU1 * Math.cos(2.0 * Math.PI * u3);\n  return out;\n}\n\n/**\n * Calculates the inverse of a quat\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a quat to calculate inverse of\n * @returns {quat} out\n */\nexport function invert(out, a) {\n  var a0 = a[0],\n    a1 = a[1],\n    a2 = a[2],\n    a3 = a[3];\n  var dot = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;\n  var invDot = dot ? 1.0 / dot : 0;\n\n  // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0\n\n  out[0] = -a0 * invDot;\n  out[1] = -a1 * invDot;\n  out[2] = -a2 * invDot;\n  out[3] = a3 * invDot;\n  return out;\n}\n\n/**\n * Calculates the conjugate of a quat\n * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a quat to calculate conjugate of\n * @returns {quat} out\n */\nexport function conjugate(out, a) {\n  out[0] = -a[0];\n  out[1] = -a[1];\n  out[2] = -a[2];\n  out[3] = a[3];\n  return out;\n}\n\n/**\n * Creates a quaternion from the given 3x3 rotation matrix.\n *\n * NOTE: The resultant quaternion is not normalized, so you should be sure\n * to renormalize the quaternion yourself where necessary.\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyMat3} m rotation matrix\n * @returns {quat} out\n * @function\n */\nexport function fromMat3(out, m) {\n  // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes\n  // article \"Quaternion Calculus and Fast Animation\".\n  var fTrace = m[0] + m[4] + m[8];\n  var fRoot;\n  if (fTrace > 0.0) {\n    // |w| > 1/2, may as well choose w > 1/2\n    fRoot = Math.sqrt(fTrace + 1.0); // 2w\n    out[3] = 0.5 * fRoot;\n    fRoot = 0.5 / fRoot; // 1/(4w)\n    out[0] = (m[5] - m[7]) * fRoot;\n    out[1] = (m[6] - m[2]) * fRoot;\n    out[2] = (m[1] - m[3]) * fRoot;\n  } else {\n    // |w| <= 1/2\n    var i = 0;\n    if (m[4] > m[0]) i = 1;\n    if (m[8] > m[i * 3 + i]) i = 2;\n    var j = (i + 1) % 3;\n    var k = (i + 2) % 3;\n    fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1.0);\n    out[i] = 0.5 * fRoot;\n    fRoot = 0.5 / fRoot;\n    out[3] = (m[j * 3 + k] - m[k * 3 + j]) * fRoot;\n    out[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;\n    out[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;\n  }\n  return out;\n}\n\n/**\n * Creates a quaternion from the given euler angle x, y, z using the provided intrinsic order for the conversion.\n *\n * @param {quat} out the receiving quaternion\n * @param {Number} x Angle to rotate around X axis in degrees.\n * @param {Number} y Angle to rotate around Y axis in degrees.\n * @param {Number} z Angle to rotate around Z axis in degrees.\n * @param {'xyz'|'xzy'|'yxz'|'yzx'|'zxy'|'zyx'} order Intrinsic order for conversion, default is zyx.\n * @returns {quat} out\n * @function\n */\nexport function fromEuler(out, x, y, z) {\n  var order = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : glMatrix.ANGLE_ORDER;\n  var halfToRad = Math.PI / 360;\n  x *= halfToRad;\n  z *= halfToRad;\n  y *= halfToRad;\n  var sx = Math.sin(x);\n  var cx = Math.cos(x);\n  var sy = Math.sin(y);\n  var cy = Math.cos(y);\n  var sz = Math.sin(z);\n  var cz = Math.cos(z);\n  switch (order) {\n    case \"xyz\":\n      out[0] = sx * cy * cz + cx * sy * sz;\n      out[1] = cx * sy * cz - sx * cy * sz;\n      out[2] = cx * cy * sz + sx * sy * cz;\n      out[3] = cx * cy * cz - sx * sy * sz;\n      break;\n    case \"xzy\":\n      out[0] = sx * cy * cz - cx * sy * sz;\n      out[1] = cx * sy * cz - sx * cy * sz;\n      out[2] = cx * cy * sz + sx * sy * cz;\n      out[3] = cx * cy * cz + sx * sy * sz;\n      break;\n    case \"yxz\":\n      out[0] = sx * cy * cz + cx * sy * sz;\n      out[1] = cx * sy * cz - sx * cy * sz;\n      out[2] = cx * cy * sz - sx * sy * cz;\n      out[3] = cx * cy * cz + sx * sy * sz;\n      break;\n    case \"yzx\":\n      out[0] = sx * cy * cz + cx * sy * sz;\n      out[1] = cx * sy * cz + sx * cy * sz;\n      out[2] = cx * cy * sz - sx * sy * cz;\n      out[3] = cx * cy * cz - sx * sy * sz;\n      break;\n    case \"zxy\":\n      out[0] = sx * cy * cz - cx * sy * sz;\n      out[1] = cx * sy * cz + sx * cy * sz;\n      out[2] = cx * cy * sz + sx * sy * cz;\n      out[3] = cx * cy * cz - sx * sy * sz;\n      break;\n    case \"zyx\":\n      out[0] = sx * cy * cz - cx * sy * sz;\n      out[1] = cx * sy * cz + sx * cy * sz;\n      out[2] = cx * cy * sz - sx * sy * cz;\n      out[3] = cx * cy * cz + sx * sy * sz;\n      break;\n    default:\n      throw new Error('Unknown angle order ' + order);\n  }\n  return out;\n}\n\n/**\n * Returns a string representation of a quaternion\n *\n * @param {ReadonlyQuat} a vector to represent as a string\n * @returns {String} string representation of the vector\n */\nexport function str(a) {\n  return \"quat(\" + a[0] + \", \" + a[1] + \", \" + a[2] + \", \" + a[3] + \")\";\n}\n\n/**\n * Creates a new quat initialized with values from an existing quaternion\n *\n * @param {ReadonlyQuat} a quaternion to clone\n * @returns {quat} a new quaternion\n * @function\n */\nexport var clone = vec4.clone;\n\n/**\n * Creates a new quat initialized with the given values\n *\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @param {Number} w W component\n * @returns {quat} a new quaternion\n * @function\n */\nexport var fromValues = vec4.fromValues;\n\n/**\n * Copy the values from one quat to another\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a the source quaternion\n * @returns {quat} out\n * @function\n */\nexport var copy = vec4.copy;\n\n/**\n * Set the components of a quat to the given values\n *\n * @param {quat} out the receiving quaternion\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @param {Number} w W component\n * @returns {quat} out\n * @function\n */\nexport var set = vec4.set;\n\n/**\n * Adds two quat's\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a the first operand\n * @param {ReadonlyQuat} b the second operand\n * @returns {quat} out\n * @function\n */\nexport var add = vec4.add;\n\n/**\n * Alias for {@link quat.multiply}\n * @function\n */\nexport var mul = multiply;\n\n/**\n * Scales a quat by a scalar number\n *\n * @param {quat} out the receiving vector\n * @param {ReadonlyQuat} a the vector to scale\n * @param {Number} b amount to scale the vector by\n * @returns {quat} out\n * @function\n */\nexport var scale = vec4.scale;\n\n/**\n * Calculates the dot product of two quat's\n *\n * @param {ReadonlyQuat} a the first operand\n * @param {ReadonlyQuat} b the second operand\n * @returns {Number} dot product of a and b\n * @function\n */\nexport var dot = vec4.dot;\n\n/**\n * Performs a linear interpolation between two quat's\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a the first operand\n * @param {ReadonlyQuat} b the second operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {quat} out\n * @function\n */\nexport var lerp = vec4.lerp;\n\n/**\n * Calculates the length of a quat\n *\n * @param {ReadonlyQuat} a vector to calculate length of\n * @returns {Number} length of a\n */\nexport var length = vec4.length;\n\n/**\n * Alias for {@link quat.length}\n * @function\n */\nexport var len = length;\n\n/**\n * Calculates the squared length of a quat\n *\n * @param {ReadonlyQuat} a vector to calculate squared length of\n * @returns {Number} squared length of a\n * @function\n */\nexport var squaredLength = vec4.squaredLength;\n\n/**\n * Alias for {@link quat.squaredLength}\n * @function\n */\nexport var sqrLen = squaredLength;\n\n/**\n * Normalize a quat\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a quaternion to normalize\n * @returns {quat} out\n * @function\n */\nexport var normalize = vec4.normalize;\n\n/**\n * Returns whether or not the quaternions have exactly the same elements in the same position (when compared with ===)\n *\n * @param {ReadonlyQuat} a The first quaternion.\n * @param {ReadonlyQuat} b The second quaternion.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\nexport var exactEquals = vec4.exactEquals;\n\n/**\n * Returns whether or not the quaternions point approximately to the same direction.\n *\n * Both quaternions are assumed to be unit length.\n *\n * @param {ReadonlyQuat} a The first unit quaternion.\n * @param {ReadonlyQuat} b The second unit quaternion.\n * @returns {Boolean} True if the quaternions are equal, false otherwise.\n */\nexport function equals(a, b) {\n  return Math.abs(vec4.dot(a, b)) >= 1 - glMatrix.EPSILON;\n}\n\n/**\n * Sets a quaternion to represent the shortest rotation from one\n * vector to another.\n *\n * Both vectors are assumed to be unit length.\n *\n * @param {quat} out the receiving quaternion.\n * @param {ReadonlyVec3} a the initial vector\n * @param {ReadonlyVec3} b the destination vector\n * @returns {quat} out\n */\nexport var rotationTo = function () {\n  var tmpvec3 = vec3.create();\n  var xUnitVec3 = vec3.fromValues(1, 0, 0);\n  var yUnitVec3 = vec3.fromValues(0, 1, 0);\n  return function (out, a, b) {\n    var dot = vec3.dot(a, b);\n    if (dot < -0.999999) {\n      vec3.cross(tmpvec3, xUnitVec3, a);\n      if (vec3.len(tmpvec3) < 0.000001) vec3.cross(tmpvec3, yUnitVec3, a);\n      vec3.normalize(tmpvec3, tmpvec3);\n      setAxisAngle(out, tmpvec3, Math.PI);\n      return out;\n    } else if (dot > 0.999999) {\n      out[0] = 0;\n      out[1] = 0;\n      out[2] = 0;\n      out[3] = 1;\n      return out;\n    } else {\n      vec3.cross(tmpvec3, a, b);\n      out[0] = tmpvec3[0];\n      out[1] = tmpvec3[1];\n      out[2] = tmpvec3[2];\n      out[3] = 1 + dot;\n      return normalize(out, out);\n    }\n  };\n}();\n\n/**\n * Performs a spherical linear interpolation with two control points\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a the first operand\n * @param {ReadonlyQuat} b the second operand\n * @param {ReadonlyQuat} c the third operand\n * @param {ReadonlyQuat} d the fourth operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {quat} out\n */\nexport var sqlerp = function () {\n  var temp1 = create();\n  var temp2 = create();\n  return function (out, a, b, c, d, t) {\n    slerp(temp1, a, d, t);\n    slerp(temp2, b, c, t);\n    slerp(out, temp1, temp2, 2 * t * (1 - t));\n    return out;\n  };\n}();\n\n/**\n * Sets the specified quaternion with values corresponding to the given\n * axes. Each axis is a vec3 and is expected to be unit length and\n * perpendicular to all other specified axes.\n *\n * @param {ReadonlyVec3} view  the vector representing the viewing direction\n * @param {ReadonlyVec3} right the vector representing the local \"right\" direction\n * @param {ReadonlyVec3} up    the vector representing the local \"up\" direction\n * @returns {quat} out\n */\nexport var setAxes = function () {\n  var matr = mat3.create();\n  return function (out, view, right, up) {\n    matr[0] = right[0];\n    matr[3] = right[1];\n    matr[6] = right[2];\n    matr[1] = up[0];\n    matr[4] = up[1];\n    matr[7] = up[2];\n    matr[2] = -view[0];\n    matr[5] = -view[1];\n    matr[8] = -view[2];\n    return normalize(out, fromMat3(out, matr));\n  };\n}();", "import * as glMatrix from \"./common.js\";\n\n/**\n * 2 Dimensional Vector\n * @module vec2\n */\n\n/**\n * Creates a new, empty vec2\n *\n * @returns {vec2} a new 2D vector\n */\nexport function create() {\n  var out = new glMatrix.ARRAY_TYPE(2);\n  if (glMatrix.ARRAY_TYPE != Float32Array) {\n    out[0] = 0;\n    out[1] = 0;\n  }\n  return out;\n}\n\n/**\n * Creates a new vec2 initialized with values from an existing vector\n *\n * @param {ReadonlyVec2} a vector to clone\n * @returns {vec2} a new 2D vector\n */\nexport function clone(a) {\n  var out = new glMatrix.ARRAY_TYPE(2);\n  out[0] = a[0];\n  out[1] = a[1];\n  return out;\n}\n\n/**\n * Creates a new vec2 initialized with the given values\n *\n * @param {Number} x X component\n * @param {Number} y Y component\n * @returns {vec2} a new 2D vector\n */\nexport function fromValues(x, y) {\n  var out = new glMatrix.ARRAY_TYPE(2);\n  out[0] = x;\n  out[1] = y;\n  return out;\n}\n\n/**\n * Copy the values from one vec2 to another\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the source vector\n * @returns {vec2} out\n */\nexport function copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  return out;\n}\n\n/**\n * Set the components of a vec2 to the given values\n *\n * @param {vec2} out the receiving vector\n * @param {Number} x X component\n * @param {Number} y Y component\n * @returns {vec2} out\n */\nexport function set(out, x, y) {\n  out[0] = x;\n  out[1] = y;\n  return out;\n}\n\n/**\n * Adds two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {vec2} out\n */\nexport function add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  return out;\n}\n\n/**\n * Subtracts vector b from vector a\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {vec2} out\n */\nexport function subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  return out;\n}\n\n/**\n * Multiplies two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {vec2} out\n */\nexport function multiply(out, a, b) {\n  out[0] = a[0] * b[0];\n  out[1] = a[1] * b[1];\n  return out;\n}\n\n/**\n * Divides two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {vec2} out\n */\nexport function divide(out, a, b) {\n  out[0] = a[0] / b[0];\n  out[1] = a[1] / b[1];\n  return out;\n}\n\n/**\n * Math.ceil the components of a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a vector to ceil\n * @returns {vec2} out\n */\nexport function ceil(out, a) {\n  out[0] = Math.ceil(a[0]);\n  out[1] = Math.ceil(a[1]);\n  return out;\n}\n\n/**\n * Math.floor the components of a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a vector to floor\n * @returns {vec2} out\n */\nexport function floor(out, a) {\n  out[0] = Math.floor(a[0]);\n  out[1] = Math.floor(a[1]);\n  return out;\n}\n\n/**\n * Returns the minimum of two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {vec2} out\n */\nexport function min(out, a, b) {\n  out[0] = Math.min(a[0], b[0]);\n  out[1] = Math.min(a[1], b[1]);\n  return out;\n}\n\n/**\n * Returns the maximum of two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {vec2} out\n */\nexport function max(out, a, b) {\n  out[0] = Math.max(a[0], b[0]);\n  out[1] = Math.max(a[1], b[1]);\n  return out;\n}\n\n/**\n * symmetric round the components of a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a vector to round\n * @returns {vec2} out\n */\nexport function round(out, a) {\n  out[0] = glMatrix.round(a[0]);\n  out[1] = glMatrix.round(a[1]);\n  return out;\n}\n\n/**\n * Scales a vec2 by a scalar number\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the vector to scale\n * @param {Number} b amount to scale the vector by\n * @returns {vec2} out\n */\nexport function scale(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  return out;\n}\n\n/**\n * Adds two vec2's after scaling the second operand by a scalar value\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @param {Number} scale the amount to scale b by before adding\n * @returns {vec2} out\n */\nexport function scaleAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  return out;\n}\n\n/**\n * Calculates the euclidian distance between two vec2's\n *\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {Number} distance between a and b\n */\nexport function distance(a, b) {\n  var x = b[0] - a[0],\n    y = b[1] - a[1];\n  return Math.sqrt(x * x + y * y);\n}\n\n/**\n * Calculates the squared euclidian distance between two vec2's\n *\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {Number} squared distance between a and b\n */\nexport function squaredDistance(a, b) {\n  var x = b[0] - a[0],\n    y = b[1] - a[1];\n  return x * x + y * y;\n}\n\n/**\n * Calculates the length of a vec2\n *\n * @param {ReadonlyVec2} a vector to calculate length of\n * @returns {Number} length of a\n */\nexport function length(a) {\n  var x = a[0],\n    y = a[1];\n  return Math.sqrt(x * x + y * y);\n}\n\n/**\n * Calculates the squared length of a vec2\n *\n * @param {ReadonlyVec2} a vector to calculate squared length of\n * @returns {Number} squared length of a\n */\nexport function squaredLength(a) {\n  var x = a[0],\n    y = a[1];\n  return x * x + y * y;\n}\n\n/**\n * Negates the components of a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a vector to negate\n * @returns {vec2} out\n */\nexport function negate(out, a) {\n  out[0] = -a[0];\n  out[1] = -a[1];\n  return out;\n}\n\n/**\n * Returns the inverse of the components of a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a vector to invert\n * @returns {vec2} out\n */\nexport function inverse(out, a) {\n  out[0] = 1.0 / a[0];\n  out[1] = 1.0 / a[1];\n  return out;\n}\n\n/**\n * Normalize a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a vector to normalize\n * @returns {vec2} out\n */\nexport function normalize(out, a) {\n  var x = a[0],\n    y = a[1];\n  var len = x * x + y * y;\n  if (len > 0) {\n    //TODO: evaluate use of glm_invsqrt here?\n    len = 1 / Math.sqrt(len);\n  }\n  out[0] = a[0] * len;\n  out[1] = a[1] * len;\n  return out;\n}\n\n/**\n * Calculates the dot product of two vec2's\n *\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {Number} dot product of a and b\n */\nexport function dot(a, b) {\n  return a[0] * b[0] + a[1] * b[1];\n}\n\n/**\n * Computes the cross product of two vec2's\n * Note that the cross product must by definition produce a 3D vector\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {vec3} out\n */\nexport function cross(out, a, b) {\n  var z = a[0] * b[1] - a[1] * b[0];\n  out[0] = out[1] = 0;\n  out[2] = z;\n  return out;\n}\n\n/**\n * Performs a linear interpolation between two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {vec2} out\n */\nexport function lerp(out, a, b, t) {\n  var ax = a[0],\n    ay = a[1];\n  out[0] = ax + t * (b[0] - ax);\n  out[1] = ay + t * (b[1] - ay);\n  return out;\n}\n\n/**\n * Generates a random vector with the given scale\n *\n * @param {vec2} out the receiving vector\n * @param {Number} [scale] Length of the resulting vector. If omitted, a unit vector will be returned\n * @returns {vec2} out\n */\nexport function random(out, scale) {\n  scale = scale === undefined ? 1.0 : scale;\n  var r = glMatrix.RANDOM() * 2.0 * Math.PI;\n  out[0] = Math.cos(r) * scale;\n  out[1] = Math.sin(r) * scale;\n  return out;\n}\n\n/**\n * Transforms the vec2 with a mat2\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the vector to transform\n * @param {ReadonlyMat2} m matrix to transform with\n * @returns {vec2} out\n */\nexport function transformMat2(out, a, m) {\n  var x = a[0],\n    y = a[1];\n  out[0] = m[0] * x + m[2] * y;\n  out[1] = m[1] * x + m[3] * y;\n  return out;\n}\n\n/**\n * Transforms the vec2 with a mat2d\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the vector to transform\n * @param {ReadonlyMat2d} m matrix to transform with\n * @returns {vec2} out\n */\nexport function transformMat2d(out, a, m) {\n  var x = a[0],\n    y = a[1];\n  out[0] = m[0] * x + m[2] * y + m[4];\n  out[1] = m[1] * x + m[3] * y + m[5];\n  return out;\n}\n\n/**\n * Transforms the vec2 with a mat3\n * 3rd vector component is implicitly '1'\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the vector to transform\n * @param {ReadonlyMat3} m matrix to transform with\n * @returns {vec2} out\n */\nexport function transformMat3(out, a, m) {\n  var x = a[0],\n    y = a[1];\n  out[0] = m[0] * x + m[3] * y + m[6];\n  out[1] = m[1] * x + m[4] * y + m[7];\n  return out;\n}\n\n/**\n * Transforms the vec2 with a mat4\n * 3rd vector component is implicitly '0'\n * 4th vector component is implicitly '1'\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the vector to transform\n * @param {ReadonlyMat4} m matrix to transform with\n * @returns {vec2} out\n */\nexport function transformMat4(out, a, m) {\n  var x = a[0];\n  var y = a[1];\n  out[0] = m[0] * x + m[4] * y + m[12];\n  out[1] = m[1] * x + m[5] * y + m[13];\n  return out;\n}\n\n/**\n * Rotate a 2D vector\n * @param {vec2} out The receiving vec2\n * @param {ReadonlyVec2} a The vec2 point to rotate\n * @param {ReadonlyVec2} b The origin of the rotation\n * @param {Number} rad The angle of rotation in radians\n * @returns {vec2} out\n */\nexport function rotate(out, a, b, rad) {\n  //Translate point to the origin\n  var p0 = a[0] - b[0],\n    p1 = a[1] - b[1],\n    sinC = Math.sin(rad),\n    cosC = Math.cos(rad);\n\n  //perform rotation and translate to correct position\n  out[0] = p0 * cosC - p1 * sinC + b[0];\n  out[1] = p0 * sinC + p1 * cosC + b[1];\n  return out;\n}\n\n/**\n * Get the smallest angle between two 2D vectors\n * @param {ReadonlyVec2} a The first operand\n * @param {ReadonlyVec2} b The second operand\n * @returns {Number} The angle in radians\n */\nexport function angle(a, b) {\n  var ax = a[0],\n    ay = a[1],\n    bx = b[0],\n    by = b[1];\n  return Math.abs(Math.atan2(ay * bx - ax * by, ax * bx + ay * by));\n}\n\n/**\n * Get the signed angle in the interval [-pi,pi] between two 2D vectors (positive if `a` is to the right of `b`)\n * \n * @param {ReadonlyVec2} a The first vector\n * @param {ReadonlyVec2} b The second vector\n * @returns {number} The signed angle in radians\n */\nexport function signedAngle(a, b) {\n  var ax = a[0],\n    ay = a[1],\n    bx = b[0],\n    by = b[1];\n  return Math.atan2(ax * by - ay * bx, ax * bx + ay * by);\n}\n\n/**\n * Set the components of a vec2 to zero\n *\n * @param {vec2} out the receiving vector\n * @returns {vec2} out\n */\nexport function zero(out) {\n  out[0] = 0.0;\n  out[1] = 0.0;\n  return out;\n}\n\n/**\n * Returns a string representation of a vector\n *\n * @param {ReadonlyVec2} a vector to represent as a string\n * @returns {String} string representation of the vector\n */\nexport function str(a) {\n  return \"vec2(\" + a[0] + \", \" + a[1] + \")\";\n}\n\n/**\n * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)\n *\n * @param {ReadonlyVec2} a The first vector.\n * @param {ReadonlyVec2} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\nexport function exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1];\n}\n\n/**\n * Returns whether or not the vectors have approximately the same elements in the same position.\n *\n * @param {ReadonlyVec2} a The first vector.\n * @param {ReadonlyVec2} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\nexport function equals(a, b) {\n  var a0 = a[0],\n    a1 = a[1];\n  var b0 = b[0],\n    b1 = b[1];\n  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1));\n}\n\n/**\n * Alias for {@link vec2.length}\n * @function\n */\nexport var len = length;\n\n/**\n * Alias for {@link vec2.subtract}\n * @function\n */\nexport var sub = subtract;\n\n/**\n * Alias for {@link vec2.multiply}\n * @function\n */\nexport var mul = multiply;\n\n/**\n * Alias for {@link vec2.divide}\n * @function\n */\nexport var div = divide;\n\n/**\n * Alias for {@link vec2.distance}\n * @function\n */\nexport var dist = distance;\n\n/**\n * Alias for {@link vec2.squaredDistance}\n * @function\n */\nexport var sqrDist = squaredDistance;\n\n/**\n * Alias for {@link vec2.squaredLength}\n * @function\n */\nexport var sqrLen = squaredLength;\n\n/**\n * Perform some operation over an array of vec2s.\n *\n * @param {Array} a the array of vectors to iterate over\n * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed\n * @param {Number} offset Number of elements to skip at the beginning of the array\n * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array\n * @param {Function} fn Function to call for each vector in the array\n * @param {Object} [arg] additional argument to pass to fn\n * @returns {Array} a\n * @function\n */\nexport var forEach = function () {\n  var vec = create();\n  return function (a, stride, offset, count, fn, arg) {\n    var i, l;\n    if (!stride) {\n      stride = 2;\n    }\n    if (!offset) {\n      offset = 0;\n    }\n    if (count) {\n      l = Math.min(count * stride + offset, a.length);\n    } else {\n      l = a.length;\n    }\n    for (i = offset; i < l; i += stride) {\n      vec[0] = a[i];\n      vec[1] = a[i + 1];\n      fn(vec, vec, arg);\n      a[i] = vec[0];\n      a[i + 1] = vec[1];\n    }\n    return a;\n  };\n}();", null, "\nimport ECS from 'ent-comp'\nimport vec3 from 'gl-vec3'\nimport { updatePositionExtents } from '../components/position'\nimport { setPhysicsFromPosition } from '../components/physics'\n\n\n// Component definitions\nimport collideEntitiesComp from \"../components/collideEntities.js\"\nimport collideTerrainComp from \"../components/collideTerrain.js\"\nimport fadeOnZoomComp from \"../components/fadeOnZoom.js\"\nimport followsEntityComp from \"../components/followsEntity.js\"\nimport meshComp from \"../components/mesh.js\"\nimport movementComp from \"../components/movement.js\"\nimport physicsComp from \"../components/physics.js\"\nimport positionComp from \"../components/position.js\"\nimport receivesInputsComp from \"../components/receivesInputs.js\"\nimport shadowComp from \"../components/shadow.js\"\nimport smoothCameraComp from \"../components/smoothCamera.js\"\n\n\n\nvar defaultOptions = {\n    shadowDistance: 10,\n}\n\n\n/**\n * `noa.entities` - manages entities and components.\n * \n * This class extends [ent-comp](https://github.com/fenomas/ent-comp), \n * a general-purpose ECS. It's also decorated with noa-specific helpers and \n * accessor functions for querying entity positions, etc.\n * \n * Expects entity definitions in a specific format - see source `components` \n * folder for examples.\n * \n * This module uses the following default options (from the options\n * object passed to the {@link Engine}):\n * \n * ```js\n * var defaults = {\n *     shadowDistance: 10,\n * }\n * ```\n*/\n\nexport class Entities extends ECS {\n\n\n    /** @internal */\n    constructor(noa, opts) {\n        super()\n        opts = Object.assign({}, defaultOptions, opts)\n        // optional arguments to supply to component creation functions\n        var componentArgs = {\n            'shadow': opts.shadowDistance,\n        }\n\n        /** \n         * @internal\n         * @type {import('../index').Engine}\n        */\n        this.noa = noa\n\n        /** Hash containing the component names of built-in components.\n         * @type {{ [key:string]: string }} \n        */\n        this.names = {}\n\n\n        // call `createComponent` on all component definitions, and\n        // store their names in ents.names\n        var compDefs = {\n            collideEntities: collideEntitiesComp,\n            collideTerrain: collideTerrainComp,\n            fadeOnZoom: fadeOnZoomComp,\n            followsEntity: followsEntityComp,\n            mesh: meshComp,\n            movement: movementComp,\n            physics: physicsComp,\n            position: positionComp,\n            receivesInputs: receivesInputsComp,\n            shadow: shadowComp,\n            smoothCamera: smoothCameraComp,\n        }\n\n        Object.keys(compDefs).forEach(bareName => {\n            var arg = componentArgs[bareName] || undefined\n            var compFn = compDefs[bareName]\n            var compDef = compFn(noa, arg)\n            this.names[bareName] = this.createComponent(compDef)\n        })\n\n\n\n        /*\n         *\n         *\n         * \n         *          ENTITY ACCESSORS\n         *\n         * A whole bunch of getters and such for accessing component state.\n         * These are moderately faster than `ents.getState(whatever)`.\n         * \n         * \n         * \n        */\n\n        /** @internal */\n        this.cameraSmoothed = this.getComponentAccessor(this.names.smoothCamera)\n\n\n        /**\n         * Returns whether the entity has a physics body\n         * @type {(id:number) => boolean}\n        */\n        this.hasPhysics = this.getComponentAccessor(this.names.physics)\n\n        /**\n         * Returns whether the entity has a position\n         * @type {(id:number) => boolean}\n        */\n        this.hasPosition = this.getComponentAccessor(this.names.position)\n\n        /**\n         * Returns the entity's position component state\n         * @type {(id:number) => null | import(\"../components/position\").PositionState} \n        */\n        this.getPositionData = this.getStateAccessor(this.names.position)\n\n        /**\n         * Returns the entity's position vector.\n         * @type {(id:number) => number[]}\n        */\n        this.getPosition = (id) => {\n            var state = this.getPositionData(id)\n            return (state) ? state.position : null\n        }\n\n        /**\n         * Get the entity's `physics` component state.\n         * @type {(id:number) => null | import(\"../components/physics\").PhysicsState} \n        */\n        this.getPhysics = this.getStateAccessor(this.names.physics)\n\n        /**\n         * Returns the entity's physics body\n         * Note, will throw if the entity doesn't have the position component!\n         * @type {(id:number) => null | import(\"voxel-physics-engine\").RigidBody} \n        */\n        this.getPhysicsBody = (id) => {\n            var state = this.getPhysics(id)\n            return (state) ? state.body : null\n        }\n\n        /**\n         * Returns whether the entity has a mesh\n         * @type {(id:number) => boolean}\n        */\n        this.hasMesh = this.getComponentAccessor(this.names.mesh)\n\n        /**\n         * Returns the entity's `mesh` component state\n         * @type {(id:number) => {mesh:any, offset:number[]}}\n        */\n        this.getMeshData = this.getStateAccessor(this.names.mesh)\n\n        /**\n         * Returns the entity's `movement` component state\n         * @type {(id:number) => import('../components/movement').MovementState}\n        */\n        this.getMovement = this.getStateAccessor(this.names.movement)\n\n        /**\n         * Returns the entity's `collideTerrain` component state\n         * @type {(id:number) => {callback: function}}\n        */\n        this.getCollideTerrain = this.getStateAccessor(this.names.collideTerrain)\n\n        /**\n         * Returns the entity's `collideEntities` component state\n         * @type {(id:number) => {\n         *      cylinder:boolean, collideBits:number, \n         *      collideMask:number, callback: function}}\n        */\n        this.getCollideEntities = this.getStateAccessor(this.names.collideEntities)\n\n\n        /**\n         * Pairwise collideEntities event - assign your own function to this \n         * property if you want to handle entity-entity overlap events.\n         * @type {(id1:number, id2:number) => void}\n         */\n        this.onPairwiseEntityCollision = function (id1, id2) { }\n    }\n\n\n\n\n    /*\n     * \n     * \n     *      PUBLIC ENTITY STATE ACCESSORS\n     * \n     * \n    */\n\n\n    /** Set an entity's position, and update all derived state.\n     * \n     * In general, always use this to set an entity's position unless\n     * you're familiar with engine internals.\n     * \n     * ```js\n     * noa.ents.setPosition(playerEntity, [5, 6, 7])\n     * noa.ents.setPosition(playerEntity, 5, 6, 7)  // also works\n     * ```\n     * \n     * @param {number} id\n     */\n    setPosition(id, pos, y = 0, z = 0) {\n        if (typeof pos === 'number') pos = [pos, y, z]\n        // convert to local and defer impl\n        var loc = this.noa.globalToLocal(pos, null, [])\n        this._localSetPosition(id, loc)\n    }\n\n    /** Set an entity's size \n     * @param {number} xs\n     * @param {number} ys\n     * @param {number} zs\n    */\n    setEntitySize(id, xs, ys, zs) {\n        var posDat = this.getPositionData(id)\n        posDat.width = (xs + zs) / 2\n        posDat.height = ys\n        this._updateDerivedPositionData(id, posDat)\n    }\n\n\n\n\n    /**\n     * called when engine rebases its local coords\n     * @internal\n     */\n    _rebaseOrigin(delta) {\n        for (var state of this.getStatesList(this.names.position)) {\n            var locPos = state._localPosition\n            var hw = state.width / 2\n            nudgePosition(locPos, 0, -hw, hw, state.__id)\n            nudgePosition(locPos, 1, 0, state.height, state.__id)\n            nudgePosition(locPos, 2, -hw, hw, state.__id)\n            vec3.subtract(locPos, locPos, delta)\n            this._updateDerivedPositionData(state.__id, state)\n        }\n    }\n\n    /** @internal */\n    _localGetPosition(id) {\n        return this.getPositionData(id)._localPosition\n    }\n\n    /** @internal */\n    _localSetPosition(id, pos) {\n        var posDat = this.getPositionData(id)\n        vec3.copy(posDat._localPosition, pos)\n        this._updateDerivedPositionData(id, posDat)\n    }\n\n\n    /** \n     * helper to update everything derived from `_localPosition`\n     * @internal \n    */\n    _updateDerivedPositionData(id, posDat) {\n        vec3.copy(posDat._renderPosition, posDat._localPosition)\n        var offset = this.noa.worldOriginOffset\n        vec3.add(posDat.position, posDat._localPosition, offset)\n        updatePositionExtents(posDat)\n        var physDat = this.getPhysics(id)\n        if (physDat) setPhysicsFromPosition(physDat, posDat)\n    }\n\n\n\n\n\n    /*\n     *\n     *\n     *      OTHER ENTITY MANAGEMENT APIs\n     * \n     *      note most APIs are on the original ECS module (ent-comp)\n     *      these are some overlaid extras for noa\n     *\n     *\n    */\n\n\n    /** \n     * Safely add a component - if the entity already had the \n     * component, this will remove and re-add it.\n    */\n    addComponentAgain(id, name, state) {\n        // removes component first if necessary\n        if (this.hasComponent(id, name)) this.removeComponent(id, name)\n        this.addComponent(id, name, state)\n    }\n\n\n    /** \n     * Checks whether a voxel is obstructed by any entity (with the \n     * `collidesTerrain` component)\n    */\n    isTerrainBlocked(x, y, z) {\n        // checks if terrain location is blocked by entities\n        var off = this.noa.worldOriginOffset\n        var xlocal = Math.floor(x - off[0])\n        var ylocal = Math.floor(y - off[1])\n        var zlocal = Math.floor(z - off[2])\n        var blockExt = [\n            xlocal + 0.001, ylocal + 0.001, zlocal + 0.001,\n            xlocal + 0.999, ylocal + 0.999, zlocal + 0.999,\n        ]\n        var list = this.getStatesList(this.names.collideTerrain)\n        for (var i = 0; i < list.length; i++) {\n            var id = list[i].__id\n            var ext = this.getPositionData(id)._extents\n            if (extentsOverlap(blockExt, ext)) return true\n        }\n        return false\n    }\n\n\n\n    /** \n     * Gets an array of all entities overlapping the given AABB\n    */\n    getEntitiesInAABB(box, withComponent) {\n        // extents to test against\n        var off = this.noa.worldOriginOffset\n        var testExtents = [\n            box.base[0] - off[0], box.base[1] - off[1], box.base[2] - off[2],\n            box.max[0] - off[0], box.max[1] - off[1], box.max[2] - off[2],\n        ]\n        // entity position state list\n        var entStates\n        if (withComponent) {\n            entStates = []\n            for (var compState of this.getStatesList(withComponent)) {\n                var pdat = this.getPositionData(compState.__id)\n                if (pdat) entStates.push(pdat)\n            }\n        } else {\n            entStates = this.getStatesList(this.names.position)\n        }\n\n        // run each test\n        var hits = []\n        for (var i = 0; i < entStates.length; i++) {\n            var state = entStates[i]\n            if (extentsOverlap(testExtents, state._extents)) {\n                hits.push(state.__id)\n            }\n        }\n        return hits\n    }\n\n\n\n    /** \n     * Helper to set up a general entity, and populate with some common components depending on arguments.\n    */\n    add(position = null, width = 1, height = 1,\n        mesh = null, meshOffset = null, doPhysics = false, shadow = false) {\n\n        var self = this\n\n        // new entity\n        var eid = this.createEntity()\n\n        // position component\n        this.addComponent(eid, this.names.position, {\n            position: position || vec3.create(),\n            width: width,\n            height: height,\n        })\n\n        // rigid body in physics simulator\n        if (doPhysics) {\n            // body = this.noa.physics.addBody(box)\n            this.addComponent(eid, this.names.physics)\n            var body = this.getPhysics(eid).body\n\n            // handler for physics engine to call on auto-step\n            var smoothName = this.names.smoothCamera\n            body.onStep = function () {\n                self.addComponentAgain(eid, smoothName)\n            }\n        }\n\n        // mesh for the entity\n        if (mesh) {\n            if (!meshOffset) meshOffset = vec3.create()\n            this.addComponent(eid, this.names.mesh, {\n                mesh: mesh,\n                offset: meshOffset\n            })\n        }\n\n        // add shadow-drawing component\n        if (shadow) {\n            this.addComponent(eid, this.names.shadow, { size: width })\n        }\n\n        return eid\n    }\n}\n\n\n/*\n * \n * \n * \n *          HELPERS\n * \n * \n * \n*/\n\n// safety helper - when rebasing, nudge extent away from \n// voxel boudaries, so floating point error doesn't carry us accross\nfunction nudgePosition(pos, index, dmin, dmax, id) {\n    var min = pos[index] + dmin\n    var max = pos[index] + dmax\n    if (Math.abs(min - Math.round(min)) < 0.002) pos[index] += 0.002\n    if (Math.abs(max - Math.round(max)) < 0.001) pos[index] -= 0.001\n}\n\n// compare extent arrays\nfunction extentsOverlap(extA, extB) {\n    if (extA[0] > extB[3]) return false\n    if (extA[1] > extB[4]) return false\n    if (extA[2] > extB[5]) return false\n    if (extA[3] < extB[0]) return false\n    if (extA[4] < extB[1]) return false\n    if (extA[5] < extB[2]) return false\n    return true\n}\n\n", "/** \n * @module \n * @internal \n */\n\nimport vec3 from 'gl-vec3'\n\n\n\n// definition for this component's state object\nexport class PositionState {\n    constructor() {\n        /** Position in global coords (may be low precision) \n         * @type {null | number[]} */\n        this.position = null\n        this.width = 0.8\n        this.height = 0.8\n\n        /** Precise position in local coords\n         * @type {null | number[]} */\n        this._localPosition = null\n\n        /** [x,y,z] in LOCAL COORDS\n         * @type {null | number[]} */\n        this._renderPosition = null\n\n        /** [lo,lo,lo, hi,hi,hi] in LOCAL COORDS\n         * @type {null | number[]} */\n        this._extents = null\n    }\n}\n\n\n\n\n/**\n * \tComponent holding entity's position, width, and height.\n *  By convention, entity's \"position\" is the bottom center of its AABB\n * \n *  Of the various properties, _localPosition is the \"real\", \n *  single-source-of-truth position. Others are derived.\n *  Local coords are relative to `noa.worldOriginOffset`.\n * @param {import('..').Engine} noa\n*/\n\nexport default function (noa) {\n\n    return {\n\n        name: 'position',\n\n        order: 60,\n\n        state: new PositionState,\n\n        onAdd: function (eid, state) {\n            // copy position into a plain array\n            var pos = [0, 0, 0]\n            if (state.position) vec3.copy(pos, state.position)\n            state.position = pos\n\n            state._localPosition = vec3.create()\n            state._renderPosition = vec3.create()\n            state._extents = new Float32Array(6)\n\n            // on init only, set local from global\n            noa.globalToLocal(state.position, null, state._localPosition)\n            vec3.copy(state._renderPosition, state._localPosition)\n            updatePositionExtents(state)\n        },\n\n        onRemove: null,\n\n\n\n        system: function (dt, states) {\n            var off = noa.worldOriginOffset\n            for (var i = 0; i < states.length; i++) {\n                var state = states[i]\n                vec3.add(state.position, state._localPosition, off)\n                updatePositionExtents(state)\n            }\n        },\n\n\n    }\n}\n\n\n\n// update an entity's position state `_extents` \nexport function updatePositionExtents(state) {\n    var hw = state.width / 2\n    var lpos = state._localPosition\n    var ext = state._extents\n    ext[0] = lpos[0] - hw\n    ext[1] = lpos[1]\n    ext[2] = lpos[2] - hw\n    ext[3] = lpos[0] + hw\n    ext[4] = lpos[1] + state.height\n    ext[5] = lpos[2] + hw\n}\n", "/** \n * @module\n * @internal\n */\n\nimport vec3 from 'gl-vec3'\n\n\nexport class PhysicsState {\n    constructor() {\n        /** @type {import('voxel-physics-engine').RigidBody} */\n        this.body = null\n    }\n}\n\n\n/**\n * Physics component, stores an entity's physics engbody.\n * @param {import('..').Engine} noa\n*/\n\nexport default function (noa) {\n\n    return {\n\n        name: 'physics',\n\n        order: 40,\n\n        state: new PhysicsState,\n\n        onAdd: function (entID, state) {\n            state.body = noa.physics.addBody()\n            // implicitly assume body has a position component, to get size\n            var posDat = noa.ents.getPositionData(state.__id)\n            setPhysicsFromPosition(state, posDat)\n        },\n\n\n        onRemove: function (entID, state) {\n            // update position before removing\n            // this lets entity wind up at e.g. the result of a collision\n            // even if physics component is removed in collision handler\n            if (noa.ents.hasPosition(state.__id)) {\n                var pdat = noa.ents.getPositionData(state.__id)\n                setPositionFromPhysics(state, pdat)\n                backtrackRenderPos(state, pdat, 0, false)\n            }\n            noa.physics.removeBody(state.body)\n        },\n\n\n        system: function (dt, states) {\n            for (var i = 0; i < states.length; i++) {\n                var state = states[i]\n                var pdat = noa.ents.getPositionData(state.__id)\n                setPositionFromPhysics(state, pdat)\n            }\n        },\n\n\n        renderSystem: function (dt, states) {\n\n            var tickPos = noa.positionInCurrentTick\n            var tickTime = 1000 / noa.container._shell.tickRate\n            tickTime *= noa.timeScale\n            var tickMS = tickPos * tickTime\n\n            // tickMS is time since last physics engine tick\n            // to avoid temporal aliasing, render the state as if lerping between\n            // the last position and the next one \n            // since the entity data is the \"next\" position this amounts to \n            // offsetting each entity into the past by tickRate - dt\n            // http://gafferongames.com/game-physics/fix-your-timestep/\n\n            var backtrackAmt = (tickMS - tickTime) / 1000\n            for (var i = 0; i < states.length; i++) {\n                var state = states[i]\n                var id = state.__id\n                var pdat = noa.ents.getPositionData(id)\n                var smoothed = noa.ents.cameraSmoothed(id)\n                backtrackRenderPos(state, pdat, backtrackAmt, smoothed)\n            }\n        }\n\n    }\n\n}\n\n\n\n// var offset = vec3.create()\nvar local = vec3.create()\n\nexport function setPhysicsFromPosition(physState, posState) {\n    var box = physState.body.aabb\n    var ext = posState._extents\n    vec3.copy(box.base, ext)\n    vec3.set(box.vec, posState.width, posState.height, posState.width)\n    vec3.add(box.max, box.base, box.vec)\n}\n\n\nfunction setPositionFromPhysics(physState, posState) {\n    var base = physState.body.aabb.base\n    var hw = posState.width / 2\n    vec3.set(posState._localPosition, base[0] + hw, base[1], base[2] + hw)\n}\n\n\nfunction backtrackRenderPos(physState, posState, backtrackAmt, smoothed) {\n    // pos = pos + backtrack * body.velocity\n    var vel = physState.body.velocity\n    vec3.scaleAndAdd(local, posState._localPosition, vel, backtrackAmt)\n\n    // smooth out update if component is present\n    // (this is set after sudden movements like auto-stepping)\n    if (smoothed) vec3.lerp(local, posState._renderPosition, local, 0.3)\n\n    // copy values over to renderPosition, \n    vec3.copy(posState._renderPosition, local)\n}\n", "\nimport boxIntersect from 'box-intersect'\n\n\n\n/*\n * \tEvery frame, entities with this component will get mutually checked for colliions\n * \n *   * cylinder: flag for checking collisions as a vertical cylindar (rather than AABB)\n *   * collideBits: category for this entity\n *   * collideMask: categories this entity collides with\n *   * callback: function(other_id) - called when `own.collideBits & other.collideMask` is true\n * \n * \n * \t\tNotes:\n * \tSet collideBits=0 for entities like bullets, which can collide with things \n * \t\tbut are never the target of a collision.\n * \tSet collideMask=0 for things with no callback - things that get collided with,\n * \t\tbut don't themselves instigate collisions.\n * \n */\n\n\n\nexport default function (noa) {\n\n    var intervals = []\n\n    return {\n\n        name: 'collideEntities',\n\n        order: 70,\n\n        state: {\n            cylinder: false,\n            collideBits: 1 | 0,\n            collideMask: 1 | 0,\n            callback: null,\n        },\n\n        onAdd: null,\n\n        onRemove: null,\n\n\n        system: function entityCollider(dt, states) {\n            var ents = noa.ents\n\n            // data struct that boxIntersect looks for\n            // - array of [lo, lo, lo, hi, hi, hi] extents\n            for (var i = 0; i < states.length; i++) {\n                var id = states[i].__id\n                var dat = ents.getPositionData(id)\n                intervals[i] = dat._extents\n            }\n            intervals.length = states.length\n\n            // run the intersect library\n            boxIntersect(intervals, function (a, b) {\n                var stateA = states[a]\n                var stateB = states[b]\n                if (!stateA || !stateB) return\n                var intervalA = intervals[a]\n                var intervalB = intervals[b]\n                if (cylindricalHitTest(stateA, stateB, intervalA, intervalB)) {\n                    handleCollision(noa, stateA, stateB)\n                }\n            })\n\n        }\n    }\n\n\n\n    /*\n     * \n     * \t\tIMPLEMENTATION\n     * \n     */\n\n\n    function handleCollision(noa, stateA, stateB) {\n        var idA = stateA.__id\n        var idB = stateB.__id\n\n        // entities really do overlap, so check masks and call event handlers\n        if (stateA.collideMask & stateB.collideBits) {\n            if (stateA.callback) stateA.callback(idB)\n        }\n        if (stateB.collideMask & stateA.collideBits) {\n            if (stateB.callback) stateB.callback(idA)\n        }\n\n        // general pairwise handler\n        noa.ents.onPairwiseEntityCollision(idA, idB)\n    }\n\n\n\n    // For entities whose extents overlap, \n    // test if collision still happens when taking cylinder flags into account\n\n    function cylindricalHitTest(stateA, stateB, intervalA, intervalB) {\n        if (stateA.cylinder) {\n            if (stateB.cylinder) {\n                return cylinderCylinderTest(intervalA, intervalB)\n            } else {\n                return cylinderBoxTest(intervalA, intervalB)\n            }\n        } else if (stateB.cylinder) {\n            return cylinderBoxTest(intervalB, intervalA)\n        }\n        return true\n    }\n\n\n\n\n    // Cylinder-cylinder hit test (AABBs are known to overlap)\n    // given their extent arrays [lo, lo, lo, hi, hi, hi]\n\n    function cylinderCylinderTest(a, b) {\n        // distance between cylinder centers\n        var rada = (a[3] - a[0]) / 2\n        var radb = (b[3] - b[0]) / 2\n        var dx = a[0] + rada - (b[0] + radb)\n        var dz = a[2] + rada - (b[2] + radb)\n        // collide if dist <= sum of radii\n        var distsq = dx * dx + dz * dz\n        var radsum = rada + radb\n        return (distsq <= radsum * radsum)\n    }\n\n\n\n\n    // Cylinder-Box hit test (AABBs are known to overlap)\n    // given their extent arrays [lo, lo, lo, hi, hi, hi]\n\n    function cylinderBoxTest(cyl, cube) {\n        // X-z center of cylinder\n        var rad = (cyl[3] - cyl[0]) / 2\n        var cx = cyl[0] + rad\n        var cz = cyl[2] + rad\n        // point in X-Z square closest to cylinder\n        var px = clamp(cx, cube[0], cube[3])\n        var pz = clamp(cz, cube[2], cube[5])\n        // collision if distance from that point to circle <= cylinder radius\n        var dx = px - cx\n        var dz = pz - cz\n        var distsq = dx * dx + dz * dz\n        return (distsq <= rad * rad)\n    }\n\n    function clamp(val, lo, hi) {\n        return (val < lo) ? lo : (val > hi) ? hi : val\n    }\n\n\n\n\n}\n", "\n\nexport default function (noa) {\n    return {\n\n        name: 'collideTerrain',\n\n        order: 0,\n\n        state: {\n            callback: null\n        },\n\n        onAdd: function (eid, state) {\n            // add collide handler for physics engine to call\n            var ents = noa.entities\n            if (ents.hasPhysics(eid)) {\n                var body = ents.getPhysics(eid).body\n                body.onCollide = function bodyOnCollide(impulse) {\n                    var cb = noa.ents.getCollideTerrain(eid).callback\n                    if (cb) cb(impulse, eid)\n                }\n            }\n        },\n\n        onRemove: function (eid, state) {\n            var ents = noa.entities\n            if (ents.hasPhysics(eid)) {\n                ents.getPhysics(eid).body.onCollide = null\n            }\n        },\n\n\n\n    }\n}\n", "\n/**\n * Component for the player entity, when active hides the player's mesh \n * when camera zoom is less than a certain amount\n */\n\nexport default function (noa) {\n    return {\n\n        name: 'fadeOnZoom',\n\n        order: 99,\n\n        state: {\n            cutoff: 1.5,\n        },\n\n        onAdd: null,\n\n        onRemove: null,\n\n        system: function fadeOnZoomProc(dt, states) {\n            var zoom = noa.camera.currentZoom\n            for (var i = 0; i < states.length; i++) {\n                checkZoom(states[i], zoom, noa)\n            }\n        }\n    }\n}\n\n\nfunction checkZoom(state, zoom, noa) {\n    if (!noa.ents.hasMesh(state.__id)) return\n    var mesh = noa.ents.getMeshData(state.__id).mesh\n    if (!mesh.metadata) return\n    var shouldHide = (zoom < state.cutoff)\n    noa.rendering.setMeshVisibility(mesh, !shouldHide)\n}\n", "\nimport vec3 from 'gl-vec3'\n\n\n/*\n * Indicates that an entity should be moved to another entity's position each tick,\n * possibly by a fixed offset, and the same for renderPositions each render\n */\n\nexport default function (noa) {\n\n    return {\n\n        name: 'followsEntity',\n\n        order: 50,\n\n        state: {\n            entity: 0 | 0,\n            offset: null,\n            onTargetMissing: null,\n        },\n\n        onAdd: function (eid, state) {\n            var off = vec3.create()\n            state.offset = (state.offset) ? vec3.copy(off, state.offset) : off\n            updatePosition(state)\n            updateRenderPosition(state)\n        },\n\n        onRemove: null,\n\n\n        // on tick, copy over regular positions\n        system: function followEntity(dt, states) {\n            for (var i = 0; i < states.length; i++) {\n                updatePosition(states[i])\n            }\n        },\n\n\n        // on render, copy over render positions\n        renderSystem: function followEntityMesh(dt, states) {\n            for (var i = 0; i < states.length; i++) {\n                updateRenderPosition(states[i])\n            }\n        }\n    }\n\n\n\n    function updatePosition(state) {\n        var id = state.__id\n        var self = noa.ents.getPositionData(id)\n        var other = noa.ents.getPositionData(state.entity)\n        if (!other) {\n            if (state.onTargetMissing) state.onTargetMissing(id)\n            noa.ents.removeComponent(id, noa.ents.names.followsEntity)\n        } else {\n            vec3.add(self._localPosition, other._localPosition, state.offset)\n        }\n    }\n\n    function updateRenderPosition(state) {\n        var id = state.__id\n        var self = noa.ents.getPositionData(id)\n        var other = noa.ents.getPositionData(state.entity)\n        if (other) {\n            vec3.add(self._renderPosition, other._renderPosition, state.offset)\n        }\n    }\n\n}\n", "\nimport vec3 from 'gl-vec3'\n\n\nexport default function (noa) {\n    return {\n\n        name: 'mesh',\n\n        order: 100,\n\n        state: {\n            mesh: null,\n            offset: null\n        },\n\n\n        onAdd: function (eid, state) {\n            // implicitly assume there's already a position component\n            var posDat = noa.ents.getPositionData(eid)\n            if (state.mesh) {\n                noa.rendering.addMeshToScene(state.mesh, false, posDat.position)\n            } else {\n                throw new Error('Mesh component added without a mesh - probably a bug!')\n            }\n            if (!state.offset) state.offset = vec3.create()\n\n            // set mesh to correct position\n            var rpos = posDat._renderPosition\n            state.mesh.position.copyFromFloats(\n                rpos[0] + state.offset[0],\n                rpos[1] + state.offset[1],\n                rpos[2] + state.offset[2])\n        },\n\n\n        onRemove: function (eid, state) {\n            state.mesh.dispose()\n        },\n\n\n\n        renderSystem: function (dt, states) {\n            // before render move each mesh to its render position, \n            // set by the physics engine or driving logic\n            for (var i = 0; i < states.length; i++) {\n                var state = states[i]\n                var id = state.__id\n\n                var rpos = noa.ents.getPositionData(id)._renderPosition\n                state.mesh.position.copyFromFloats(\n                    rpos[0] + state.offset[0],\n                    rpos[1] + state.offset[1],\n                    rpos[2] + state.offset[2])\n            }\n        }\n\n\n    }\n}\n", "\nimport vec3 from 'gl-vec3'\n\n\n\n\n\n/** \n * \n * State object of the `movement` component\n * \n*/\nexport function MovementState() {\n    this.heading = 0 // radians\n    this.running = false\n    this.jumping = false\n\n    // options\n    this.maxSpeed = 10\n    this.moveForce = 30\n    this.responsiveness = 15\n    this.runningFriction = 0\n    this.standingFriction = 2\n\n    // jumps\n    this.airMoveMult = 0.5\n    this.jumpImpulse = 10\n    this.jumpForce = 12\n    this.jumpTime = 500 // ms\n    this.airJumps = 1\n\n    // internal state\n    this._jumpCount = 0\n    this._currjumptime = 0\n    this._isJumping = false\n}\n\n\n\n\n\n/**\n * Movement component. State stores settings like jump height, etc.,\n * as well as current state (running, jumping, heading angle).\n * Processor checks state and applies movement/friction/jump forces\n * to the entity's physics body. \n * @param {import('..').Engine} noa\n*/\n\nexport default function (noa) {\n    return {\n\n        name: 'movement',\n\n        order: 30,\n\n        state: new MovementState(),\n\n        onAdd: null,\n\n        onRemove: null,\n\n\n        system: function movementProcessor(dt, states) {\n            var ents = noa.entities\n            for (var i = 0; i < states.length; i++) {\n                var state = states[i]\n                var phys = ents.getPhysics(state.__id)\n                if (phys) applyMovementPhysics(dt, state, phys.body)\n            }\n        }\n\n\n    }\n}\n\n\nvar tempvec = vec3.create()\nvar tempvec2 = vec3.create()\nvar zeroVec = vec3.create()\n\n\n/**\n * @param {number} dt \n * @param {MovementState} state \n * @param {*} body \n*/\n\nfunction applyMovementPhysics(dt, state, body) {\n    // move implementation originally written as external module\n    //   see https://github.com/fenomas/voxel-fps-controller\n    //   for original code\n\n    // jumping\n    var onGround = (body.atRestY() < 0)\n    var canjump = (onGround || state._jumpCount < state.airJumps)\n    if (onGround) {\n        state._isJumping = false\n        state._jumpCount = 0\n    }\n\n    // process jump input\n    if (state.jumping) {\n        if (state._isJumping) { // continue previous jump\n            if (state._currjumptime > 0) {\n                var jf = state.jumpForce\n                if (state._currjumptime < dt) jf *= state._currjumptime / dt\n                body.applyForce([0, jf, 0])\n                state._currjumptime -= dt\n            }\n        } else if (canjump) { // start new jump\n            state._isJumping = true\n            if (!onGround) state._jumpCount++\n            state._currjumptime = state.jumpTime\n            body.applyImpulse([0, state.jumpImpulse, 0])\n            // clear downward velocity on airjump\n            if (!onGround && body.velocity[1] < 0) body.velocity[1] = 0\n        }\n    } else {\n        state._isJumping = false\n    }\n\n    // apply movement forces if entity is moving, otherwise just friction\n    var m = tempvec\n    var push = tempvec2\n    if (state.running) {\n\n        var speed = state.maxSpeed\n        // todo: add crouch/sprint modifiers if needed\n        // if (state.sprint) speed *= state.sprintMoveMult\n        // if (state.crouch) speed *= state.crouchMoveMult\n        vec3.set(m, 0, 0, speed)\n\n        // rotate move vector to entity's heading\n        vec3.rotateY(m, m, zeroVec, state.heading)\n\n        // push vector to achieve desired speed & dir\n        // following code to adjust 2D velocity to desired amount is patterned on Quake: \n        // https://github.com/id-Software/Quake-III-Arena/blob/master/code/game/bg_pmove.c#L275\n        vec3.subtract(push, m, body.velocity)\n        push[1] = 0\n        var pushLen = vec3.length(push)\n        vec3.normalize(push, push)\n\n        if (pushLen > 0) {\n            // pushing force vector\n            var canPush = state.moveForce\n            if (!onGround) canPush *= state.airMoveMult\n\n            // apply final force\n            var pushAmt = state.responsiveness * pushLen\n            if (canPush > pushAmt) canPush = pushAmt\n\n            vec3.scale(push, push, canPush)\n            body.applyForce(push)\n        }\n\n        // different friction when not moving\n        // idea from Sonic: http://info.sonicretro.org/SPG:Running\n        body.friction = state.runningFriction\n    } else {\n        body.friction = state.standingFriction\n    }\n}\n", "\n/**\n * \n * Input processing component - gets (key) input state and  \n * applies it to receiving entities by updating their movement \n * component state (heading, movespeed, jumping, etc.)\n * \n */\n\nexport default function (noa) {\n    return {\n\n        name: 'receivesInputs',\n\n        order: 20,\n\n        state: {},\n\n        onAdd: null,\n\n        onRemove: null,\n\n        system: function inputProcessor(dt, states) {\n            var ents = noa.entities\n            var inputState = noa.inputs.state\n            var camHeading = noa.camera.heading\n\n            for (var i = 0; i < states.length; i++) {\n                var state = states[i]\n                var moveState = ents.getMovement(state.__id)\n                setMovementState(moveState, inputState, camHeading)\n            }\n        }\n\n    }\n}\n\n\n\n/**\n * @param {import('../components/movement').MovementState} state \n * @param {Object<string, boolean>} inputs \n * @param {number} camHeading \n*/\n\nfunction setMovementState(state, inputs, camHeading) {\n    state.jumping = !!inputs.jump\n\n    var fb = inputs.forward ? (inputs.backward ? 0 : 1) : (inputs.backward ? -1 : 0)\n    var rl = inputs.right ? (inputs.left ? 0 : 1) : (inputs.left ? -1 : 0)\n\n    if ((fb | rl) === 0) {\n        state.running = false\n    } else {\n        state.running = true\n        if (fb) {\n            if (fb == -1) camHeading += Math.PI\n            if (rl) {\n                camHeading += Math.PI / 4 * fb * rl // didn't plan this but it works!\n            }\n        } else {\n            camHeading += rl * Math.PI / 2\n        }\n        state.heading = camHeading\n    }\n\n}\n", "\nimport vec3 from 'gl-vec3'\n\nimport { Color3 } from '@babylonjs/core/Maths/math.color'\nimport { CreateDisc } from '@babylonjs/core/Meshes/Builders/discBuilder'\nimport '@babylonjs/core/Meshes/instancedMesh'\n\n\n/** @param {import('../index').Engine} noa  */\nexport default function (noa, distance = 10) {\n\n    var shadowDist = distance\n\n    // create a mesh to re-use for shadows\n    var scene = noa.rendering.getScene()\n    var disc = CreateDisc('shadow', { radius: 0.75, tessellation: 30 }, scene)\n    disc.rotation.x = Math.PI / 2\n    var mat = noa.rendering.makeStandardMaterial('shadow_component_mat')\n    mat.diffuseColor.set(0, 0, 0)\n    mat.ambientColor.set(0, 0, 0)\n    mat.alpha = 0.5\n    disc.material = mat\n    mat.freeze()\n\n    // source mesh needn't be in the scene graph\n    noa.rendering.setMeshVisibility(disc, false)\n\n\n    return {\n\n        name: 'shadow',\n\n        order: 80,\n\n        state: {\n            size: 0.5,\n            _mesh: null,\n        },\n\n\n        onAdd: function (eid, state) {\n            var mesh = disc.createInstance('shadow_instance')\n            noa.rendering.addMeshToScene(mesh)\n            mesh.setEnabled(false)\n            state._mesh = mesh\n        },\n\n\n        onRemove: function (eid, state) {\n            state._mesh.dispose()\n            state._mesh = null\n        },\n\n\n        system: function shadowSystem(dt, states) {\n            var cpos = noa.camera._localGetPosition()\n            var dist = shadowDist\n            for (var i = 0; i < states.length; i++) {\n                var state = states[i]\n                var posState = noa.ents.getPositionData(state.__id)\n                var physState = noa.ents.getPhysics(state.__id)\n                updateShadowHeight(noa, posState, physState, state._mesh, state.size, dist, cpos)\n            }\n        },\n\n\n        renderSystem: function (dt, states) {\n            // before render adjust shadow x/z to render positions\n            for (var i = 0; i < states.length; i++) {\n                var state = states[i]\n                var rpos = noa.ents.getPositionData(state.__id)._renderPosition\n                var spos = state._mesh.position\n                spos.x = rpos[0]\n                spos.z = rpos[2]\n            }\n        }\n\n\n\n\n    }\n}\n\nvar shadowPos = vec3.fromValues(0, 0, 0)\nvar down = vec3.fromValues(0, -1, 0)\n\nfunction updateShadowHeight(noa, posDat, physDat, mesh, size, shadowDist, camPos) {\n\n    // local Y ground position - from physics or raycast\n    var localY\n    if (physDat && physDat.body.resting[1] < 0) {\n        localY = posDat._localPosition[1]\n    } else {\n        var res = noa._localPick(posDat._localPosition, down, shadowDist)\n        if (!res) {\n            mesh.setEnabled(false)\n            return\n        }\n        localY = res.position[1] - noa.worldOriginOffset[1]\n    }\n\n    // round Y pos and offset upwards slightly to avoid z-fighting\n    localY = Math.round(localY)\n    vec3.copy(shadowPos, posDat._localPosition)\n    shadowPos[1] = localY\n    var sqdist = vec3.squaredDistance(camPos, shadowPos)\n    // offset ~ 0.01 for nearby shadows, up to 0.1 at distance of ~40\n    var offset = 0.01 + 0.1 * (sqdist / 1600)\n    if (offset > 0.1) offset = 0.1\n    mesh.position.y = localY + offset\n    // set shadow scale\n    var dist = posDat._localPosition[1] - localY\n    var scale = size * 0.7 * (1 - dist / shadowDist)\n    mesh.scaling.copyFromFloats(scale, scale, scale)\n    mesh.setEnabled(true)\n}\n", "import type { Nullable } from \"../../types\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { Vector4 } from \"../../Maths/math.vector\";\r\nimport { Mesh } from \"../mesh\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\nimport { CompatibilityOptions } from \"../../Compat/compatibilityOptions\";\r\n\r\n/**\r\n * Creates the VertexData of the Disc or regular Polygon\r\n * @param options an object used to set the following optional parameters for the disc, required but can be empty\r\n * * radius the radius of the disc, optional default 0.5\r\n * * tessellation the number of polygon sides, optional, default 64\r\n * * arc a number from 0 to 1, to create an unclosed polygon based on the fraction of the circumference given by the arc value, optional, default 1\r\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n * @returns the VertexData of the box\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport function CreateDiscVertexData(options: {\r\n    radius?: number;\r\n    tessellation?: number;\r\n    arc?: number;\r\n    sideOrientation?: number;\r\n    frontUVs?: Vector4;\r\n    backUVs?: Vector4;\r\n}): VertexData {\r\n    const positions: number[] = [];\r\n    const indices: number[] = [];\r\n    const normals: number[] = [];\r\n    const uvs: number[] = [];\r\n\r\n    const radius = options.radius || 0.5;\r\n    const tessellation = options.tessellation || 64;\r\n    const arc: number = options.arc && (options.arc <= 0 || options.arc > 1) ? 1.0 : options.arc || 1.0;\r\n    const sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;\r\n\r\n    // positions and uvs\r\n    positions.push(0, 0, 0); // disc center first\r\n    uvs.push(0.5, 0.5);\r\n\r\n    const theta = Math.PI * 2 * arc;\r\n    const step = arc === 1 ? theta / tessellation : theta / (tessellation - 1);\r\n    let a = 0;\r\n    for (let t = 0; t < tessellation; t++) {\r\n        const x = Math.cos(a);\r\n        const y = Math.sin(a);\r\n        const u = (x + 1) / 2;\r\n        const v = (1 - y) / 2;\r\n        positions.push(radius * x, radius * y, 0);\r\n        uvs.push(u, CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - v : v);\r\n        a += step;\r\n    }\r\n    if (arc === 1) {\r\n        positions.push(positions[3], positions[4], positions[5]); // close the circle\r\n        uvs.push(uvs[2], CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - uvs[3] : uvs[3]);\r\n    }\r\n\r\n    //indices\r\n    const vertexNb = positions.length / 3;\r\n    for (let i = 1; i < vertexNb - 1; i++) {\r\n        indices.push(i + 1, 0, i);\r\n    }\r\n\r\n    // result\r\n    VertexData.ComputeNormals(positions, indices, normals);\r\n    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\r\n\r\n    const vertexData = new VertexData();\r\n\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    vertexData.normals = normals;\r\n    vertexData.uvs = uvs;\r\n\r\n    return vertexData;\r\n}\r\n\r\n/**\r\n * Creates a plane polygonal mesh.  By default, this is a disc\r\n * * The parameter `radius` sets the radius size (float) of the polygon (default 0.5)\r\n * * The parameter `tessellation` sets the number of polygon sides (positive integer, default 64). So a tessellation valued to 3 will build a triangle, to 4 a square, etc\r\n * * You can create an unclosed polygon with the parameter `arc` (positive float, default 1), valued between 0 and 1, what is the ratio of the circumference : 2 x PI x ratio\r\n * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#side-orientation\r\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n * @param name defines the name of the mesh\r\n * @param options defines the options used to create the mesh\r\n * @param scene defines the hosting scene\r\n * @returns the plane polygonal mesh\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#disc-or-regular-polygon\r\n */\r\nexport function CreateDisc(\r\n    name: string,\r\n    options: { radius?: number; tessellation?: number; arc?: number; updatable?: boolean; sideOrientation?: number; frontUVs?: Vector4; backUVs?: Vector4 } = {},\r\n    scene: Nullable<Scene> = null\r\n): Mesh {\r\n    const disc = new Mesh(name, scene);\r\n\r\n    options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\r\n    disc._originalBuilderSideOrientation = options.sideOrientation;\r\n\r\n    const vertexData = CreateDiscVertexData(options);\r\n\r\n    vertexData.applyToMesh(disc, options.updatable);\r\n\r\n    return disc;\r\n}\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n * @deprecated please use CreateDisc directly\r\n */\r\nexport const DiscBuilder = {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    CreateDisc,\r\n};\r\n\r\nVertexData.CreateDisc = CreateDiscVertexData;\r\n\r\nMesh.CreateDisc = (name: string, radius: number, tessellation: number, scene: Nullable<Scene> = null, updatable?: boolean, sideOrientation?: number): Mesh => {\r\n    const options = {\r\n        radius,\r\n        tessellation,\r\n        sideOrientation,\r\n        updatable,\r\n    };\r\n\r\n    return CreateDisc(name, options, scene);\r\n};\r\n", "import type { Nullable, FloatArray, IndicesArray } from \"../types\";\r\nimport type { Vector3 } from \"../Maths/math.vector\";\r\nimport { Matrix, TmpVectors } from \"../Maths/math.vector\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport type { Node } from \"../node\";\r\nimport { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport type { Material } from \"../Materials/material\";\r\nimport type { Skeleton } from \"../Bones/skeleton\";\r\nimport { DeepCopier } from \"../Misc/deepCopier\";\r\nimport { TransformNode } from \"./transformNode\";\r\nimport type { Light } from \"../Lights/light\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport { Tools } from \"../Misc/tools\";\r\n\r\nMesh._instancedMeshFactory = (name: string, mesh: Mesh): InstancedMesh => {\r\n    const instance = new InstancedMesh(name, mesh);\r\n\r\n    if (mesh.instancedBuffers) {\r\n        instance.instancedBuffers = {};\r\n\r\n        for (const key in mesh.instancedBuffers) {\r\n            instance.instancedBuffers[key] = mesh.instancedBuffers[key];\r\n        }\r\n    }\r\n\r\n    return instance;\r\n};\r\n\r\n/**\r\n * Creates an instance based on a source mesh.\r\n */\r\nexport class InstancedMesh extends AbstractMesh {\r\n    private _sourceMesh: Mesh;\r\n    private _currentLOD: Mesh;\r\n    private _billboardWorldMatrix: Matrix;\r\n\r\n    /** @internal */\r\n    public _indexInSourceMeshInstanceArray = -1;\r\n    /** @internal */\r\n    public _distanceToCamera: number = 0;\r\n    /** @internal */\r\n    public _previousWorldMatrix: Nullable<Matrix>;\r\n\r\n    /**\r\n     * Creates a new InstancedMesh object from the mesh source.\r\n     * @param name defines the name of the instance\r\n     * @param source the mesh to create the instance from\r\n     */\r\n    constructor(name: string, source: Mesh) {\r\n        super(name, source.getScene());\r\n\r\n        source.addInstance(this);\r\n\r\n        this._sourceMesh = source;\r\n\r\n        this._unIndexed = source._unIndexed;\r\n\r\n        this.position.copyFrom(source.position);\r\n        this.rotation.copyFrom(source.rotation);\r\n        this.scaling.copyFrom(source.scaling);\r\n\r\n        if (source.rotationQuaternion) {\r\n            this.rotationQuaternion = source.rotationQuaternion.clone();\r\n        }\r\n\r\n        this.animations = source.animations.slice();\r\n        for (const range of source.getAnimationRanges()) {\r\n            if (range != null) {\r\n                this.createAnimationRange(range.name, range.from, range.to);\r\n            }\r\n        }\r\n\r\n        this.infiniteDistance = source.infiniteDistance;\r\n\r\n        this.setPivotMatrix(source.getPivotMatrix());\r\n\r\n        this.refreshBoundingInfo(true, true);\r\n        this._syncSubMeshes();\r\n    }\r\n\r\n    /**\r\n     * @returns the string \"InstancedMesh\".\r\n     */\r\n    public getClassName(): string {\r\n        return \"InstancedMesh\";\r\n    }\r\n\r\n    /** Gets the list of lights affecting that mesh */\r\n    public get lightSources(): Light[] {\r\n        return this._sourceMesh._lightSources;\r\n    }\r\n\r\n    public _resyncLightSources(): void {\r\n        // Do nothing as all the work will be done by source mesh\r\n    }\r\n\r\n    public _resyncLightSource(): void {\r\n        // Do nothing as all the work will be done by source mesh\r\n    }\r\n\r\n    public _removeLightSource(): void {\r\n        // Do nothing as all the work will be done by source mesh\r\n    }\r\n\r\n    // Methods\r\n    /**\r\n     * If the source mesh receives shadows\r\n     */\r\n    public get receiveShadows(): boolean {\r\n        return this._sourceMesh.receiveShadows;\r\n    }\r\n\r\n    public set receiveShadows(_value: boolean) {\r\n        if (this._sourceMesh?.receiveShadows !== _value) {\r\n            Tools.Warn(\"Setting receiveShadows on an instanced mesh has no effect\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The material of the source mesh\r\n     */\r\n    public get material(): Nullable<Material> {\r\n        return this._sourceMesh.material;\r\n    }\r\n\r\n    public set material(_value: Nullable<Material>) {\r\n        if (this._sourceMesh?.material !== _value) {\r\n            Tools.Warn(\"Setting material on an instanced mesh has no effect\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Visibility of the source mesh\r\n     */\r\n    public get visibility(): number {\r\n        return this._sourceMesh.visibility;\r\n    }\r\n\r\n    public set visibility(_value: number) {\r\n        if (this._sourceMesh?.visibility !== _value) {\r\n            Tools.Warn(\"Setting visibility on an instanced mesh has no effect\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Skeleton of the source mesh\r\n     */\r\n    public get skeleton(): Nullable<Skeleton> {\r\n        return this._sourceMesh.skeleton;\r\n    }\r\n\r\n    public set skeleton(_value: Nullable<Skeleton>) {\r\n        if (this._sourceMesh?.skeleton !== _value) {\r\n            Tools.Warn(\"Setting skeleton on an instanced mesh has no effect\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Rendering ground id of the source mesh\r\n     */\r\n    public get renderingGroupId(): number {\r\n        return this._sourceMesh.renderingGroupId;\r\n    }\r\n\r\n    public set renderingGroupId(value: number) {\r\n        if (!this._sourceMesh || value === this._sourceMesh.renderingGroupId) {\r\n            return;\r\n        }\r\n\r\n        //no-op with warning\r\n        Logger.Warn(\"Note - setting renderingGroupId of an instanced mesh has no effect on the scene\");\r\n    }\r\n\r\n    /**\r\n     * @returns the total number of vertices (integer).\r\n     */\r\n    public getTotalVertices(): number {\r\n        return this._sourceMesh ? this._sourceMesh.getTotalVertices() : 0;\r\n    }\r\n\r\n    /**\r\n     * Returns a positive integer : the total number of indices in this mesh geometry.\r\n     * @returns the number of indices or zero if the mesh has no geometry.\r\n     */\r\n    public getTotalIndices(): number {\r\n        return this._sourceMesh.getTotalIndices();\r\n    }\r\n\r\n    /**\r\n     * The source mesh of the instance\r\n     */\r\n    public get sourceMesh(): Mesh {\r\n        return this._sourceMesh;\r\n    }\r\n\r\n    /**\r\n     * Creates a new InstancedMesh object from the mesh model.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/copies/instances\r\n     * @param name defines the name of the new instance\r\n     * @returns a new InstancedMesh\r\n     */\r\n    public createInstance(name: string): InstancedMesh {\r\n        return this._sourceMesh.createInstance(name);\r\n    }\r\n\r\n    /**\r\n     * Is this node ready to be used/rendered\r\n     * @param completeCheck defines if a complete check (including materials and lights) has to be done (false by default)\r\n     * @returns {boolean} is it ready\r\n     */\r\n    public isReady(completeCheck = false): boolean {\r\n        return this._sourceMesh.isReady(completeCheck, true);\r\n    }\r\n\r\n    /**\r\n     * Returns an array of integers or a typed array (Int32Array, Uint32Array, Uint16Array) populated with the mesh indices.\r\n     * @param kind kind of verticies to retrieve (eg. positions, normals, uvs, etc.)\r\n     * @param copyWhenShared If true (default false) and and if the mesh geometry is shared among some other meshes, the returned array is a copy of the internal one.\r\n     * @param forceCopy defines a boolean forcing the copy of the buffer no matter what the value of copyWhenShared is\r\n     * @returns a float array or a Float32Array of the requested kind of data : positions, normals, uvs, etc.\r\n     */\r\n    public getVerticesData(kind: string, copyWhenShared?: boolean, forceCopy?: boolean): Nullable<FloatArray> {\r\n        return this._sourceMesh.getVerticesData(kind, copyWhenShared, forceCopy);\r\n    }\r\n\r\n    /**\r\n     * Sets the vertex data of the mesh geometry for the requested `kind`.\r\n     * If the mesh has no geometry, a new Geometry object is set to the mesh and then passed this vertex data.\r\n     * The `data` are either a numeric array either a Float32Array.\r\n     * The parameter `updatable` is passed as is to the underlying Geometry object constructor (if initially none) or updater.\r\n     * The parameter `stride` is an optional positive integer, it is usually automatically deducted from the `kind` (3 for positions or normals, 2 for UV, etc).\r\n     * Note that a new underlying VertexBuffer object is created each call.\r\n     * If the `kind` is the `PositionKind`, the mesh BoundingInfo is renewed, so the bounding box and sphere, and the mesh World Matrix is recomputed.\r\n     *\r\n     * Possible `kind` values :\r\n     * - VertexBuffer.PositionKind\r\n     * - VertexBuffer.UVKind\r\n     * - VertexBuffer.UV2Kind\r\n     * - VertexBuffer.UV3Kind\r\n     * - VertexBuffer.UV4Kind\r\n     * - VertexBuffer.UV5Kind\r\n     * - VertexBuffer.UV6Kind\r\n     * - VertexBuffer.ColorKind\r\n     * - VertexBuffer.MatricesIndicesKind\r\n     * - VertexBuffer.MatricesIndicesExtraKind\r\n     * - VertexBuffer.MatricesWeightsKind\r\n     * - VertexBuffer.MatricesWeightsExtraKind\r\n     *\r\n     * Returns the Mesh.\r\n     * @param kind defines vertex data kind\r\n     * @param data defines the data source\r\n     * @param updatable defines if the data must be flagged as updatable (false as default)\r\n     * @param stride defines the vertex stride (optional)\r\n     * @returns the current mesh\r\n     */\r\n    public setVerticesData(kind: string, data: FloatArray, updatable?: boolean, stride?: number): AbstractMesh {\r\n        if (this.sourceMesh) {\r\n            this.sourceMesh.setVerticesData(kind, data, updatable, stride);\r\n        }\r\n        return this.sourceMesh;\r\n    }\r\n\r\n    /**\r\n     * Updates the existing vertex data of the mesh geometry for the requested `kind`.\r\n     * If the mesh has no geometry, it is simply returned as it is.\r\n     * The `data` are either a numeric array either a Float32Array.\r\n     * No new underlying VertexBuffer object is created.\r\n     * If the `kind` is the `PositionKind` and if `updateExtends` is true, the mesh BoundingInfo is renewed, so the bounding box and sphere, and the mesh World Matrix is recomputed.\r\n     * If the parameter `makeItUnique` is true, a new global geometry is created from this positions and is set to the mesh.\r\n     *\r\n     * Possible `kind` values :\r\n     * - VertexBuffer.PositionKind\r\n     * - VertexBuffer.UVKind\r\n     * - VertexBuffer.UV2Kind\r\n     * - VertexBuffer.UV3Kind\r\n     * - VertexBuffer.UV4Kind\r\n     * - VertexBuffer.UV5Kind\r\n     * - VertexBuffer.UV6Kind\r\n     * - VertexBuffer.ColorKind\r\n     * - VertexBuffer.MatricesIndicesKind\r\n     * - VertexBuffer.MatricesIndicesExtraKind\r\n     * - VertexBuffer.MatricesWeightsKind\r\n     * - VertexBuffer.MatricesWeightsExtraKind\r\n     *\r\n     * Returns the Mesh.\r\n     * @param kind defines vertex data kind\r\n     * @param data defines the data source\r\n     * @param updateExtends defines if extends info of the mesh must be updated (can be null). This is mostly useful for \"position\" kind\r\n     * @param makeItUnique defines it the updated vertex buffer must be flagged as unique (false by default)\r\n     * @returns the source mesh\r\n     */\r\n    public updateVerticesData(kind: string, data: FloatArray, updateExtends?: boolean, makeItUnique?: boolean): Mesh {\r\n        if (this.sourceMesh) {\r\n            this.sourceMesh.updateVerticesData(kind, data, updateExtends, makeItUnique);\r\n        }\r\n        return this.sourceMesh;\r\n    }\r\n\r\n    /**\r\n     * Sets the mesh indices.\r\n     * Expects an array populated with integers or a typed array (Int32Array, Uint32Array, Uint16Array).\r\n     * If the mesh has no geometry, a new Geometry object is created and set to the mesh.\r\n     * This method creates a new index buffer each call.\r\n     * Returns the Mesh.\r\n     * @param indices the source data\r\n     * @param totalVertices defines the total number of vertices referenced by indices (could be null)\r\n     * @returns source mesh\r\n     */\r\n    public setIndices(indices: IndicesArray, totalVertices: Nullable<number> = null): Mesh {\r\n        if (this.sourceMesh) {\r\n            this.sourceMesh.setIndices(indices, totalVertices);\r\n        }\r\n        return this.sourceMesh;\r\n    }\r\n\r\n    /**\r\n     * Boolean : True if the mesh owns the requested kind of data.\r\n     * @param kind defines which buffer to check (positions, indices, normals, etc). Possible `kind` values :\r\n     * - VertexBuffer.PositionKind\r\n     * - VertexBuffer.UVKind\r\n     * - VertexBuffer.UV2Kind\r\n     * - VertexBuffer.UV3Kind\r\n     * - VertexBuffer.UV4Kind\r\n     * - VertexBuffer.UV5Kind\r\n     * - VertexBuffer.UV6Kind\r\n     * - VertexBuffer.ColorKind\r\n     * - VertexBuffer.MatricesIndicesKind\r\n     * - VertexBuffer.MatricesIndicesExtraKind\r\n     * - VertexBuffer.MatricesWeightsKind\r\n     * - VertexBuffer.MatricesWeightsExtraKind\r\n     * @returns true if data kind is present\r\n     */\r\n    public isVerticesDataPresent(kind: string): boolean {\r\n        return this._sourceMesh.isVerticesDataPresent(kind);\r\n    }\r\n\r\n    /**\r\n     * @returns an array of indices (IndicesArray).\r\n     */\r\n    public getIndices(): Nullable<IndicesArray> {\r\n        return this._sourceMesh.getIndices();\r\n    }\r\n\r\n    public get _positions(): Nullable<Vector3[]> {\r\n        return this._sourceMesh._positions;\r\n    }\r\n\r\n    /**\r\n     * This method recomputes and sets a new BoundingInfo to the mesh unless it is locked.\r\n     * This means the mesh underlying bounding box and sphere are recomputed.\r\n     * @param applySkeleton defines whether to apply the skeleton before computing the bounding info\r\n     * @param applyMorph  defines whether to apply the morph target before computing the bounding info\r\n     * @returns the current mesh\r\n     */\r\n    public refreshBoundingInfo(applySkeleton: boolean = false, applyMorph: boolean = false): InstancedMesh {\r\n        if (this.hasBoundingInfo && this.getBoundingInfo().isLocked) {\r\n            return this;\r\n        }\r\n\r\n        const bias = this._sourceMesh.geometry ? this._sourceMesh.geometry.boundingBias : null;\r\n        this._refreshBoundingInfo(this._sourceMesh._getPositionData(applySkeleton, applyMorph), bias);\r\n        return this;\r\n    }\r\n\r\n    /** @internal */\r\n    public _preActivate(): InstancedMesh {\r\n        if (this._currentLOD) {\r\n            this._currentLOD._preActivate();\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _activate(renderId: number, intermediateRendering: boolean): boolean {\r\n        super._activate(renderId, intermediateRendering);\r\n\r\n        if (!this._sourceMesh.subMeshes) {\r\n            Logger.Warn(\"Instances should only be created for meshes with geometry.\");\r\n        }\r\n\r\n        if (this._currentLOD) {\r\n            const differentSign = this._currentLOD._getWorldMatrixDeterminant() >= 0 !== this._getWorldMatrixDeterminant() >= 0;\r\n            if (differentSign) {\r\n                this._internalAbstractMeshDataInfo._actAsRegularMesh = true;\r\n                return true;\r\n            }\r\n            this._internalAbstractMeshDataInfo._actAsRegularMesh = false;\r\n\r\n            this._currentLOD._registerInstanceForRenderId(this, renderId);\r\n\r\n            if (intermediateRendering) {\r\n                if (!this._currentLOD._internalAbstractMeshDataInfo._isActiveIntermediate) {\r\n                    this._currentLOD._internalAbstractMeshDataInfo._onlyForInstancesIntermediate = true;\r\n                    return true;\r\n                }\r\n            } else {\r\n                if (!this._currentLOD._internalAbstractMeshDataInfo._isActive) {\r\n                    this._currentLOD._internalAbstractMeshDataInfo._onlyForInstances = true;\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /** @internal */\r\n    public _postActivate(): void {\r\n        if (this._sourceMesh.edgesShareWithInstances && this._sourceMesh._edgesRenderer && this._sourceMesh._edgesRenderer.isEnabled && this._sourceMesh._renderingGroup) {\r\n            // we are using the edge renderer of the source mesh\r\n            this._sourceMesh._renderingGroup._edgesRenderers.pushNoDuplicate(this._sourceMesh._edgesRenderer);\r\n            this._sourceMesh._edgesRenderer.customInstances.push(this.getWorldMatrix());\r\n        } else if (this._edgesRenderer && this._edgesRenderer.isEnabled && this._sourceMesh._renderingGroup) {\r\n            // we are using the edge renderer defined for this instance\r\n            this._sourceMesh._renderingGroup._edgesRenderers.push(this._edgesRenderer);\r\n        }\r\n    }\r\n\r\n    public getWorldMatrix(): Matrix {\r\n        if (this._currentLOD && this._currentLOD.billboardMode !== TransformNode.BILLBOARDMODE_NONE && this._currentLOD._masterMesh !== this) {\r\n            if (!this._billboardWorldMatrix) {\r\n                this._billboardWorldMatrix = new Matrix();\r\n            }\r\n            const tempMaster = this._currentLOD._masterMesh;\r\n            this._currentLOD._masterMesh = this;\r\n            TmpVectors.Vector3[7].copyFrom(this._currentLOD.position);\r\n            this._currentLOD.position.set(0, 0, 0);\r\n            this._billboardWorldMatrix.copyFrom(this._currentLOD.computeWorldMatrix(true));\r\n            this._currentLOD.position.copyFrom(TmpVectors.Vector3[7]);\r\n            this._currentLOD._masterMesh = tempMaster;\r\n            return this._billboardWorldMatrix;\r\n        }\r\n\r\n        return super.getWorldMatrix();\r\n    }\r\n\r\n    public get isAnInstance(): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Returns the current associated LOD AbstractMesh.\r\n     * @param camera defines the camera to use to pick the LOD level\r\n     * @returns a Mesh or `null` if no LOD is associated with the AbstractMesh\r\n     */\r\n    public getLOD(camera: Camera): AbstractMesh {\r\n        if (!camera) {\r\n            return this;\r\n        }\r\n\r\n        const sourceMeshLODLevels = this.sourceMesh.getLODLevels();\r\n        if (!sourceMeshLODLevels || sourceMeshLODLevels.length === 0) {\r\n            this._currentLOD = this.sourceMesh;\r\n        } else {\r\n            const boundingInfo = this.getBoundingInfo();\r\n            this._currentLOD = <Mesh>this.sourceMesh.getLOD(camera, boundingInfo.boundingSphere);\r\n        }\r\n\r\n        return this._currentLOD;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _preActivateForIntermediateRendering(renderId: number): Mesh {\r\n        return <Mesh>this.sourceMesh._preActivateForIntermediateRendering(renderId);\r\n    }\r\n\r\n    /** @internal */\r\n    public _syncSubMeshes(): InstancedMesh {\r\n        this.releaseSubMeshes();\r\n        if (this._sourceMesh.subMeshes) {\r\n            for (let index = 0; index < this._sourceMesh.subMeshes.length; index++) {\r\n                this._sourceMesh.subMeshes[index].clone(this, this._sourceMesh);\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /** @internal */\r\n    public _generatePointsArray(): boolean {\r\n        return this._sourceMesh._generatePointsArray();\r\n    }\r\n\r\n    /** @internal */\r\n    public _updateBoundingInfo(): AbstractMesh {\r\n        if (this.hasBoundingInfo) {\r\n            this.getBoundingInfo().update(this.worldMatrixFromCache);\r\n        } else {\r\n            this.buildBoundingInfo(this.absolutePosition, this.absolutePosition, this.worldMatrixFromCache);\r\n        }\r\n        this._updateSubMeshesBoundingInfo(this.worldMatrixFromCache);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Creates a new InstancedMesh from the current mesh.\r\n     *\r\n     * Returns the clone.\r\n     * @param name the cloned mesh name\r\n     * @param newParent the optional Node to parent the clone to.\r\n     * @param doNotCloneChildren if `true` the model children aren't cloned.\r\n     * @param newSourceMesh if set this mesh will be used as the source mesh instead of ths instance's one\r\n     * @returns the clone\r\n     */\r\n    public clone(name: string, newParent: Nullable<Node> = null, doNotCloneChildren?: boolean, newSourceMesh?: Mesh): InstancedMesh {\r\n        const result = (newSourceMesh || this._sourceMesh).createInstance(name);\r\n\r\n        // Deep copy\r\n        DeepCopier.DeepCopy(\r\n            this,\r\n            result,\r\n            [\r\n                \"name\",\r\n                \"subMeshes\",\r\n                \"uniqueId\",\r\n                \"parent\",\r\n                \"lightSources\",\r\n                \"receiveShadows\",\r\n                \"material\",\r\n                \"visibility\",\r\n                \"skeleton\",\r\n                \"sourceMesh\",\r\n                \"isAnInstance\",\r\n                \"facetNb\",\r\n                \"isFacetDataEnabled\",\r\n                \"isBlocked\",\r\n                \"useBones\",\r\n                \"hasInstances\",\r\n                \"collider\",\r\n                \"edgesRenderer\",\r\n                \"forward\",\r\n                \"up\",\r\n                \"right\",\r\n                \"absolutePosition\",\r\n                \"absoluteScaling\",\r\n                \"absoluteRotationQuaternion\",\r\n                \"isWorldMatrixFrozen\",\r\n                \"nonUniformScaling\",\r\n                \"behaviors\",\r\n                \"worldMatrixFromCache\",\r\n                \"hasThinInstances\",\r\n                \"hasBoundingInfo\",\r\n            ],\r\n            []\r\n        );\r\n\r\n        // Bounding info\r\n        this.refreshBoundingInfo();\r\n\r\n        // Parent\r\n        if (newParent) {\r\n            result.parent = newParent;\r\n        }\r\n\r\n        if (!doNotCloneChildren) {\r\n            // Children\r\n            for (let index = 0; index < this.getScene().meshes.length; index++) {\r\n                const mesh = this.getScene().meshes[index];\r\n\r\n                if (mesh.parent === this) {\r\n                    mesh.clone(mesh.name, result);\r\n                }\r\n            }\r\n        }\r\n\r\n        result.computeWorldMatrix(true);\r\n\r\n        this.onClonedObservable.notifyObservers(result);\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Disposes the InstancedMesh.\r\n     * Returns nothing.\r\n     * @param doNotRecurse Set to true to not recurse into each children (recurse into each children by default)\r\n     * @param disposeMaterialAndTextures Set to true to also dispose referenced materials and textures (false by default)\r\n     */\r\n    public dispose(doNotRecurse?: boolean, disposeMaterialAndTextures = false): void {\r\n        // Remove from mesh\r\n        this._sourceMesh.removeInstance(this);\r\n        super.dispose(doNotRecurse, disposeMaterialAndTextures);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _serializeAsParent(serializationObject: any) {\r\n        super._serializeAsParent(serializationObject);\r\n\r\n        serializationObject.parentId = this._sourceMesh.uniqueId;\r\n        serializationObject.parentInstanceIndex = this._indexInSourceMeshInstanceArray;\r\n    }\r\n\r\n    /**\r\n     * Instantiate (when possible) or clone that node with its hierarchy\r\n     * @param newParent defines the new parent to use for the instance (or clone)\r\n     * @param options defines options to configure how copy is done\r\n     * @param options.doNotInstantiate defines if the model must be instantiated or just cloned\r\n     * @param options.newSourcedMesh newSourcedMesh the new source mesh for the instance (or clone)\r\n     * @param onNewNodeCreated defines an option callback to call when a clone or an instance is created\r\n     * @returns an instance (or a clone) of the current node with its hierarchy\r\n     */\r\n    public instantiateHierarchy(\r\n        newParent: Nullable<TransformNode> = null,\r\n        options?: { doNotInstantiate: boolean | ((node: TransformNode) => boolean); newSourcedMesh?: Mesh },\r\n        onNewNodeCreated?: (source: TransformNode, clone: TransformNode) => void\r\n    ): Nullable<TransformNode> {\r\n        const clone = this.clone(\"Clone of \" + (this.name || this.id), newParent || this.parent, true, options && options.newSourcedMesh);\r\n\r\n        if (clone) {\r\n            if (onNewNodeCreated) {\r\n                onNewNodeCreated(this, clone);\r\n            }\r\n        }\r\n\r\n        for (const child of this.getChildTransformNodes(true)) {\r\n            child.instantiateHierarchy(clone, options, onNewNodeCreated);\r\n        }\r\n\r\n        return clone;\r\n    }\r\n}\r\n\r\ndeclare module \"./mesh\" {\r\n    export interface Mesh {\r\n        /**\r\n         * Register a custom buffer that will be instanced\r\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/copies/instances#custom-buffers\r\n         * @param kind defines the buffer kind\r\n         * @param stride defines the stride in floats\r\n         */\r\n        registerInstancedBuffer(kind: string, stride: number): void;\r\n\r\n        /**\r\n         * Invalidate VertexArrayObjects belonging to the mesh (but not to the Geometry of the mesh).\r\n         */\r\n        _invalidateInstanceVertexArrayObject(): void;\r\n\r\n        /**\r\n         * true to use the edge renderer for all instances of this mesh\r\n         */\r\n        edgesShareWithInstances: boolean;\r\n\r\n        /** @internal */\r\n        _userInstancedBuffersStorage: {\r\n            data: { [key: string]: Float32Array };\r\n            sizes: { [key: string]: number };\r\n            vertexBuffers: { [key: string]: Nullable<VertexBuffer> };\r\n            strides: { [key: string]: number };\r\n            vertexArrayObjects?: { [key: string]: WebGLVertexArrayObject };\r\n        };\r\n    }\r\n}\r\n\r\ndeclare module \"./abstractMesh\" {\r\n    export interface AbstractMesh {\r\n        /**\r\n         * Object used to store instanced buffers defined by user\r\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/copies/instances#custom-buffers\r\n         */\r\n        instancedBuffers: { [key: string]: any };\r\n    }\r\n}\r\n\r\nMesh.prototype.registerInstancedBuffer = function (kind: string, stride: number): void {\r\n    // Remove existing one\r\n    this._userInstancedBuffersStorage?.vertexBuffers[kind]?.dispose();\r\n\r\n    // Creates the instancedBuffer field if not present\r\n    if (!this.instancedBuffers) {\r\n        this.instancedBuffers = {};\r\n\r\n        for (const instance of this.instances) {\r\n            instance.instancedBuffers = {};\r\n        }\r\n    }\r\n\r\n    if (!this._userInstancedBuffersStorage) {\r\n        this._userInstancedBuffersStorage = {\r\n            data: {},\r\n            vertexBuffers: {},\r\n            strides: {},\r\n            sizes: {},\r\n            vertexArrayObjects: this.getEngine().getCaps().vertexArrayObject ? {} : undefined,\r\n        };\r\n    }\r\n\r\n    // Creates an empty property for this kind\r\n    this.instancedBuffers[kind] = null;\r\n\r\n    this._userInstancedBuffersStorage.strides[kind] = stride;\r\n    this._userInstancedBuffersStorage.sizes[kind] = stride * 32; // Initial size\r\n    this._userInstancedBuffersStorage.data[kind] = new Float32Array(this._userInstancedBuffersStorage.sizes[kind]);\r\n    this._userInstancedBuffersStorage.vertexBuffers[kind] = new VertexBuffer(this.getEngine(), this._userInstancedBuffersStorage.data[kind], kind, true, false, stride, true);\r\n\r\n    for (const instance of this.instances) {\r\n        instance.instancedBuffers[kind] = null;\r\n    }\r\n\r\n    this._invalidateInstanceVertexArrayObject();\r\n\r\n    this._markSubMeshesAsAttributesDirty();\r\n};\r\n\r\nMesh.prototype._processInstancedBuffers = function (visibleInstances: Nullable<InstancedMesh[]>, renderSelf: boolean) {\r\n    const instanceCount = visibleInstances ? visibleInstances.length : 0;\r\n\r\n    for (const kind in this.instancedBuffers) {\r\n        let size = this._userInstancedBuffersStorage.sizes[kind];\r\n        const stride = this._userInstancedBuffersStorage.strides[kind];\r\n\r\n        // Resize if required\r\n        const expectedSize = (instanceCount + 1) * stride;\r\n\r\n        while (size < expectedSize) {\r\n            size *= 2;\r\n        }\r\n\r\n        if (this._userInstancedBuffersStorage.data[kind].length != size) {\r\n            this._userInstancedBuffersStorage.data[kind] = new Float32Array(size);\r\n            this._userInstancedBuffersStorage.sizes[kind] = size;\r\n            if (this._userInstancedBuffersStorage.vertexBuffers[kind]) {\r\n                this._userInstancedBuffersStorage.vertexBuffers[kind]!.dispose();\r\n                this._userInstancedBuffersStorage.vertexBuffers[kind] = null;\r\n            }\r\n        }\r\n\r\n        const data = this._userInstancedBuffersStorage.data[kind];\r\n\r\n        // Update data buffer\r\n        let offset = 0;\r\n        if (renderSelf) {\r\n            const value = this.instancedBuffers[kind];\r\n\r\n            if (value.toArray) {\r\n                value.toArray(data, offset);\r\n            } else if (value.copyToArray) {\r\n                value.copyToArray(data, offset);\r\n            } else {\r\n                data[offset] = value;\r\n            }\r\n\r\n            offset += stride;\r\n        }\r\n\r\n        for (let instanceIndex = 0; instanceIndex < instanceCount; instanceIndex++) {\r\n            const instance = visibleInstances![instanceIndex]!;\r\n\r\n            const value = instance.instancedBuffers[kind];\r\n\r\n            if (value.toArray) {\r\n                value.toArray(data, offset);\r\n            } else if (value.copyToArray) {\r\n                value.copyToArray(data, offset);\r\n            } else {\r\n                data[offset] = value;\r\n            }\r\n\r\n            offset += stride;\r\n        }\r\n\r\n        // Update vertex buffer\r\n        if (!this._userInstancedBuffersStorage.vertexBuffers[kind]) {\r\n            this._userInstancedBuffersStorage.vertexBuffers[kind] = new VertexBuffer(\r\n                this.getEngine(),\r\n                this._userInstancedBuffersStorage.data[kind],\r\n                kind,\r\n                true,\r\n                false,\r\n                stride,\r\n                true\r\n            );\r\n            this._invalidateInstanceVertexArrayObject();\r\n        } else {\r\n            this._userInstancedBuffersStorage.vertexBuffers[kind]!.updateDirectly(data, 0);\r\n        }\r\n    }\r\n};\r\n\r\nMesh.prototype._invalidateInstanceVertexArrayObject = function () {\r\n    if (!this._userInstancedBuffersStorage || this._userInstancedBuffersStorage.vertexArrayObjects === undefined) {\r\n        return;\r\n    }\r\n\r\n    for (const kind in this._userInstancedBuffersStorage.vertexArrayObjects) {\r\n        this.getEngine().releaseVertexArrayObject(this._userInstancedBuffersStorage.vertexArrayObjects[kind]);\r\n    }\r\n\r\n    this._userInstancedBuffersStorage.vertexArrayObjects = {};\r\n};\r\n\r\nMesh.prototype._disposeInstanceSpecificData = function () {\r\n    if (this._instanceDataStorage.instancesBuffer) {\r\n        this._instanceDataStorage.instancesBuffer.dispose();\r\n        this._instanceDataStorage.instancesBuffer = null;\r\n    }\r\n\r\n    while (this.instances.length) {\r\n        this.instances[0].dispose();\r\n    }\r\n\r\n    for (const kind in this.instancedBuffers) {\r\n        if (this._userInstancedBuffersStorage.vertexBuffers[kind]) {\r\n            this._userInstancedBuffersStorage.vertexBuffers[kind]!.dispose();\r\n        }\r\n    }\r\n\r\n    this._invalidateInstanceVertexArrayObject();\r\n\r\n    this.instancedBuffers = {};\r\n};\r\n", "\n\nexport default function (noa) {\n\n    var compName = 'smoothCamera'\n\n    return {\n\n        name: compName,\n\n        order: 99,\n\n        state: {\n            time: 100.1\n        },\n\n        onAdd: null,\n\n        onRemove: null,\n\n        system: function (dt, states) {\n            // remove self after time elapses\n            for (var i = 0; i < states.length; i++) {\n                var state = states[i]\n                state.time -= dt\n                if (state.time < 0) noa.ents.removeComponent(state.__id, compName)\n            }\n        },\n\n    }\n}\n", "\n\n\n\n// helper to swap item to end and pop(), instead of splice()ing\nexport function removeUnorderedListItem(list, item) {\n    var i = list.indexOf(item)\n    if (i < 0) return\n    if (i === list.length - 1) {\n        list.pop()\n    } else {\n        list[i] = list.pop()\n    }\n}\n\n\n\n\n\n\n\n// ....\nexport function numberOfVoxelsInSphere(rad) {\n    if (rad === prevRad) return prevAnswer\n    var ext = Math.ceil(rad), ct = 0, rsq = rad * rad\n    for (var i = -ext; i <= ext; ++i) {\n        for (var j = -ext; j <= ext; ++j) {\n            for (var k = -ext; k <= ext; ++k) {\n                var dsq = i * i + j * j + k * k\n                if (dsq < rsq) ct++\n            }\n        }\n    }\n    prevRad = rad\n    prevAnswer = ct\n    return ct\n}\nvar prevRad = 0, prevAnswer = 0\n\n\n\n\n\n// partly \"unrolled\" loops to copy contents of ndarrays\n// when there's no source, zeroes out the array instead\nexport function copyNdarrayContents(src, tgt, pos, size, tgtPos) {\n    if (typeof src === 'number') {\n        doNdarrayFill(src, tgt, tgtPos[0], tgtPos[1], tgtPos[2],\n            size[0], size[1], size[2])\n    } else {\n        doNdarrayCopy(src, tgt, pos[0], pos[1], pos[2],\n            size[0], size[1], size[2], tgtPos[0], tgtPos[1], tgtPos[2])\n    }\n}\nfunction doNdarrayCopy(src, tgt, i0, j0, k0, si, sj, sk, ti, tj, tk) {\n    var sdx = src.stride[2]\n    var tdx = tgt.stride[2]\n    for (var i = 0; i < si; i++) {\n        for (var j = 0; j < sj; j++) {\n            var six = src.index(i0 + i, j0 + j, k0)\n            var tix = tgt.index(ti + i, tj + j, tk)\n            for (var k = 0; k < sk; k++) {\n                tgt.data[tix] = src.data[six]\n                six += sdx\n                tix += tdx\n            }\n        }\n    }\n}\n\nfunction doNdarrayFill(value, tgt, i0, j0, k0, si, sj, sk) {\n    var dx = tgt.stride[2]\n    for (var i = 0; i < si; i++) {\n        for (var j = 0; j < sj; j++) {\n            var ix = tgt.index(i0 + i, j0 + j, k0)\n            for (var k = 0; k < sk; k++) {\n                tgt.data[ix] = value\n                ix += dx\n            }\n        }\n    }\n}\n\n\n\n\n// iterates over 3D positions a given manhattan distance from (0,0,0)\n// and exit early if the callback returns true\n// skips locations beyond a horiz or vertical max distance\nexport function iterateOverShellAtDistance(d, xmax, ymax, cb) {\n    if (d === 0) return cb(0, 0, 0)\n    // larger top/bottom planes of current shell\n    var dx = Math.min(d, xmax)\n    var dy = Math.min(d, ymax)\n    if (d <= ymax) {\n        for (var x = -dx; x <= dx; x++) {\n            for (var z = -dx; z <= dx; z++) {\n                if (cb(x, d, z)) return true\n                if (cb(x, -d, z)) return true\n            }\n        }\n    }\n    // smaller side planes of shell\n    if (d <= xmax) {\n        for (var i = -d; i < d; i++) {\n            for (var y = -dy + 1; y < dy; y++) {\n                if (cb(i, y, d)) return true\n                if (cb(-i, y, -d)) return true\n                if (cb(d, y, -i)) return true\n                if (cb(-d, y, i)) return true\n            }\n        }\n    }\n    return false\n}\n\n\n\n\n\n\n// function to hash three indexes (i,j,k) into one integer\n// note that hash wraps around every 1024 indexes.\n//      i.e.:   hash(1, 1, 1) === hash(1025, 1, -1023)\nexport function locationHasher(i, j, k) {\n    return (i & 1023)\n        | ((j & 1023) << 10)\n        | ((k & 1023) << 20)\n}\n\n\n\n/*\n * \n *      chunkStorage - a Map-backed abstraction for storing/\n *      retrieving chunk objects by their location indexes\n * \n*/\n\n/** @internal */\nexport class ChunkStorage {\n    constructor() {\n        this.hash = {}\n    }\n\n    /** @returns {import('./chunk').Chunk} */\n    getChunkByIndexes(i = 0, j = 0, k = 0) {\n        return this.hash[locationHasher(i, j, k)] || null\n    }\n    /** @param {import('./chunk').Chunk} chunk */\n    storeChunkByIndexes(i = 0, j = 0, k = 0, chunk) {\n        this.hash[locationHasher(i, j, k)] = chunk\n    }\n    removeChunkByIndexes(i = 0, j = 0, k = 0) {\n        delete this.hash[locationHasher(i, j, k)]\n    }\n}\n\n\n\n\n\n\n/*\n * \n *      LocationQueue - simple array of [i,j,k] locations, \n *      backed by a hash for O(1) existence checks.\n *      removals by value are O(n).\n * \n*/\n\n/** @internal */\nexport class LocationQueue {\n    constructor() {\n        this.arr = []\n        this.hash = {}\n    }\n    forEach(cb, thisArg) {\n        this.arr.forEach(cb, thisArg)\n    }\n    includes(i, j, k) {\n        var id = locationHasher(i, j, k)\n        return !!this.hash[id]\n    }\n    add(i, j, k, toFront = false) {\n        var id = locationHasher(i, j, k)\n        if (this.hash[id]) return\n        if (toFront) {\n            this.arr.unshift([i, j, k, id])\n        } else {\n            this.arr.push([i, j, k, id])\n        }\n        this.hash[id] = true\n    }\n    removeByIndex(ix) {\n        var el = this.arr[ix]\n        delete this.hash[el[3]]\n        this.arr.splice(ix, 1)\n    }\n    remove(i, j, k) {\n        var id = locationHasher(i, j, k)\n        if (!this.hash[id]) return\n        delete this.hash[id]\n        for (var ix = 0; ix < this.arr.length; ix++) {\n            if (id === this.arr[ix][3]) {\n                this.arr.splice(ix, 1)\n                return\n            }\n        }\n        throw 'internal bug with location queue - hash value overlapped'\n    }\n    count() { return this.arr.length }\n    isEmpty() { return (this.arr.length === 0) }\n    empty() {\n        this.arr = []\n        this.hash = {}\n    }\n    pop() {\n        var el = this.arr.pop()\n        delete this.hash[el[3]]\n        return el\n    }\n    copyFrom(queue) {\n        this.arr = queue.arr.slice()\n        this.hash = {}\n        for (var key in queue.hash) this.hash[key] = true\n    }\n    sortByDistance(locToDist, reverse = false) {\n        sortLocationArrByDistance(this.arr, locToDist, reverse)\n    }\n}\n\n// internal helper for preceding class\nfunction sortLocationArrByDistance(arr, distFn, reverse) {\n    var hash = {}\n    for (var loc of arr) {\n        hash[loc[3]] = distFn(loc[0], loc[1], loc[2])\n    }\n    if (reverse) {\n        arr.sort((a, b) => hash[a[3]] - hash[b[3]]) // ascending\n    } else {\n        arr.sort((a, b) => hash[b[3]] - hash[a[3]]) // descending\n    }\n    hash = null\n}\n\n\n\n\n\n\n\n\n\n\n\n// simple thing for reporting time split up between several activities\nexport function makeProfileHook(every, title = '', filter) {\n    if (!(every > 0)) return () => { }\n    var times = {}\n    var started = 0, last = 0, iter = 0, total = 0\n\n    var start = () => {\n        started = last = performance.now()\n        iter++\n    }\n    var add = (name) => {\n        var t = performance.now()\n        times[name] = (times[name] || 0) + (t - last)\n        last = t\n    }\n    var report = () => {\n        total += performance.now() - started\n        if (iter < every) return\n        var out = `${title}: ${(total / every).toFixed(2)}ms  --  `\n        out += Object.keys(times).map(name => {\n            if (filter && (times[name] / total) < 0.05) return ''\n            return `${name}: ${(times[name] / iter).toFixed(2)}ms`\n        }).join('  ')\n        console.log(out + `    (avg over ${every} runs)`)\n        times = {}\n        iter = total = 0\n    }\n    return (state) => {\n        if (state === 'start') start()\n        else if (state === 'end') report()\n        else add(state)\n    }\n}\n\n\n\n\n// simple thing for reporting time actions/sec\nexport function makeThroughputHook(_every, _title, filter) {\n    var title = _title || ''\n    var every = _every || 1\n    var counts = {}\n    var started = performance.now()\n    var iter = 0\n    return function profile_hook(state) {\n        if (state === 'start') return\n        if (state === 'end') {\n            if (++iter < every) return\n            var t = performance.now()\n            console.log(title + '   ' + Object.keys(counts).map(k => {\n                var through = counts[k] / (t - started) * 1000\n                counts[k] = 0\n                return k + ':' + through.toFixed(2) + '   '\n            }).join(''))\n            started = t\n            iter = 0\n        } else {\n            if (!counts[state]) counts[state] = 0\n            counts[state]++\n        }\n    }\n}\n", "import type { Nullable, DeepImmutableObject } from \"../types\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport { VertexBuffer, Buffer } from \"../Buffers/buffer\";\r\nimport { Matrix, Vector3, TmpVectors } from \"../Maths/math.vector\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport { BoundingInfo } from \"core/Culling/boundingInfo\";\r\n\r\ndeclare module \"./mesh\" {\r\n    export interface Mesh {\r\n        /**\r\n         * Gets or sets a boolean defining if we want picking to pick thin instances as well\r\n         */\r\n        thinInstanceEnablePicking: boolean;\r\n\r\n        /**\r\n         * Indicates that a buffer created as static should be recreated if the buffer is updated (by calling thinInstanceSetMatrixAt or thinInstanceSetAttributeAt, for eg.)\r\n         * If this flag is false (the default behavior), a buffer created as \"static\" won't show any update done to it, and will stay the same as it was created.\r\n         * Note however that recreating a buffer each time there's a change will have some performance cost, that's why it is set to false by default.\r\n         * You should set this flag to true only if your static buffers should change infrequently. If they change frequently, you should create your buffers as \"dynamic\" instead.\r\n         */\r\n        thinInstanceAllowAutomaticStaticBufferRecreation: boolean;\r\n\r\n        /**\r\n         * Creates a new thin instance\r\n         * @param matrix the matrix or array of matrices (position, rotation, scale) of the thin instance(s) to create\r\n         * @param refresh true to refresh the underlying gpu buffer (default: true). If you do multiple calls to this method in a row, set refresh to true only for the last call to save performance\r\n         * @returns the thin instance index number. If you pass an array of matrices, other instance indexes are index+1, index+2, etc\r\n         */\r\n        thinInstanceAdd(matrix: DeepImmutableObject<Matrix> | Array<DeepImmutableObject<Matrix>>, refresh?: boolean): number;\r\n\r\n        /**\r\n         * Adds the transformation (matrix) of the current mesh as a thin instance\r\n         * @param refresh true to refresh the underlying gpu buffer (default: true). If you do multiple calls to this method in a row, set refresh to true only for the last call to save performance\r\n         * @returns the thin instance index number\r\n         */\r\n        thinInstanceAddSelf(refresh?: boolean): number;\r\n\r\n        /**\r\n         * Registers a custom attribute to be used with thin instances\r\n         * @param kind name of the attribute\r\n         * @param stride size in floats of the attribute\r\n         */\r\n        thinInstanceRegisterAttribute(kind: string, stride: number): void;\r\n\r\n        /**\r\n         * Sets the matrix of a thin instance\r\n         * @param index index of the thin instance\r\n         * @param matrix matrix to set\r\n         * @param refresh true to refresh the underlying gpu buffer (default: true). If you do multiple calls to this method in a row, set refresh to true only for the last call to save performance\r\n         */\r\n        thinInstanceSetMatrixAt(index: number, matrix: DeepImmutableObject<Matrix>, refresh?: boolean): void;\r\n\r\n        /**\r\n         * Sets the value of a custom attribute for a thin instance\r\n         * @param kind name of the attribute\r\n         * @param index index of the thin instance\r\n         * @param value value to set\r\n         * @param refresh true to refresh the underlying gpu buffer (default: true). If you do multiple calls to this method in a row, set refresh to true only for the last call to save performance\r\n         */\r\n        thinInstanceSetAttributeAt(kind: string, index: number, value: Array<number>, refresh?: boolean): void;\r\n\r\n        /**\r\n         * Gets / sets the number of thin instances to display. Note that you can't set a number higher than what the underlying buffer can handle.\r\n         */\r\n        thinInstanceCount: number;\r\n\r\n        /**\r\n         * Sets a buffer to be used with thin instances. This method is a faster way to setup multiple instances than calling thinInstanceAdd repeatedly\r\n         * @param kind name of the attribute. Use \"matrix\" to setup the buffer of matrices\r\n         * @param buffer buffer to set\r\n         * @param stride size in floats of each value of the buffer\r\n         * @param staticBuffer indicates that the buffer is static, so that you won't change it after it is set (better performances - true by default)\r\n         */\r\n        thinInstanceSetBuffer(kind: string, buffer: Nullable<Float32Array>, stride?: number, staticBuffer?: boolean): void;\r\n\r\n        /**\r\n         * Gets the list of world matrices\r\n         * @returns an array containing all the world matrices from the thin instances\r\n         */\r\n        thinInstanceGetWorldMatrices(): Matrix[];\r\n\r\n        /**\r\n         * Synchronize the gpu buffers with a thin instance buffer. Call this method if you update later on the buffers passed to thinInstanceSetBuffer\r\n         * @param kind name of the attribute to update. Use \"matrix\" to update the buffer of matrices\r\n         */\r\n        thinInstanceBufferUpdated(kind: string): void;\r\n\r\n        /**\r\n         * Applies a partial update to a buffer directly on the GPU\r\n         * Note that the buffer located on the CPU is NOT updated! It's up to you to update it (or not) with the same data you pass to this method\r\n         * @param kind name of the attribute to update. Use \"matrix\" to update the buffer of matrices\r\n         * @param data the data to set in the GPU buffer\r\n         * @param offset the offset in the GPU buffer where to update the data\r\n         */\r\n        thinInstancePartialBufferUpdate(kind: string, data: Float32Array, offset: number): void;\r\n\r\n        /**\r\n         * Refreshes the bounding info, taking into account all the thin instances defined\r\n         * @param forceRefreshParentInfo true to force recomputing the mesh bounding info and use it to compute the aggregated bounding info\r\n         * @param applySkeleton defines whether to apply the skeleton before computing the bounding info\r\n         * @param applyMorph  defines whether to apply the morph target before computing the bounding info\r\n         */\r\n        thinInstanceRefreshBoundingInfo(forceRefreshParentInfo?: boolean, applySkeleton?: boolean, applyMorph?: boolean): void;\r\n\r\n        /** @internal */\r\n        _thinInstanceInitializeUserStorage(): void;\r\n\r\n        /** @internal */\r\n        _thinInstanceUpdateBufferSize(kind: string, numInstances?: number): void;\r\n\r\n        /** @internal */\r\n        _thinInstanceCreateMatrixBuffer(kind: string, buffer: Nullable<Float32Array>, staticBuffer: boolean): Buffer;\r\n\r\n        /** @internal */\r\n        _thinInstanceRecreateBuffer(kind: string, staticBuffer?: boolean): void;\r\n\r\n        /** @internal */\r\n        _userThinInstanceBuffersStorage: {\r\n            data: { [key: string]: Float32Array };\r\n            sizes: { [key: string]: number };\r\n            vertexBuffers: { [key: string]: Nullable<VertexBuffer> };\r\n            strides: { [key: string]: number };\r\n        };\r\n    }\r\n}\r\n\r\nMesh.prototype.thinInstanceAdd = function (matrix: DeepImmutableObject<Matrix> | Array<DeepImmutableObject<Matrix>>, refresh: boolean = true): number {\r\n    if (!this.getScene().getEngine().getCaps().instancedArrays) {\r\n        Logger.Error(\"Thin Instances are not supported on this device as Instanced Array extension not supported\");\r\n        return -1;\r\n    }\r\n\r\n    this._thinInstanceUpdateBufferSize(\"matrix\", Array.isArray(matrix) ? matrix.length : 1);\r\n\r\n    const index = this._thinInstanceDataStorage.instancesCount;\r\n\r\n    if (Array.isArray(matrix)) {\r\n        for (let i = 0; i < matrix.length; ++i) {\r\n            this.thinInstanceSetMatrixAt(this._thinInstanceDataStorage.instancesCount++, matrix[i], i === matrix.length - 1 && refresh);\r\n        }\r\n    } else {\r\n        this.thinInstanceSetMatrixAt(this._thinInstanceDataStorage.instancesCount++, matrix, refresh);\r\n    }\r\n\r\n    return index;\r\n};\r\n\r\nMesh.prototype.thinInstanceAddSelf = function (refresh: boolean = true): number {\r\n    return this.thinInstanceAdd(Matrix.IdentityReadOnly, refresh);\r\n};\r\n\r\nMesh.prototype.thinInstanceRegisterAttribute = function (kind: string, stride: number): void {\r\n    // preserve backward compatibility\r\n    if (kind === VertexBuffer.ColorKind) {\r\n        kind = VertexBuffer.ColorInstanceKind;\r\n    }\r\n\r\n    this.removeVerticesData(kind);\r\n\r\n    this._thinInstanceInitializeUserStorage();\r\n\r\n    this._userThinInstanceBuffersStorage.strides[kind] = stride;\r\n    this._userThinInstanceBuffersStorage.sizes[kind] = stride * Math.max(32, this._thinInstanceDataStorage.instancesCount); // Initial size\r\n    this._userThinInstanceBuffersStorage.data[kind] = new Float32Array(this._userThinInstanceBuffersStorage.sizes[kind]);\r\n    this._userThinInstanceBuffersStorage.vertexBuffers[kind] = new VertexBuffer(this.getEngine(), this._userThinInstanceBuffersStorage.data[kind], kind, true, false, stride, true);\r\n\r\n    this.setVerticesBuffer(this._userThinInstanceBuffersStorage.vertexBuffers[kind]!);\r\n};\r\n\r\nMesh.prototype.thinInstanceSetMatrixAt = function (index: number, matrix: DeepImmutableObject<Matrix>, refresh: boolean = true): boolean {\r\n    if (!this._thinInstanceDataStorage.matrixData || index >= this._thinInstanceDataStorage.instancesCount) {\r\n        return false;\r\n    }\r\n\r\n    const matrixData = this._thinInstanceDataStorage.matrixData;\r\n\r\n    matrix.copyToArray(matrixData, index * 16);\r\n\r\n    if (this._thinInstanceDataStorage.worldMatrices) {\r\n        this._thinInstanceDataStorage.worldMatrices[index] = matrix as Matrix;\r\n    }\r\n\r\n    if (refresh) {\r\n        this.thinInstanceBufferUpdated(\"matrix\");\r\n\r\n        if (!this.doNotSyncBoundingInfo) {\r\n            this.thinInstanceRefreshBoundingInfo(false);\r\n        }\r\n    }\r\n\r\n    return true;\r\n};\r\n\r\nMesh.prototype.thinInstanceSetAttributeAt = function (kind: string, index: number, value: Array<number>, refresh: boolean = true): boolean {\r\n    // preserve backward compatibility\r\n    if (kind === VertexBuffer.ColorKind) {\r\n        kind = VertexBuffer.ColorInstanceKind;\r\n    }\r\n\r\n    if (!this._userThinInstanceBuffersStorage || !this._userThinInstanceBuffersStorage.data[kind] || index >= this._thinInstanceDataStorage.instancesCount) {\r\n        return false;\r\n    }\r\n\r\n    this._thinInstanceUpdateBufferSize(kind, 0); // make sur the buffer for the kind attribute is big enough\r\n\r\n    this._userThinInstanceBuffersStorage.data[kind].set(value, index * this._userThinInstanceBuffersStorage.strides[kind]);\r\n\r\n    if (refresh) {\r\n        this.thinInstanceBufferUpdated(kind);\r\n    }\r\n\r\n    return true;\r\n};\r\n\r\nObject.defineProperty(Mesh.prototype, \"thinInstanceCount\", {\r\n    get: function (this: Mesh) {\r\n        return this._thinInstanceDataStorage.instancesCount;\r\n    },\r\n    set: function (this: Mesh, value: number) {\r\n        const matrixData = this._thinInstanceDataStorage.matrixData ?? this.source?._thinInstanceDataStorage.matrixData;\r\n        const numMaxInstances = matrixData ? matrixData.length / 16 : 0;\r\n\r\n        if (value <= numMaxInstances) {\r\n            this._thinInstanceDataStorage.instancesCount = value;\r\n        }\r\n    },\r\n    enumerable: true,\r\n    configurable: true,\r\n});\r\n\r\nMesh.prototype._thinInstanceCreateMatrixBuffer = function (kind: string, buffer: Float32Array, staticBuffer: boolean = true): Buffer {\r\n    const matrixBuffer = new Buffer(this.getEngine(), buffer, !staticBuffer, 16, false, true);\r\n\r\n    for (let i = 0; i < 4; i++) {\r\n        this.setVerticesBuffer(matrixBuffer.createVertexBuffer(kind + i, i * 4, 4));\r\n    }\r\n\r\n    return matrixBuffer;\r\n};\r\n\r\nMesh.prototype.thinInstanceSetBuffer = function (kind: string, buffer: Nullable<Float32Array>, stride: number = 0, staticBuffer: boolean = true): void {\r\n    stride = stride || 16;\r\n\r\n    if (kind === \"matrix\") {\r\n        this._thinInstanceDataStorage.matrixBuffer?.dispose();\r\n        this._thinInstanceDataStorage.matrixBuffer = null;\r\n        this._thinInstanceDataStorage.matrixBufferSize = buffer ? buffer.length : 32 * stride;\r\n        this._thinInstanceDataStorage.matrixData = buffer;\r\n        this._thinInstanceDataStorage.worldMatrices = null;\r\n\r\n        if (buffer !== null) {\r\n            this._thinInstanceDataStorage.instancesCount = buffer.length / stride;\r\n            this._thinInstanceDataStorage.matrixBuffer = this._thinInstanceCreateMatrixBuffer(\"world\", buffer, staticBuffer);\r\n\r\n            if (!this.doNotSyncBoundingInfo) {\r\n                this.thinInstanceRefreshBoundingInfo(false);\r\n            }\r\n        } else {\r\n            this._thinInstanceDataStorage.instancesCount = 0;\r\n            if (!this.doNotSyncBoundingInfo) {\r\n                // mesh has no more thin instances, so need to recompute the bounding box because it's the regular mesh that will now be displayed\r\n                this.refreshBoundingInfo();\r\n            }\r\n        }\r\n    } else if (kind === \"previousMatrix\") {\r\n        this._thinInstanceDataStorage.previousMatrixBuffer?.dispose();\r\n        this._thinInstanceDataStorage.previousMatrixBuffer = null;\r\n        this._thinInstanceDataStorage.previousMatrixData = buffer;\r\n        if (buffer !== null) {\r\n            this._thinInstanceDataStorage.previousMatrixBuffer = this._thinInstanceCreateMatrixBuffer(\"previousWorld\", buffer, staticBuffer);\r\n        }\r\n    } else {\r\n        // color for instanced mesh is ColorInstanceKind and not ColorKind because of native that needs to do the differenciation\r\n        // hot switching kind here to preserve backward compatibility\r\n        if (kind === VertexBuffer.ColorKind) {\r\n            kind = VertexBuffer.ColorInstanceKind;\r\n        }\r\n\r\n        if (buffer === null) {\r\n            if (this._userThinInstanceBuffersStorage?.data[kind]) {\r\n                this.removeVerticesData(kind);\r\n                delete this._userThinInstanceBuffersStorage.data[kind];\r\n                delete this._userThinInstanceBuffersStorage.strides[kind];\r\n                delete this._userThinInstanceBuffersStorage.sizes[kind];\r\n                delete this._userThinInstanceBuffersStorage.vertexBuffers[kind];\r\n            }\r\n        } else {\r\n            this._thinInstanceInitializeUserStorage();\r\n\r\n            this._userThinInstanceBuffersStorage.data[kind] = buffer;\r\n            this._userThinInstanceBuffersStorage.strides[kind] = stride;\r\n            this._userThinInstanceBuffersStorage.sizes[kind] = buffer.length;\r\n            this._userThinInstanceBuffersStorage.vertexBuffers[kind] = new VertexBuffer(this.getEngine(), buffer, kind, !staticBuffer, false, stride, true);\r\n\r\n            this.setVerticesBuffer(this._userThinInstanceBuffersStorage.vertexBuffers[kind]!);\r\n        }\r\n    }\r\n};\r\n\r\nMesh.prototype.thinInstanceBufferUpdated = function (kind: string): void {\r\n    if (kind === \"matrix\") {\r\n        if (this.thinInstanceAllowAutomaticStaticBufferRecreation && this._thinInstanceDataStorage.matrixBuffer && !this._thinInstanceDataStorage.matrixBuffer.isUpdatable()) {\r\n            this._thinInstanceRecreateBuffer(kind);\r\n        }\r\n        this._thinInstanceDataStorage.matrixBuffer?.updateDirectly(this._thinInstanceDataStorage.matrixData!, 0, this._thinInstanceDataStorage.instancesCount);\r\n    } else if (kind === \"previousMatrix\") {\r\n        if (\r\n            this.thinInstanceAllowAutomaticStaticBufferRecreation &&\r\n            this._thinInstanceDataStorage.previousMatrixBuffer &&\r\n            !this._thinInstanceDataStorage.previousMatrixBuffer.isUpdatable()\r\n        ) {\r\n            this._thinInstanceRecreateBuffer(kind);\r\n        }\r\n        this._thinInstanceDataStorage.previousMatrixBuffer?.updateDirectly(this._thinInstanceDataStorage.previousMatrixData!, 0, this._thinInstanceDataStorage.instancesCount);\r\n    } else {\r\n        // preserve backward compatibility\r\n        if (kind === VertexBuffer.ColorKind) {\r\n            kind = VertexBuffer.ColorInstanceKind;\r\n        }\r\n\r\n        if (this._userThinInstanceBuffersStorage?.vertexBuffers[kind]) {\r\n            if (this.thinInstanceAllowAutomaticStaticBufferRecreation && !this._userThinInstanceBuffersStorage.vertexBuffers[kind]!.isUpdatable()) {\r\n                this._thinInstanceRecreateBuffer(kind);\r\n            }\r\n            this._userThinInstanceBuffersStorage.vertexBuffers[kind]!.updateDirectly(this._userThinInstanceBuffersStorage.data[kind], 0);\r\n        }\r\n    }\r\n};\r\n\r\nMesh.prototype.thinInstancePartialBufferUpdate = function (kind: string, data: Float32Array, offset: number): void {\r\n    if (kind === \"matrix\") {\r\n        if (this._thinInstanceDataStorage.matrixBuffer) {\r\n            this._thinInstanceDataStorage.matrixBuffer.updateDirectly(data, offset);\r\n        }\r\n    } else {\r\n        // preserve backward compatibility\r\n        if (kind === VertexBuffer.ColorKind) {\r\n            kind = VertexBuffer.ColorInstanceKind;\r\n        }\r\n\r\n        if (this._userThinInstanceBuffersStorage?.vertexBuffers[kind]) {\r\n            this._userThinInstanceBuffersStorage.vertexBuffers[kind]!.updateDirectly(data, offset);\r\n        }\r\n    }\r\n};\r\n\r\nMesh.prototype.thinInstanceGetWorldMatrices = function (): Matrix[] {\r\n    if (!this._thinInstanceDataStorage.matrixData || !this._thinInstanceDataStorage.matrixBuffer) {\r\n        return [];\r\n    }\r\n    const matrixData = this._thinInstanceDataStorage.matrixData;\r\n\r\n    if (!this._thinInstanceDataStorage.worldMatrices) {\r\n        this._thinInstanceDataStorage.worldMatrices = [] as Matrix[];\r\n\r\n        for (let i = 0; i < this._thinInstanceDataStorage.instancesCount; ++i) {\r\n            this._thinInstanceDataStorage.worldMatrices[i] = Matrix.FromArray(matrixData, i * 16);\r\n        }\r\n    }\r\n\r\n    return this._thinInstanceDataStorage.worldMatrices;\r\n};\r\n\r\nMesh.prototype.thinInstanceRefreshBoundingInfo = function (forceRefreshParentInfo: boolean = false, applySkeleton: boolean = false, applyMorph: boolean = false) {\r\n    if (!this._thinInstanceDataStorage.matrixData || !this._thinInstanceDataStorage.matrixBuffer) {\r\n        return;\r\n    }\r\n\r\n    const vectors = this._thinInstanceDataStorage.boundingVectors;\r\n\r\n    if (forceRefreshParentInfo || !this.rawBoundingInfo) {\r\n        vectors.length = 0;\r\n        this.refreshBoundingInfo(applySkeleton, applyMorph);\r\n        const boundingInfo = this.getBoundingInfo();\r\n        this.rawBoundingInfo = new BoundingInfo(boundingInfo.minimum, boundingInfo.maximum);\r\n    }\r\n\r\n    const boundingInfo = this.getBoundingInfo();\r\n    const matrixData = this._thinInstanceDataStorage.matrixData;\r\n\r\n    if (vectors.length === 0) {\r\n        for (let v = 0; v < boundingInfo.boundingBox.vectors.length; ++v) {\r\n            vectors.push(boundingInfo.boundingBox.vectors[v].clone());\r\n        }\r\n    }\r\n\r\n    TmpVectors.Vector3[0].setAll(Number.POSITIVE_INFINITY); // min\r\n    TmpVectors.Vector3[1].setAll(Number.NEGATIVE_INFINITY); // max\r\n\r\n    for (let i = 0; i < this._thinInstanceDataStorage.instancesCount; ++i) {\r\n        Matrix.FromArrayToRef(matrixData, i * 16, TmpVectors.Matrix[0]);\r\n\r\n        for (let v = 0; v < vectors.length; ++v) {\r\n            Vector3.TransformCoordinatesToRef(vectors[v], TmpVectors.Matrix[0], TmpVectors.Vector3[2]);\r\n            TmpVectors.Vector3[0].minimizeInPlace(TmpVectors.Vector3[2]);\r\n            TmpVectors.Vector3[1].maximizeInPlace(TmpVectors.Vector3[2]);\r\n        }\r\n    }\r\n\r\n    boundingInfo.reConstruct(TmpVectors.Vector3[0], TmpVectors.Vector3[1]);\r\n\r\n    this._updateBoundingInfo();\r\n};\r\n\r\nMesh.prototype._thinInstanceRecreateBuffer = function (kind: string, staticBuffer: boolean = true) {\r\n    if (kind === \"matrix\") {\r\n        this._thinInstanceDataStorage.matrixBuffer?.dispose();\r\n        this._thinInstanceDataStorage.matrixBuffer = this._thinInstanceCreateMatrixBuffer(\"world\", this._thinInstanceDataStorage.matrixData, staticBuffer);\r\n    } else if (kind === \"previousMatrix\") {\r\n        if (this._scene.needsPreviousWorldMatrices) {\r\n            this._thinInstanceDataStorage.previousMatrixBuffer?.dispose();\r\n            this._thinInstanceDataStorage.previousMatrixBuffer = this._thinInstanceCreateMatrixBuffer(\r\n                \"previousWorld\",\r\n                this._thinInstanceDataStorage.previousMatrixData ?? this._thinInstanceDataStorage.matrixData,\r\n                staticBuffer\r\n            );\r\n        }\r\n    } else {\r\n        if (kind === VertexBuffer.ColorKind) {\r\n            kind = VertexBuffer.ColorInstanceKind;\r\n        }\r\n\r\n        this._userThinInstanceBuffersStorage.vertexBuffers[kind]?.dispose();\r\n        this._userThinInstanceBuffersStorage.vertexBuffers[kind] = new VertexBuffer(\r\n            this.getEngine(),\r\n            this._userThinInstanceBuffersStorage.data[kind],\r\n            kind,\r\n            !staticBuffer,\r\n            false,\r\n            this._userThinInstanceBuffersStorage.strides[kind],\r\n            true\r\n        );\r\n        this.setVerticesBuffer(this._userThinInstanceBuffersStorage.vertexBuffers[kind]!);\r\n    }\r\n};\r\n\r\nMesh.prototype._thinInstanceUpdateBufferSize = function (kind: string, numInstances: number = 1) {\r\n    // preserve backward compatibility\r\n    if (kind === VertexBuffer.ColorKind) {\r\n        kind = VertexBuffer.ColorInstanceKind;\r\n    }\r\n\r\n    const kindIsMatrix = kind === \"matrix\";\r\n\r\n    if (!kindIsMatrix && (!this._userThinInstanceBuffersStorage || !this._userThinInstanceBuffersStorage.strides[kind])) {\r\n        return;\r\n    }\r\n\r\n    const stride = kindIsMatrix ? 16 : this._userThinInstanceBuffersStorage.strides[kind];\r\n    const currentSize = kindIsMatrix ? this._thinInstanceDataStorage.matrixBufferSize : this._userThinInstanceBuffersStorage.sizes[kind];\r\n    let data = kindIsMatrix ? this._thinInstanceDataStorage.matrixData : this._userThinInstanceBuffersStorage.data[kind];\r\n\r\n    const bufferSize = (this._thinInstanceDataStorage.instancesCount + numInstances) * stride;\r\n\r\n    let newSize = currentSize;\r\n\r\n    while (newSize < bufferSize) {\r\n        newSize *= 2;\r\n    }\r\n\r\n    if (!data || currentSize != newSize) {\r\n        if (!data) {\r\n            data = new Float32Array(newSize);\r\n        } else {\r\n            const newData = new Float32Array(newSize);\r\n            newData.set(data, 0);\r\n            data = newData;\r\n        }\r\n\r\n        if (kindIsMatrix) {\r\n            this._thinInstanceDataStorage.matrixBuffer?.dispose();\r\n            this._thinInstanceDataStorage.matrixBuffer = this._thinInstanceCreateMatrixBuffer(\"world\", data, false);\r\n            this._thinInstanceDataStorage.matrixData = data;\r\n            this._thinInstanceDataStorage.matrixBufferSize = newSize;\r\n            if (this._scene.needsPreviousWorldMatrices && !this._thinInstanceDataStorage.previousMatrixData) {\r\n                this._thinInstanceDataStorage.previousMatrixBuffer?.dispose();\r\n                this._thinInstanceDataStorage.previousMatrixBuffer = this._thinInstanceCreateMatrixBuffer(\"previousWorld\", data, false);\r\n            }\r\n        } else {\r\n            this._userThinInstanceBuffersStorage.vertexBuffers[kind]?.dispose();\r\n\r\n            this._userThinInstanceBuffersStorage.data[kind] = data;\r\n            this._userThinInstanceBuffersStorage.sizes[kind] = newSize;\r\n            this._userThinInstanceBuffersStorage.vertexBuffers[kind] = new VertexBuffer(this.getEngine(), data, kind, true, false, stride, true);\r\n\r\n            this.setVerticesBuffer(this._userThinInstanceBuffersStorage.vertexBuffers[kind]!);\r\n        }\r\n    }\r\n};\r\n\r\nMesh.prototype._thinInstanceInitializeUserStorage = function () {\r\n    if (!this._userThinInstanceBuffersStorage) {\r\n        this._userThinInstanceBuffersStorage = {\r\n            data: {},\r\n            sizes: {},\r\n            vertexBuffers: {},\r\n            strides: {},\r\n        };\r\n    }\r\n};\r\n\r\nMesh.prototype._disposeThinInstanceSpecificData = function () {\r\n    if (this._thinInstanceDataStorage?.matrixBuffer) {\r\n        this._thinInstanceDataStorage.matrixBuffer.dispose();\r\n        this._thinInstanceDataStorage.matrixBuffer = null;\r\n    }\r\n};\r\n", "\nimport { TransformNode } from '@babylonjs/core/Meshes/transformNode'\nimport { makeProfileHook } from './util'\nimport '@babylonjs/core/Meshes/thinInstanceMesh'\n\n\nvar PROFILE = 0\n\n\n\n\n\n/*\n *\n *          Object meshing\n * \n *      Per-chunk handling of the creation/disposal of static meshes\n *      associated with particular voxel IDs\n * \n * \n*/\n\n\n/** \n * @internal\n * @param {import('../index').Engine} noa\n*/\nexport function ObjectMesher(noa) {\n\n    // transform node for all instance meshes to be parented to\n    this.rootNode = new TransformNode('objectMeshRoot', noa.rendering.scene)\n\n    // tracking rebase amount inside matrix data\n    var rebaseOffset = [0, 0, 0]\n\n    // flag to trigger a rebuild after a chunk is disposed\n    var rebuildNextTick = false\n\n    // mock object to pass to customMesh handler, to get transforms\n    var transformObj = new TransformNode('')\n\n    // list of known base meshes\n    this.allBaseMeshes = []\n\n    // internal storage of instance managers, keyed by ID\n    // has check to dedupe by mesh, since babylon chokes on\n    // separate sets of instances for the same mesh/clone/geometry\n    var managers = {}\n    var getManager = (id) => {\n        if (managers[id]) return managers[id]\n        var mesh = noa.registry._blockMeshLookup[id]\n        for (var id2 in managers) {\n            var prev = managers[id2].mesh\n            if (prev === mesh || (prev.geometry === mesh.geometry)) {\n                return managers[id] = managers[id2]\n            }\n        }\n        this.allBaseMeshes.push(mesh)\n        if (!mesh.metadata) mesh.metadata = {}\n        mesh.metadata[objectMeshFlag] = true\n        return managers[id] = new InstanceManager(noa, mesh)\n    }\n    var objectMeshFlag = 'noa_object_base_mesh'\n\n\n\n    /*\n     * \n     *      public API\n     * \n    */\n\n\n    // add any properties that will get used for meshing\n    this.initChunk = function (chunk) {\n        chunk._objectBlocks = {}\n    }\n\n\n    // called by world when an object block is set or cleared\n    this.setObjectBlock = function (chunk, blockID, i, j, k) {\n        var x = chunk.x + i\n        var y = chunk.y + j\n        var z = chunk.z + k\n        var key = `${x}:${y}:${z}`\n\n        var oldID = chunk._objectBlocks[key] || 0\n        if (oldID === blockID) return // should be impossible\n        if (oldID > 0) {\n            var oldMgr = getManager(oldID)\n            oldMgr.removeInstance(chunk, key)\n        }\n\n        if (blockID > 0) {\n            // if there's a block event handler, call it with\n            // a mock object so client can add transforms\n            var handlers = noa.registry._blockHandlerLookup[blockID]\n            var onCreate = handlers && handlers.onCustomMeshCreate\n            if (onCreate) {\n                transformObj.position.copyFromFloats(0.5, 0, 0.5)\n                transformObj.scaling.setAll(1)\n                transformObj.rotation.setAll(0)\n                onCreate(transformObj, x, y, z)\n            }\n            var mgr = getManager(blockID)\n            var xform = (onCreate) ? transformObj : null\n            mgr.addInstance(chunk, key, i, j, k, xform, rebaseOffset)\n        }\n\n        if (oldID > 0 && !blockID) delete chunk._objectBlocks[key]\n        if (blockID > 0) chunk._objectBlocks[key] = blockID\n    }\n\n\n\n    // called by world when it knows that objects have been updated\n    this.buildObjectMeshes = function () {\n        profile_hook('start')\n\n        for (var id in managers) {\n            var mgr = managers[id]\n            mgr.updateMatrix()\n            if (mgr.count === 0) mgr.dispose()\n            if (mgr.disposed) delete managers[id]\n        }\n\n        profile_hook('rebuilt')\n        profile_hook('end')\n    }\n\n\n\n    // called by world at end of chunk lifecycle\n    this.disposeChunk = function (chunk) {\n        for (var key in chunk._objectBlocks) {\n            var id = chunk._objectBlocks[key]\n            if (id > 0) {\n                var mgr = getManager(id)\n                mgr.removeInstance(chunk, key)\n            }\n        }\n        chunk._objectBlocks = null\n\n        // since some instance managers will have been updated\n        rebuildNextTick = true\n    }\n\n\n\n    // tick handler catches case where objects are dirty due to disposal\n    this.tick = function () {\n        if (rebuildNextTick) {\n            this.buildObjectMeshes()\n            rebuildNextTick = false\n        }\n    }\n\n\n\n    // world rebase handler\n    this._rebaseOrigin = function (delta) {\n        rebaseOffset[0] += delta[0]\n        rebaseOffset[1] += delta[1]\n        rebaseOffset[2] += delta[2]\n\n        for (var id1 in managers) managers[id1].rebased = false\n        for (var id2 in managers) {\n            var mgr = managers[id2]\n            if (mgr.rebased) continue\n            for (var i = 0; i < mgr.count; i++) {\n                var ix = i << 4\n                mgr.buffer[ix + 12] -= delta[0]\n                mgr.buffer[ix + 13] -= delta[1]\n                mgr.buffer[ix + 14] -= delta[2]\n            }\n            mgr.rebased = true\n            mgr.dirty = true\n        }\n        rebuildNextTick = true\n    }\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/*\n * \n * \n *      manager class for thin instances of a given object block ID \n * \n * \n*/\n\n/** @param {import('../index').Engine} noa*/\nfunction InstanceManager(noa, mesh) {\n    this.noa = noa\n    this.mesh = mesh\n    this.buffer = null\n    this.capacity = 0\n    this.count = 0\n    this.dirty = false\n    this.rebased = true\n    this.disposed = false\n    // dual struct to map keys (locations) to buffer locations, and back\n    this.keyToIndex = {}\n    this.locToKey = []\n    // prepare mesh for rendering\n    this.mesh.position.setAll(0)\n    this.mesh.parent = noa._objectMesher.rootNode\n    this.noa.rendering.addMeshToScene(this.mesh, false)\n    this.noa.emit('addingTerrainMesh', this.mesh)\n    this.mesh.isPickable = false\n    this.mesh.doNotSyncBoundingInfo = true\n    this.mesh.alwaysSelectAsActiveMesh = true\n}\n\n\n\nInstanceManager.prototype.dispose = function () {\n    if (this.disposed) return\n    this.mesh.thinInstanceCount = 0\n    this.setCapacity(0)\n    this.noa.emit('removingTerrainMesh', this.mesh)\n    this.noa.rendering.setMeshVisibility(this.mesh, false)\n    this.mesh = null\n    this.keyToIndex = null\n    this.locToKey = null\n    this.disposed = true\n}\n\n\nInstanceManager.prototype.addInstance = function (chunk, key, i, j, k, transform, rebaseVec) {\n    maybeExpandBuffer(this)\n    var ix = this.count << 4\n    this.locToKey[this.count] = key\n    this.keyToIndex[key] = ix\n    if (transform) {\n        transform.position.x += (chunk.x - rebaseVec[0]) + i\n        transform.position.y += (chunk.y - rebaseVec[1]) + j\n        transform.position.z += (chunk.z - rebaseVec[2]) + k\n        transform.computeWorldMatrix(true)\n        var xformArr = transform._localMatrix._m\n        copyMatrixData(xformArr, 0, this.buffer, ix)\n    } else {\n        var matArray = tempMatrixArray\n        matArray[12] = (chunk.x - rebaseVec[0]) + i + 0.5\n        matArray[13] = (chunk.y - rebaseVec[1]) + j\n        matArray[14] = (chunk.z - rebaseVec[2]) + k + 0.5\n        copyMatrixData(matArray, 0, this.buffer, ix)\n    }\n    this.count++\n    this.dirty = true\n}\n\n\nInstanceManager.prototype.removeInstance = function (chunk, key) {\n    var remIndex = this.keyToIndex[key]\n    if (!(remIndex >= 0)) throw 'tried to remove object instance not in storage'\n    delete this.keyToIndex[key]\n    var remLoc = remIndex >> 4\n    // copy tail instance's data to location of one we're removing\n    var tailLoc = this.count - 1\n    if (remLoc !== tailLoc) {\n        var tailIndex = tailLoc << 4\n        copyMatrixData(this.buffer, tailIndex, this.buffer, remIndex)\n        // update key/location structs\n        var tailKey = this.locToKey[tailLoc]\n        this.keyToIndex[tailKey] = remIndex\n        this.locToKey[remLoc] = tailKey\n    }\n    this.count--\n    this.dirty = true\n    maybeContractBuffer(this)\n}\n\n\nInstanceManager.prototype.updateMatrix = function () {\n    if (!this.dirty) return\n    this.mesh.thinInstanceCount = this.count\n    this.mesh.thinInstanceBufferUpdated('matrix')\n    this.mesh.isVisible = (this.count > 0)\n    this.dirty = false\n}\n\n\n\nInstanceManager.prototype.setCapacity = function (size = 4) {\n    this.capacity = size\n    if (size === 0) {\n        this.buffer = null\n    } else {\n        var newBuff = new Float32Array(this.capacity * 16)\n        if (this.buffer) {\n            var len = Math.min(this.buffer.length, newBuff.length)\n            for (var i = 0; i < len; i++) newBuff[i] = this.buffer[i]\n        }\n        this.buffer = newBuff\n    }\n    this.mesh.thinInstanceSetBuffer('matrix', this.buffer)\n    this.updateMatrix()\n}\n\n\nfunction maybeExpandBuffer(mgr) {\n    if (mgr.count < mgr.capacity) return\n    var size = Math.max(8, mgr.capacity * 2)\n    mgr.setCapacity(size)\n}\n\nfunction maybeContractBuffer(mgr) {\n    if (mgr.count > mgr.capacity * 0.4) return\n    if (mgr.capacity < 100) return\n    mgr.setCapacity(Math.round(mgr.capacity / 2))\n    mgr.locToKey.length = Math.min(mgr.locToKey.length, mgr.capacity)\n}\n\n\n\n// helpers\n\nvar tempMatrixArray = [\n    1.0, 0.0, 0.0, 0.0,\n    0.0, 1.0, 0.0, 0.0,\n    0.0, 0.0, 1.0, 0.0,\n    0.0, 0.0, 0.0, 1.0,\n]\n\nfunction copyMatrixData(src, srcOff, dest, destOff) {\n    for (var i = 0; i < 16; i++) dest[destOff + i] = src[srcOff + i]\n}\n\n\n\n\n\n\n\n\n\n\n\n\nvar profile_hook = (PROFILE) ?\n    makeProfileHook(PROFILE, 'Object meshing') : () => { }\n", "\nimport ndarray from 'ndarray'\nimport { Mesh } from '@babylonjs/core/Meshes/mesh'\nimport { VertexData } from '@babylonjs/core/Meshes/mesh.vertexData'\nimport { TerrainMatManager } from './terrainMaterials'\nimport { makeProfileHook } from './util'\n\n\n\n// enable for profiling..\nvar PROFILE_EVERY = 0\n\n\n\n\n/*\n * \n *          TERRAIN MESHER!!\n * \n * \n *  top-level entry point:\n *      takes a chunk, passes it to the greedy mesher,\n *      gets back an intermediate struct of face data,\n *      passes that to the mesh builder,\n *      gets back an array of Mesh objects,\n *      and finally puts those into the 3D engine\n *      \n*/\n\n\n/** \n * @internal\n * @param {import('../index').Engine} noa \n*/\nexport function TerrainMesher(noa) {\n\n    // wrangles which block materials can be merged into the same mesh\n    var terrainMatManager = new TerrainMatManager(noa)\n    this.allTerrainMaterials = terrainMatManager.allMaterials\n\n    // internally expose the default flat material used for untextured terrain\n    this._defaultMaterial = terrainMatManager._defaultMat\n\n    // two-pass implementations for this module\n    var greedyMesher = new GreedyMesher(noa, terrainMatManager)\n    var meshBuilder = new MeshBuilder(noa, terrainMatManager)\n\n\n    /*\n     * \n     *      API\n     * \n    */\n\n    // set or clean up any per-chunk properties needed for terrain meshing\n    this.initChunk = function (chunk) {\n        chunk._terrainMeshes.length = 0\n    }\n\n    this.disposeChunk = function (chunk) {\n        chunk._terrainMeshes.forEach(mesh => {\n            noa.emit('removingTerrainMesh', mesh)\n            mesh.dispose()\n        })\n        chunk._terrainMeshes.length = 0\n    }\n\n\n    /**\n     * meshing entry point and high-level flow\n     * @param {import('./chunk').Chunk} chunk \n     */\n    this.meshChunk = function (chunk, ignoreMaterials = false) {\n        profile_hook('start')\n\n        // remove any previous terrain meshes\n        this.disposeChunk(chunk)\n        profile_hook('cleanup')\n\n        // greedy mesher generates struct of face data\n        var faceDataSet = greedyMesher.mesh(chunk, ignoreMaterials)\n        profile_hook('geom')\n\n        // builder generates mesh data (positions, normals, etc)\n        var meshes = meshBuilder.buildMesh(chunk, faceDataSet, ignoreMaterials)\n        profile_hook('build')\n\n        profile_hook('end')\n\n        // add meshes to scene and finish\n        meshes.forEach((mesh) => {\n            mesh.cullingStrategy = Mesh.CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY\n            noa.rendering.addMeshToScene(mesh, true, chunk.pos, this)\n            noa.emit('addingTerrainMesh', mesh)\n            mesh.freezeNormals()\n            mesh.freezeWorldMatrix()\n            chunk._terrainMeshes.push(mesh)\n            if (!mesh.metadata) mesh.metadata = {}\n            mesh.metadata[terrainMeshFlag] = true\n        })\n    }\n    var terrainMeshFlag = 'noa_chunk_terrain_mesh'\n\n}\n\n\n\n\n\n\n\n/*\n * \n * \n * \n * \n *      Intermediate struct to hold data for a bunch of merged block faces\n * \n *      The greedy mesher produces these (one per terrainID), \n *      and the mesh builder turns each one into a Mesh instance.\n *\n * \n * \n * \n * \n*/\n\nfunction MeshedFaceData() {\n    this.terrainID = 0\n    this.numFaces = 0\n    // following arrays are all one element per quad\n    this.matIDs = []\n    this.dirs = []\n    this.is = []\n    this.js = []\n    this.ks = []\n    this.wids = []\n    this.hts = []\n    this.packedAO = []\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * \n * \n * \n *      Greedy meshing algorithm\n *      \n *      Originally based on algo by Mikola Lysenko:\n *          http://0fps.net/2012/07/07/meshing-minecraft-part-2/\n *      but probably no code remaining from there anymore.\n *      Ad-hoc AO handling by me, made of cobwebs and dreams\n * \n *    \n *      Takes in a Chunk instance, and returns an object containing \n *      GeometryData structs, keyed by terrain material ID, \n *      which the terrain builder can then make into meshes.\n * \n * \n * @param {import('../index').Engine} noa\n * @param {import('./terrainMaterials').TerrainMatManager} terrainMatManager\n*/\n\nfunction GreedyMesher(noa, terrainMatManager) {\n\n    // class-wide cached structs and getters\n    var maskCache = new Int16Array(16)\n    var aoMaskCache = new Int16Array(16)\n\n    // terrain ID accessor can be overridded for hacky reasons\n    var realGetTerrainID = terrainMatManager.getTerrainMatId.bind(terrainMatManager)\n    var fakeGetTerrainID = (matID) => 1\n    var terrainIDgetter = realGetTerrainID\n\n\n\n\n\n    /** \n     * Entry point\n     * \n     * @param {import('./chunk').Chunk} chunk\n     * @returns {Object.<string, MeshedFaceData>} keyed by terrain material ID \n     */\n    this.mesh = function (chunk, ignoreMaterials) {\n        var cs = chunk.size\n        terrainIDgetter = (ignoreMaterials) ? fakeGetTerrainID : realGetTerrainID\n\n        // no internal faces for empty or entirely solid chunks\n        var edgesOnly = (chunk._isEmpty || chunk._isFull)\n\n        /** @type {Object.<string, MeshedFaceData>} */\n        var faceDataSet = {}\n        faceDataPool.reset()\n\n        // Sweep over each axis, mapping axes to [d,u,v]\n        for (var d = 0; d < 3; ++d) {\n            var u = (d === 2) ? 0 : 2\n            var v = (d === 1) ? 0 : 1\n\n            // transposed ndarrays of nearby chunk voxels (self and neighbors)\n            var nabVoxelsArr = chunk._neighbors.data.map(c => {\n                if (c && c.voxels) return c.voxels.transpose(d, u, v)\n                return null\n            })\n\n            // ndarray of the previous, similarly transposed\n            var nabVoxelsT = ndarray(nabVoxelsArr, [3, 3, 3])\n                .lo(1, 1, 1)\n                .transpose(d, u, v)\n\n            // embiggen the cached mask arrays if needed\n            if (maskCache.length < cs * cs) {\n                maskCache = new Int16Array(cs * cs)\n                aoMaskCache = new Int16Array(cs * cs)\n            }\n\n            // sets up transposed accessor for querying solidity of (i,j,k):\n            prepareSolidityLookup(nabVoxelsT, cs)\n\n\n            // ACTUAL MASK AND GEOMETRY CREATION\n\n\n            // mesh plane between this chunk and previous neighbor on i axis?\n            var prev = nabVoxelsT.get(-1, 0, 0)\n            var here = nabVoxelsT.get(0, 0, 0)\n            if (prev) {\n                // offset version of neighbor to make queries work at i=-1\n                var prevOff = prev.lo(cs, 0, 0)\n                var nFaces = constructMeshMask(d, prevOff, -1, here, 0)\n\n                if (nFaces > 0) {\n                    constructGeometryFromMasks(0, d, u, v, cs, cs, nFaces, faceDataSet)\n                }\n            }\n\n            // if only doing edges, we're done with this axis\n            if (edgesOnly) continue\n\n\n            // mesh the rest of the planes internal to this chunk\n            // note only looping up to (size-1), skipping final coord so as \n            // not to duplicate faces at chunk borders\n            for (var i = 0; i < cs - 1; i++) {\n\n                // maybe skip y axis, if both layers are all the same voxel\n                if (d === 1) {\n                    var v1 = chunk._wholeLayerVoxel[i]\n                    if (v1 >= 0 && v1 === chunk._wholeLayerVoxel[i + 1]) {\n                        continue\n                    }\n                }\n\n                // pass in layer array for skip checks, only if not already checked\n                var layerVoxRef = (d === 1) ? null : chunk._wholeLayerVoxel\n\n                var nf = constructMeshMask(d, here, i, here, i + 1, layerVoxRef)\n                if (nf > 0) {\n                    constructGeometryFromMasks(i + 1, d, u, v, cs, cs, nf, faceDataSet)\n                }\n            }\n\n            // we skip the i-positive neighbor so as not to duplicate edge faces\n        }\n\n        // done!\n        return faceDataSet\n    }\n\n\n\n\n\n\n    /**\n     * Rigging for a transposed (i,j,k) => boolean solidity lookup, \n     * that knows how to query into neigboring chunks at edges.\n     * This sets up the indirection used by `voxelIsSolid` below.\n    */\n    function prepareSolidityLookup(nabVoxelsT, size) {\n        if (solidityLookupInittedSize !== size) {\n            solidityLookupInittedSize = size\n            voxelIDtoSolidity = noa.registry._solidityLookup\n\n            for (var x = -1; x < size + 1; x++) {\n                var loc = (x < 0) ? 0 : (x < size) ? 1 : 2\n                coordToLoc[x + 1] = [0, 1, 2][loc]\n                edgeCoordLookup[x + 1] = [size - 1, x, 0][loc]\n                missingCoordLookup[x + 1] = [0, x, size - 1][loc]\n            }\n        }\n\n        var centerChunk = nabVoxelsT.get(0, 0, 0)\n        for (var i = 0; i < 3; i++) {\n            for (var j = 0; j < 3; j++) {\n                for (var k = 0; k < 3; k++) {\n                    var ix = i * 9 + j * 3 + k\n                    var nab = nabVoxelsT.get(i - 1, j - 1, k - 1)\n                    var type = 0\n                    if (!nab) type = 1\n                    if (nab === centerChunk) type = 2\n                    voxTypeLookup[ix] = type\n                    voxLookup[ix] = nab || centerChunk\n                }\n            }\n        }\n    }\n\n    var solidityLookupInittedSize = -1\n    var voxelIDtoSolidity = [false, true]\n    var voxLookup = Array(27).fill(null)\n    var voxTypeLookup = Array(27).fill(0)\n    var coordToLoc = [0, 1, 1, 1, 1, 1, 2]\n    var edgeCoordLookup = [3, 0, 1, 2, 3, 0]\n    var missingCoordLookup = [0, 0, 1, 2, 3, 3]\n\n\n    function voxelIsSolid(i, j, k) {\n        var li = coordToLoc[i + 1]\n        var lj = coordToLoc[j + 1]\n        var lk = coordToLoc[k + 1]\n        var ix = li * 9 + lj * 3 + lk\n        var voxArray = voxLookup[ix]\n        var type = voxTypeLookup[ix]\n        if (type === 2) {\n            return voxelIDtoSolidity[voxArray.get(i, j, k)]\n        }\n        var lookup = [edgeCoordLookup, missingCoordLookup][type]\n        var ci = lookup[i + 1]\n        var cj = lookup[j + 1]\n        var ck = lookup[k + 1]\n        return voxelIDtoSolidity[voxArray.get(ci, cj, ck)]\n    }\n\n\n\n\n\n\n\n\n    /**\n     * \n     *      Build a 2D array of mask values representing whether a \n     *      mesh face is needed at each position\n     * \n     *      Each mask value is a terrain material ID, negative if\n     *      the face needs to point in the -i direction (towards voxel arr A)\n     * \n     * @returns {number} number of mesh faces found\n     */\n\n    function constructMeshMask(d, arrA, iA, arrB, iB, wholeLayerVoxel = null) {\n        var len = arrA.shape[1]\n        var mask = maskCache\n        var aoMask = aoMaskCache\n        var doAO = noa.rendering.useAO\n        var skipRevAo = (noa.rendering.revAoVal === noa.rendering.aoVals[0])\n\n        var opacityLookup = noa.registry._opacityLookup\n        var getMaterial = noa.registry.getBlockFaceMaterial\n        var materialDir = d * 2\n\n        // mask is iterated by a simple integer, both here and later when\n        // merging meshes, so the j/k order must be the same in both places\n        var n = 0\n\n        // set up for quick ndarray traversals\n        var indexA = arrA.index(iA, 0, 0)\n        var jstrideA = arrA.stride[1]\n        var kstrideA = arrA.stride[2]\n        var indexB = arrB.index(iB, 0, 0)\n        var jstrideB = arrB.stride[1]\n        var kstrideB = arrB.stride[2]\n\n        var facesFound = 0\n\n        for (var k = 0; k < len; ++k) {\n            var dA = indexA\n            var dB = indexB\n            indexA += kstrideA\n            indexB += kstrideB\n\n            // skip this second axis, if whole layer is same voxel?\n            if (wholeLayerVoxel && wholeLayerVoxel[k] >= 0) {\n                n += len\n                continue\n            }\n\n            for (var j = 0; j < len; j++, n++, dA += jstrideA, dB += jstrideB) {\n\n                // mask[n] represents the face needed between the two voxel layers\n                // for now, assume we never have two faces in both directions\n\n                // note that mesher zeroes out the mask as it goes, so there's \n                // no need to zero it here when no face is needed\n\n                // IDs at i-1,j,k  and  i,j,k\n                var id0 = arrA.data[dA]\n                var id1 = arrB.data[dB]\n\n                // most common case: never a face between same voxel IDs, \n                // so skip out early\n                if (id0 === id1) continue\n\n                // no face if both blocks are opaque\n                var op0 = opacityLookup[id0]\n                var op1 = opacityLookup[id1]\n                if (op0 && op1) continue\n\n                // also no face if both block faces have the same block material\n                var m0 = getMaterial(id0, materialDir)\n                var m1 = getMaterial(id1, materialDir + 1)\n                if (m0 === m1) continue\n\n                // choose which block face to draw:\n                //   * if either block is opaque draw that one\n                //   * if either material is missing draw the other one\n                if (op0 || m1 === 0) {\n                    mask[n] = m0\n                    if (doAO) aoMask[n] = packAOMask(voxelIsSolid, iB, iA, j, k, skipRevAo)\n                    facesFound++\n                } else if (op1 || m0 === 0) {\n                    mask[n] = -m1\n                    if (doAO) aoMask[n] = packAOMask(voxelIsSolid, iA, iB, j, k, skipRevAo)\n                    facesFound++\n                } else {\n                    // leftover case is two different non-opaque blocks facing each other.\n                    // Someday we could try to draw both, but for now we draw neither.\n                }\n            }\n        }\n        return facesFound\n    }\n\n\n\n\n\n\n    // \n    //      Greedy meshing inner loop two\n    //\n    // construct geometry data from the masks\n\n    function constructGeometryFromMasks(i, d, u, v, len1, len2, numFaces, faceDataSet) {\n        var doAO = noa.rendering.useAO\n        var mask = maskCache\n        var aomask = aoMaskCache\n\n        var n = 0\n        var materialDir = d * 2\n        var x = [0, 0, 0]\n        x[d] = i\n\n        var maskCompareFcn = (doAO) ? maskCompare : maskCompare_noAO\n\n        for (var k = 0; k < len2; ++k) {\n            var w = 1\n            var h = 1\n            for (var j = 0; j < len1; j += w, n += w) {\n\n                var maskVal = mask[n] | 0\n                if (!maskVal) {\n                    w = 1\n                    continue\n                }\n\n                var ao = aomask[n] | 0\n\n                // Compute width and height of area with same mask/aomask values\n                for (w = 1; w < len1 - j; ++w) {\n                    if (!maskCompareFcn(n + w, mask, maskVal, aomask, ao)) break\n                }\n\n                OUTER:\n                for (h = 1; h < len2 - k; ++h) {\n                    for (var m = 0; m < w; ++m) {\n                        var ix = n + m + h * len1\n                        if (!maskCompareFcn(ix, mask, maskVal, aomask, ao)) break OUTER\n                    }\n                }\n\n                // for testing: doing the following will disable greediness\n                //w=h=1\n\n                //  materialID and terrain ID type for the face\n                var matID = Math.abs(maskVal)\n                var terrainID = terrainIDgetter(matID)\n\n                // if terrainID not seen before, start a new MeshedFaceData\n                // from the extremely naive object pool\n                if (!(terrainID in faceDataSet)) {\n                    var fdFromPool = faceDataPool.get()\n                    fdFromPool.numFaces = 0\n                    fdFromPool.terrainID = terrainID\n                    faceDataSet[terrainID] = fdFromPool\n                }\n\n                // pack one face worth of data into the return struct\n\n                var faceData = faceDataSet[terrainID]\n                var nf = faceData.numFaces\n                faceData.numFaces++\n\n                faceData.matIDs[nf] = matID\n                x[u] = j\n                x[v] = k\n                faceData.is[nf] = x[0]\n                faceData.js[nf] = x[1]\n                faceData.ks[nf] = x[2]\n                faceData.wids[nf] = w\n                faceData.hts[nf] = h\n                faceData.packedAO[nf] = ao\n                faceData.dirs[nf] = (maskVal > 0) ? materialDir : materialDir + 1\n\n\n                // Face now finished, zero out the used part of the mask\n                for (var hx = 0; hx < h; ++hx) {\n                    for (var wx = 0; wx < w; ++wx) {\n                        mask[n + wx + hx * len1] = 0\n                    }\n                }\n\n                // exit condition where no more faces are left to mesh\n                numFaces -= w * h\n                if (numFaces === 0) return\n            }\n        }\n    }\n\n    function maskCompare(index, mask, maskVal, aomask, aoVal) {\n        if (maskVal !== mask[index]) return false\n        if (aoVal !== aomask[index]) return false\n        return true\n    }\n\n    function maskCompare_noAO(index, mask, maskVal, aomask, aoVal) {\n        if (maskVal !== mask[index]) return false\n        return true\n    }\n\n}\n\n\n/**\n * Extremely naive object pool for MeshedFaceData objects\n*/\nvar faceDataPool = (() => {\n    var arr = [], ix = 0\n    var get = () => {\n        if (ix >= arr.length) arr.push(new MeshedFaceData)\n        ix++\n        return arr[ix - 1]\n    }\n    var reset = () => { ix = 0 }\n    return { get, reset }\n})()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * \n * \n * \n * \n *       Mesh Builder - consumes all the raw data in geomData to build\n *          Babylon.js mesh/submeshes, ready to be added to the scene\n * \n * \n * \n * \n * \n */\n\n/** @param {import('../index').Engine} noa  */\nfunction MeshBuilder(noa, terrainMatManager) {\n\n    /** \n     * Consume the intermediate FaceData struct and produce\n     * actual mesehes the 3D engine can render\n     * @param {Object.<string, MeshedFaceData>} faceDataSet  \n    */\n    this.buildMesh = function (chunk, faceDataSet, ignoreMaterials) {\n        var scene = noa.rendering.getScene()\n\n        var doAO = noa.rendering.useAO\n        var aoVals = noa.rendering.aoVals\n        var revAoVal = noa.rendering.revAoVal\n\n        var atlasIndexLookup = noa.registry._matAtlasIndexLookup\n        var matColorLookup = noa.registry._materialColorLookup\n        var white = [1, 1, 1]\n\n\n\n\n        // geometry data is already keyed by terrain type, so build\n        // one mesh per geomData object in the hash\n        var meshes = []\n        for (var key in faceDataSet) {\n            var faceData = faceDataSet[key]\n            var terrainID = faceData.terrainID\n\n            // will this mesh need texture atlas indexes?\n            var usesAtlas = false\n            if (!ignoreMaterials) {\n                var firstIx = atlasIndexLookup[faceData.matIDs[0]]\n                usesAtlas = (firstIx >= 0)\n            }\n\n            // build the necessary arrays\n            var nf = faceData.numFaces\n            var indices = new Uint16Array(nf * 6)\n            var positions = new Float32Array(nf * 12)\n            var normals = new Float32Array(nf * 12)\n            var colors = new Float32Array(nf * 16)\n            var uvs = new Float32Array(nf * 8)\n            var atlasIndexes\n            if (usesAtlas) atlasIndexes = new Float32Array(nf * 4)\n\n            // scan all faces in the struct, creating data for each\n            for (var f = 0; f < faceData.numFaces; f++) {\n\n                // basic data from struct\n                var matID = faceData.matIDs[f]\n                var materialDir = faceData.dirs[f]  // 0..5: x,-x, y,-y, z,-z\n\n                var i = faceData.is[f]\n                var j = faceData.js[f]\n                var k = faceData.ks[f]\n                var w = faceData.wids[f]\n                var h = faceData.hts[f]\n                var axis = (materialDir / 2) | 0\n                var dir = (materialDir % 2) ? -1 : 1\n\n\n                addPositionValues(positions, f, i, j, k, axis, w, h)\n                addUVs(uvs, f, axis, w, h, dir)\n\n                var norms = [0, 0, 0]\n                norms[axis] = dir\n                addNormalValues(normals, f, norms)\n\n                var ao = faceData.packedAO[f]\n                var [A, B, C, D] = unpackAOMask(ao)\n                var triDir = decideTriDir(A, B, C, D)\n\n                addIndexValues(indices, f, axis, dir, triDir)\n\n                if (usesAtlas) {\n                    var atlasIndex = atlasIndexLookup[matID]\n                    addAtlasIndices(atlasIndexes, f, atlasIndex)\n                }\n\n                var matColor = matColorLookup[matID] || white\n                if (doAO) {\n                    pushMeshColors(colors, f, matColor, aoVals, revAoVal, A, B, C, D)\n                } else {\n                    pushMeshColors_noAO(colors, f, matColor)\n                }\n            }\n\n\n\n            // the mesh and vertexData object\n            var name = `chunk_${chunk.requestID}_${terrainID}`\n            var mesh = new Mesh(name, scene)\n            var vdat = new VertexData()\n\n            // finish the mesh\n            vdat.positions = positions\n            vdat.indices = indices\n            vdat.normals = normals\n            vdat.colors = colors\n            vdat.uvs = uvs\n            vdat.applyToMesh(mesh)\n\n            // meshes using a texture atlas need atlasIndices\n            if (usesAtlas) {\n                mesh.setVerticesData('texAtlasIndices', atlasIndexes, false, 1)\n            }\n\n            // disable some unnecessary bounding checks\n            mesh.isPickable = false\n            mesh.doNotSyncBoundingInfo = true\n            mesh._refreshBoundingInfo = () => mesh\n\n            // materials wrangled by external module\n            if (!ignoreMaterials) {\n                mesh.material = terrainMatManager.getMaterial(terrainID)\n            }\n\n            // done\n            meshes.push(mesh)\n        }\n\n        return meshes\n    }\n\n\n\n\n    // HELPERS ---- these could probably be simplified and less magical\n\n    function addPositionValues(posArr, faceNum, i, j, k, axis, w, h) {\n        var offset = faceNum * 12\n\n        var loc = [i, j, k]\n        var du = [0, 0, 0]\n        var dv = [0, 0, 0]\n        du[(axis === 2) ? 0 : 2] = w\n        dv[(axis === 1) ? 0 : 1] = h\n\n        for (var ix = 0; ix < 3; ix++) {\n            posArr[offset + ix] = loc[ix]\n            posArr[offset + 3 + ix] = loc[ix] + du[ix]\n            posArr[offset + 6 + ix] = loc[ix] + du[ix] + dv[ix]\n            posArr[offset + 9 + ix] = loc[ix] + dv[ix]\n        }\n    }\n\n\n\n    function addUVs(uvArr, faceNum, d, w, h, dir) {\n        var offset = faceNum * 8\n        var epsilon = 0\n        for (var i = 0; i < 8; i++) uvArr[offset + i] = epsilon\n        if (d === 0) {\n            uvArr[offset + 1] = uvArr[offset + 3] = h - epsilon\n            uvArr[offset + 2] = uvArr[offset + 4] = dir * w\n        } else if (d === 1) {\n            uvArr[offset + 1] = uvArr[offset + 7] = w - epsilon\n            uvArr[offset + 4] = uvArr[offset + 6] = dir * h\n        } else {\n            uvArr[offset + 1] = uvArr[offset + 3] = h - epsilon\n            uvArr[offset + 2] = uvArr[offset + 4] = -dir * w\n        }\n    }\n\n    function addNormalValues(normArr, faceNum, norms) {\n        var offset = faceNum * 12\n        for (var i = 0; i < 12; i++) {\n            normArr[offset + i] = norms[i % 3]\n        }\n    }\n\n    function addIndexValues(indArr, faceNum, axis, dir, triDir) {\n        var offset = faceNum * 6\n        var baseIndex = faceNum * 4\n        if (axis === 0) dir = -dir\n        var ix = (dir < 0) ? 0 : 1\n        if (!triDir) ix += 2\n        var indexVals = indexLists[ix]\n        for (var i = 0; i < 6; i++) {\n            indArr[offset + i] = baseIndex + indexVals[i]\n        }\n    }\n    var indexLists = [\n        [0, 1, 2, 0, 2, 3], // base\n        [0, 2, 1, 0, 3, 2], // flipped\n        [1, 2, 3, 1, 3, 0], // opposite triDir\n        [1, 3, 2, 1, 0, 3], // opposite triDir\n    ]\n\n\n\n\n    function addAtlasIndices(indArr, faceNum, atlasIndex) {\n        var offset = faceNum * 4\n        for (var i = 0; i < 4; i++) {\n            indArr[offset + i] = atlasIndex\n        }\n    }\n\n    function decideTriDir(A, B, C, D) {\n        // this bit is pretty magical..\n        // (true means split along the a00-a11 axis)\n        if (A === C) {\n            return (D === B) ? (D === 2) : true\n        } else {\n            return (D === B) ? false : (A + C > D + B)\n        }\n    }\n\n    function pushMeshColors_noAO(colors, faceNum, col) {\n        var offset = faceNum * 16\n        for (var i = 0; i < 16; i += 4) {\n            colors[offset + i] = col[0]\n            colors[offset + i + 1] = col[1]\n            colors[offset + i + 2] = col[2]\n            colors[offset + i + 3] = 1\n        }\n    }\n\n    function pushMeshColors(colors, faceNum, col, aoVals, revAo, A, B, C, D) {\n        var offset = faceNum * 16\n        pushAOColor(colors, offset, col, A, aoVals, revAo)\n        pushAOColor(colors, offset + 4, col, D, aoVals, revAo)\n        pushAOColor(colors, offset + 8, col, C, aoVals, revAo)\n        pushAOColor(colors, offset + 12, col, B, aoVals, revAo)\n    }\n\n    // premultiply vertex colors by value depending on AO level\n    // then push them into color array\n    function pushAOColor(colors, ix, baseCol, ao, aoVals, revAoVal) {\n        var mult = (ao === 0) ? revAoVal : aoVals[ao - 1]\n        colors[ix] = baseCol[0] * mult\n        colors[ix + 1] = baseCol[1] * mult\n        colors[ix + 2] = baseCol[2] * mult\n        colors[ix + 3] = 1\n    }\n\n}\n\n\n\n\n\n\n\n\n/*\n *\n *\n *\n *\n *          SHARED HELPERS - used by both main classes\n *\n *\n *\n *\n *\n*/\n\n\n\n\n/**\n *\n *\n *\n *  packAOMask:\n *\n *    For a given face, find occlusion levels for each vertex, then\n *    pack 4 such (2-bit) values into one Uint8 value\n * \n *  Occlusion levels:\n *    1 is flat ground, 2 is partial occlusion, 3 is max (corners)\n *    0 is \"reverse occlusion\" - an unoccluded exposed edge \n *  Packing order var(bit offset):\n * \n *      B(2)  -  C(6)   ^  K\n *       -        -     +> J\n *      A(0)  -  D(4)\n * \n*/\n\nfunction packAOMask(isSolid, ipos, ineg, j, k, skipReverse = false) {\n    var A = 1\n    var B = 1\n    var D = 1\n    var C = 1\n\n    // inc occlusion of vertex next to obstructed side\n    if (isSolid(ipos, j + 1, k)) { ++D; ++C }\n    if (isSolid(ipos, j - 1, k)) { ++A; ++B }\n    if (isSolid(ipos, j, k + 1)) { ++B; ++C }\n    if (isSolid(ipos, j, k - 1)) { ++A; ++D }\n\n    // facing into a solid (non-opaque) block?\n    var facingSolid = isSolid(ipos, j, k)\n    if (facingSolid) {\n        // always 2, or 3 in corners\n        C = (C === 3 || isSolid(ipos, j + 1, k + 1)) ? 3 : 2\n        B = (B === 3 || isSolid(ipos, j - 1, k + 1)) ? 3 : 2\n        D = (D === 3 || isSolid(ipos, j + 1, k - 1)) ? 3 : 2\n        A = (A === 3 || isSolid(ipos, j - 1, k - 1)) ? 3 : 2\n        return C << 6 | D << 4 | B << 2 | A\n    }\n\n    // simpler logic if skipping reverse AO?\n    if (skipReverse) {\n        // treat corner as occlusion 3 only if not occluded already\n        if (C === 1 && (isSolid(ipos, j + 1, k + 1))) { C = 2 }\n        if (B === 1 && (isSolid(ipos, j - 1, k + 1))) { B = 2 }\n        if (D === 1 && (isSolid(ipos, j + 1, k - 1))) { D = 2 }\n        if (A === 1 && (isSolid(ipos, j - 1, k - 1))) { A = 2 }\n        return C << 6 | D << 4 | B << 2 | A\n    }\n\n    // check each corner, and if not present do reverse AO\n    if (C === 1) {\n        if (isSolid(ipos, j + 1, k + 1)) {\n            C = 2\n        } else if (!(isSolid(ineg, j, k + 1)) ||\n            !(isSolid(ineg, j + 1, k)) ||\n            !(isSolid(ineg, j + 1, k + 1))) {\n            C = 0\n        }\n    }\n\n    if (D === 1) {\n        if (isSolid(ipos, j + 1, k - 1)) {\n            D = 2\n        } else if (!(isSolid(ineg, j, k - 1)) ||\n            !(isSolid(ineg, j + 1, k)) ||\n            !(isSolid(ineg, j + 1, k - 1))) {\n            D = 0\n        }\n    }\n\n    if (B === 1) {\n        if (isSolid(ipos, j - 1, k + 1)) {\n            B = 2\n        } else if (!(isSolid(ineg, j, k + 1)) ||\n            !(isSolid(ineg, j - 1, k)) ||\n            !(isSolid(ineg, j - 1, k + 1))) {\n            B = 0\n        }\n    }\n\n    if (A === 1) {\n        if (isSolid(ipos, j - 1, k - 1)) {\n            A = 2\n        } else if (!(isSolid(ineg, j, k - 1)) ||\n            !(isSolid(ineg, j - 1, k)) ||\n            !(isSolid(ineg, j - 1, k - 1))) {\n            A = 0\n        }\n    }\n\n    return C << 6 | D << 4 | B << 2 | A\n}\n\n/**\n * \n *      Takes in a packed AO value representing a face,\n *      and returns four 2-bit numbers for the AO levels\n *      at the four corners.\n *      \n*/\nfunction unpackAOMask(aomask) {\n    var A = aomask & 3\n    var B = (aomask >> 2) & 3\n    var D = (aomask >> 4) & 3\n    var C = (aomask >> 6) & 3\n    return [A, B, C, D]\n}\n\n\n\n\n\n\n\n\nvar profile_hook = (PROFILE_EVERY) ?\n    makeProfileHook(PROFILE_EVERY, 'Meshing') : () => { }\n\n", "/**\r\n * Interface for the size containing width and height\r\n */\r\nexport interface ISize {\r\n    /**\r\n     * Width\r\n     */\r\n    width: number;\r\n    /**\r\n     * Height\r\n     */\r\n    height: number;\r\n}\r\n\r\n/**\r\n * Size containing width and height\r\n */\r\nexport class Size implements ISize {\r\n    /**\r\n     * Width\r\n     */\r\n    public width: number;\r\n    /**\r\n     * Height\r\n     */\r\n    public height: number;\r\n\r\n    /**\r\n     * Creates a Size object from the given width and height (floats).\r\n     * @param width width of the new size\r\n     * @param height height of the new size\r\n     */\r\n    public constructor(width: number, height: number) {\r\n        this.width = width;\r\n        this.height = height;\r\n    }\r\n\r\n    /**\r\n     * Returns a string with the Size width and height\r\n     * @returns a string with the Size width and height\r\n     */\r\n    public toString(): string {\r\n        return `{W: ${this.width}, H: ${this.height}}`;\r\n    }\r\n    /**\r\n     * \"Size\"\r\n     * @returns the string \"Size\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"Size\";\r\n    }\r\n    /**\r\n     * Returns the Size hash code.\r\n     * @returns a hash code for a unique width and height\r\n     */\r\n    public getHashCode(): number {\r\n        let hash = this.width | 0;\r\n        hash = (hash * 397) ^ (this.height | 0);\r\n        return hash;\r\n    }\r\n    /**\r\n     * Updates the current size from the given one.\r\n     * @param src the given size\r\n     */\r\n    public copyFrom(src: Size) {\r\n        this.width = src.width;\r\n        this.height = src.height;\r\n    }\r\n    /**\r\n     * Updates in place the current Size from the given floats.\r\n     * @param width width of the new size\r\n     * @param height height of the new size\r\n     * @returns the updated Size.\r\n     */\r\n    public copyFromFloats(width: number, height: number): Size {\r\n        this.width = width;\r\n        this.height = height;\r\n        return this;\r\n    }\r\n    /**\r\n     * Updates in place the current Size from the given floats.\r\n     * @param width width to set\r\n     * @param height height to set\r\n     * @returns the updated Size.\r\n     */\r\n    public set(width: number, height: number): Size {\r\n        return this.copyFromFloats(width, height);\r\n    }\r\n    /**\r\n     * Multiplies the width and height by numbers\r\n     * @param w factor to multiple the width by\r\n     * @param h factor to multiple the height by\r\n     * @returns a new Size set with the multiplication result of the current Size and the given floats.\r\n     */\r\n    public multiplyByFloats(w: number, h: number): Size {\r\n        return new Size(this.width * w, this.height * h);\r\n    }\r\n    /**\r\n     * Clones the size\r\n     * @returns a new Size copied from the given one.\r\n     */\r\n    public clone(): Size {\r\n        return new Size(this.width, this.height);\r\n    }\r\n    /**\r\n     * True if the current Size and the given one width and height are strictly equal.\r\n     * @param other the other size to compare against\r\n     * @returns True if the current Size and the given one width and height are strictly equal.\r\n     */\r\n    public equals(other: Size): boolean {\r\n        if (!other) {\r\n            return false;\r\n        }\r\n        return this.width === other.width && this.height === other.height;\r\n    }\r\n    /**\r\n     * The surface of the Size : width * height (float).\r\n     */\r\n    public get surface(): number {\r\n        return this.width * this.height;\r\n    }\r\n    /**\r\n     * Create a new size of zero\r\n     * @returns a new Size set to (0.0, 0.0)\r\n     */\r\n    public static Zero(): Size {\r\n        return new Size(0.0, 0.0);\r\n    }\r\n    /**\r\n     * Sums the width and height of two sizes\r\n     * @param otherSize size to add to this size\r\n     * @returns a new Size set as the addition result of the current Size and the given one.\r\n     */\r\n    public add(otherSize: Size): Size {\r\n        const r = new Size(this.width + otherSize.width, this.height + otherSize.height);\r\n        return r;\r\n    }\r\n    /**\r\n     * Subtracts the width and height of two\r\n     * @param otherSize size to subtract to this size\r\n     * @returns a new Size set as the subtraction result of  the given one from the current Size.\r\n     */\r\n    public subtract(otherSize: Size): Size {\r\n        const r = new Size(this.width - otherSize.width, this.height - otherSize.height);\r\n        return r;\r\n    }\r\n    /**\r\n     * Scales the width and height\r\n     * @param scale the scale to multiply the width and height by\r\n     * @returns a new Size set with the multiplication result of the current Size and the given floats.\r\n     */\r\n    public scale(scale: number): Size {\r\n        return new Size(this.width * scale, this.height * scale);\r\n    }\r\n    /**\r\n     * Creates a new Size set at the linear interpolation \"amount\" between \"start\" and \"end\"\r\n     * @param start starting size to lerp between\r\n     * @param end end size to lerp between\r\n     * @param amount amount to lerp between the start and end values\r\n     * @returns a new Size set at the linear interpolation \"amount\" between \"start\" and \"end\"\r\n     */\r\n    public static Lerp(start: Size, end: Size, amount: number): Size {\r\n        const w = start.width + (end.width - start.width) * amount;\r\n        const h = start.height + (end.height - start.height) * amount;\r\n\r\n        return new Size(w, h);\r\n    }\r\n}\r\n", "import type { Nullable } from \"../../types\";\r\nimport type { InternalTexture } from \"../../Materials/Textures/internalTexture\";\r\nimport { Constants } from \"../../Engines/constants\";\r\n\r\nimport type { ISize } from \"../../Maths/math.size\";\r\nimport { Size } from \"../../Maths/math.size\";\r\n\r\nimport type { ThinEngine } from \"../../Engines/thinEngine\";\r\nimport type { RenderTargetWrapper } from \"core/Engines/renderTargetWrapper\";\r\n\r\n/**\r\n * Base class of all the textures in babylon.\r\n * It groups all the common properties required to work with Thin Engine.\r\n */\r\nexport class ThinTexture {\r\n    protected _wrapU = Constants.TEXTURE_WRAP_ADDRESSMODE;\r\n    /**\r\n     * | Value | Type               | Description |\r\n     * | ----- | ------------------ | ----------- |\r\n     * | 0     | CLAMP_ADDRESSMODE  |             |\r\n     * | 1     | WRAP_ADDRESSMODE   |             |\r\n     * | 2     | MIRROR_ADDRESSMODE |             |\r\n     */\r\n    public get wrapU() {\r\n        return this._wrapU;\r\n    }\r\n\r\n    public set wrapU(value: number) {\r\n        this._wrapU = value;\r\n    }\r\n\r\n    protected _wrapV = Constants.TEXTURE_WRAP_ADDRESSMODE;\r\n    /**\r\n     * | Value | Type               | Description |\r\n     * | ----- | ------------------ | ----------- |\r\n     * | 0     | CLAMP_ADDRESSMODE  |             |\r\n     * | 1     | WRAP_ADDRESSMODE   |             |\r\n     * | 2     | MIRROR_ADDRESSMODE |             |\r\n     */\r\n    public get wrapV() {\r\n        return this._wrapV;\r\n    }\r\n\r\n    public set wrapV(value: number) {\r\n        this._wrapV = value;\r\n    }\r\n\r\n    /**\r\n     * | Value | Type               | Description |\r\n     * | ----- | ------------------ | ----------- |\r\n     * | 0     | CLAMP_ADDRESSMODE  |             |\r\n     * | 1     | WRAP_ADDRESSMODE   |             |\r\n     * | 2     | MIRROR_ADDRESSMODE |             |\r\n     */\r\n    public wrapR = Constants.TEXTURE_WRAP_ADDRESSMODE;\r\n\r\n    /**\r\n     * With compliant hardware and browser (supporting anisotropic filtering)\r\n     * this defines the level of anisotropic filtering in the texture.\r\n     * The higher the better but the slower. This defaults to 4 as it seems to be the best tradeoff.\r\n     */\r\n    public anisotropicFilteringLevel = 4;\r\n\r\n    /**\r\n     * Define the current state of the loading sequence when in delayed load mode.\r\n     */\r\n    public delayLoadState = Constants.DELAYLOADSTATE_NONE;\r\n\r\n    /**\r\n     * How a texture is mapped.\r\n     * Unused in thin texture mode.\r\n     */\r\n    public get coordinatesMode(): number {\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Define if the texture is a cube texture or if false a 2d texture.\r\n     */\r\n    public get isCube(): boolean {\r\n        if (!this._texture) {\r\n            return false;\r\n        }\r\n\r\n        return this._texture.isCube;\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    protected set isCube(value: boolean) {\r\n        if (!this._texture) {\r\n            return;\r\n        }\r\n\r\n        this._texture.isCube = value;\r\n    }\r\n\r\n    /**\r\n     * Define if the texture is a 3d texture (webgl 2) or if false a 2d texture.\r\n     */\r\n    public get is3D(): boolean {\r\n        if (!this._texture) {\r\n            return false;\r\n        }\r\n\r\n        return this._texture.is3D;\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    protected set is3D(value: boolean) {\r\n        if (!this._texture) {\r\n            return;\r\n        }\r\n\r\n        this._texture.is3D = value;\r\n    }\r\n\r\n    /**\r\n     * Define if the texture is a 2d array texture (webgl 2) or if false a 2d texture.\r\n     */\r\n    public get is2DArray(): boolean {\r\n        if (!this._texture) {\r\n            return false;\r\n        }\r\n\r\n        return this._texture.is2DArray;\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    protected set is2DArray(value: boolean) {\r\n        if (!this._texture) {\r\n            return;\r\n        }\r\n\r\n        this._texture.is2DArray = value;\r\n    }\r\n\r\n    /**\r\n     * Get the class name of the texture.\r\n     * @returns \"ThinTexture\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"ThinTexture\";\r\n    }\r\n\r\n    /** @internal */\r\n    public _texture: Nullable<InternalTexture> = null;\r\n\r\n    protected _engine: Nullable<ThinEngine> = null;\r\n\r\n    private _cachedSize: ISize = Size.Zero();\r\n    private _cachedBaseSize: ISize = Size.Zero();\r\n\r\n    private static _IsRenderTargetWrapper(texture: Nullable<InternalTexture> | Nullable<RenderTargetWrapper>): texture is RenderTargetWrapper {\r\n        return (texture as RenderTargetWrapper)?._shareDepth !== undefined;\r\n    }\r\n\r\n    /**\r\n     * Instantiates a new ThinTexture.\r\n     * Base class of all the textures in babylon.\r\n     * This can be used as an internal texture wrapper in ThinEngine to benefit from the cache\r\n     * @param internalTexture Define the internalTexture to wrap. You can also pass a RenderTargetWrapper, in which case the texture will be the render target's texture\r\n     */\r\n    constructor(internalTexture: Nullable<InternalTexture | RenderTargetWrapper>) {\r\n        this._texture = ThinTexture._IsRenderTargetWrapper(internalTexture) ? internalTexture.texture : internalTexture;\r\n        if (this._texture) {\r\n            this._engine = this._texture.getEngine();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get if the texture is ready to be used (downloaded, converted, mip mapped...).\r\n     * @returns true if fully ready\r\n     */\r\n    public isReady(): boolean {\r\n        if (this.delayLoadState === Constants.DELAYLOADSTATE_NOTLOADED) {\r\n            this.delayLoad();\r\n            return false;\r\n        }\r\n\r\n        if (this._texture) {\r\n            return this._texture.isReady;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Triggers the load sequence in delayed load mode.\r\n     */\r\n    public delayLoad(): void {}\r\n\r\n    /**\r\n     * Get the underlying lower level texture from Babylon.\r\n     * @returns the internal texture\r\n     */\r\n    public getInternalTexture(): Nullable<InternalTexture> {\r\n        return this._texture;\r\n    }\r\n\r\n    /**\r\n     * Get the size of the texture.\r\n     * @returns the texture size.\r\n     */\r\n    public getSize(): ISize {\r\n        if (this._texture) {\r\n            if (this._texture.width) {\r\n                this._cachedSize.width = this._texture.width;\r\n                this._cachedSize.height = this._texture.height;\r\n                return this._cachedSize;\r\n            }\r\n\r\n            if (this._texture._size) {\r\n                this._cachedSize.width = this._texture._size;\r\n                this._cachedSize.height = this._texture._size;\r\n                return this._cachedSize;\r\n            }\r\n        }\r\n\r\n        return this._cachedSize;\r\n    }\r\n\r\n    /**\r\n     * Get the base size of the texture.\r\n     * It can be different from the size if the texture has been resized for POT for instance\r\n     * @returns the base size\r\n     */\r\n    public getBaseSize(): ISize {\r\n        if (!this.isReady() || !this._texture) {\r\n            this._cachedBaseSize.width = 0;\r\n            this._cachedBaseSize.height = 0;\r\n            return this._cachedBaseSize;\r\n        }\r\n\r\n        if (this._texture._size) {\r\n            this._cachedBaseSize.width = this._texture._size;\r\n            this._cachedBaseSize.height = this._texture._size;\r\n            return this._cachedBaseSize;\r\n        }\r\n\r\n        this._cachedBaseSize.width = this._texture.baseWidth;\r\n        this._cachedBaseSize.height = this._texture.baseHeight;\r\n        return this._cachedBaseSize;\r\n    }\r\n\r\n    /** @internal */\r\n    protected _initialSamplingMode = Constants.TEXTURE_BILINEAR_SAMPLINGMODE;\r\n\r\n    /**\r\n     * Get the current sampling mode associated with the texture.\r\n     */\r\n    public get samplingMode(): number {\r\n        if (!this._texture) {\r\n            return this._initialSamplingMode;\r\n        }\r\n\r\n        return this._texture.samplingMode;\r\n    }\r\n\r\n    /**\r\n     * Update the sampling mode of the texture.\r\n     * Default is Trilinear mode.\r\n     *\r\n     * | Value | Type               | Description |\r\n     * | ----- | ------------------ | ----------- |\r\n     * | 1     | NEAREST_SAMPLINGMODE or NEAREST_NEAREST_MIPLINEAR  | Nearest is: mag = nearest, min = nearest, mip = linear |\r\n     * | 2     | BILINEAR_SAMPLINGMODE or LINEAR_LINEAR_MIPNEAREST | Bilinear is: mag = linear, min = linear, mip = nearest |\r\n     * | 3     | TRILINEAR_SAMPLINGMODE or LINEAR_LINEAR_MIPLINEAR | Trilinear is: mag = linear, min = linear, mip = linear |\r\n     * | 4     | NEAREST_NEAREST_MIPNEAREST |             |\r\n     * | 5    | NEAREST_LINEAR_MIPNEAREST |             |\r\n     * | 6    | NEAREST_LINEAR_MIPLINEAR |             |\r\n     * | 7    | NEAREST_LINEAR |             |\r\n     * | 8    | NEAREST_NEAREST |             |\r\n     * | 9   | LINEAR_NEAREST_MIPNEAREST |             |\r\n     * | 10   | LINEAR_NEAREST_MIPLINEAR |             |\r\n     * | 11   | LINEAR_LINEAR |             |\r\n     * | 12   | LINEAR_NEAREST |             |\r\n     *\r\n     *    > _mag_: magnification filter (close to the viewer)\r\n     *    > _min_: minification filter (far from the viewer)\r\n     *    > _mip_: filter used between mip map levels\r\n     *@param samplingMode Define the new sampling mode of the texture\r\n     */\r\n    public updateSamplingMode(samplingMode: number): void {\r\n        if (this._texture && this._engine) {\r\n            this._engine.updateTextureSamplingMode(samplingMode, this._texture);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Release and destroy the underlying lower level texture aka internalTexture.\r\n     */\r\n    public releaseInternalTexture(): void {\r\n        if (this._texture) {\r\n            this._texture.dispose();\r\n            this._texture = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Dispose the texture and release its associated resources.\r\n     */\r\n    public dispose(): void {\r\n        if (this._texture) {\r\n            this.releaseInternalTexture();\r\n            this._engine = null;\r\n        }\r\n    }\r\n}\r\n", "import { serialize, serializeAsTexture } from \"../../Misc/decorators\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { Matrix } from \"../../Maths/math.vector\";\r\nimport { EngineStore } from \"../../Engines/engineStore\";\r\nimport type { InternalTexture } from \"../../Materials/Textures/internalTexture\";\r\nimport { Constants } from \"../../Engines/constants\";\r\nimport type { IAnimatable } from \"../../Animations/animatable.interface\";\r\nimport { RandomGUID } from \"../../Misc/guid\";\r\n\r\nimport \"../../Misc/fileTools\";\r\nimport type { ThinEngine } from \"../../Engines/thinEngine\";\r\nimport { ThinTexture } from \"./thinTexture\";\r\nimport type { AbstractScene } from \"../../abstractScene\";\r\n\r\nimport type { Animation } from \"../../Animations/animation\";\r\nimport { SerializationHelper } from \"../../Misc/decorators.serialization\";\r\n\r\n/**\r\n * Base class of all the textures in babylon.\r\n * It groups all the common properties the materials, post process, lights... might need\r\n * in order to make a correct use of the texture.\r\n */\r\nexport class BaseTexture extends ThinTexture implements IAnimatable {\r\n    /**\r\n     * Default anisotropic filtering level for the application.\r\n     * It is set to 4 as a good tradeoff between perf and quality.\r\n     */\r\n    public static DEFAULT_ANISOTROPIC_FILTERING_LEVEL = 4;\r\n\r\n    /**\r\n     * Gets or sets the unique id of the texture\r\n     */\r\n    @serialize()\r\n    public uniqueId: number;\r\n\r\n    /**\r\n     * Define the name of the texture.\r\n     */\r\n    @serialize()\r\n    public name: string;\r\n\r\n    /**\r\n     * Gets or sets an object used to store user defined information.\r\n     */\r\n    @serialize()\r\n    public metadata: any = null;\r\n\r\n    /** @internal */\r\n    public _internalMetadata: any;\r\n\r\n    /**\r\n     * For internal use only. Please do not use.\r\n     */\r\n    public reservedDataStore: any = null;\r\n\r\n    @serialize(\"hasAlpha\")\r\n    private _hasAlpha = false;\r\n    /**\r\n     * Define if the texture is having a usable alpha value (can be use for transparency or glossiness for instance).\r\n     */\r\n    public set hasAlpha(value: boolean) {\r\n        if (this._hasAlpha === value) {\r\n            return;\r\n        }\r\n        this._hasAlpha = value;\r\n        if (this._scene) {\r\n            this._scene.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag, (mat) => {\r\n                return mat.hasTexture(this);\r\n            });\r\n        }\r\n    }\r\n    public get hasAlpha(): boolean {\r\n        return this._hasAlpha;\r\n    }\r\n\r\n    @serialize(\"getAlphaFromRGB\")\r\n    private _getAlphaFromRGB = false;\r\n    /**\r\n     * Defines if the alpha value should be determined via the rgb values.\r\n     * If true the luminance of the pixel might be used to find the corresponding alpha value.\r\n     */\r\n    public set getAlphaFromRGB(value: boolean) {\r\n        if (this._getAlphaFromRGB === value) {\r\n            return;\r\n        }\r\n        this._getAlphaFromRGB = value;\r\n        if (this._scene) {\r\n            this._scene.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag, (mat) => {\r\n                return mat.hasTexture(this);\r\n            });\r\n        }\r\n    }\r\n    public get getAlphaFromRGB(): boolean {\r\n        return this._getAlphaFromRGB;\r\n    }\r\n\r\n    /**\r\n     * Intensity or strength of the texture.\r\n     * It is commonly used by materials to fine tune the intensity of the texture\r\n     */\r\n    @serialize()\r\n    public level = 1;\r\n\r\n    @serialize(\"coordinatesIndex\")\r\n    protected _coordinatesIndex = 0;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that the texture should try to reduce shader code if there is no UV manipulation.\r\n     * (ie. when texture.getTextureMatrix().isIdentityAs3x2() returns true)\r\n     */\r\n    @serialize()\r\n    public optimizeUVAllocation = true;\r\n\r\n    /**\r\n     * Define the UV channel to use starting from 0 and defaulting to 0.\r\n     * This is part of the texture as textures usually maps to one uv set.\r\n     */\r\n    public set coordinatesIndex(value: number) {\r\n        if (this._coordinatesIndex === value) {\r\n            return;\r\n        }\r\n        this._coordinatesIndex = value;\r\n        if (this._scene) {\r\n            this._scene.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag, (mat) => {\r\n                return mat.hasTexture(this);\r\n            });\r\n        }\r\n    }\r\n    public get coordinatesIndex(): number {\r\n        return this._coordinatesIndex;\r\n    }\r\n\r\n    @serialize(\"coordinatesMode\")\r\n    protected _coordinatesMode = Constants.TEXTURE_EXPLICIT_MODE;\r\n\r\n    /**\r\n     * How a texture is mapped.\r\n     *\r\n     * | Value | Type                                | Description |\r\n     * | ----- | ----------------------------------- | ----------- |\r\n     * | 0     | EXPLICIT_MODE                       |             |\r\n     * | 1     | SPHERICAL_MODE                      |             |\r\n     * | 2     | PLANAR_MODE                         |             |\r\n     * | 3     | CUBIC_MODE                          |             |\r\n     * | 4     | PROJECTION_MODE                     |             |\r\n     * | 5     | SKYBOX_MODE                         |             |\r\n     * | 6     | INVCUBIC_MODE                       |             |\r\n     * | 7     | EQUIRECTANGULAR_MODE                |             |\r\n     * | 8     | FIXED_EQUIRECTANGULAR_MODE          |             |\r\n     * | 9     | FIXED_EQUIRECTANGULAR_MIRRORED_MODE |             |\r\n     */\r\n    public set coordinatesMode(value: number) {\r\n        if (this._coordinatesMode === value) {\r\n            return;\r\n        }\r\n        this._coordinatesMode = value;\r\n        if (this._scene) {\r\n            this._scene.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag, (mat) => {\r\n                return mat.hasTexture(this);\r\n            });\r\n        }\r\n    }\r\n    public get coordinatesMode(): number {\r\n        return this._coordinatesMode;\r\n    }\r\n\r\n    /**\r\n     * | Value | Type               | Description |\r\n     * | ----- | ------------------ | ----------- |\r\n     * | 0     | CLAMP_ADDRESSMODE  |             |\r\n     * | 1     | WRAP_ADDRESSMODE   |             |\r\n     * | 2     | MIRROR_ADDRESSMODE |             |\r\n     */\r\n    @serialize()\r\n    public get wrapU() {\r\n        return this._wrapU;\r\n    }\r\n    public set wrapU(value: number) {\r\n        this._wrapU = value;\r\n    }\r\n\r\n    /**\r\n     * | Value | Type               | Description |\r\n     * | ----- | ------------------ | ----------- |\r\n     * | 0     | CLAMP_ADDRESSMODE  |             |\r\n     * | 1     | WRAP_ADDRESSMODE   |             |\r\n     * | 2     | MIRROR_ADDRESSMODE |             |\r\n     */\r\n    @serialize()\r\n    public get wrapV() {\r\n        return this._wrapV;\r\n    }\r\n    public set wrapV(value: number) {\r\n        this._wrapV = value;\r\n    }\r\n\r\n    /**\r\n     * | Value | Type               | Description |\r\n     * | ----- | ------------------ | ----------- |\r\n     * | 0     | CLAMP_ADDRESSMODE  |             |\r\n     * | 1     | WRAP_ADDRESSMODE   |             |\r\n     * | 2     | MIRROR_ADDRESSMODE |             |\r\n     */\r\n    @serialize()\r\n    public wrapR = Constants.TEXTURE_WRAP_ADDRESSMODE;\r\n\r\n    /**\r\n     * With compliant hardware and browser (supporting anisotropic filtering)\r\n     * this defines the level of anisotropic filtering in the texture.\r\n     * The higher the better but the slower. This defaults to 4 as it seems to be the best tradeoff.\r\n     */\r\n    @serialize()\r\n    public anisotropicFilteringLevel = BaseTexture.DEFAULT_ANISOTROPIC_FILTERING_LEVEL;\r\n\r\n    /** @internal */\r\n    public _isCube = false;\r\n    /**\r\n     * Define if the texture is a cube texture or if false a 2d texture.\r\n     */\r\n    @serialize()\r\n    public get isCube(): boolean {\r\n        if (!this._texture) {\r\n            return this._isCube;\r\n        }\r\n\r\n        return this._texture.isCube;\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    protected set isCube(value: boolean) {\r\n        if (!this._texture) {\r\n            this._isCube = value;\r\n        } else {\r\n            this._texture.isCube = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Define if the texture is a 3d texture (webgl 2) or if false a 2d texture.\r\n     */\r\n    @serialize()\r\n    public get is3D(): boolean {\r\n        if (!this._texture) {\r\n            return false;\r\n        }\r\n\r\n        return this._texture.is3D;\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    protected set is3D(value: boolean) {\r\n        if (!this._texture) {\r\n            return;\r\n        }\r\n\r\n        this._texture.is3D = value;\r\n    }\r\n\r\n    /**\r\n     * Define if the texture is a 2d array texture (webgl 2) or if false a 2d texture.\r\n     */\r\n    @serialize()\r\n    public get is2DArray(): boolean {\r\n        if (!this._texture) {\r\n            return false;\r\n        }\r\n\r\n        return this._texture.is2DArray;\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    protected set is2DArray(value: boolean) {\r\n        if (!this._texture) {\r\n            return;\r\n        }\r\n\r\n        this._texture.is2DArray = value;\r\n    }\r\n\r\n    /** @internal */\r\n    protected _gammaSpace = true;\r\n    /**\r\n     * Define if the texture contains data in gamma space (most of the png/jpg aside bump).\r\n     * HDR texture are usually stored in linear space.\r\n     * This only impacts the PBR and Background materials\r\n     */\r\n    @serialize()\r\n    public get gammaSpace(): boolean {\r\n        if (!this._texture) {\r\n            return this._gammaSpace;\r\n        } else {\r\n            if (this._texture._gammaSpace === null) {\r\n                this._texture._gammaSpace = this._gammaSpace;\r\n            }\r\n        }\r\n\r\n        return this._texture._gammaSpace && !this._texture._useSRGBBuffer;\r\n    }\r\n\r\n    public set gammaSpace(gamma: boolean) {\r\n        if (!this._texture) {\r\n            if (this._gammaSpace === gamma) {\r\n                return;\r\n            }\r\n\r\n            this._gammaSpace = gamma;\r\n        } else {\r\n            if (this._texture._gammaSpace === gamma) {\r\n                return;\r\n            }\r\n            this._texture._gammaSpace = gamma;\r\n        }\r\n\r\n        this.getScene()?.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag, (mat) => {\r\n            return mat.hasTexture(this);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Gets or sets whether or not the texture contains RGBD data.\r\n     */\r\n    public get isRGBD(): boolean {\r\n        return this._texture != null && this._texture._isRGBD;\r\n    }\r\n    public set isRGBD(value: boolean) {\r\n        if (value === this.isRGBD) {\r\n            return;\r\n        }\r\n\r\n        if (this._texture) {\r\n            this._texture._isRGBD = value;\r\n        }\r\n\r\n        this.getScene()?.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag, (mat) => {\r\n            return mat.hasTexture(this);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Is Z inverted in the texture (useful in a cube texture).\r\n     */\r\n    @serialize()\r\n    public invertZ = false;\r\n\r\n    /**\r\n     * Are mip maps generated for this texture or not.\r\n     */\r\n    public get noMipmap(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    @serialize()\r\n    public lodLevelInAlpha = false;\r\n\r\n    /**\r\n     * With prefiltered texture, defined the offset used during the prefiltering steps.\r\n     */\r\n    @serialize()\r\n    public get lodGenerationOffset(): number {\r\n        if (this._texture) {\r\n            return this._texture._lodGenerationOffset;\r\n        }\r\n\r\n        return 0.0;\r\n    }\r\n    public set lodGenerationOffset(value: number) {\r\n        if (this._texture) {\r\n            this._texture._lodGenerationOffset = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * With prefiltered texture, defined the scale used during the prefiltering steps.\r\n     */\r\n    @serialize()\r\n    public get lodGenerationScale(): number {\r\n        if (this._texture) {\r\n            return this._texture._lodGenerationScale;\r\n        }\r\n\r\n        return 0.0;\r\n    }\r\n    public set lodGenerationScale(value: number) {\r\n        if (this._texture) {\r\n            this._texture._lodGenerationScale = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * With prefiltered texture, defined if the specular generation is based on a linear ramp.\r\n     * By default we are using a log2 of the linear roughness helping to keep a better resolution for\r\n     * average roughness values.\r\n     */\r\n    @serialize()\r\n    public get linearSpecularLOD(): boolean {\r\n        if (this._texture) {\r\n            return this._texture._linearSpecularLOD;\r\n        }\r\n\r\n        return false;\r\n    }\r\n    public set linearSpecularLOD(value: boolean) {\r\n        if (this._texture) {\r\n            this._texture._linearSpecularLOD = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * In case a better definition than spherical harmonics is required for the diffuse part of the environment.\r\n     * You can set the irradiance texture to rely on a texture instead of the spherical approach.\r\n     * This texture need to have the same characteristics than its parent (Cube vs 2d, coordinates mode, Gamma/Linear, RGBD).\r\n     */\r\n    @serializeAsTexture()\r\n    public get irradianceTexture(): Nullable<BaseTexture> {\r\n        if (this._texture) {\r\n            return this._texture._irradianceTexture;\r\n        }\r\n\r\n        return null;\r\n    }\r\n    public set irradianceTexture(value: Nullable<BaseTexture>) {\r\n        if (this._texture) {\r\n            this._texture._irradianceTexture = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Define if the texture is a render target.\r\n     */\r\n    @serialize()\r\n    public isRenderTarget = false;\r\n\r\n    /**\r\n     * Define the unique id of the texture in the scene.\r\n     */\r\n    public get uid(): string {\r\n        if (!this._uid) {\r\n            this._uid = RandomGUID();\r\n        }\r\n        return this._uid;\r\n    }\r\n\r\n    /** @internal */\r\n    public _prefiltered: boolean = false;\r\n    /** @internal */\r\n    public _forceSerialize: boolean = false;\r\n\r\n    /**\r\n     * Return a string representation of the texture.\r\n     * @returns the texture as a string\r\n     */\r\n    public toString(): string {\r\n        return this.name;\r\n    }\r\n\r\n    /**\r\n     * Get the class name of the texture.\r\n     * @returns \"BaseTexture\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"BaseTexture\";\r\n    }\r\n\r\n    /**\r\n     * Define the list of animation attached to the texture.\r\n     */\r\n    public animations: Animation[] = [];\r\n\r\n    /**\r\n     * An event triggered when the texture is disposed.\r\n     */\r\n    public onDisposeObservable = new Observable<BaseTexture>();\r\n\r\n    private _onDisposeObserver: Nullable<Observer<BaseTexture>> = null;\r\n    /**\r\n     * Callback triggered when the texture has been disposed.\r\n     * Kept for back compatibility, you can use the onDisposeObservable instead.\r\n     */\r\n    public set onDispose(callback: () => void) {\r\n        if (this._onDisposeObserver) {\r\n            this.onDisposeObservable.remove(this._onDisposeObserver);\r\n        }\r\n        this._onDisposeObserver = this.onDisposeObservable.add(callback);\r\n    }\r\n\r\n    protected _scene: Nullable<Scene> = null;\r\n\r\n    /** @internal */\r\n    private _uid: Nullable<string> = null;\r\n\r\n    /**\r\n     * Define if the texture is preventing a material to render or not.\r\n     * If not and the texture is not ready, the engine will use a default black texture instead.\r\n     */\r\n    public get isBlocking(): boolean {\r\n        return true;\r\n    }\r\n\r\n    /** @internal */\r\n    public _parentContainer: Nullable<AbstractScene> = null;\r\n\r\n    protected _loadingError: boolean = false;\r\n    protected _errorObject?: {\r\n        message?: string;\r\n        exception?: any;\r\n    };\r\n\r\n    /**\r\n     * Was there any loading error?\r\n     */\r\n    public get loadingError(): boolean {\r\n        return this._loadingError;\r\n    }\r\n\r\n    /**\r\n     * If a loading error occurred this object will be populated with information about the error.\r\n     */\r\n    public get errorObject():\r\n        | {\r\n              message?: string;\r\n              exception?: any;\r\n          }\r\n        | undefined {\r\n        return this._errorObject;\r\n    }\r\n\r\n    /**\r\n     * Instantiates a new BaseTexture.\r\n     * Base class of all the textures in babylon.\r\n     * It groups all the common properties the materials, post process, lights... might need\r\n     * in order to make a correct use of the texture.\r\n     * @param sceneOrEngine Define the scene or engine the texture belongs to\r\n     * @param internalTexture Define the internal texture associated with the texture\r\n     */\r\n    constructor(sceneOrEngine?: Nullable<Scene | ThinEngine>, internalTexture: Nullable<InternalTexture> = null) {\r\n        super(null);\r\n\r\n        if (sceneOrEngine) {\r\n            if (BaseTexture._IsScene(sceneOrEngine)) {\r\n                this._scene = sceneOrEngine;\r\n            } else {\r\n                this._engine = sceneOrEngine;\r\n            }\r\n        } else {\r\n            this._scene = EngineStore.LastCreatedScene;\r\n        }\r\n\r\n        if (this._scene) {\r\n            this.uniqueId = this._scene.getUniqueId();\r\n            this._scene.addTexture(this);\r\n            this._engine = this._scene.getEngine();\r\n        }\r\n\r\n        this._texture = internalTexture;\r\n\r\n        this._uid = null;\r\n    }\r\n\r\n    /**\r\n     * Get the scene the texture belongs to.\r\n     * @returns the scene or null if undefined\r\n     */\r\n    public getScene(): Nullable<Scene> {\r\n        return this._scene;\r\n    }\r\n\r\n    /** @internal */\r\n    protected _getEngine(): Nullable<ThinEngine> {\r\n        return this._engine;\r\n    }\r\n\r\n    /**\r\n     * Checks if the texture has the same transform matrix than another texture\r\n     * @param texture texture to check against\r\n     * @returns true if the transforms are the same, else false\r\n     */\r\n    public checkTransformsAreIdentical(texture: Nullable<BaseTexture>): boolean {\r\n        return texture !== null;\r\n    }\r\n\r\n    /**\r\n     * Get the texture transform matrix used to offset tile the texture for instance.\r\n     * @returns the transformation matrix\r\n     */\r\n    public getTextureMatrix(): Matrix {\r\n        return <Matrix>Matrix.IdentityReadOnly;\r\n    }\r\n\r\n    /**\r\n     * Get the texture reflection matrix used to rotate/transform the reflection.\r\n     * @returns the reflection matrix\r\n     */\r\n    public getReflectionTextureMatrix(): Matrix {\r\n        return <Matrix>Matrix.IdentityReadOnly;\r\n    }\r\n\r\n    /**\r\n     * Gets a suitable rotate/transform matrix when the texture is used for refraction.\r\n     * There's a separate function from getReflectionTextureMatrix because refraction requires a special configuration of the matrix in right-handed mode.\r\n     * @returns The refraction matrix\r\n     */\r\n    public getRefractionTextureMatrix(): Matrix {\r\n        return this.getReflectionTextureMatrix();\r\n    }\r\n\r\n    /**\r\n     * Get if the texture is ready to be consumed (either it is ready or it is not blocking)\r\n     * @returns true if ready, not blocking or if there was an error loading the texture\r\n     */\r\n    public isReadyOrNotBlocking(): boolean {\r\n        return !this.isBlocking || this.isReady() || this.loadingError;\r\n    }\r\n\r\n    /**\r\n     * Scales the texture if is `canRescale()`\r\n     * @param ratio the resize factor we want to use to rescale\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public scale(ratio: number): void {}\r\n\r\n    /**\r\n     * Get if the texture can rescale.\r\n     */\r\n    public get canRescale(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _getFromCache(url: Nullable<string>, noMipmap: boolean, sampling?: number, invertY?: boolean, useSRGBBuffer?: boolean, isCube?: boolean): Nullable<InternalTexture> {\r\n        const engine = this._getEngine();\r\n        if (!engine) {\r\n            return null;\r\n        }\r\n\r\n        const correctedUseSRGBBuffer = engine._getUseSRGBBuffer(!!useSRGBBuffer, noMipmap);\r\n\r\n        const texturesCache = engine.getLoadedTexturesCache();\r\n        for (let index = 0; index < texturesCache.length; index++) {\r\n            const texturesCacheEntry = texturesCache[index];\r\n\r\n            if (useSRGBBuffer === undefined || correctedUseSRGBBuffer === texturesCacheEntry._useSRGBBuffer) {\r\n                if (invertY === undefined || invertY === texturesCacheEntry.invertY) {\r\n                    if (texturesCacheEntry.url === url && texturesCacheEntry.generateMipMaps === !noMipmap) {\r\n                        if (!sampling || sampling === texturesCacheEntry.samplingMode) {\r\n                            if (isCube === undefined || isCube === texturesCacheEntry.isCube) {\r\n                                texturesCacheEntry.incrementReferences();\r\n                                return texturesCacheEntry;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /** @internal */\r\n    public _rebuild(_fromContextLost = false): void {}\r\n\r\n    /**\r\n     * Clones the texture.\r\n     * @returns the cloned texture\r\n     */\r\n    public clone(): Nullable<BaseTexture> {\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Get the texture underlying type (INT, FLOAT...)\r\n     */\r\n    public get textureType(): number {\r\n        if (!this._texture) {\r\n            return Constants.TEXTURETYPE_UNSIGNED_INT;\r\n        }\r\n\r\n        return this._texture.type !== undefined ? this._texture.type : Constants.TEXTURETYPE_UNSIGNED_INT;\r\n    }\r\n\r\n    /**\r\n     * Get the texture underlying format (RGB, RGBA...)\r\n     */\r\n    public get textureFormat(): number {\r\n        if (!this._texture) {\r\n            return Constants.TEXTUREFORMAT_RGBA;\r\n        }\r\n\r\n        return this._texture.format !== undefined ? this._texture.format : Constants.TEXTUREFORMAT_RGBA;\r\n    }\r\n\r\n    /**\r\n     * Indicates that textures need to be re-calculated for all materials\r\n     */\r\n    protected _markAllSubMeshesAsTexturesDirty() {\r\n        const scene = this.getScene();\r\n\r\n        if (!scene) {\r\n            return;\r\n        }\r\n\r\n        scene.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag);\r\n    }\r\n\r\n    /**\r\n     * Reads the pixels stored in the webgl texture and returns them as an ArrayBuffer.\r\n     * This will returns an RGBA array buffer containing either in values (0-255) or\r\n     * float values (0-1) depending of the underlying buffer type.\r\n     * @param faceIndex defines the face of the texture to read (in case of cube texture)\r\n     * @param level defines the LOD level of the texture to read (in case of Mip Maps)\r\n     * @param buffer defines a user defined buffer to fill with data (can be null)\r\n     * @param flushRenderer true to flush the renderer from the pending commands before reading the pixels\r\n     * @param noDataConversion false to convert the data to Uint8Array (if texture type is UNSIGNED_BYTE) or to Float32Array (if texture type is anything but UNSIGNED_BYTE). If true, the type of the generated buffer (if buffer==null) will depend on the type of the texture\r\n     * @param x defines the region x coordinates to start reading from (default to 0)\r\n     * @param y defines the region y coordinates to start reading from (default to 0)\r\n     * @param width defines the region width to read from (default to the texture size at level)\r\n     * @param height defines the region width to read from (default to the texture size at level)\r\n     * @returns The Array buffer promise containing the pixels data.\r\n     */\r\n    public readPixels(\r\n        faceIndex = 0,\r\n        level = 0,\r\n        buffer: Nullable<ArrayBufferView> = null,\r\n        flushRenderer = true,\r\n        noDataConversion = false,\r\n        x = 0,\r\n        y = 0,\r\n        width = Number.MAX_VALUE,\r\n        height = Number.MAX_VALUE\r\n    ): Nullable<Promise<ArrayBufferView>> {\r\n        if (!this._texture) {\r\n            return null;\r\n        }\r\n\r\n        const engine = this._getEngine();\r\n        if (!engine) {\r\n            return null;\r\n        }\r\n\r\n        const size = this.getSize();\r\n        let maxWidth = size.width;\r\n        let maxHeight = size.height;\r\n        if (level !== 0) {\r\n            maxWidth = maxWidth / Math.pow(2, level);\r\n            maxHeight = maxHeight / Math.pow(2, level);\r\n            maxWidth = Math.round(maxWidth);\r\n            maxHeight = Math.round(maxHeight);\r\n        }\r\n\r\n        width = Math.min(maxWidth, width);\r\n        height = Math.min(maxHeight, height);\r\n\r\n        try {\r\n            if (this._texture.isCube) {\r\n                return engine._readTexturePixels(this._texture, width, height, faceIndex, level, buffer, flushRenderer, noDataConversion, x, y);\r\n            }\r\n\r\n            return engine._readTexturePixels(this._texture, width, height, -1, level, buffer, flushRenderer, noDataConversion, x, y);\r\n        } catch (e) {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _readPixelsSync(faceIndex = 0, level = 0, buffer: Nullable<ArrayBufferView> = null, flushRenderer = true, noDataConversion = false): Nullable<ArrayBufferView> {\r\n        if (!this._texture) {\r\n            return null;\r\n        }\r\n\r\n        const size = this.getSize();\r\n        let width = size.width;\r\n        let height = size.height;\r\n\r\n        const engine = this._getEngine();\r\n        if (!engine) {\r\n            return null;\r\n        }\r\n\r\n        if (level != 0) {\r\n            width = width / Math.pow(2, level);\r\n            height = height / Math.pow(2, level);\r\n\r\n            width = Math.round(width);\r\n            height = Math.round(height);\r\n        }\r\n\r\n        try {\r\n            if (this._texture.isCube) {\r\n                return engine._readTexturePixelsSync(this._texture, width, height, faceIndex, level, buffer, flushRenderer, noDataConversion);\r\n            }\r\n\r\n            return engine._readTexturePixelsSync(this._texture, width, height, -1, level, buffer, flushRenderer, noDataConversion);\r\n        } catch (e) {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public get _lodTextureHigh(): Nullable<BaseTexture> {\r\n        if (this._texture) {\r\n            return this._texture._lodTextureHigh;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /** @internal */\r\n    public get _lodTextureMid(): Nullable<BaseTexture> {\r\n        if (this._texture) {\r\n            return this._texture._lodTextureMid;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /** @internal */\r\n    public get _lodTextureLow(): Nullable<BaseTexture> {\r\n        if (this._texture) {\r\n            return this._texture._lodTextureLow;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Dispose the texture and release its associated resources.\r\n     */\r\n    public dispose(): void {\r\n        if (this._scene) {\r\n            // Animations\r\n            if (this._scene.stopAnimation) {\r\n                this._scene.stopAnimation(this);\r\n            }\r\n\r\n            // Remove from scene\r\n            this._scene.removePendingData(this);\r\n            const index = this._scene.textures.indexOf(this);\r\n\r\n            if (index >= 0) {\r\n                this._scene.textures.splice(index, 1);\r\n            }\r\n            this._scene.onTextureRemovedObservable.notifyObservers(this);\r\n            this._scene = null;\r\n\r\n            if (this._parentContainer) {\r\n                const index = this._parentContainer.textures.indexOf(this);\r\n                if (index > -1) {\r\n                    this._parentContainer.textures.splice(index, 1);\r\n                }\r\n                this._parentContainer = null;\r\n            }\r\n        }\r\n\r\n        // Callback\r\n        this.onDisposeObservable.notifyObservers(this);\r\n        this.onDisposeObservable.clear();\r\n\r\n        this.metadata = null;\r\n\r\n        super.dispose();\r\n    }\r\n\r\n    /**\r\n     * Serialize the texture into a JSON representation that can be parsed later on.\r\n     * @param allowEmptyName True to force serialization even if name is empty. Default: false\r\n     * @returns the JSON representation of the texture\r\n     */\r\n    public serialize(allowEmptyName = false): any {\r\n        if (!this.name && !allowEmptyName) {\r\n            return null;\r\n        }\r\n\r\n        const serializationObject = SerializationHelper.Serialize(this);\r\n\r\n        // Animations\r\n        SerializationHelper.AppendSerializedAnimations(this, serializationObject);\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Helper function to be called back once a list of texture contains only ready textures.\r\n     * @param textures Define the list of textures to wait for\r\n     * @param callback Define the callback triggered once the entire list will be ready\r\n     */\r\n    public static WhenAllReady(textures: BaseTexture[], callback: () => void): void {\r\n        let numRemaining = textures.length;\r\n        if (numRemaining === 0) {\r\n            callback();\r\n            return;\r\n        }\r\n\r\n        for (let i = 0; i < textures.length; i++) {\r\n            const texture = textures[i];\r\n\r\n            if (texture.isReady()) {\r\n                if (--numRemaining === 0) {\r\n                    callback();\r\n                }\r\n            } else {\r\n                const onLoadObservable = (texture as any).onLoadObservable as Observable<BaseTexture>;\r\n\r\n                if (onLoadObservable) {\r\n                    onLoadObservable.addOnce(() => {\r\n                        if (--numRemaining === 0) {\r\n                            callback();\r\n                        }\r\n                    });\r\n                } else {\r\n                    if (--numRemaining === 0) {\r\n                        callback();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private static _IsScene(sceneOrEngine: Scene | ThinEngine): sceneOrEngine is Scene {\r\n        return sceneOrEngine.getClassName() === \"Scene\";\r\n    }\r\n}\r\n", "/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { ISize } from \"../Maths/math.size\";\r\nimport type { Nullable } from \"../types\";\r\n\r\nimport type { BaseTexture } from \"../Materials/Textures/baseTexture\";\r\n\r\n/**\r\n * Transform some pixel data to a base64 string\r\n * @param pixels defines the pixel data to transform to base64\r\n * @param size defines the width and height of the (texture) data\r\n * @param invertY true if the data must be inverted for the Y coordinate during the conversion\r\n * @returns The base64 encoded string or null\r\n */\r\nexport function GenerateBase64StringFromPixelData(pixels: ArrayBufferView, size: ISize, invertY = false): Nullable<string> {\r\n    const width = size.width;\r\n    const height = size.height;\r\n\r\n    if (pixels instanceof Float32Array) {\r\n        let len = pixels.byteLength / pixels.BYTES_PER_ELEMENT;\r\n        const npixels = new Uint8Array(len);\r\n\r\n        while (--len >= 0) {\r\n            let val = pixels[len];\r\n            if (val < 0) {\r\n                val = 0;\r\n            } else if (val > 1) {\r\n                val = 1;\r\n            }\r\n            npixels[len] = val * 255;\r\n        }\r\n\r\n        pixels = npixels;\r\n    }\r\n\r\n    const canvas = document.createElement(\"canvas\");\r\n    canvas.width = width;\r\n    canvas.height = height;\r\n\r\n    const ctx = canvas.getContext(\"2d\");\r\n    if (!ctx) {\r\n        return null;\r\n    }\r\n\r\n    const imageData = ctx.createImageData(width, height);\r\n    const castData = <any>imageData.data;\r\n    castData.set(pixels);\r\n    ctx.putImageData(imageData, 0, 0);\r\n\r\n    if (invertY) {\r\n        const canvas2 = document.createElement(\"canvas\");\r\n        canvas2.width = width;\r\n        canvas2.height = height;\r\n\r\n        const ctx2 = canvas2.getContext(\"2d\");\r\n        if (!ctx2) {\r\n            return null;\r\n        }\r\n\r\n        ctx2.translate(0, height);\r\n        ctx2.scale(1, -1);\r\n        ctx2.drawImage(canvas, 0, 0);\r\n\r\n        return canvas2.toDataURL(\"image/png\");\r\n    }\r\n\r\n    return canvas.toDataURL(\"image/png\");\r\n}\r\n\r\n/**\r\n * Reads the pixels stored in the webgl texture and returns them as a base64 string\r\n * @param texture defines the texture to read pixels from\r\n * @param faceIndex defines the face of the texture to read (in case of cube texture)\r\n * @param level defines the LOD level of the texture to read (in case of Mip Maps)\r\n * @returns The base64 encoded string or null\r\n */\r\nexport function GenerateBase64StringFromTexture(texture: BaseTexture, faceIndex = 0, level = 0): Nullable<string> {\r\n    const internalTexture = texture.getInternalTexture();\r\n    if (!internalTexture) {\r\n        return null;\r\n    }\r\n\r\n    const pixels = texture._readPixelsSync(faceIndex, level);\r\n    if (!pixels) {\r\n        return null;\r\n    }\r\n\r\n    return GenerateBase64StringFromPixelData(pixels, texture.getSize(), internalTexture.invertY);\r\n}\r\n\r\n/**\r\n * Reads the pixels stored in the webgl texture and returns them as a base64 string\r\n * @param texture defines the texture to read pixels from\r\n * @param faceIndex defines the face of the texture to read (in case of cube texture)\r\n * @param level defines the LOD level of the texture to read (in case of Mip Maps)\r\n * @returns The base64 encoded string or null wrapped in a promise\r\n */\r\nexport async function GenerateBase64StringFromTextureAsync(texture: BaseTexture, faceIndex = 0, level = 0): Promise<Nullable<string>> {\r\n    const internalTexture = texture.getInternalTexture();\r\n    if (!internalTexture) {\r\n        return null;\r\n    }\r\n\r\n    const pixels = await texture.readPixels(faceIndex, level);\r\n    if (!pixels) {\r\n        return null;\r\n    }\r\n\r\n    return GenerateBase64StringFromPixelData(pixels, texture.getSize(), internalTexture.invertY);\r\n}\r\n\r\n/**\r\n * Class used to host copy specific utilities\r\n * (Back-compat)\r\n */\r\nexport const CopyTools = {\r\n    /**\r\n     * Transform some pixel data to a base64 string\r\n     * @param pixels defines the pixel data to transform to base64\r\n     * @param size defines the width and height of the (texture) data\r\n     * @param invertY true if the data must be inverted for the Y coordinate during the conversion\r\n     * @returns The base64 encoded string or null\r\n     */\r\n    GenerateBase64StringFromPixelData,\r\n\r\n    /**\r\n     * Reads the pixels stored in the webgl texture and returns them as a base64 string\r\n     * @param texture defines the texture to read pixels from\r\n     * @param faceIndex defines the face of the texture to read (in case of cube texture)\r\n     * @param level defines the LOD level of the texture to read (in case of Mip Maps)\r\n     * @returns The base64 encoded string or null\r\n     */\r\n    GenerateBase64StringFromTexture,\r\n\r\n    /**\r\n     * Reads the pixels stored in the webgl texture and returns them as a base64 string\r\n     * @param texture defines the texture to read pixels from\r\n     * @param faceIndex defines the face of the texture to read (in case of cube texture)\r\n     * @param level defines the LOD level of the texture to read (in case of Mip Maps)\r\n     * @returns The base64 encoded string or null wrapped in a promise\r\n     */\r\n    GenerateBase64StringFromTextureAsync,\r\n};\r\n", "import { serialize } from \"../../Misc/decorators\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { Matrix, TmpVectors, Vector3 } from \"../../Maths/math.vector\";\r\nimport { BaseTexture } from \"../../Materials/Textures/baseTexture\";\r\nimport { Constants } from \"../../Engines/constants\";\r\nimport { GetClass, RegisterClass } from \"../../Misc/typeStore\";\r\nimport { _WarnImport } from \"../../Misc/devTools\";\r\nimport type { IInspectable } from \"../../Misc/iInspectable\";\r\nimport type { ThinEngine } from \"../../Engines/thinEngine\";\r\nimport { TimingTools } from \"../../Misc/timingTools\";\r\nimport { InstantiationTools } from \"../../Misc/instantiationTools\";\r\nimport { Plane } from \"../../Maths/math.plane\";\r\nimport { EncodeArrayBufferToBase64 } from \"../../Misc/stringTools\";\r\nimport { GenerateBase64StringFromTexture, GenerateBase64StringFromTextureAsync } from \"../../Misc/copyTools\";\r\nimport { CompatibilityOptions } from \"../../Compat/compatibilityOptions\";\r\nimport type { InternalTexture } from \"./internalTexture\";\r\n\r\nimport type { CubeTexture } from \"../../Materials/Textures/cubeTexture\";\r\nimport type { MirrorTexture } from \"../../Materials/Textures/mirrorTexture\";\r\nimport type { RenderTargetTexture } from \"../../Materials/Textures/renderTargetTexture\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { VideoTexture, VideoTextureSettings } from \"./videoTexture\";\r\n\r\nimport { SerializationHelper } from \"../../Misc/decorators.serialization\";\r\n\r\n/**\r\n * Defines the available options when creating a texture\r\n */\r\nexport interface ITextureCreationOptions {\r\n    /** Defines if the texture will require mip maps or not (default: false) */\r\n    noMipmap?: boolean;\r\n\r\n    /** Defines if the texture needs to be inverted on the y axis during loading (default: true) */\r\n    invertY?: boolean;\r\n\r\n    /** Defines the sampling mode we want for the texture while fetching from it (Texture.NEAREST_SAMPLINGMODE...) (default: Texture.TRILINEAR_SAMPLINGMODE) */\r\n    samplingMode?: number;\r\n\r\n    /** Defines a callback triggered when the texture has been loaded (default: null) */\r\n    onLoad?: Nullable<() => void>;\r\n\r\n    /** Defines a callback triggered when an error occurred during the loading session (default: null) */\r\n    onError?: Nullable<(message?: string, exception?: any) => void>;\r\n\r\n    /** Defines the buffer to load the texture from in case the texture is loaded from a buffer representation (default: null) */\r\n    buffer?: Nullable<string | ArrayBuffer | ArrayBufferView | HTMLImageElement | Blob | ImageBitmap>;\r\n\r\n    /** Defines if the buffer we are loading the texture from should be deleted after load (default: false) */\r\n    deleteBuffer?: boolean;\r\n\r\n    /** Defines the format of the texture we are trying to load (Engine.TEXTUREFORMAT_RGBA...) (default: ) */\r\n    format?: number;\r\n\r\n    /** Defines an optional mime type information (default: undefined) */\r\n    mimeType?: string;\r\n\r\n    /** Options to be passed to the loader (default: undefined) */\r\n    loaderOptions?: any;\r\n\r\n    /** Specific flags to use when creating the texture (Constants.TEXTURE_CREATIONFLAG_STORAGE for storage textures, for eg) (default: undefined) */\r\n    creationFlags?: number;\r\n\r\n    /** Defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU) (default: false) */\r\n    useSRGBBuffer?: boolean;\r\n\r\n    /** Defines the underlying texture from an already existing one */\r\n    internalTexture?: InternalTexture;\r\n\r\n    /** Defines the underlying texture texture space */\r\n    gammaSpace?: boolean;\r\n}\r\n\r\n/**\r\n * This represents a texture in babylon. It can be easily loaded from a network, base64 or html input.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/materials_introduction#texture\r\n */\r\nexport class Texture extends BaseTexture {\r\n    /**\r\n     * Gets or sets a general boolean used to indicate that textures containing direct data (buffers) must be saved as part of the serialization process\r\n     */\r\n    public static SerializeBuffers = true;\r\n\r\n    /**\r\n     * Gets or sets a general boolean used to indicate that texture buffers must be saved as part of the serialization process.\r\n     * If no buffer exists, one will be created as base64 string from the internal webgl data.\r\n     */\r\n    public static ForceSerializeBuffers = false;\r\n\r\n    /**\r\n     * This observable will notify when any texture had a loading error\r\n     */\r\n    public static OnTextureLoadErrorObservable = new Observable<BaseTexture>();\r\n\r\n    /** @internal */\r\n    public static _SerializeInternalTextureUniqueId = false;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public static _CubeTextureParser = (jsonTexture: any, scene: Scene, rootUrl: string): CubeTexture => {\r\n        throw _WarnImport(\"CubeTexture\");\r\n    };\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public static _CreateMirror = (name: string, renderTargetSize: number, scene: Scene, generateMipMaps: boolean): MirrorTexture => {\r\n        throw _WarnImport(\"MirrorTexture\");\r\n    };\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public static _CreateRenderTargetTexture = (name: string, renderTargetSize: number, scene: Scene, generateMipMaps: boolean, creationFlags?: number): RenderTargetTexture => {\r\n        throw _WarnImport(\"RenderTargetTexture\");\r\n    };\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public static _CreateVideoTexture(\r\n        name: Nullable<string>,\r\n        src: string | string[] | HTMLVideoElement,\r\n        scene: Nullable<Scene>,\r\n        generateMipMaps = false,\r\n        invertY = false,\r\n        samplingMode: number = Texture.TRILINEAR_SAMPLINGMODE,\r\n        settings: Partial<VideoTextureSettings> = {},\r\n        onError?: Nullable<(message?: string, exception?: any) => void>,\r\n        format: number = Constants.TEXTUREFORMAT_RGBA\r\n    ): VideoTexture {\r\n        throw _WarnImport(\"VideoTexture\");\r\n    }\r\n\r\n    /** nearest is mag = nearest and min = nearest and no mip */\r\n    public static readonly NEAREST_SAMPLINGMODE = Constants.TEXTURE_NEAREST_SAMPLINGMODE;\r\n    /** nearest is mag = nearest and min = nearest and mip = linear */\r\n    public static readonly NEAREST_NEAREST_MIPLINEAR = Constants.TEXTURE_NEAREST_NEAREST_MIPLINEAR; // nearest is mag = nearest and min = nearest and mip = linear\r\n\r\n    /** Bilinear is mag = linear and min = linear and no mip */\r\n    public static readonly BILINEAR_SAMPLINGMODE = Constants.TEXTURE_BILINEAR_SAMPLINGMODE;\r\n    /** Bilinear is mag = linear and min = linear and mip = nearest */\r\n    public static readonly LINEAR_LINEAR_MIPNEAREST = Constants.TEXTURE_LINEAR_LINEAR_MIPNEAREST; // Bilinear is mag = linear and min = linear and mip = nearest\r\n\r\n    /** Trilinear is mag = linear and min = linear and mip = linear */\r\n    public static readonly TRILINEAR_SAMPLINGMODE = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE;\r\n    /** Trilinear is mag = linear and min = linear and mip = linear */\r\n    public static readonly LINEAR_LINEAR_MIPLINEAR = Constants.TEXTURE_LINEAR_LINEAR_MIPLINEAR; // Trilinear is mag = linear and min = linear and mip = linear\r\n\r\n    /** mag = nearest and min = nearest and mip = nearest */\r\n    public static readonly NEAREST_NEAREST_MIPNEAREST = Constants.TEXTURE_NEAREST_NEAREST_MIPNEAREST;\r\n    /** mag = nearest and min = linear and mip = nearest */\r\n    public static readonly NEAREST_LINEAR_MIPNEAREST = Constants.TEXTURE_NEAREST_LINEAR_MIPNEAREST;\r\n    /** mag = nearest and min = linear and mip = linear */\r\n    public static readonly NEAREST_LINEAR_MIPLINEAR = Constants.TEXTURE_NEAREST_LINEAR_MIPLINEAR;\r\n    /** mag = nearest and min = linear and mip = none */\r\n    public static readonly NEAREST_LINEAR = Constants.TEXTURE_NEAREST_LINEAR;\r\n    /** mag = nearest and min = nearest and mip = none */\r\n    public static readonly NEAREST_NEAREST = Constants.TEXTURE_NEAREST_NEAREST;\r\n    /** mag = linear and min = nearest and mip = nearest */\r\n    public static readonly LINEAR_NEAREST_MIPNEAREST = Constants.TEXTURE_LINEAR_NEAREST_MIPNEAREST;\r\n    /** mag = linear and min = nearest and mip = linear */\r\n    public static readonly LINEAR_NEAREST_MIPLINEAR = Constants.TEXTURE_LINEAR_NEAREST_MIPLINEAR;\r\n    /** mag = linear and min = linear and mip = none */\r\n    public static readonly LINEAR_LINEAR = Constants.TEXTURE_LINEAR_LINEAR;\r\n    /** mag = linear and min = nearest and mip = none */\r\n    public static readonly LINEAR_NEAREST = Constants.TEXTURE_LINEAR_NEAREST;\r\n\r\n    /** Explicit coordinates mode */\r\n    public static readonly EXPLICIT_MODE = Constants.TEXTURE_EXPLICIT_MODE;\r\n    /** Spherical coordinates mode */\r\n    public static readonly SPHERICAL_MODE = Constants.TEXTURE_SPHERICAL_MODE;\r\n    /** Planar coordinates mode */\r\n    public static readonly PLANAR_MODE = Constants.TEXTURE_PLANAR_MODE;\r\n    /** Cubic coordinates mode */\r\n    public static readonly CUBIC_MODE = Constants.TEXTURE_CUBIC_MODE;\r\n    /** Projection coordinates mode */\r\n    public static readonly PROJECTION_MODE = Constants.TEXTURE_PROJECTION_MODE;\r\n    /** Inverse Cubic coordinates mode */\r\n    public static readonly SKYBOX_MODE = Constants.TEXTURE_SKYBOX_MODE;\r\n    /** Inverse Cubic coordinates mode */\r\n    public static readonly INVCUBIC_MODE = Constants.TEXTURE_INVCUBIC_MODE;\r\n    /** Equirectangular coordinates mode */\r\n    public static readonly EQUIRECTANGULAR_MODE = Constants.TEXTURE_EQUIRECTANGULAR_MODE;\r\n    /** Equirectangular Fixed coordinates mode */\r\n    public static readonly FIXED_EQUIRECTANGULAR_MODE = Constants.TEXTURE_FIXED_EQUIRECTANGULAR_MODE;\r\n    /** Equirectangular Fixed Mirrored coordinates mode */\r\n    public static readonly FIXED_EQUIRECTANGULAR_MIRRORED_MODE = Constants.TEXTURE_FIXED_EQUIRECTANGULAR_MIRRORED_MODE;\r\n\r\n    /** Texture is not repeating outside of 0..1 UVs */\r\n    public static readonly CLAMP_ADDRESSMODE = Constants.TEXTURE_CLAMP_ADDRESSMODE;\r\n    /** Texture is repeating outside of 0..1 UVs */\r\n    public static readonly WRAP_ADDRESSMODE = Constants.TEXTURE_WRAP_ADDRESSMODE;\r\n    /** Texture is repeating and mirrored */\r\n    public static readonly MIRROR_ADDRESSMODE = Constants.TEXTURE_MIRROR_ADDRESSMODE;\r\n\r\n    /**\r\n     * Gets or sets a boolean which defines if the texture url must be build from the serialized URL instead of just using the name and loading them side by side with the scene file\r\n     */\r\n    public static UseSerializedUrlIfAny = false;\r\n\r\n    /**\r\n     * Define the url of the texture.\r\n     */\r\n    @serialize()\r\n    public url: Nullable<string> = null;\r\n\r\n    /**\r\n     * Define an offset on the texture to offset the u coordinates of the UVs\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/moreMaterials#offsetting\r\n     */\r\n    @serialize()\r\n    public uOffset = 0;\r\n\r\n    /**\r\n     * Define an offset on the texture to offset the v coordinates of the UVs\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/moreMaterials#offsetting\r\n     */\r\n    @serialize()\r\n    public vOffset = 0;\r\n\r\n    /**\r\n     * Define an offset on the texture to scale the u coordinates of the UVs\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/moreMaterials#tiling\r\n     */\r\n    @serialize()\r\n    public uScale = 1.0;\r\n\r\n    /**\r\n     * Define an offset on the texture to scale the v coordinates of the UVs\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/moreMaterials#tiling\r\n     */\r\n    @serialize()\r\n    public vScale = 1.0;\r\n\r\n    /**\r\n     * Define an offset on the texture to rotate around the u coordinates of the UVs\r\n     * The angle is defined in radians.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/moreMaterials\r\n     */\r\n    @serialize()\r\n    public uAng = 0;\r\n\r\n    /**\r\n     * Define an offset on the texture to rotate around the v coordinates of the UVs\r\n     * The angle is defined in radians.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/moreMaterials\r\n     */\r\n    @serialize()\r\n    public vAng = 0;\r\n\r\n    /**\r\n     * Define an offset on the texture to rotate around the w coordinates of the UVs (in case of 3d texture)\r\n     * The angle is defined in radians.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/moreMaterials\r\n     */\r\n    @serialize()\r\n    public wAng = 0;\r\n\r\n    /**\r\n     * Defines the center of rotation (U)\r\n     */\r\n    @serialize()\r\n    public uRotationCenter = 0.5;\r\n\r\n    /**\r\n     * Defines the center of rotation (V)\r\n     */\r\n    @serialize()\r\n    public vRotationCenter = 0.5;\r\n\r\n    /**\r\n     * Defines the center of rotation (W)\r\n     */\r\n    @serialize()\r\n    public wRotationCenter = 0.5;\r\n\r\n    /**\r\n     * Sets this property to true to avoid deformations when rotating the texture with non-uniform scaling\r\n     */\r\n    @serialize()\r\n    public homogeneousRotationInUVTransform = false;\r\n\r\n    /**\r\n     * Are mip maps generated for this texture or not.\r\n     */\r\n    get noMipmap(): boolean {\r\n        return this._noMipmap;\r\n    }\r\n\r\n    /**\r\n     * List of inspectable custom properties (used by the Inspector)\r\n     * @see https://doc.babylonjs.com/toolsAndResources/inspector#extensibility\r\n     */\r\n    public inspectableCustomProperties: Nullable<IInspectable[]> = null;\r\n\r\n    /** @internal */\r\n    public _noMipmap: boolean = false;\r\n    /** @internal */\r\n    public _invertY: boolean = false;\r\n    private _rowGenerationMatrix: Nullable<Matrix> = null;\r\n    private _cachedTextureMatrix: Nullable<Matrix> = null;\r\n    private _projectionModeMatrix: Nullable<Matrix> = null;\r\n    private _t0: Nullable<Vector3> = null;\r\n    private _t1: Nullable<Vector3> = null;\r\n    private _t2: Nullable<Vector3> = null;\r\n\r\n    private _cachedUOffset: number = -1;\r\n    private _cachedVOffset: number = -1;\r\n    private _cachedUScale: number = 0;\r\n    private _cachedVScale: number = 0;\r\n    private _cachedUAng: number = -1;\r\n    private _cachedVAng: number = -1;\r\n    private _cachedWAng: number = -1;\r\n    private _cachedReflectionProjectionMatrixId: number = -1;\r\n    private _cachedURotationCenter: number = -1;\r\n    private _cachedVRotationCenter: number = -1;\r\n    private _cachedWRotationCenter: number = -1;\r\n    private _cachedHomogeneousRotationInUVTransform: boolean = false;\r\n\r\n    private _cachedReflectionTextureMatrix: Nullable<Matrix> = null;\r\n    private _cachedReflectionUOffset = -1;\r\n    private _cachedReflectionVOffset = -1;\r\n    private _cachedReflectionUScale = 0;\r\n    private _cachedReflectionVScale = 0;\r\n    private _cachedReflectionCoordinatesMode = -1;\r\n\r\n    /** @internal */\r\n    public _buffer: Nullable<string | ArrayBuffer | ArrayBufferView | HTMLImageElement | Blob | ImageBitmap> = null;\r\n    private _deleteBuffer: boolean = false;\r\n    protected _format: Nullable<number> = null;\r\n    private _delayedOnLoad: Nullable<() => void> = null;\r\n    private _delayedOnError: Nullable<() => void> = null;\r\n    private _mimeType?: string;\r\n    private _loaderOptions?: any;\r\n    private _creationFlags?: number;\r\n    /** @internal */\r\n    public _useSRGBBuffer?: boolean;\r\n    private _forcedExtension?: string;\r\n\r\n    /** Returns the texture mime type if it was defined by a loader (undefined else) */\r\n    public get mimeType() {\r\n        return this._mimeType;\r\n    }\r\n\r\n    /**\r\n     * Observable triggered once the texture has been loaded.\r\n     */\r\n    public onLoadObservable: Observable<Texture> = new Observable<Texture>();\r\n\r\n    protected _isBlocking: boolean = true;\r\n    /**\r\n     * Is the texture preventing material to render while loading.\r\n     * If false, a default texture will be used instead of the loading one during the preparation step.\r\n     */\r\n    public set isBlocking(value: boolean) {\r\n        this._isBlocking = value;\r\n    }\r\n    @serialize()\r\n    public get isBlocking(): boolean {\r\n        return this._isBlocking;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if the texture needs to be inverted on the y axis during loading\r\n     */\r\n    public get invertY(): boolean {\r\n        return this._invertY;\r\n    }\r\n\r\n    /**\r\n     * Instantiates a new texture.\r\n     * This represents a texture in babylon. It can be easily loaded from a network, base64 or html input.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/materials_introduction#texture\r\n     * @param url defines the url of the picture to load as a texture\r\n     * @param sceneOrEngine defines the scene or engine the texture will belong to\r\n     * @param noMipmapOrOptions defines if the texture will require mip maps or not or set of all options to create the texture\r\n     * @param invertY defines if the texture needs to be inverted on the y axis during loading\r\n     * @param samplingMode defines the sampling mode we want for the texture while fetching from it (Texture.NEAREST_SAMPLINGMODE...)\r\n     * @param onLoad defines a callback triggered when the texture has been loaded\r\n     * @param onError defines a callback triggered when an error occurred during the loading session\r\n     * @param buffer defines the buffer to load the texture from in case the texture is loaded from a buffer representation\r\n     * @param deleteBuffer defines if the buffer we are loading the texture from should be deleted after load\r\n     * @param format defines the format of the texture we are trying to load (Engine.TEXTUREFORMAT_RGBA...)\r\n     * @param mimeType defines an optional mime type information\r\n     * @param loaderOptions options to be passed to the loader\r\n     * @param creationFlags specific flags to use when creating the texture (Constants.TEXTURE_CREATIONFLAG_STORAGE for storage textures, for eg)\r\n     * @param forcedExtension defines the extension to use to pick the right loader\r\n     */\r\n    constructor(\r\n        url: Nullable<string>,\r\n        sceneOrEngine?: Nullable<Scene | ThinEngine>,\r\n        noMipmapOrOptions?: boolean | ITextureCreationOptions,\r\n        invertY?: boolean,\r\n        samplingMode: number = Texture.TRILINEAR_SAMPLINGMODE,\r\n        onLoad: Nullable<() => void> = null,\r\n        onError: Nullable<(message?: string, exception?: any) => void> = null,\r\n        buffer: Nullable<string | ArrayBuffer | ArrayBufferView | HTMLImageElement | Blob | ImageBitmap> = null,\r\n        deleteBuffer: boolean = false,\r\n        format?: number,\r\n        mimeType?: string,\r\n        loaderOptions?: any,\r\n        creationFlags?: number,\r\n        forcedExtension?: string\r\n    ) {\r\n        super(sceneOrEngine);\r\n\r\n        this.name = url || \"\";\r\n        this.url = url;\r\n\r\n        let noMipmap: boolean;\r\n        let useSRGBBuffer: boolean = false;\r\n        let internalTexture: Nullable<InternalTexture> = null;\r\n        let gammaSpace = true;\r\n\r\n        if (typeof noMipmapOrOptions === \"object\" && noMipmapOrOptions !== null) {\r\n            noMipmap = noMipmapOrOptions.noMipmap ?? false;\r\n            invertY = noMipmapOrOptions.invertY ?? (CompatibilityOptions.UseOpenGLOrientationForUV ? false : true);\r\n            samplingMode = noMipmapOrOptions.samplingMode ?? Texture.TRILINEAR_SAMPLINGMODE;\r\n            onLoad = noMipmapOrOptions.onLoad ?? null;\r\n            onError = noMipmapOrOptions.onError ?? null;\r\n            buffer = noMipmapOrOptions.buffer ?? null;\r\n            deleteBuffer = noMipmapOrOptions.deleteBuffer ?? false;\r\n            format = noMipmapOrOptions.format;\r\n            mimeType = noMipmapOrOptions.mimeType;\r\n            loaderOptions = noMipmapOrOptions.loaderOptions;\r\n            creationFlags = noMipmapOrOptions.creationFlags;\r\n            useSRGBBuffer = noMipmapOrOptions.useSRGBBuffer ?? false;\r\n            internalTexture = noMipmapOrOptions.internalTexture ?? null;\r\n            gammaSpace = noMipmapOrOptions.gammaSpace ?? gammaSpace;\r\n        } else {\r\n            noMipmap = !!noMipmapOrOptions;\r\n        }\r\n\r\n        this._gammaSpace = gammaSpace;\r\n        this._noMipmap = noMipmap;\r\n        this._invertY = invertY === undefined ? (CompatibilityOptions.UseOpenGLOrientationForUV ? false : true) : invertY;\r\n        this._initialSamplingMode = samplingMode;\r\n        this._buffer = buffer;\r\n        this._deleteBuffer = deleteBuffer;\r\n        this._mimeType = mimeType;\r\n        this._loaderOptions = loaderOptions;\r\n        this._creationFlags = creationFlags;\r\n        this._useSRGBBuffer = useSRGBBuffer;\r\n        this._forcedExtension = forcedExtension;\r\n        if (format) {\r\n            this._format = format;\r\n        }\r\n\r\n        const scene = this.getScene();\r\n        const engine = this._getEngine();\r\n        if (!engine) {\r\n            return;\r\n        }\r\n\r\n        engine.onBeforeTextureInitObservable.notifyObservers(this);\r\n\r\n        const load = () => {\r\n            if (this._texture) {\r\n                if (this._texture._invertVScale) {\r\n                    this.vScale *= -1;\r\n                    this.vOffset += 1;\r\n                }\r\n\r\n                // Update texture to match internal texture's wrapping\r\n                if (this._texture._cachedWrapU !== null) {\r\n                    this.wrapU = this._texture._cachedWrapU;\r\n                    this._texture._cachedWrapU = null;\r\n                }\r\n                if (this._texture._cachedWrapV !== null) {\r\n                    this.wrapV = this._texture._cachedWrapV;\r\n                    this._texture._cachedWrapV = null;\r\n                }\r\n                if (this._texture._cachedWrapR !== null) {\r\n                    this.wrapR = this._texture._cachedWrapR;\r\n                    this._texture._cachedWrapR = null;\r\n                }\r\n            }\r\n\r\n            if (this.onLoadObservable.hasObservers()) {\r\n                this.onLoadObservable.notifyObservers(this);\r\n            }\r\n            if (onLoad) {\r\n                onLoad();\r\n            }\r\n\r\n            if (!this.isBlocking && scene) {\r\n                scene.resetCachedMaterial();\r\n            }\r\n        };\r\n\r\n        const errorHandler = (message?: string, exception?: any) => {\r\n            this._loadingError = true;\r\n            this._errorObject = { message, exception };\r\n            if (onError) {\r\n                onError(message, exception);\r\n            }\r\n            Texture.OnTextureLoadErrorObservable.notifyObservers(this);\r\n        };\r\n\r\n        if (!this.url && !internalTexture) {\r\n            this._delayedOnLoad = load;\r\n            this._delayedOnError = errorHandler;\r\n            return;\r\n        }\r\n\r\n        this._texture = internalTexture ?? this._getFromCache(this.url, noMipmap, samplingMode, this._invertY, useSRGBBuffer, this.isCube);\r\n\r\n        if (!this._texture) {\r\n            if (!scene || !scene.useDelayedTextureLoading) {\r\n                try {\r\n                    this._texture = engine.createTexture(\r\n                        this.url,\r\n                        noMipmap,\r\n                        this._invertY,\r\n                        scene,\r\n                        samplingMode,\r\n                        load,\r\n                        errorHandler,\r\n                        this._buffer,\r\n                        undefined,\r\n                        this._format,\r\n                        this._forcedExtension,\r\n                        mimeType,\r\n                        loaderOptions,\r\n                        creationFlags,\r\n                        useSRGBBuffer\r\n                    );\r\n                } catch (e) {\r\n                    errorHandler(\"error loading\", e);\r\n                    throw e;\r\n                }\r\n                if (deleteBuffer) {\r\n                    this._buffer = null;\r\n                }\r\n            } else {\r\n                this.delayLoadState = Constants.DELAYLOADSTATE_NOTLOADED;\r\n\r\n                this._delayedOnLoad = load;\r\n                this._delayedOnError = errorHandler;\r\n            }\r\n        } else {\r\n            if (this._texture.isReady) {\r\n                TimingTools.SetImmediate(() => load());\r\n            } else {\r\n                const loadObserver = this._texture.onLoadedObservable.add(load);\r\n                this._texture.onErrorObservable.add((e) => {\r\n                    errorHandler(e.message, e.exception);\r\n                    this._texture?.onLoadedObservable.remove(loadObserver);\r\n                });\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Update the url (and optional buffer) of this texture if url was null during construction.\r\n     * @param url the url of the texture\r\n     * @param buffer the buffer of the texture (defaults to null)\r\n     * @param onLoad callback called when the texture is loaded  (defaults to null)\r\n     * @param forcedExtension defines the extension to use to pick the right loader\r\n     */\r\n    public updateURL(\r\n        url: string,\r\n        buffer: Nullable<string | ArrayBuffer | ArrayBufferView | HTMLImageElement | Blob | ImageBitmap> = null,\r\n        onLoad?: () => void,\r\n        forcedExtension?: string\r\n    ): void {\r\n        if (this.url) {\r\n            this.releaseInternalTexture();\r\n            this.getScene()!.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag, (mat) => {\r\n                return mat.hasTexture(this);\r\n            });\r\n        }\r\n\r\n        if (!this.name || this.name.startsWith(\"data:\")) {\r\n            this.name = url;\r\n        }\r\n        this.url = url;\r\n        this._buffer = buffer;\r\n        this._forcedExtension = forcedExtension;\r\n        this.delayLoadState = Constants.DELAYLOADSTATE_NOTLOADED;\r\n\r\n        if (onLoad) {\r\n            this._delayedOnLoad = onLoad;\r\n        }\r\n        this.delayLoad();\r\n    }\r\n\r\n    /**\r\n     * Finish the loading sequence of a texture flagged as delayed load.\r\n     * @internal\r\n     */\r\n    public delayLoad(): void {\r\n        if (this.delayLoadState !== Constants.DELAYLOADSTATE_NOTLOADED) {\r\n            return;\r\n        }\r\n\r\n        const scene = this.getScene();\r\n        if (!scene) {\r\n            return;\r\n        }\r\n\r\n        this.delayLoadState = Constants.DELAYLOADSTATE_LOADED;\r\n        this._texture = this._getFromCache(this.url, this._noMipmap, this.samplingMode, this._invertY, this._useSRGBBuffer, this.isCube);\r\n\r\n        if (!this._texture) {\r\n            this._texture = scene\r\n                .getEngine()\r\n                .createTexture(\r\n                    this.url,\r\n                    this._noMipmap,\r\n                    this._invertY,\r\n                    scene,\r\n                    this.samplingMode,\r\n                    this._delayedOnLoad,\r\n                    this._delayedOnError,\r\n                    this._buffer,\r\n                    null,\r\n                    this._format,\r\n                    this._forcedExtension,\r\n                    this._mimeType,\r\n                    this._loaderOptions,\r\n                    this._creationFlags,\r\n                    this._useSRGBBuffer\r\n                );\r\n            if (this._deleteBuffer) {\r\n                this._buffer = null;\r\n            }\r\n        } else {\r\n            if (this._delayedOnLoad) {\r\n                if (this._texture.isReady) {\r\n                    TimingTools.SetImmediate(this._delayedOnLoad);\r\n                } else {\r\n                    this._texture.onLoadedObservable.add(this._delayedOnLoad);\r\n                }\r\n            }\r\n        }\r\n\r\n        this._delayedOnLoad = null;\r\n        this._delayedOnError = null;\r\n    }\r\n\r\n    private _prepareRowForTextureGeneration(x: number, y: number, z: number, t: Vector3): void {\r\n        x *= this._cachedUScale;\r\n        y *= this._cachedVScale;\r\n\r\n        x -= this.uRotationCenter * this._cachedUScale;\r\n        y -= this.vRotationCenter * this._cachedVScale;\r\n        z -= this.wRotationCenter;\r\n\r\n        Vector3.TransformCoordinatesFromFloatsToRef(x, y, z, this._rowGenerationMatrix!, t);\r\n\r\n        t.x += this.uRotationCenter * this._cachedUScale + this._cachedUOffset;\r\n        t.y += this.vRotationCenter * this._cachedVScale + this._cachedVOffset;\r\n        t.z += this.wRotationCenter;\r\n    }\r\n\r\n    /**\r\n     * Checks if the texture has the same transform matrix than another texture\r\n     * @param texture texture to check against\r\n     * @returns true if the transforms are the same, else false\r\n     */\r\n    public checkTransformsAreIdentical(texture: Nullable<Texture>): boolean {\r\n        return (\r\n            texture !== null &&\r\n            this.uOffset === texture.uOffset &&\r\n            this.vOffset === texture.vOffset &&\r\n            this.uScale === texture.uScale &&\r\n            this.vScale === texture.vScale &&\r\n            this.uAng === texture.uAng &&\r\n            this.vAng === texture.vAng &&\r\n            this.wAng === texture.wAng\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Get the current texture matrix which includes the requested offsetting, tiling and rotation components.\r\n     * @param uBase The horizontal base offset multiplier (1 by default)\r\n     * @returns the transform matrix of the texture.\r\n     */\r\n    public getTextureMatrix(uBase = 1): Matrix {\r\n        if (\r\n            this.uOffset === this._cachedUOffset &&\r\n            this.vOffset === this._cachedVOffset &&\r\n            this.uScale * uBase === this._cachedUScale &&\r\n            this.vScale === this._cachedVScale &&\r\n            this.uAng === this._cachedUAng &&\r\n            this.vAng === this._cachedVAng &&\r\n            this.wAng === this._cachedWAng &&\r\n            this.uRotationCenter === this._cachedURotationCenter &&\r\n            this.vRotationCenter === this._cachedVRotationCenter &&\r\n            this.wRotationCenter === this._cachedWRotationCenter &&\r\n            this.homogeneousRotationInUVTransform === this._cachedHomogeneousRotationInUVTransform\r\n        ) {\r\n            return this._cachedTextureMatrix!;\r\n        }\r\n\r\n        this._cachedUOffset = this.uOffset;\r\n        this._cachedVOffset = this.vOffset;\r\n        this._cachedUScale = this.uScale * uBase;\r\n        this._cachedVScale = this.vScale;\r\n        this._cachedUAng = this.uAng;\r\n        this._cachedVAng = this.vAng;\r\n        this._cachedWAng = this.wAng;\r\n        this._cachedURotationCenter = this.uRotationCenter;\r\n        this._cachedVRotationCenter = this.vRotationCenter;\r\n        this._cachedWRotationCenter = this.wRotationCenter;\r\n        this._cachedHomogeneousRotationInUVTransform = this.homogeneousRotationInUVTransform;\r\n\r\n        if (!this._cachedTextureMatrix || !this._rowGenerationMatrix) {\r\n            this._cachedTextureMatrix = Matrix.Zero();\r\n            this._rowGenerationMatrix = new Matrix();\r\n            this._t0 = Vector3.Zero();\r\n            this._t1 = Vector3.Zero();\r\n            this._t2 = Vector3.Zero();\r\n        }\r\n\r\n        Matrix.RotationYawPitchRollToRef(this.vAng, this.uAng, this.wAng, this._rowGenerationMatrix!);\r\n\r\n        if (this.homogeneousRotationInUVTransform) {\r\n            Matrix.TranslationToRef(-this._cachedURotationCenter, -this._cachedVRotationCenter, -this._cachedWRotationCenter, TmpVectors.Matrix[0]);\r\n            Matrix.TranslationToRef(this._cachedURotationCenter, this._cachedVRotationCenter, this._cachedWRotationCenter, TmpVectors.Matrix[1]);\r\n            Matrix.ScalingToRef(this._cachedUScale, this._cachedVScale, 0, TmpVectors.Matrix[2]);\r\n            Matrix.TranslationToRef(this._cachedUOffset, this._cachedVOffset, 0, TmpVectors.Matrix[3]);\r\n\r\n            TmpVectors.Matrix[0].multiplyToRef(this._rowGenerationMatrix!, this._cachedTextureMatrix);\r\n            this._cachedTextureMatrix.multiplyToRef(TmpVectors.Matrix[1], this._cachedTextureMatrix);\r\n            this._cachedTextureMatrix.multiplyToRef(TmpVectors.Matrix[2], this._cachedTextureMatrix);\r\n            this._cachedTextureMatrix.multiplyToRef(TmpVectors.Matrix[3], this._cachedTextureMatrix);\r\n\r\n            // copy the translation row to the 3rd row of the matrix so that we don't need to update the shaders (which expects the translation to be on the 3rd row)\r\n            this._cachedTextureMatrix.setRowFromFloats(2, this._cachedTextureMatrix.m[12], this._cachedTextureMatrix.m[13], this._cachedTextureMatrix.m[14], 1);\r\n        } else {\r\n            this._prepareRowForTextureGeneration(0, 0, 0, this._t0!);\r\n            this._prepareRowForTextureGeneration(1.0, 0, 0, this._t1!);\r\n            this._prepareRowForTextureGeneration(0, 1.0, 0, this._t2!);\r\n\r\n            this._t1!.subtractInPlace(this._t0!);\r\n            this._t2!.subtractInPlace(this._t0!);\r\n\r\n            Matrix.FromValuesToRef(\r\n                this._t1!.x,\r\n                this._t1!.y,\r\n                this._t1!.z,\r\n                0.0,\r\n                this._t2!.x,\r\n                this._t2!.y,\r\n                this._t2!.z,\r\n                0.0,\r\n                this._t0!.x,\r\n                this._t0!.y,\r\n                this._t0!.z,\r\n                0.0,\r\n                0.0,\r\n                0.0,\r\n                0.0,\r\n                1.0,\r\n                this._cachedTextureMatrix\r\n            );\r\n        }\r\n\r\n        const scene = this.getScene();\r\n\r\n        if (!scene) {\r\n            return this._cachedTextureMatrix;\r\n        }\r\n\r\n        if (this.optimizeUVAllocation) {\r\n            // We flag the materials that are using this texture as \"texture dirty\" because depending on the fact that the matrix is the identity or not, some defines\r\n            // will get different values (see PrepareDefinesForMergedUV), meaning we should regenerate the effect accordingly\r\n            scene.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag, (mat) => {\r\n                return mat.hasTexture(this);\r\n            });\r\n        }\r\n\r\n        return this._cachedTextureMatrix;\r\n    }\r\n\r\n    /**\r\n     * Get the current matrix used to apply reflection. This is useful to rotate an environment texture for instance.\r\n     * @returns The reflection texture transform\r\n     */\r\n    public getReflectionTextureMatrix(): Matrix {\r\n        const scene = this.getScene();\r\n\r\n        if (!scene) {\r\n            return this._cachedReflectionTextureMatrix!;\r\n        }\r\n\r\n        if (\r\n            this.uOffset === this._cachedReflectionUOffset &&\r\n            this.vOffset === this._cachedReflectionVOffset &&\r\n            this.uScale === this._cachedReflectionUScale &&\r\n            this.vScale === this._cachedReflectionVScale &&\r\n            this.coordinatesMode === this._cachedReflectionCoordinatesMode\r\n        ) {\r\n            if (this.coordinatesMode === Texture.PROJECTION_MODE) {\r\n                if (this._cachedReflectionProjectionMatrixId === scene.getProjectionMatrix().updateFlag) {\r\n                    return this._cachedReflectionTextureMatrix!;\r\n                }\r\n            } else {\r\n                return this._cachedReflectionTextureMatrix!;\r\n            }\r\n        }\r\n\r\n        if (!this._cachedReflectionTextureMatrix) {\r\n            this._cachedReflectionTextureMatrix = Matrix.Zero();\r\n        }\r\n\r\n        if (!this._projectionModeMatrix) {\r\n            this._projectionModeMatrix = Matrix.Zero();\r\n        }\r\n\r\n        const flagMaterialsAsTextureDirty = this._cachedReflectionCoordinatesMode !== this.coordinatesMode;\r\n\r\n        this._cachedReflectionUOffset = this.uOffset;\r\n        this._cachedReflectionVOffset = this.vOffset;\r\n        this._cachedReflectionUScale = this.uScale;\r\n        this._cachedReflectionVScale = this.vScale;\r\n        this._cachedReflectionCoordinatesMode = this.coordinatesMode;\r\n\r\n        switch (this.coordinatesMode) {\r\n            case Texture.PLANAR_MODE: {\r\n                Matrix.IdentityToRef(this._cachedReflectionTextureMatrix);\r\n                (<any>this._cachedReflectionTextureMatrix)[0] = this.uScale;\r\n                (<any>this._cachedReflectionTextureMatrix)[5] = this.vScale;\r\n                (<any>this._cachedReflectionTextureMatrix)[12] = this.uOffset;\r\n                (<any>this._cachedReflectionTextureMatrix)[13] = this.vOffset;\r\n                break;\r\n            }\r\n            case Texture.PROJECTION_MODE: {\r\n                Matrix.FromValuesToRef(0.5, 0.0, 0.0, 0.0, 0.0, -0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.5, 0.5, 1.0, 1.0, this._projectionModeMatrix);\r\n\r\n                const projectionMatrix = scene.getProjectionMatrix();\r\n                this._cachedReflectionProjectionMatrixId = projectionMatrix.updateFlag;\r\n                projectionMatrix.multiplyToRef(this._projectionModeMatrix, this._cachedReflectionTextureMatrix);\r\n                break;\r\n            }\r\n            default:\r\n                Matrix.IdentityToRef(this._cachedReflectionTextureMatrix);\r\n                break;\r\n        }\r\n\r\n        if (flagMaterialsAsTextureDirty) {\r\n            // We flag the materials that are using this texture as \"texture dirty\" if the coordinatesMode has changed.\r\n            // Indeed, this property is used to set the value of some defines used to generate the effect (in material.isReadyForSubMesh), so we must make sure this code will be re-executed and the effect recreated if necessary\r\n            scene.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag, (mat) => {\r\n                return mat.hasTexture(this);\r\n            });\r\n        }\r\n\r\n        return this._cachedReflectionTextureMatrix;\r\n    }\r\n\r\n    /**\r\n     * Clones the texture.\r\n     * @returns the cloned texture\r\n     */\r\n    public clone(): Texture {\r\n        const options: ITextureCreationOptions = {\r\n            noMipmap: this._noMipmap,\r\n            invertY: this._invertY,\r\n            samplingMode: this.samplingMode,\r\n            onLoad: undefined,\r\n            onError: undefined,\r\n            buffer: this._texture ? this._texture._buffer : undefined,\r\n            deleteBuffer: this._deleteBuffer,\r\n            format: this.textureFormat,\r\n            mimeType: this.mimeType,\r\n            loaderOptions: this._loaderOptions,\r\n            creationFlags: this._creationFlags,\r\n            useSRGBBuffer: this._useSRGBBuffer,\r\n        };\r\n\r\n        return SerializationHelper.Clone(() => {\r\n            return new Texture(this._texture ? this._texture.url : null, this.getScene(), options);\r\n        }, this);\r\n    }\r\n\r\n    /**\r\n     * Serialize the texture to a JSON representation we can easily use in the respective Parse function.\r\n     * @returns The JSON representation of the texture\r\n     */\r\n    public serialize(): any {\r\n        const savedName = this.name;\r\n\r\n        if (!Texture.SerializeBuffers) {\r\n            if (this.name.startsWith(\"data:\")) {\r\n                this.name = \"\";\r\n            }\r\n        }\r\n\r\n        if (this.name.startsWith(\"data:\") && this.url === this.name) {\r\n            this.url = \"\";\r\n        }\r\n\r\n        const serializationObject = super.serialize(Texture._SerializeInternalTextureUniqueId);\r\n\r\n        if (!serializationObject) {\r\n            return null;\r\n        }\r\n\r\n        if (Texture.SerializeBuffers || Texture.ForceSerializeBuffers) {\r\n            if (typeof this._buffer === \"string\" && (this._buffer as string).substr(0, 5) === \"data:\") {\r\n                serializationObject.base64String = this._buffer;\r\n                serializationObject.name = serializationObject.name.replace(\"data:\", \"\");\r\n            } else if (this.url && this.url.startsWith(\"data:\") && this._buffer instanceof Uint8Array) {\r\n                serializationObject.base64String = \"data:image/png;base64,\" + EncodeArrayBufferToBase64(this._buffer);\r\n            } else if (Texture.ForceSerializeBuffers || (this.url && this.url.startsWith(\"blob:\")) || this._forceSerialize) {\r\n                serializationObject.base64String =\r\n                    !this._engine || this._engine._features.supportSyncTextureRead ? GenerateBase64StringFromTexture(this) : GenerateBase64StringFromTextureAsync(this);\r\n            }\r\n        }\r\n\r\n        serializationObject.invertY = this._invertY;\r\n        serializationObject.samplingMode = this.samplingMode;\r\n        serializationObject._creationFlags = this._creationFlags;\r\n        serializationObject._useSRGBBuffer = this._useSRGBBuffer;\r\n        if (Texture._SerializeInternalTextureUniqueId) {\r\n            serializationObject.internalTextureUniqueId = this._texture?.uniqueId ?? undefined;\r\n        }\r\n        serializationObject.noMipmap = this._noMipmap;\r\n\r\n        this.name = savedName;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Get the current class name of the texture useful for serialization or dynamic coding.\r\n     * @returns \"Texture\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"Texture\";\r\n    }\r\n\r\n    /**\r\n     * Dispose the texture and release its associated resources.\r\n     */\r\n    public dispose(): void {\r\n        super.dispose();\r\n\r\n        this.onLoadObservable.clear();\r\n\r\n        this._delayedOnLoad = null;\r\n        this._delayedOnError = null;\r\n        this._buffer = null;\r\n    }\r\n\r\n    /**\r\n     * Parse the JSON representation of a texture in order to recreate the texture in the given scene.\r\n     * @param parsedTexture Define the JSON representation of the texture\r\n     * @param scene Define the scene the parsed texture should be instantiated in\r\n     * @param rootUrl Define the root url of the parsing sequence in the case of relative dependencies\r\n     * @returns The parsed texture if successful\r\n     */\r\n    public static Parse(parsedTexture: any, scene: Scene, rootUrl: string): Nullable<BaseTexture> {\r\n        if (parsedTexture.customType) {\r\n            const customTexture = InstantiationTools.Instantiate(parsedTexture.customType);\r\n            // Update Sampling Mode\r\n            const parsedCustomTexture: any = customTexture.Parse(parsedTexture, scene, rootUrl);\r\n            if (parsedTexture.samplingMode && parsedCustomTexture.updateSamplingMode && parsedCustomTexture._samplingMode) {\r\n                if (parsedCustomTexture._samplingMode !== parsedTexture.samplingMode) {\r\n                    parsedCustomTexture.updateSamplingMode(parsedTexture.samplingMode);\r\n                }\r\n            }\r\n            return parsedCustomTexture;\r\n        }\r\n\r\n        if (parsedTexture.isCube && !parsedTexture.isRenderTarget) {\r\n            return Texture._CubeTextureParser(parsedTexture, scene, rootUrl);\r\n        }\r\n\r\n        const hasInternalTextureUniqueId = parsedTexture.internalTextureUniqueId !== undefined;\r\n\r\n        if (!parsedTexture.name && !parsedTexture.isRenderTarget && !hasInternalTextureUniqueId) {\r\n            return null;\r\n        }\r\n\r\n        let internalTexture: InternalTexture | undefined;\r\n\r\n        if (hasInternalTextureUniqueId) {\r\n            const cache = scene.getEngine().getLoadedTexturesCache();\r\n            for (const texture of cache) {\r\n                if (texture.uniqueId === parsedTexture.internalTextureUniqueId) {\r\n                    internalTexture = texture;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        const onLoaded = (texture: Texture | null) => {\r\n            // Clear cache\r\n            if (texture && texture._texture) {\r\n                texture._texture._cachedWrapU = null;\r\n                texture._texture._cachedWrapV = null;\r\n                texture._texture._cachedWrapR = null;\r\n            }\r\n\r\n            // Update Sampling Mode\r\n            if (parsedTexture.samplingMode) {\r\n                const sampling: number = parsedTexture.samplingMode;\r\n                if (texture && texture.samplingMode !== sampling) {\r\n                    texture.updateSamplingMode(sampling);\r\n                }\r\n            }\r\n            // Animations\r\n            if (texture && parsedTexture.animations) {\r\n                for (let animationIndex = 0; animationIndex < parsedTexture.animations.length; animationIndex++) {\r\n                    const parsedAnimation = parsedTexture.animations[animationIndex];\r\n                    const internalClass = GetClass(\"BABYLON.Animation\");\r\n                    if (internalClass) {\r\n                        texture.animations.push(internalClass.Parse(parsedAnimation));\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (hasInternalTextureUniqueId && !internalTexture) {\r\n                texture?._texture?._setUniqueId(parsedTexture.internalTextureUniqueId);\r\n            }\r\n        };\r\n\r\n        const texture = SerializationHelper.Parse(\r\n            () => {\r\n                let generateMipMaps: boolean = true;\r\n                if (parsedTexture.noMipmap) {\r\n                    generateMipMaps = false;\r\n                }\r\n                if (parsedTexture.mirrorPlane) {\r\n                    const mirrorTexture = Texture._CreateMirror(parsedTexture.name, parsedTexture.renderTargetSize, scene, generateMipMaps);\r\n                    mirrorTexture._waitingRenderList = parsedTexture.renderList;\r\n                    mirrorTexture.mirrorPlane = Plane.FromArray(parsedTexture.mirrorPlane);\r\n                    onLoaded(mirrorTexture);\r\n                    return mirrorTexture;\r\n                } else if (parsedTexture.isRenderTarget) {\r\n                    let renderTargetTexture: Nullable<RenderTargetTexture> = null;\r\n                    if (parsedTexture.isCube) {\r\n                        // Search for an existing reflection probe (which contains a cube render target texture)\r\n                        if (scene.reflectionProbes) {\r\n                            for (let index = 0; index < scene.reflectionProbes.length; index++) {\r\n                                const probe = scene.reflectionProbes[index];\r\n                                if (probe.name === parsedTexture.name) {\r\n                                    return probe.cubeTexture;\r\n                                }\r\n                            }\r\n                        }\r\n                    } else {\r\n                        renderTargetTexture = Texture._CreateRenderTargetTexture(\r\n                            parsedTexture.name,\r\n                            parsedTexture.renderTargetSize,\r\n                            scene,\r\n                            generateMipMaps,\r\n                            parsedTexture._creationFlags ?? 0\r\n                        );\r\n                        renderTargetTexture._waitingRenderList = parsedTexture.renderList;\r\n                    }\r\n                    onLoaded(renderTargetTexture);\r\n                    return renderTargetTexture;\r\n                } else if (parsedTexture.isVideo) {\r\n                    const texture = Texture._CreateVideoTexture(\r\n                        rootUrl + (parsedTexture.url || parsedTexture.name),\r\n                        rootUrl + (parsedTexture.src || parsedTexture.url),\r\n                        scene,\r\n                        generateMipMaps,\r\n                        parsedTexture.invertY,\r\n                        parsedTexture.samplingMode,\r\n                        parsedTexture.settings || {}\r\n                    );\r\n                    onLoaded(texture);\r\n                    return texture;\r\n                } else {\r\n                    let texture: Texture;\r\n\r\n                    if (parsedTexture.base64String && !internalTexture) {\r\n                        // name and url are the same to ensure caching happens from the actual base64 string\r\n                        texture = Texture.CreateFromBase64String(\r\n                            parsedTexture.base64String,\r\n                            parsedTexture.base64String,\r\n                            scene,\r\n                            !generateMipMaps,\r\n                            parsedTexture.invertY,\r\n                            parsedTexture.samplingMode,\r\n                            () => {\r\n                                onLoaded(texture);\r\n                            },\r\n                            parsedTexture._creationFlags ?? 0,\r\n                            parsedTexture._useSRGBBuffer ?? false\r\n                        );\r\n\r\n                        // prettier name to fit with the loaded data\r\n                        texture.name = parsedTexture.name;\r\n                    } else {\r\n                        let url: string;\r\n                        if (parsedTexture.name && (parsedTexture.name.indexOf(\"://\") > 0 || parsedTexture.name.startsWith(\"data:\"))) {\r\n                            url = parsedTexture.name;\r\n                        } else {\r\n                            url = rootUrl + parsedTexture.name;\r\n                        }\r\n\r\n                        if (parsedTexture.url && (parsedTexture.url.startsWith(\"data:\") || Texture.UseSerializedUrlIfAny)) {\r\n                            url = parsedTexture.url;\r\n                        }\r\n\r\n                        const options: ITextureCreationOptions = {\r\n                            noMipmap: !generateMipMaps,\r\n                            invertY: parsedTexture.invertY,\r\n                            samplingMode: parsedTexture.samplingMode,\r\n                            onLoad: () => {\r\n                                onLoaded(texture);\r\n                            },\r\n                            internalTexture,\r\n                        };\r\n\r\n                        texture = new Texture(url, scene, options);\r\n                    }\r\n\r\n                    return texture;\r\n                }\r\n            },\r\n            parsedTexture,\r\n            scene\r\n        );\r\n\r\n        return texture;\r\n    }\r\n\r\n    /**\r\n     * Creates a texture from its base 64 representation.\r\n     * @param data Define the base64 payload without the data: prefix\r\n     * @param name Define the name of the texture in the scene useful fo caching purpose for instance\r\n     * @param scene Define the scene the texture should belong to\r\n     * @param noMipmapOrOptions defines if the texture will require mip maps or not or set of all options to create the texture\r\n     * @param invertY define if the texture needs to be inverted on the y axis during loading\r\n     * @param samplingMode define the sampling mode we want for the texture while fetching from it (Texture.NEAREST_SAMPLINGMODE...)\r\n     * @param onLoad define a callback triggered when the texture has been loaded\r\n     * @param onError define a callback triggered when an error occurred during the loading session\r\n     * @param format define the format of the texture we are trying to load (Engine.TEXTUREFORMAT_RGBA...)\r\n     * @param creationFlags specific flags to use when creating the texture (Constants.TEXTURE_CREATIONFLAG_STORAGE for storage textures, for eg)\r\n     * @returns the created texture\r\n     */\r\n    public static CreateFromBase64String(\r\n        data: string,\r\n        name: string,\r\n        scene: Scene,\r\n        noMipmapOrOptions?: boolean | ITextureCreationOptions,\r\n        invertY?: boolean,\r\n        samplingMode: number = Texture.TRILINEAR_SAMPLINGMODE,\r\n        onLoad: Nullable<() => void> = null,\r\n        onError: Nullable<() => void> = null,\r\n        format: number = Constants.TEXTUREFORMAT_RGBA,\r\n        creationFlags?: number\r\n    ): Texture {\r\n        return new Texture(\"data:\" + name, scene, noMipmapOrOptions, invertY, samplingMode, onLoad, onError, data, false, format, undefined, undefined, creationFlags);\r\n    }\r\n\r\n    /**\r\n     * Creates a texture from its data: representation. (data: will be added in case only the payload has been passed in)\r\n     * @param name Define the name of the texture in the scene useful fo caching purpose for instance\r\n     * @param buffer define the buffer to load the texture from in case the texture is loaded from a buffer representation\r\n     * @param scene Define the scene the texture should belong to\r\n     * @param deleteBuffer define if the buffer we are loading the texture from should be deleted after load\r\n     * @param noMipmapOrOptions defines if the texture will require mip maps or not or set of all options to create the texture\r\n     * @param invertY define if the texture needs to be inverted on the y axis during loading\r\n     * @param samplingMode define the sampling mode we want for the texture while fetching from it (Texture.NEAREST_SAMPLINGMODE...)\r\n     * @param onLoad define a callback triggered when the texture has been loaded\r\n     * @param onError define a callback triggered when an error occurred during the loading session\r\n     * @param format define the format of the texture we are trying to load (Engine.TEXTUREFORMAT_RGBA...)\r\n     * @param creationFlags specific flags to use when creating the texture (Constants.TEXTURE_CREATIONFLAG_STORAGE for storage textures, for eg)\r\n     * @returns the created texture\r\n     */\r\n    public static LoadFromDataString(\r\n        name: string,\r\n        buffer: any,\r\n        scene: Scene,\r\n        deleteBuffer: boolean = false,\r\n        noMipmapOrOptions?: boolean | ITextureCreationOptions,\r\n        invertY: boolean = true,\r\n        samplingMode: number = Texture.TRILINEAR_SAMPLINGMODE,\r\n        onLoad: Nullable<() => void> = null,\r\n        onError: Nullable<(message?: string, exception?: any) => void> = null,\r\n        format: number = Constants.TEXTUREFORMAT_RGBA,\r\n        creationFlags?: number\r\n    ): Texture {\r\n        if (name.substr(0, 5) !== \"data:\") {\r\n            name = \"data:\" + name;\r\n        }\r\n\r\n        return new Texture(name, scene, noMipmapOrOptions, invertY, samplingMode, onLoad, onError, buffer, deleteBuffer, format, undefined, undefined, creationFlags);\r\n    }\r\n}\r\n\r\n// References the dependencies.\r\nRegisterClass(\"BABYLON.Texture\", Texture);\r\nSerializationHelper._TextureParser = Texture.Parse;\r\n", "import type { ProcessingOptions, ShaderCustomProcessingFunction } from \"../Engines/Processors/shaderProcessingOptions\";\r\nimport type { Nullable } from \"../types\";\r\nimport { Material } from \"./material\";\r\nimport type {\r\n    MaterialPluginPrepareEffect,\r\n    MaterialPluginBindForSubMesh,\r\n    MaterialPluginDisposed,\r\n    MaterialPluginGetActiveTextures,\r\n    MaterialPluginGetAnimatables,\r\n    MaterialPluginGetDefineNames,\r\n    MaterialPluginHasTexture,\r\n    MaterialPluginIsReadyForSubMesh,\r\n    MaterialPluginPrepareDefines,\r\n    MaterialPluginPrepareUniformBuffer,\r\n    MaterialPluginHardBindForSubMesh,\r\n    MaterialPluginHasRenderTargetTextures,\r\n    MaterialPluginFillRenderTargetTextures,\r\n} from \"./materialPluginEvent\";\r\nimport { MaterialPluginEvent } from \"./materialPluginEvent\";\r\nimport type { Observer } from \"core/Misc/observable\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\n\r\nimport type { Scene } from \"../scene\";\r\nimport type { Engine } from \"../Engines/engine\";\r\nimport type { MaterialPluginBase } from \"./materialPluginBase\";\r\nimport { ShaderProcessor } from \"../Engines/Processors/shaderProcessor\";\r\nimport { ShaderLanguage } from \"./shaderLanguage\";\r\nimport { ShaderStore } from \"../Engines/shaderStore\";\r\n\r\ndeclare module \"./material\" {\r\n    export interface Material {\r\n        /**\r\n         * Plugin manager for this material\r\n         */\r\n        pluginManager?: MaterialPluginManager;\r\n    }\r\n}\r\n\r\nconst rxOption = new RegExp(\"^([gimus]+)!\");\r\n\r\n/**\r\n * Class that manages the plugins of a material\r\n * @since 5.0\r\n */\r\nexport class MaterialPluginManager {\r\n    /** Map a plugin class name to a #define name (used in the vertex/fragment shaders as a marker of the plugin usage) */\r\n    private static _MaterialPluginClassToMainDefine: { [name: string]: string } = {};\r\n    private static _MaterialPluginCounter: number = 0;\r\n\r\n    protected _material: Material;\r\n    protected _scene: Scene;\r\n    protected _engine: Engine;\r\n    /** @internal */\r\n    public _plugins: MaterialPluginBase[] = [];\r\n    protected _activePlugins: MaterialPluginBase[] = [];\r\n    protected _activePluginsForExtraEvents: MaterialPluginBase[] = [];\r\n    protected _codeInjectionPoints: { [shaderType: string]: { [codeName: string]: boolean } };\r\n    protected _defineNamesFromPlugins?: { [name: string]: { type: string; default: any } };\r\n    protected _uboDeclaration: string;\r\n    protected _vertexDeclaration: string;\r\n    protected _fragmentDeclaration: string;\r\n    protected _uniformList: string[];\r\n    protected _samplerList: string[];\r\n    protected _uboList: string[];\r\n\r\n    static {\r\n        EngineStore.OnEnginesDisposedObservable.add(() => {\r\n            UnregisterAllMaterialPlugins();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates a new instance of the plugin manager\r\n     * @param material material that this manager will manage the plugins for\r\n     */\r\n    constructor(material: Material) {\r\n        this._material = material;\r\n        this._scene = material.getScene();\r\n        this._engine = this._scene.getEngine();\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _addPlugin(plugin: MaterialPluginBase): boolean {\r\n        for (let i = 0; i < this._plugins.length; ++i) {\r\n            if (this._plugins[i].name === plugin.name) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        if (this._material._uniformBufferLayoutBuilt) {\r\n            // eslint-disable-next-line no-throw-literal\r\n            throw `The plugin \"${plugin.name}\" can't be added to the material \"${this._material.name}\" because this material has already been used for rendering! Please add plugins to materials before any rendering with this material occurs.`;\r\n        }\r\n\r\n        const pluginClassName = plugin.getClassName();\r\n        if (!MaterialPluginManager._MaterialPluginClassToMainDefine[pluginClassName]) {\r\n            MaterialPluginManager._MaterialPluginClassToMainDefine[pluginClassName] = \"MATERIALPLUGIN_\" + ++MaterialPluginManager._MaterialPluginCounter;\r\n        }\r\n\r\n        this._material._callbackPluginEventGeneric = (id, info) => this._handlePluginEvent(id, info);\r\n\r\n        this._plugins.push(plugin);\r\n        this._plugins.sort((a, b) => a.priority - b.priority);\r\n\r\n        this._codeInjectionPoints = {};\r\n\r\n        const defineNamesFromPlugins: { [name: string]: { type: string; default: any } } = {};\r\n        defineNamesFromPlugins[MaterialPluginManager._MaterialPluginClassToMainDefine[pluginClassName]] = {\r\n            type: \"boolean\",\r\n            default: true,\r\n        };\r\n\r\n        for (const plugin of this._plugins) {\r\n            plugin.collectDefines(defineNamesFromPlugins);\r\n            this._collectPointNames(\"vertex\", plugin.getCustomCode(\"vertex\"));\r\n            this._collectPointNames(\"fragment\", plugin.getCustomCode(\"fragment\"));\r\n        }\r\n\r\n        this._defineNamesFromPlugins = defineNamesFromPlugins;\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _activatePlugin(plugin: MaterialPluginBase): void {\r\n        if (this._activePlugins.indexOf(plugin) === -1) {\r\n            this._activePlugins.push(plugin);\r\n            this._activePlugins.sort((a, b) => a.priority - b.priority);\r\n\r\n            this._material._callbackPluginEventIsReadyForSubMesh = this._handlePluginEventIsReadyForSubMesh.bind(this);\r\n            this._material._callbackPluginEventPrepareDefinesBeforeAttributes = this._handlePluginEventPrepareDefinesBeforeAttributes.bind(this);\r\n            this._material._callbackPluginEventPrepareDefines = this._handlePluginEventPrepareDefines.bind(this);\r\n            this._material._callbackPluginEventBindForSubMesh = this._handlePluginEventBindForSubMesh.bind(this);\r\n\r\n            if (plugin.registerForExtraEvents) {\r\n                this._activePluginsForExtraEvents.push(plugin);\r\n                this._activePluginsForExtraEvents.sort((a, b) => a.priority - b.priority);\r\n                this._material._callbackPluginEventHasRenderTargetTextures = this._handlePluginEventHasRenderTargetTextures.bind(this);\r\n                this._material._callbackPluginEventFillRenderTargetTextures = this._handlePluginEventFillRenderTargetTextures.bind(this);\r\n                this._material._callbackPluginEventHardBindForSubMesh = this._handlePluginEventHardBindForSubMesh.bind(this);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets a plugin from the list of plugins managed by this manager\r\n     * @param name name of the plugin\r\n     * @returns the plugin if found, else null\r\n     */\r\n    public getPlugin<T = MaterialPluginBase>(name: string): Nullable<T> {\r\n        for (let i = 0; i < this._plugins.length; ++i) {\r\n            if (this._plugins[i].name === name) {\r\n                return this._plugins[i] as T;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    protected _handlePluginEventIsReadyForSubMesh(eventData: MaterialPluginIsReadyForSubMesh): void {\r\n        let isReady = true;\r\n        for (const plugin of this._activePlugins) {\r\n            isReady = isReady && plugin.isReadyForSubMesh(eventData.defines, this._scene, this._engine, eventData.subMesh);\r\n        }\r\n        eventData.isReadyForSubMesh = isReady;\r\n    }\r\n\r\n    protected _handlePluginEventPrepareDefinesBeforeAttributes(eventData: MaterialPluginPrepareDefines): void {\r\n        for (const plugin of this._activePlugins) {\r\n            plugin.prepareDefinesBeforeAttributes(eventData.defines, this._scene, eventData.mesh);\r\n        }\r\n    }\r\n\r\n    protected _handlePluginEventPrepareDefines(eventData: MaterialPluginPrepareDefines): void {\r\n        for (const plugin of this._activePlugins) {\r\n            plugin.prepareDefines(eventData.defines, this._scene, eventData.mesh);\r\n        }\r\n    }\r\n\r\n    protected _handlePluginEventHardBindForSubMesh(eventData: MaterialPluginHardBindForSubMesh): void {\r\n        for (const plugin of this._activePluginsForExtraEvents) {\r\n            plugin.hardBindForSubMesh(this._material._uniformBuffer, this._scene, this._engine, eventData.subMesh);\r\n        }\r\n    }\r\n\r\n    protected _handlePluginEventBindForSubMesh(eventData: MaterialPluginBindForSubMesh): void {\r\n        for (const plugin of this._activePlugins) {\r\n            plugin.bindForSubMesh(this._material._uniformBuffer, this._scene, this._engine, eventData.subMesh);\r\n        }\r\n    }\r\n\r\n    protected _handlePluginEventHasRenderTargetTextures(eventData: MaterialPluginHasRenderTargetTextures): void {\r\n        let hasRenderTargetTextures = false;\r\n        for (const plugin of this._activePluginsForExtraEvents) {\r\n            hasRenderTargetTextures = plugin.hasRenderTargetTextures();\r\n            if (hasRenderTargetTextures) {\r\n                break;\r\n            }\r\n        }\r\n        eventData.hasRenderTargetTextures = hasRenderTargetTextures;\r\n    }\r\n\r\n    protected _handlePluginEventFillRenderTargetTextures(eventData: MaterialPluginFillRenderTargetTextures): void {\r\n        for (const plugin of this._activePluginsForExtraEvents) {\r\n            plugin.fillRenderTargetTextures(eventData.renderTargets);\r\n        }\r\n    }\r\n\r\n    protected _handlePluginEvent(\r\n        id: number,\r\n        info:\r\n            | MaterialPluginGetActiveTextures\r\n            | MaterialPluginGetAnimatables\r\n            | MaterialPluginHasTexture\r\n            | MaterialPluginDisposed\r\n            | MaterialPluginGetDefineNames\r\n            | MaterialPluginPrepareEffect\r\n            | MaterialPluginPrepareUniformBuffer\r\n    ): void {\r\n        switch (id) {\r\n            case MaterialPluginEvent.GetActiveTextures: {\r\n                const eventData = info as MaterialPluginGetActiveTextures;\r\n                for (const plugin of this._activePlugins) {\r\n                    plugin.getActiveTextures(eventData.activeTextures);\r\n                }\r\n                break;\r\n            }\r\n\r\n            case MaterialPluginEvent.GetAnimatables: {\r\n                const eventData = info as MaterialPluginGetAnimatables;\r\n                for (const plugin of this._activePlugins) {\r\n                    plugin.getAnimatables(eventData.animatables);\r\n                }\r\n                break;\r\n            }\r\n\r\n            case MaterialPluginEvent.HasTexture: {\r\n                const eventData = info as MaterialPluginHasTexture;\r\n                let hasTexture = false;\r\n                for (const plugin of this._activePlugins) {\r\n                    hasTexture = plugin.hasTexture(eventData.texture);\r\n                    if (hasTexture) {\r\n                        break;\r\n                    }\r\n                }\r\n                eventData.hasTexture = hasTexture;\r\n                break;\r\n            }\r\n\r\n            case MaterialPluginEvent.Disposed: {\r\n                const eventData = info as MaterialPluginDisposed;\r\n                for (const plugin of this._plugins) {\r\n                    plugin.dispose(eventData.forceDisposeTextures);\r\n                }\r\n                break;\r\n            }\r\n\r\n            case MaterialPluginEvent.GetDefineNames: {\r\n                const eventData = info as MaterialPluginGetDefineNames;\r\n                eventData.defineNames = this._defineNamesFromPlugins;\r\n                break;\r\n            }\r\n\r\n            case MaterialPluginEvent.PrepareEffect: {\r\n                const eventData = info as MaterialPluginPrepareEffect;\r\n                for (const plugin of this._activePlugins) {\r\n                    eventData.fallbackRank = plugin.addFallbacks(eventData.defines, eventData.fallbacks, eventData.fallbackRank);\r\n                    plugin.getAttributes(eventData.attributes, this._scene, eventData.mesh);\r\n                }\r\n                if (this._uniformList.length > 0) {\r\n                    eventData.uniforms.push(...this._uniformList);\r\n                }\r\n                if (this._samplerList.length > 0) {\r\n                    eventData.samplers.push(...this._samplerList);\r\n                }\r\n                if (this._uboList.length > 0) {\r\n                    eventData.uniformBuffersNames.push(...this._uboList);\r\n                }\r\n                eventData.customCode = this._injectCustomCode(eventData, eventData.customCode);\r\n                break;\r\n            }\r\n\r\n            case MaterialPluginEvent.PrepareUniformBuffer: {\r\n                const eventData = info as MaterialPluginPrepareUniformBuffer;\r\n                this._uboDeclaration = \"\";\r\n                this._vertexDeclaration = \"\";\r\n                this._fragmentDeclaration = \"\";\r\n                this._uniformList = [];\r\n                this._samplerList = [];\r\n                this._uboList = [];\r\n                for (const plugin of this._plugins) {\r\n                    const uniforms = plugin.getUniforms();\r\n                    if (uniforms) {\r\n                        if (uniforms.ubo) {\r\n                            for (const uniform of uniforms.ubo) {\r\n                                if (uniform.size && uniform.type) {\r\n                                    const arraySize = uniform.arraySize ?? 0;\r\n                                    eventData.ubo.addUniform(uniform.name, uniform.size, arraySize);\r\n                                    this._uboDeclaration += `${uniform.type} ${uniform.name}${arraySize > 0 ? `[${arraySize}]` : \"\"};\\n`;\r\n                                }\r\n                                this._uniformList.push(uniform.name);\r\n                            }\r\n                        }\r\n                        if (uniforms.vertex) {\r\n                            this._vertexDeclaration += uniforms.vertex + \"\\n\";\r\n                        }\r\n                        if (uniforms.fragment) {\r\n                            this._fragmentDeclaration += uniforms.fragment + \"\\n\";\r\n                        }\r\n                    }\r\n                    plugin.getSamplers(this._samplerList);\r\n                    plugin.getUniformBuffersNames(this._uboList);\r\n                }\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    protected _collectPointNames(shaderType: string, customCode: Nullable<{ [pointName: string]: string }> | undefined): void {\r\n        if (!customCode) {\r\n            return;\r\n        }\r\n        for (const pointName in customCode) {\r\n            if (!this._codeInjectionPoints[shaderType]) {\r\n                this._codeInjectionPoints[shaderType] = {};\r\n            }\r\n            this._codeInjectionPoints[shaderType][pointName] = true;\r\n        }\r\n    }\r\n\r\n    protected _injectCustomCode(eventData: MaterialPluginPrepareEffect, existingCallback?: (shaderType: string, code: string) => string): ShaderCustomProcessingFunction {\r\n        return (shaderType: string, code: string) => {\r\n            if (existingCallback) {\r\n                code = existingCallback(shaderType, code);\r\n            }\r\n            if (this._uboDeclaration) {\r\n                code = code.replace(\"#define ADDITIONAL_UBO_DECLARATION\", this._uboDeclaration);\r\n            }\r\n            if (this._vertexDeclaration) {\r\n                code = code.replace(\"#define ADDITIONAL_VERTEX_DECLARATION\", this._vertexDeclaration);\r\n            }\r\n            if (this._fragmentDeclaration) {\r\n                code = code.replace(\"#define ADDITIONAL_FRAGMENT_DECLARATION\", this._fragmentDeclaration);\r\n            }\r\n            const points = this._codeInjectionPoints?.[shaderType];\r\n            if (!points) {\r\n                return code;\r\n            }\r\n            let processorOptions: Nullable<ProcessingOptions> = null;\r\n            for (let pointName in points) {\r\n                let injectedCode = \"\";\r\n                for (const plugin of this._activePlugins) {\r\n                    let customCode = plugin.getCustomCode(shaderType)?.[pointName];\r\n                    if (!customCode) {\r\n                        continue;\r\n                    }\r\n                    if (plugin.resolveIncludes) {\r\n                        if (processorOptions === null) {\r\n                            const shaderLanguage = ShaderLanguage.GLSL;\r\n                            processorOptions = {\r\n                                defines: [], // not used by _ProcessIncludes\r\n                                indexParameters: eventData.indexParameters,\r\n                                isFragment: false,\r\n                                shouldUseHighPrecisionShader: this._engine._shouldUseHighPrecisionShader,\r\n                                processor: undefined as any, // not used by _ProcessIncludes\r\n                                supportsUniformBuffers: this._engine.supportsUniformBuffers,\r\n                                shadersRepository: ShaderStore.GetShadersRepository(shaderLanguage),\r\n                                includesShadersStore: ShaderStore.GetIncludesShadersStore(shaderLanguage),\r\n                                version: undefined as any, // not used by _ProcessIncludes\r\n                                platformName: this._engine.shaderPlatformName,\r\n                                processingContext: undefined as any, // not used by _ProcessIncludes\r\n                                isNDCHalfZRange: this._engine.isNDCHalfZRange,\r\n                                useReverseDepthBuffer: this._engine.useReverseDepthBuffer,\r\n                                processCodeAfterIncludes: undefined as any, // not used by _ProcessIncludes\r\n                            };\r\n                        }\r\n                        processorOptions.isFragment = shaderType === \"fragment\";\r\n                        ShaderProcessor._ProcessIncludes(customCode, processorOptions, (code) => (customCode = code));\r\n                    }\r\n                    injectedCode += customCode + \"\\n\";\r\n                }\r\n                if (injectedCode.length > 0) {\r\n                    if (pointName.charAt(0) === \"!\") {\r\n                        // pointName is a regular expression\r\n                        pointName = pointName.substring(1);\r\n\r\n                        let regexFlags = \"g\";\r\n                        if (pointName.charAt(0) === \"!\") {\r\n                            // no flags\r\n                            regexFlags = \"\";\r\n                            pointName = pointName.substring(1);\r\n                        } else {\r\n                            // get the flag(s)\r\n                            const matchOption = rxOption.exec(pointName);\r\n                            if (matchOption && matchOption.length >= 2) {\r\n                                regexFlags = matchOption[1];\r\n                                pointName = pointName.substring(regexFlags.length + 1);\r\n                            }\r\n                        }\r\n\r\n                        if (regexFlags.indexOf(\"g\") < 0) {\r\n                            // we force the \"g\" flag so that the regexp object is stateful!\r\n                            regexFlags += \"g\";\r\n                        }\r\n\r\n                        const sourceCode = code;\r\n                        const rx = new RegExp(pointName, regexFlags);\r\n                        let match = rx.exec(sourceCode);\r\n                        while (match !== null) {\r\n                            let newCode = injectedCode;\r\n                            for (let i = 0; i < match.length; ++i) {\r\n                                newCode = newCode.replace(\"$\" + i, match[i]);\r\n                            }\r\n                            code = code.replace(match[0], newCode);\r\n                            match = rx.exec(sourceCode);\r\n                        }\r\n                    } else {\r\n                        const fullPointName = \"#define \" + pointName;\r\n                        code = code.replace(fullPointName, \"\\n\" + injectedCode + \"\\n\" + fullPointName);\r\n                    }\r\n                }\r\n            }\r\n            return code;\r\n        };\r\n    }\r\n}\r\n\r\n/**\r\n * Type for plugin material factories.\r\n */\r\nexport type PluginMaterialFactory = (material: Material) => Nullable<MaterialPluginBase>;\r\n\r\nconst plugins: Array<[string, PluginMaterialFactory]> = [];\r\nlet inited = false;\r\nlet observer: Nullable<Observer<Material>> = null;\r\n\r\n/**\r\n * Registers a new material plugin through a factory, or updates it. This makes the plugin available to all materials instantiated after its registration.\r\n * @param pluginName The plugin name\r\n * @param factory The factory function which allows to create the plugin\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport function RegisterMaterialPlugin(pluginName: string, factory: PluginMaterialFactory): void {\r\n    if (!inited) {\r\n        observer = Material.OnEventObservable.add((material: Material) => {\r\n            for (const [, factory] of plugins) {\r\n                factory(material);\r\n            }\r\n        }, MaterialPluginEvent.Created);\r\n        inited = true;\r\n    }\r\n    const existing = plugins.filter(([name, _factory]) => name === pluginName);\r\n    if (existing.length > 0) {\r\n        existing[0][1] = factory;\r\n    } else {\r\n        plugins.push([pluginName, factory]);\r\n    }\r\n}\r\n\r\n/**\r\n * Removes a material plugin from the list of global plugins.\r\n * @param pluginName The plugin name\r\n * @returns true if the plugin has been removed, else false\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport function UnregisterMaterialPlugin(pluginName: string): boolean {\r\n    for (let i = 0; i < plugins.length; ++i) {\r\n        if (plugins[i][0] === pluginName) {\r\n            plugins.splice(i, 1);\r\n            if (plugins.length === 0) {\r\n                UnregisterAllMaterialPlugins();\r\n            }\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\n/**\r\n * Clear the list of global material plugins\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport function UnregisterAllMaterialPlugins(): void {\r\n    plugins.length = 0;\r\n    inited = false;\r\n    Material.OnEventObservable.remove(observer);\r\n    observer = null;\r\n}\r\n", "import { serialize } from \"../Misc/decorators\";\r\nimport type { Nullable } from \"../types\";\r\nimport { MaterialPluginManager } from \"./materialPluginManager\";\r\nimport type { SmartArray } from \"../Misc/smartArray\";\r\nimport { Constants } from \"../Engines/constants\";\r\n\r\nimport type { Engine } from \"../Engines/engine\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { SubMesh } from \"../Meshes/subMesh\";\r\nimport type { IAnimatable } from \"../Animations/animatable.interface\";\r\nimport type { UniformBuffer } from \"./uniformBuffer\";\r\nimport type { EffectFallbacks } from \"./effectFallbacks\";\r\nimport type { MaterialDefines } from \"./materialDefines\";\r\nimport type { Material } from \"./material\";\r\nimport type { BaseTexture } from \"./Textures/baseTexture\";\r\nimport type { RenderTargetTexture } from \"./Textures/renderTargetTexture\";\r\nimport { SerializationHelper } from \"../Misc/decorators.serialization\";\r\n\r\n/**\r\n * Base class for material plugins.\r\n * @since 5.0\r\n */\r\nexport class MaterialPluginBase {\r\n    /**\r\n     * Defines the name of the plugin\r\n     */\r\n    @serialize()\r\n    public name: string;\r\n\r\n    /**\r\n     * Defines the priority of the plugin. Lower numbers run first.\r\n     */\r\n    @serialize()\r\n    public priority: number = 500;\r\n\r\n    /**\r\n     * Indicates that any #include directive in the plugin code must be replaced by the corresponding code.\r\n     */\r\n    @serialize()\r\n    public resolveIncludes: boolean = false;\r\n\r\n    /**\r\n     * Indicates that this plugin should be notified for the extra events (HasRenderTargetTextures / FillRenderTargetTextures / HardBindForSubMesh)\r\n     */\r\n    @serialize()\r\n    public registerForExtraEvents: boolean = false;\r\n\r\n    protected _material: Material;\r\n    protected _pluginManager: MaterialPluginManager;\r\n    protected _pluginDefineNames?: { [name: string]: any };\r\n\r\n    protected _enable(enable: boolean) {\r\n        if (enable) {\r\n            this._pluginManager._activatePlugin(this);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Helper function to mark defines as being dirty.\r\n     */\r\n    public readonly markAllDefinesAsDirty: () => void;\r\n\r\n    /**\r\n     * Creates a new material plugin\r\n     * @param material parent material of the plugin\r\n     * @param name name of the plugin\r\n     * @param priority priority of the plugin\r\n     * @param defines list of defines used by the plugin. The value of the property is the default value for this property\r\n     * @param addToPluginList true to add the plugin to the list of plugins managed by the material plugin manager of the material (default: true)\r\n     * @param enable true to enable the plugin (it is handy if the plugin does not handle properties to switch its current activation)\r\n     * @param resolveIncludes Indicates that any #include directive in the plugin code must be replaced by the corresponding code (default: false)\r\n     */\r\n    constructor(material: Material, name: string, priority: number, defines?: { [key: string]: any }, addToPluginList = true, enable = false, resolveIncludes = false) {\r\n        this._material = material;\r\n        this.name = name;\r\n        this.priority = priority;\r\n        this.resolveIncludes = resolveIncludes;\r\n\r\n        if (!material.pluginManager) {\r\n            material.pluginManager = new MaterialPluginManager(material);\r\n            material.onDisposeObservable.add(() => {\r\n                material.pluginManager = undefined;\r\n            });\r\n        }\r\n\r\n        this._pluginDefineNames = defines;\r\n        this._pluginManager = material.pluginManager;\r\n\r\n        if (addToPluginList) {\r\n            this._pluginManager._addPlugin(this);\r\n        }\r\n\r\n        if (enable) {\r\n            this._enable(true);\r\n        }\r\n\r\n        this.markAllDefinesAsDirty = material._dirtyCallbacks[Constants.MATERIAL_AllDirtyFlag];\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name useful for serialization or dynamic coding.\r\n     * @returns The class name.\r\n     */\r\n    public getClassName(): string {\r\n        return \"MaterialPluginBase\";\r\n    }\r\n\r\n    /**\r\n     * Specifies that the submesh is ready to be used.\r\n     * @param defines the list of \"defines\" to update.\r\n     * @param scene defines the scene the material belongs to.\r\n     * @param engine the engine this scene belongs to.\r\n     * @param subMesh the submesh to check for readiness\r\n     * @returns - boolean indicating that the submesh is ready or not.\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public isReadyForSubMesh(defines: MaterialDefines, scene: Scene, engine: Engine, subMesh: SubMesh): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Binds the material data (this function is called even if mustRebind() returns false)\r\n     * @param uniformBuffer defines the Uniform buffer to fill in.\r\n     * @param scene defines the scene the material belongs to.\r\n     * @param engine defines the engine the material belongs to.\r\n     * @param subMesh the submesh to bind data for\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public hardBindForSubMesh(uniformBuffer: UniformBuffer, scene: Scene, engine: Engine, subMesh: SubMesh): void {}\r\n\r\n    /**\r\n     * Binds the material data.\r\n     * @param uniformBuffer defines the Uniform buffer to fill in.\r\n     * @param scene defines the scene the material belongs to.\r\n     * @param engine the engine this scene belongs to.\r\n     * @param subMesh the submesh to bind data for\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public bindForSubMesh(uniformBuffer: UniformBuffer, scene: Scene, engine: Engine, subMesh: SubMesh): void {}\r\n\r\n    /**\r\n     * Disposes the resources of the material.\r\n     * @param forceDisposeTextures - Forces the disposal of all textures.\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public dispose(forceDisposeTextures?: boolean): void {}\r\n\r\n    /**\r\n     * Returns a list of custom shader code fragments to customize the shader.\r\n     * @param shaderType \"vertex\" or \"fragment\"\r\n     * @returns null if no code to be added, or a list of pointName =\\> code.\r\n     * Note that `pointName` can also be a regular expression if it starts with a `!`.\r\n     * In that case, the string found by the regular expression (if any) will be\r\n     * replaced by the code provided.\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public getCustomCode(shaderType: string): Nullable<{ [pointName: string]: string }> {\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Collects all defines.\r\n     * @param defines The object to append to.\r\n     */\r\n    public collectDefines(defines: { [name: string]: { type: string; default: any } }): void {\r\n        if (!this._pluginDefineNames) {\r\n            return;\r\n        }\r\n        for (const key of Object.keys(this._pluginDefineNames)) {\r\n            if (key[0] === \"_\") {\r\n                continue;\r\n            }\r\n\r\n            const type = typeof this._pluginDefineNames[key];\r\n            defines[key] = {\r\n                type: type === \"number\" ? \"number\" : type === \"string\" ? \"string\" : type === \"boolean\" ? \"boolean\" : \"object\",\r\n                default: this._pluginDefineNames[key],\r\n            };\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the defines for the next rendering. Called before PrepareDefinesForAttributes is called.\r\n     * @param defines the list of \"defines\" to update.\r\n     * @param scene defines the scene to the material belongs to.\r\n     * @param mesh the mesh being rendered\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public prepareDefinesBeforeAttributes(defines: MaterialDefines, scene: Scene, mesh: AbstractMesh): void {}\r\n\r\n    /**\r\n     * Sets the defines for the next rendering\r\n     * @param defines the list of \"defines\" to update.\r\n     * @param scene defines the scene to the material belongs to.\r\n     * @param mesh the mesh being rendered\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public prepareDefines(defines: MaterialDefines, scene: Scene, mesh: AbstractMesh): void {}\r\n\r\n    /**\r\n     * Checks to see if a texture is used in the material.\r\n     * @param texture - Base texture to use.\r\n     * @returns - Boolean specifying if a texture is used in the material.\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public hasTexture(texture: BaseTexture): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating that current material needs to register RTT\r\n     * @returns true if this uses a render target otherwise false.\r\n     */\r\n    public hasRenderTargetTextures(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Fills the list of render target textures.\r\n     * @param renderTargets the list of render targets to update\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public fillRenderTargetTextures(renderTargets: SmartArray<RenderTargetTexture>): void {}\r\n\r\n    /**\r\n     * Returns an array of the actively used textures.\r\n     * @param activeTextures Array of BaseTextures\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public getActiveTextures(activeTextures: BaseTexture[]): void {}\r\n\r\n    /**\r\n     * Returns the animatable textures.\r\n     * @param animatables Array of animatable textures.\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public getAnimatables(animatables: IAnimatable[]): void {}\r\n\r\n    /**\r\n     * Add fallbacks to the effect fallbacks list.\r\n     * @param defines defines the Base texture to use.\r\n     * @param fallbacks defines the current fallback list.\r\n     * @param currentRank defines the current fallback rank.\r\n     * @returns the new fallback rank.\r\n     */\r\n    public addFallbacks(defines: MaterialDefines, fallbacks: EffectFallbacks, currentRank: number): number {\r\n        return currentRank;\r\n    }\r\n\r\n    /**\r\n     * Gets the samplers used by the plugin.\r\n     * @param samplers list that the sampler names should be added to.\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public getSamplers(samplers: string[]): void {}\r\n\r\n    /**\r\n     * Gets the attributes used by the plugin.\r\n     * @param attributes list that the attribute names should be added to.\r\n     * @param scene the scene that the material belongs to.\r\n     * @param mesh the mesh being rendered.\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public getAttributes(attributes: string[], scene: Scene, mesh: AbstractMesh): void {}\r\n\r\n    /**\r\n     * Gets the uniform buffers names added by the plugin.\r\n     * @param ubos list that the ubo names should be added to.\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public getUniformBuffersNames(ubos: string[]): void {}\r\n\r\n    /**\r\n     * Gets the description of the uniforms to add to the ubo (if engine supports ubos) or to inject directly in the vertex/fragment shaders (if engine does not support ubos)\r\n     * @returns the description of the uniforms\r\n     */\r\n    public getUniforms(): { ubo?: Array<{ name: string; size?: number; type?: string; arraySize?: number }>; vertex?: string; fragment?: string } {\r\n        return {};\r\n    }\r\n\r\n    /**\r\n     * Makes a duplicate of the current configuration into another one.\r\n     * @param plugin define the config where to copy the info\r\n     */\r\n    public copyTo(plugin: MaterialPluginBase): void {\r\n        SerializationHelper.Clone(() => plugin, this);\r\n    }\r\n\r\n    /**\r\n     * Serializes this plugin configuration.\r\n     * @returns - An object with the serialized config.\r\n     */\r\n    public serialize(): any {\r\n        return SerializationHelper.Serialize(this);\r\n    }\r\n\r\n    /**\r\n     * Parses a plugin configuration from a serialized object.\r\n     * @param source - Serialized object.\r\n     * @param scene Defines the scene we are parsing for\r\n     * @param rootUrl Defines the rootUrl to load from\r\n     */\r\n    public parse(source: any, scene: Scene, rootUrl: string): void {\r\n        SerializationHelper.Parse(() => this, source, scene, rootUrl);\r\n    }\r\n}\r\n", "import type { Nullable } from \"../../types\";\r\nimport { InternalTexture, InternalTextureSource } from \"../../Materials/Textures/internalTexture\";\r\nimport { Logger } from \"../../Misc/logger\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { Constants } from \"../constants\";\r\nimport { ThinEngine } from \"../thinEngine\";\r\nimport type { IWebRequest } from \"../../Misc/interfaces/iWebRequest\";\r\nimport { IsExponentOfTwo } from \"../../Misc/tools.functions\";\r\n\r\ndeclare module \"../../Engines/thinEngine\" {\r\n    export interface ThinEngine {\r\n        /**\r\n         * Creates a raw texture\r\n         * @param data defines the data to store in the texture\r\n         * @param width defines the width of the texture\r\n         * @param height defines the height of the texture\r\n         * @param format defines the format of the data\r\n         * @param generateMipMaps defines if the engine should generate the mip levels\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         * @param samplingMode defines the required sampling mode (Texture.NEAREST_SAMPLINGMODE by default)\r\n         * @param compression defines the compression used (null by default)\r\n         * @param type defines the type fo the data (Engine.TEXTURETYPE_UNSIGNED_INT by default)\r\n         * @param creationFlags specific flags to use when creating the texture (Constants.TEXTURE_CREATIONFLAG_STORAGE for storage textures, for eg)\r\n         * @param useSRGBBuffer defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU).\r\n         * @returns the raw texture inside an InternalTexture\r\n         */\r\n        createRawTexture(\r\n            data: Nullable<ArrayBufferView>,\r\n            width: number,\r\n            height: number,\r\n            format: number,\r\n            generateMipMaps: boolean,\r\n            invertY: boolean,\r\n            samplingMode: number,\r\n            compression: Nullable<string>,\r\n            type: number,\r\n            creationFlags?: number,\r\n            useSRGBBuffer?: boolean\r\n        ): InternalTexture;\r\n\r\n        /**\r\n         * Update a raw texture\r\n         * @param texture defines the texture to update\r\n         * @param data defines the data to store in the texture\r\n         * @param format defines the format of the data\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         */\r\n        updateRawTexture(texture: Nullable<InternalTexture>, data: Nullable<ArrayBufferView>, format: number, invertY: boolean): void;\r\n\r\n        /**\r\n         * Update a raw texture\r\n         * @param texture defines the texture to update\r\n         * @param data defines the data to store in the texture\r\n         * @param format defines the format of the data\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         * @param compression defines the compression used (null by default)\r\n         * @param type defines the type fo the data (Engine.TEXTURETYPE_UNSIGNED_INT by default)\r\n         * @param useSRGBBuffer defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU).\r\n         */\r\n        updateRawTexture(\r\n            texture: Nullable<InternalTexture>,\r\n            data: Nullable<ArrayBufferView>,\r\n            format: number,\r\n            invertY: boolean,\r\n            compression: Nullable<string>,\r\n            type: number,\r\n            useSRGBBuffer: boolean\r\n        ): void;\r\n\r\n        /**\r\n         * Creates a new raw cube texture\r\n         * @param data defines the array of data to use to create each face\r\n         * @param size defines the size of the textures\r\n         * @param format defines the format of the data\r\n         * @param type defines the type of the data (like Engine.TEXTURETYPE_UNSIGNED_INT)\r\n         * @param generateMipMaps  defines if the engine should generate the mip levels\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         * @param samplingMode defines the required sampling mode (like Texture.NEAREST_SAMPLINGMODE)\r\n         * @param compression defines the compression used (null by default)\r\n         * @returns the cube texture as an InternalTexture\r\n         */\r\n        createRawCubeTexture(\r\n            data: Nullable<ArrayBufferView[]>,\r\n            size: number,\r\n            format: number,\r\n            type: number,\r\n            generateMipMaps: boolean,\r\n            invertY: boolean,\r\n            samplingMode: number,\r\n            compression: Nullable<string>\r\n        ): InternalTexture;\r\n\r\n        /**\r\n         * Update a raw cube texture\r\n         * @param texture defines the texture to update\r\n         * @param data defines the data to store\r\n         * @param format defines the data format\r\n         * @param type defines the type fo the data (Engine.TEXTURETYPE_UNSIGNED_INT by default)\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         */\r\n        updateRawCubeTexture(texture: InternalTexture, data: ArrayBufferView[], format: number, type: number, invertY: boolean): void;\r\n\r\n        /**\r\n         * Update a raw cube texture\r\n         * @param texture defines the texture to update\r\n         * @param data defines the data to store\r\n         * @param format defines the data format\r\n         * @param type defines the type fo the data (Engine.TEXTURETYPE_UNSIGNED_INT by default)\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         * @param compression defines the compression used (null by default)\r\n         */\r\n        updateRawCubeTexture(texture: InternalTexture, data: ArrayBufferView[], format: number, type: number, invertY: boolean, compression: Nullable<string>): void;\r\n\r\n        /**\r\n         * Update a raw cube texture\r\n         * @param texture defines the texture to update\r\n         * @param data defines the data to store\r\n         * @param format defines the data format\r\n         * @param type defines the type fo the data (Engine.TEXTURETYPE_UNSIGNED_INT by default)\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         * @param compression defines the compression used (null by default)\r\n         * @param level defines which level of the texture to update\r\n         */\r\n        updateRawCubeTexture(texture: InternalTexture, data: ArrayBufferView[], format: number, type: number, invertY: boolean, compression: Nullable<string>, level: number): void;\r\n\r\n        /**\r\n         * Creates a new raw cube texture from a specified url\r\n         * @param url defines the url where the data is located\r\n         * @param scene defines the current scene\r\n         * @param size defines the size of the textures\r\n         * @param format defines the format of the data\r\n         * @param type defines the type fo the data (like Engine.TEXTURETYPE_UNSIGNED_INT)\r\n         * @param noMipmap defines if the engine should avoid generating the mip levels\r\n         * @param callback defines a callback used to extract texture data from loaded data\r\n         * @param mipmapGenerator defines to provide an optional tool to generate mip levels\r\n         * @param onLoad defines a callback called when texture is loaded\r\n         * @param onError defines a callback called if there is an error\r\n         * @returns the cube texture as an InternalTexture\r\n         */\r\n        createRawCubeTextureFromUrl(\r\n            url: string,\r\n            scene: Nullable<Scene>,\r\n            size: number,\r\n            format: number,\r\n            type: number,\r\n            noMipmap: boolean,\r\n            callback: (ArrayBuffer: ArrayBuffer) => Nullable<ArrayBufferView[]>,\r\n            mipmapGenerator: Nullable<(faces: ArrayBufferView[]) => ArrayBufferView[][]>,\r\n            onLoad: Nullable<() => void>,\r\n            onError: Nullable<(message?: string, exception?: any) => void>\r\n        ): InternalTexture;\r\n\r\n        /**\r\n         * Creates a new raw cube texture from a specified url\r\n         * @param url defines the url where the data is located\r\n         * @param scene defines the current scene\r\n         * @param size defines the size of the textures\r\n         * @param format defines the format of the data\r\n         * @param type defines the type fo the data (like Engine.TEXTURETYPE_UNSIGNED_INT)\r\n         * @param noMipmap defines if the engine should avoid generating the mip levels\r\n         * @param callback defines a callback used to extract texture data from loaded data\r\n         * @param mipmapGenerator defines to provide an optional tool to generate mip levels\r\n         * @param onLoad defines a callback called when texture is loaded\r\n         * @param onError defines a callback called if there is an error\r\n         * @param samplingMode defines the required sampling mode (like Texture.NEAREST_SAMPLINGMODE)\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         * @returns the cube texture as an InternalTexture\r\n         */\r\n        createRawCubeTextureFromUrl(\r\n            url: string,\r\n            scene: Nullable<Scene>,\r\n            size: number,\r\n            format: number,\r\n            type: number,\r\n            noMipmap: boolean,\r\n            callback: (ArrayBuffer: ArrayBuffer) => Nullable<ArrayBufferView[]>,\r\n            mipmapGenerator: Nullable<(faces: ArrayBufferView[]) => ArrayBufferView[][]>,\r\n            onLoad: Nullable<() => void>,\r\n            onError: Nullable<(message?: string, exception?: any) => void>,\r\n            samplingMode: number,\r\n            invertY: boolean\r\n        ): InternalTexture;\r\n\r\n        /**\r\n         * Creates a new raw 3D texture\r\n         * @param data defines the data used to create the texture\r\n         * @param width defines the width of the texture\r\n         * @param height defines the height of the texture\r\n         * @param depth defines the depth of the texture\r\n         * @param format defines the format of the texture\r\n         * @param generateMipMaps defines if the engine must generate mip levels\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         * @param samplingMode defines the required sampling mode (like Texture.NEAREST_SAMPLINGMODE)\r\n         * @param compression defines the compressed used (can be null)\r\n         * @param textureType defines the compressed used (can be null)\r\n         * @param creationFlags specific flags to use when creating the texture (Constants.TEXTURE_CREATIONFLAG_STORAGE for storage textures, for eg)\r\n         * @returns a new raw 3D texture (stored in an InternalTexture)\r\n         */\r\n        createRawTexture3D(\r\n            data: Nullable<ArrayBufferView>,\r\n            width: number,\r\n            height: number,\r\n            depth: number,\r\n            format: number,\r\n            generateMipMaps: boolean,\r\n            invertY: boolean,\r\n            samplingMode: number,\r\n            compression: Nullable<string>,\r\n            textureType: number,\r\n            creationFlags?: number\r\n        ): InternalTexture;\r\n\r\n        /**\r\n         * Update a raw 3D texture\r\n         * @param texture defines the texture to update\r\n         * @param data defines the data to store\r\n         * @param format defines the data format\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         */\r\n        updateRawTexture3D(texture: InternalTexture, data: Nullable<ArrayBufferView>, format: number, invertY: boolean): void;\r\n\r\n        /**\r\n         * Update a raw 3D texture\r\n         * @param texture defines the texture to update\r\n         * @param data defines the data to store\r\n         * @param format defines the data format\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         * @param compression defines the used compression (can be null)\r\n         * @param textureType defines the texture Type (Engine.TEXTURETYPE_UNSIGNED_INT, Engine.TEXTURETYPE_FLOAT...)\r\n         */\r\n        updateRawTexture3D(texture: InternalTexture, data: Nullable<ArrayBufferView>, format: number, invertY: boolean, compression: Nullable<string>, textureType: number): void;\r\n\r\n        /**\r\n         * Creates a new raw 2D array texture\r\n         * @param data defines the data used to create the texture\r\n         * @param width defines the width of the texture\r\n         * @param height defines the height of the texture\r\n         * @param depth defines the number of layers of the texture\r\n         * @param format defines the format of the texture\r\n         * @param generateMipMaps defines if the engine must generate mip levels\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         * @param samplingMode defines the required sampling mode (like Texture.NEAREST_SAMPLINGMODE)\r\n         * @param compression defines the compressed used (can be null)\r\n         * @param textureType defines the compressed used (can be null)\r\n         * @param creationFlags specific flags to use when creating the texture (Constants.TEXTURE_CREATIONFLAG_STORAGE for storage textures, for eg)\r\n         * @returns a new raw 2D array texture (stored in an InternalTexture)\r\n         */\r\n        createRawTexture2DArray(\r\n            data: Nullable<ArrayBufferView>,\r\n            width: number,\r\n            height: number,\r\n            depth: number,\r\n            format: number,\r\n            generateMipMaps: boolean,\r\n            invertY: boolean,\r\n            samplingMode: number,\r\n            compression: Nullable<string>,\r\n            textureType: number,\r\n            creationFlags?: number\r\n        ): InternalTexture;\r\n\r\n        /**\r\n         * Update a raw 2D array texture\r\n         * @param texture defines the texture to update\r\n         * @param data defines the data to store\r\n         * @param format defines the data format\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         */\r\n        updateRawTexture2DArray(texture: InternalTexture, data: Nullable<ArrayBufferView>, format: number, invertY: boolean): void;\r\n\r\n        /**\r\n         * Update a raw 2D array texture\r\n         * @param texture defines the texture to update\r\n         * @param data defines the data to store\r\n         * @param format defines the data format\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         * @param compression defines the used compression (can be null)\r\n         * @param textureType defines the texture Type (Engine.TEXTURETYPE_UNSIGNED_INT, Engine.TEXTURETYPE_FLOAT...)\r\n         */\r\n        updateRawTexture2DArray(\r\n            texture: InternalTexture,\r\n            data: Nullable<ArrayBufferView>,\r\n            format: number,\r\n            invertY: boolean,\r\n            compression: Nullable<string>,\r\n            textureType: number\r\n        ): void;\r\n    }\r\n}\r\n\r\nThinEngine.prototype.updateRawTexture = function (\r\n    texture: Nullable<InternalTexture>,\r\n    data: Nullable<ArrayBufferView>,\r\n    format: number,\r\n    invertY: boolean,\r\n    compression: Nullable<string> = null,\r\n    type: number = Constants.TEXTURETYPE_UNSIGNED_INT,\r\n    useSRGBBuffer: boolean = false\r\n): void {\r\n    if (!texture) {\r\n        return;\r\n    }\r\n    // Babylon's internalSizedFomat but gl's texImage2D internalFormat\r\n    const internalSizedFomat = this._getRGBABufferInternalSizedFormat(type, format, useSRGBBuffer);\r\n\r\n    // Babylon's internalFormat but gl's texImage2D format\r\n    const internalFormat = this._getInternalFormat(format);\r\n    const textureType = this._getWebGLTextureType(type);\r\n    this._bindTextureDirectly(this._gl.TEXTURE_2D, texture, true);\r\n    this._unpackFlipY(invertY === undefined ? true : invertY ? true : false);\r\n\r\n    if (!this._doNotHandleContextLost) {\r\n        texture._bufferView = data;\r\n        texture.format = format;\r\n        texture.type = type;\r\n        texture.invertY = invertY;\r\n        texture._compression = compression;\r\n    }\r\n\r\n    if (texture.width % 4 !== 0) {\r\n        this._gl.pixelStorei(this._gl.UNPACK_ALIGNMENT, 1);\r\n    }\r\n\r\n    if (compression && data) {\r\n        this._gl.compressedTexImage2D(this._gl.TEXTURE_2D, 0, (<any>this.getCaps().s3tc)[compression], texture.width, texture.height, 0, <DataView>data);\r\n    } else {\r\n        this._gl.texImage2D(this._gl.TEXTURE_2D, 0, internalSizedFomat, texture.width, texture.height, 0, internalFormat, textureType, data);\r\n    }\r\n\r\n    if (texture.generateMipMaps) {\r\n        this._gl.generateMipmap(this._gl.TEXTURE_2D);\r\n    }\r\n    this._bindTextureDirectly(this._gl.TEXTURE_2D, null);\r\n    //  this.resetTextureCache();\r\n    texture.isReady = true;\r\n};\r\n\r\nThinEngine.prototype.createRawTexture = function (\r\n    data: Nullable<ArrayBufferView>,\r\n    width: number,\r\n    height: number,\r\n    format: number,\r\n    generateMipMaps: boolean,\r\n    invertY: boolean,\r\n    samplingMode: number,\r\n    compression: Nullable<string> = null,\r\n    type: number = Constants.TEXTURETYPE_UNSIGNED_INT,\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    creationFlags = 0,\r\n    useSRGBBuffer = false\r\n): InternalTexture {\r\n    const texture = new InternalTexture(this, InternalTextureSource.Raw);\r\n    texture.baseWidth = width;\r\n    texture.baseHeight = height;\r\n    texture.width = width;\r\n    texture.height = height;\r\n    texture.format = format;\r\n    texture.generateMipMaps = generateMipMaps;\r\n    texture.samplingMode = samplingMode;\r\n    texture.invertY = invertY;\r\n    texture._compression = compression;\r\n    texture.type = type;\r\n    texture._useSRGBBuffer = this._getUseSRGBBuffer(useSRGBBuffer, !generateMipMaps);\r\n\r\n    if (!this._doNotHandleContextLost) {\r\n        texture._bufferView = data;\r\n    }\r\n\r\n    this.updateRawTexture(texture, data, format, invertY, compression, type, texture._useSRGBBuffer);\r\n    this._bindTextureDirectly(this._gl.TEXTURE_2D, texture, true);\r\n\r\n    // Filters\r\n    const filters = this._getSamplingParameters(samplingMode, generateMipMaps);\r\n\r\n    this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MAG_FILTER, filters.mag);\r\n    this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MIN_FILTER, filters.min);\r\n\r\n    if (generateMipMaps) {\r\n        this._gl.generateMipmap(this._gl.TEXTURE_2D);\r\n    }\r\n\r\n    this._bindTextureDirectly(this._gl.TEXTURE_2D, null);\r\n\r\n    this._internalTexturesCache.push(texture);\r\n\r\n    return texture;\r\n};\r\n\r\nThinEngine.prototype.createRawCubeTexture = function (\r\n    data: Nullable<ArrayBufferView[]>,\r\n    size: number,\r\n    format: number,\r\n    type: number,\r\n    generateMipMaps: boolean,\r\n    invertY: boolean,\r\n    samplingMode: number,\r\n    compression: Nullable<string> = null\r\n): InternalTexture {\r\n    const gl = this._gl;\r\n    const texture = new InternalTexture(this, InternalTextureSource.CubeRaw);\r\n    texture.isCube = true;\r\n    texture.format = format;\r\n    texture.type = type;\r\n    if (!this._doNotHandleContextLost) {\r\n        texture._bufferViewArray = data;\r\n    }\r\n\r\n    const textureType = this._getWebGLTextureType(type);\r\n    let internalFormat = this._getInternalFormat(format);\r\n\r\n    if (internalFormat === gl.RGB) {\r\n        internalFormat = gl.RGBA;\r\n    }\r\n\r\n    // Mipmap generation needs a sized internal format that is both color-renderable and texture-filterable\r\n    if (textureType === gl.FLOAT && !this._caps.textureFloatLinearFiltering) {\r\n        generateMipMaps = false;\r\n        samplingMode = Constants.TEXTURE_NEAREST_SAMPLINGMODE;\r\n        Logger.Warn(\"Float texture filtering is not supported. Mipmap generation and sampling mode are forced to false and TEXTURE_NEAREST_SAMPLINGMODE, respectively.\");\r\n    } else if (textureType === this._gl.HALF_FLOAT_OES && !this._caps.textureHalfFloatLinearFiltering) {\r\n        generateMipMaps = false;\r\n        samplingMode = Constants.TEXTURE_NEAREST_SAMPLINGMODE;\r\n        Logger.Warn(\"Half float texture filtering is not supported. Mipmap generation and sampling mode are forced to false and TEXTURE_NEAREST_SAMPLINGMODE, respectively.\");\r\n    } else if (textureType === gl.FLOAT && !this._caps.textureFloatRender) {\r\n        generateMipMaps = false;\r\n        Logger.Warn(\"Render to float textures is not supported. Mipmap generation forced to false.\");\r\n    } else if (textureType === gl.HALF_FLOAT && !this._caps.colorBufferFloat) {\r\n        generateMipMaps = false;\r\n        Logger.Warn(\"Render to half float textures is not supported. Mipmap generation forced to false.\");\r\n    }\r\n\r\n    const width = size;\r\n    const height = width;\r\n\r\n    texture.width = width;\r\n    texture.height = height;\r\n    texture.invertY = invertY;\r\n    texture._compression = compression;\r\n\r\n    // Double check on POT to generate Mips.\r\n    const isPot = !this.needPOTTextures || (IsExponentOfTwo(texture.width) && IsExponentOfTwo(texture.height));\r\n    if (!isPot) {\r\n        generateMipMaps = false;\r\n    }\r\n\r\n    // Upload data if needed. The texture won't be ready until then.\r\n    if (data) {\r\n        this.updateRawCubeTexture(texture, data, format, type, invertY, compression);\r\n    } else {\r\n        const internalSizedFomat = this._getRGBABufferInternalSizedFormat(type);\r\n        const level = 0;\r\n\r\n        this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, texture, true);\r\n\r\n        for (let faceIndex = 0; faceIndex < 6; faceIndex++) {\r\n            if (compression) {\r\n                gl.compressedTexImage2D(\r\n                    gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex,\r\n                    level,\r\n                    (<any>this.getCaps().s3tc)[compression],\r\n                    texture.width,\r\n                    texture.height,\r\n                    0,\r\n                    undefined as any\r\n                );\r\n            } else {\r\n                gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex, level, internalSizedFomat, texture.width, texture.height, 0, internalFormat, textureType, null);\r\n            }\r\n        }\r\n\r\n        this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, null);\r\n    }\r\n\r\n    this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, texture, true);\r\n\r\n    // Filters\r\n    if (data && generateMipMaps) {\r\n        this._gl.generateMipmap(this._gl.TEXTURE_CUBE_MAP);\r\n    }\r\n\r\n    const filters = this._getSamplingParameters(samplingMode, generateMipMaps);\r\n    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, filters.mag);\r\n    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, filters.min);\r\n\r\n    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n    this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, null);\r\n\r\n    texture.generateMipMaps = generateMipMaps;\r\n    texture.samplingMode = samplingMode;\r\n    texture.isReady = true;\r\n\r\n    return texture;\r\n};\r\n\r\nThinEngine.prototype.updateRawCubeTexture = function (\r\n    texture: InternalTexture,\r\n    data: ArrayBufferView[],\r\n    format: number,\r\n    type: number,\r\n    invertY: boolean,\r\n    compression: Nullable<string> = null,\r\n    level: number = 0\r\n): void {\r\n    texture._bufferViewArray = data;\r\n    texture.format = format;\r\n    texture.type = type;\r\n    texture.invertY = invertY;\r\n    texture._compression = compression;\r\n\r\n    const gl = this._gl;\r\n    const textureType = this._getWebGLTextureType(type);\r\n    let internalFormat = this._getInternalFormat(format);\r\n    const internalSizedFomat = this._getRGBABufferInternalSizedFormat(type);\r\n\r\n    let needConversion = false;\r\n    if (internalFormat === gl.RGB) {\r\n        internalFormat = gl.RGBA;\r\n        needConversion = true;\r\n    }\r\n\r\n    this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, texture, true);\r\n    this._unpackFlipY(invertY === undefined ? true : invertY ? true : false);\r\n\r\n    if (texture.width % 4 !== 0) {\r\n        gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);\r\n    }\r\n\r\n    // Data are known to be in +X +Y +Z -X -Y -Z\r\n    for (let faceIndex = 0; faceIndex < 6; faceIndex++) {\r\n        let faceData = data[faceIndex];\r\n\r\n        if (compression) {\r\n            gl.compressedTexImage2D(\r\n                gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex,\r\n                level,\r\n                (<any>this.getCaps().s3tc)[compression],\r\n                texture.width,\r\n                texture.height,\r\n                0,\r\n                <DataView>faceData\r\n            );\r\n        } else {\r\n            if (needConversion) {\r\n                faceData = _convertRGBtoRGBATextureData(faceData, texture.width, texture.height, type);\r\n            }\r\n            gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex, level, internalSizedFomat, texture.width, texture.height, 0, internalFormat, textureType, faceData);\r\n        }\r\n    }\r\n\r\n    const isPot = !this.needPOTTextures || (IsExponentOfTwo(texture.width) && IsExponentOfTwo(texture.height));\r\n    if (isPot && texture.generateMipMaps && level === 0) {\r\n        this._gl.generateMipmap(this._gl.TEXTURE_CUBE_MAP);\r\n    }\r\n    this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, null);\r\n\r\n    // this.resetTextureCache();\r\n    texture.isReady = true;\r\n};\r\n\r\nThinEngine.prototype.createRawCubeTextureFromUrl = function (\r\n    url: string,\r\n    scene: Nullable<Scene>,\r\n    size: number,\r\n    format: number,\r\n    type: number,\r\n    noMipmap: boolean,\r\n    callback: (ArrayBuffer: ArrayBuffer) => Nullable<ArrayBufferView[]>,\r\n    mipmapGenerator: Nullable<(faces: ArrayBufferView[]) => ArrayBufferView[][]>,\r\n    onLoad: Nullable<() => void> = null,\r\n    onError: Nullable<(message?: string, exception?: any) => void> = null,\r\n    samplingMode: number = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE,\r\n    invertY: boolean = false\r\n): InternalTexture {\r\n    const gl = this._gl;\r\n    const texture = this.createRawCubeTexture(null, size, format, type, !noMipmap, invertY, samplingMode, null);\r\n    scene?.addPendingData(texture);\r\n    texture.url = url;\r\n    texture.isReady = false;\r\n    this._internalTexturesCache.push(texture);\r\n\r\n    const onerror = (request?: IWebRequest, exception?: any) => {\r\n        scene?.removePendingData(texture);\r\n        if (onError && request) {\r\n            onError(request.status + \" \" + request.statusText, exception);\r\n        }\r\n    };\r\n\r\n    const internalCallback = (data: any) => {\r\n        const width = texture.width;\r\n        const faceDataArrays = callback(data);\r\n\r\n        if (!faceDataArrays) {\r\n            return;\r\n        }\r\n\r\n        if (mipmapGenerator) {\r\n            const textureType = this._getWebGLTextureType(type);\r\n            let internalFormat = this._getInternalFormat(format);\r\n            const internalSizedFomat = this._getRGBABufferInternalSizedFormat(type);\r\n\r\n            let needConversion = false;\r\n            if (internalFormat === gl.RGB) {\r\n                internalFormat = gl.RGBA;\r\n                needConversion = true;\r\n            }\r\n\r\n            this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, texture, true);\r\n            this._unpackFlipY(false);\r\n\r\n            const mipData = mipmapGenerator(faceDataArrays);\r\n            for (let level = 0; level < mipData.length; level++) {\r\n                const mipSize = width >> level;\r\n\r\n                for (let faceIndex = 0; faceIndex < 6; faceIndex++) {\r\n                    let mipFaceData = mipData[level][faceIndex];\r\n                    if (needConversion) {\r\n                        mipFaceData = _convertRGBtoRGBATextureData(mipFaceData, mipSize, mipSize, type);\r\n                    }\r\n                    gl.texImage2D(faceIndex, level, internalSizedFomat, mipSize, mipSize, 0, internalFormat, textureType, mipFaceData);\r\n                }\r\n            }\r\n\r\n            this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, null);\r\n        } else {\r\n            this.updateRawCubeTexture(texture, faceDataArrays, format, type, invertY);\r\n        }\r\n\r\n        texture.isReady = true;\r\n        // this.resetTextureCache();\r\n        scene?.removePendingData(texture);\r\n\r\n        texture.onLoadedObservable.notifyObservers(texture);\r\n        texture.onLoadedObservable.clear();\r\n\r\n        if (onLoad) {\r\n            onLoad();\r\n        }\r\n    };\r\n\r\n    this._loadFile(\r\n        url,\r\n        (data) => {\r\n            internalCallback(data);\r\n        },\r\n        undefined,\r\n        scene?.offlineProvider,\r\n        true,\r\n        onerror\r\n    );\r\n\r\n    return texture;\r\n};\r\n\r\n/**\r\n * @internal\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nfunction _convertRGBtoRGBATextureData(rgbData: any, width: number, height: number, textureType: number): ArrayBufferView {\r\n    // Create new RGBA data container.\r\n    let rgbaData: any;\r\n    let val1 = 1;\r\n    if (textureType === Constants.TEXTURETYPE_FLOAT) {\r\n        rgbaData = new Float32Array(width * height * 4);\r\n    } else if (textureType === Constants.TEXTURETYPE_HALF_FLOAT) {\r\n        rgbaData = new Uint16Array(width * height * 4);\r\n        val1 = 15360; // 15360 is the encoding of 1 in half float\r\n    } else if (textureType === Constants.TEXTURETYPE_UNSIGNED_INTEGER) {\r\n        rgbaData = new Uint32Array(width * height * 4);\r\n    } else {\r\n        rgbaData = new Uint8Array(width * height * 4);\r\n    }\r\n\r\n    // Convert each pixel.\r\n    for (let x = 0; x < width; x++) {\r\n        for (let y = 0; y < height; y++) {\r\n            const index = (y * width + x) * 3;\r\n            const newIndex = (y * width + x) * 4;\r\n\r\n            // Map Old Value to new value.\r\n            rgbaData[newIndex + 0] = rgbData[index + 0];\r\n            rgbaData[newIndex + 1] = rgbData[index + 1];\r\n            rgbaData[newIndex + 2] = rgbData[index + 2];\r\n\r\n            // Add fully opaque alpha channel.\r\n            rgbaData[newIndex + 3] = val1;\r\n        }\r\n    }\r\n\r\n    return rgbaData;\r\n}\r\n\r\n/**\r\n * Create a function for createRawTexture3D/createRawTexture2DArray\r\n * @param is3D true for TEXTURE_3D and false for TEXTURE_2D_ARRAY\r\n * @internal\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nfunction _makeCreateRawTextureFunction(is3D: boolean) {\r\n    return function (\r\n        this: ThinEngine,\r\n        data: Nullable<ArrayBufferView>,\r\n        width: number,\r\n        height: number,\r\n        depth: number,\r\n        format: number,\r\n        generateMipMaps: boolean,\r\n        invertY: boolean,\r\n        samplingMode: number,\r\n        compression: Nullable<string> = null,\r\n        textureType: number = Constants.TEXTURETYPE_UNSIGNED_INT\r\n    ): InternalTexture {\r\n        const target = is3D ? this._gl.TEXTURE_3D : this._gl.TEXTURE_2D_ARRAY;\r\n        const source = is3D ? InternalTextureSource.Raw3D : InternalTextureSource.Raw2DArray;\r\n        const texture = new InternalTexture(this, source);\r\n        texture.baseWidth = width;\r\n        texture.baseHeight = height;\r\n        texture.baseDepth = depth;\r\n        texture.width = width;\r\n        texture.height = height;\r\n        texture.depth = depth;\r\n        texture.format = format;\r\n        texture.type = textureType;\r\n        texture.generateMipMaps = generateMipMaps;\r\n        texture.samplingMode = samplingMode;\r\n        if (is3D) {\r\n            texture.is3D = true;\r\n        } else {\r\n            texture.is2DArray = true;\r\n        }\r\n\r\n        if (!this._doNotHandleContextLost) {\r\n            texture._bufferView = data;\r\n        }\r\n\r\n        if (is3D) {\r\n            this.updateRawTexture3D(texture, data, format, invertY, compression, textureType);\r\n        } else {\r\n            this.updateRawTexture2DArray(texture, data, format, invertY, compression, textureType);\r\n        }\r\n        this._bindTextureDirectly(target, texture, true);\r\n\r\n        // Filters\r\n        const filters = this._getSamplingParameters(samplingMode, generateMipMaps);\r\n\r\n        this._gl.texParameteri(target, this._gl.TEXTURE_MAG_FILTER, filters.mag);\r\n        this._gl.texParameteri(target, this._gl.TEXTURE_MIN_FILTER, filters.min);\r\n\r\n        if (generateMipMaps) {\r\n            this._gl.generateMipmap(target);\r\n        }\r\n\r\n        this._bindTextureDirectly(target, null);\r\n\r\n        this._internalTexturesCache.push(texture);\r\n\r\n        return texture;\r\n    };\r\n}\r\n\r\nThinEngine.prototype.createRawTexture2DArray = _makeCreateRawTextureFunction(false);\r\nThinEngine.prototype.createRawTexture3D = _makeCreateRawTextureFunction(true);\r\n\r\n/**\r\n * Create a function for updateRawTexture3D/updateRawTexture2DArray\r\n * @param is3D true for TEXTURE_3D and false for TEXTURE_2D_ARRAY\r\n * @internal\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nfunction _makeUpdateRawTextureFunction(is3D: boolean) {\r\n    return function (\r\n        this: ThinEngine,\r\n        texture: InternalTexture,\r\n        data: Nullable<ArrayBufferView>,\r\n        format: number,\r\n        invertY: boolean,\r\n        compression: Nullable<string> = null,\r\n        textureType: number = Constants.TEXTURETYPE_UNSIGNED_INT\r\n    ): void {\r\n        const target = is3D ? this._gl.TEXTURE_3D : this._gl.TEXTURE_2D_ARRAY;\r\n        const internalType = this._getWebGLTextureType(textureType);\r\n        const internalFormat = this._getInternalFormat(format);\r\n        const internalSizedFomat = this._getRGBABufferInternalSizedFormat(textureType, format);\r\n\r\n        this._bindTextureDirectly(target, texture, true);\r\n        this._unpackFlipY(invertY === undefined ? true : invertY ? true : false);\r\n\r\n        if (!this._doNotHandleContextLost) {\r\n            texture._bufferView = data;\r\n            texture.format = format;\r\n            texture.invertY = invertY;\r\n            texture._compression = compression;\r\n        }\r\n\r\n        if (texture.width % 4 !== 0) {\r\n            this._gl.pixelStorei(this._gl.UNPACK_ALIGNMENT, 1);\r\n        }\r\n\r\n        if (compression && data) {\r\n            this._gl.compressedTexImage3D(target, 0, (<any>this.getCaps().s3tc)[compression], texture.width, texture.height, texture.depth, 0, data);\r\n        } else {\r\n            this._gl.texImage3D(target, 0, internalSizedFomat, texture.width, texture.height, texture.depth, 0, internalFormat, internalType, data);\r\n        }\r\n\r\n        if (texture.generateMipMaps) {\r\n            this._gl.generateMipmap(target);\r\n        }\r\n        this._bindTextureDirectly(target, null);\r\n        // this.resetTextureCache();\r\n        texture.isReady = true;\r\n    };\r\n}\r\n\r\nThinEngine.prototype.updateRawTexture2DArray = _makeUpdateRawTextureFunction(false);\r\nThinEngine.prototype.updateRawTexture3D = _makeUpdateRawTextureFunction(true);\r\n", "import { Texture } from \"./texture\";\r\nimport { Constants } from \"../../Engines/constants\";\r\nimport \"../../Engines/Extensions/engine.rawTexture\";\r\nimport type { Nullable } from \"../../types\";\r\n\r\nimport type { Scene } from \"../../scene\";\r\n\r\n/**\r\n * Class used to store 2D array textures containing user data\r\n */\r\nexport class RawTexture2DArray extends Texture {\r\n    private _depth: number;\r\n\r\n    /**\r\n     * Gets the number of layers of the texture\r\n     */\r\n    public get depth() {\r\n        return this._depth;\r\n    }\r\n\r\n    /**\r\n     * Create a new RawTexture2DArray\r\n     * @param data defines the data of the texture\r\n     * @param width defines the width of the texture\r\n     * @param height defines the height of the texture\r\n     * @param depth defines the number of layers of the texture\r\n     * @param format defines the texture format to use\r\n     * @param scene defines the hosting scene\r\n     * @param generateMipMaps defines a boolean indicating if mip levels should be generated (true by default)\r\n     * @param invertY defines if texture must be stored with Y axis inverted\r\n     * @param samplingMode defines the sampling mode to use (Texture.TRILINEAR_SAMPLINGMODE by default)\r\n     * @param textureType defines the texture Type (Engine.TEXTURETYPE_UNSIGNED_INT, Engine.TEXTURETYPE_FLOAT...)\r\n     * @param creationFlags specific flags to use when creating the texture (Constants.TEXTURE_CREATIONFLAG_STORAGE for storage textures, for eg)\r\n     */\r\n    constructor(\r\n        data: Nullable<ArrayBufferView>,\r\n        width: number,\r\n        height: number,\r\n        depth: number,\r\n        /** Gets or sets the texture format to use */\r\n        public format: number,\r\n        scene: Scene,\r\n        generateMipMaps: boolean = true,\r\n        invertY: boolean = false,\r\n        samplingMode: number = Texture.TRILINEAR_SAMPLINGMODE,\r\n        textureType = Constants.TEXTURETYPE_UNSIGNED_INT,\r\n        creationFlags?: number\r\n    ) {\r\n        super(null, scene, !generateMipMaps, invertY);\r\n\r\n        this._texture = scene.getEngine().createRawTexture2DArray(data, width, height, depth, format, generateMipMaps, invertY, samplingMode, null, textureType, creationFlags);\r\n\r\n        this._depth = depth;\r\n        this.is2DArray = true;\r\n    }\r\n\r\n    /**\r\n     * Update the texture with new data\r\n     * @param data defines the data to store in the texture\r\n     */\r\n    public update(data: ArrayBufferView): void {\r\n        if (!this._texture) {\r\n            return;\r\n        }\r\n        this._getEngine()!.updateRawTexture2DArray(this._texture, data, this._texture.format, this._texture!.invertY, null, this._texture.type);\r\n    }\r\n\r\n    /**\r\n     * Creates a RGBA texture from some data.\r\n     * @param data Define the texture data\r\n     * @param width Define the width of the texture\r\n     * @param height Define the height of the texture\r\n     * @param depth defines the number of layers of the texture\r\n     * @param scene defines the scene the texture will belong to\r\n     * @param generateMipMaps Define whether or not to create mip maps for the texture\r\n     * @param invertY define if the data should be flipped on Y when uploaded to the GPU\r\n     * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\r\n     * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)\r\n     * @returns the RGBA texture\r\n     */\r\n    public static CreateRGBATexture(\r\n        data: ArrayBufferView,\r\n        width: number,\r\n        height: number,\r\n        depth: number,\r\n        scene: Scene,\r\n        generateMipMaps: boolean = true,\r\n        invertY: boolean = false,\r\n        samplingMode: number = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE,\r\n        type: number = Constants.TEXTURETYPE_UNSIGNED_INT\r\n    ): RawTexture2DArray {\r\n        return new RawTexture2DArray(data, width, height, depth, Constants.TEXTUREFORMAT_RGBA, scene, generateMipMaps, invertY, samplingMode, type);\r\n    }\r\n}\r\n", "\nimport { Engine } from '@babylonjs/core/Engines/engine'\nimport { Texture } from '@babylonjs/core/Materials/Textures/texture'\nimport { MaterialPluginBase } from '@babylonjs/core/Materials/materialPluginBase'\nimport { RawTexture2DArray } from '@babylonjs/core/Materials/Textures/rawTexture2DArray'\n\n/**\n * \n * \n *      This module creates and manages Materials for terrain meshes. \n *      It tells the terrain mesher which block face materials can share\n *      the same material (and should thus be joined into a single mesh),\n *      and also creates the materials when needed.\n * \n * @internal\n*/\n\nexport class TerrainMatManager {\n\n    /** @param {import('../index').Engine} noa  */\n    constructor(noa) {\n        // make a baseline default material for untextured terrain with no alpha\n        this._defaultMat = noa.rendering.makeStandardMaterial('base-terrain')\n        this._defaultMat.freeze()\n\n        this.allMaterials = [this._defaultMat]\n\n        // internals\n        this.noa = noa\n        this._idCounter = 1000\n        this._blockMatIDtoTerrainID = {}\n        this._terrainIDtoMatObject = {}\n        this._texURLtoTerrainID = {}\n        this._renderMatToTerrainID = new Map()\n    }\n\n\n\n    /** \n     * Maps a given `matID` (from noa.registry) to a unique ID of which \n     * terrain material can be used for that block material.\n     * This lets the terrain mesher map which blocks can be merged into\n     * the same meshes.\n     * Internally, this accessor also creates the material for each \n     * terrainMatID as they are first encountered.\n     */\n\n    getTerrainMatId(blockMatID) {\n        // fast case where matID has been seen before\n        if (blockMatID in this._blockMatIDtoTerrainID) {\n            return this._blockMatIDtoTerrainID[blockMatID]\n        }\n        // decide a unique terrainID for this block material\n        var terrID = decideTerrainMatID(this, blockMatID)\n        // create a mat object for it, if needed\n        if (!(terrID in this._terrainIDtoMatObject)) {\n            var mat = createTerrainMat(this, blockMatID)\n            this.allMaterials.push(mat)\n            this._terrainIDtoMatObject[terrID] = mat\n        }\n        // cache results and done\n        this._blockMatIDtoTerrainID[blockMatID] = terrID\n        return terrID\n    }\n\n\n    /**\n     * Get a Babylon Material object, given a terrainMatID (gotten from this module)\n     */\n    getMaterial(terrainMatID = 1) {\n        return this._terrainIDtoMatObject[terrainMatID]\n    }\n\n\n\n\n\n}\n\n\n\n\n/**\n * \n * \n *      Implementations of creating/disambiguating terrain Materials\n * \n * \n*/\n\n/** \n * Decide a unique terrainID, based on block material ID properties\n * @param {TerrainMatManager} self \n*/\nfunction decideTerrainMatID(self, blockMatID = 0) {\n    var matInfo = self.noa.registry.getMaterialData(blockMatID)\n\n    // custom render materials get one unique terrainID per material\n    if (matInfo.renderMat) {\n        var mat = matInfo.renderMat\n        if (!self._renderMatToTerrainID.has(mat)) {\n            self._renderMatToTerrainID.set(mat, self._idCounter++)\n        }\n        return self._renderMatToTerrainID.get(mat)\n    }\n\n    // ditto for textures, unique URL\n    if (matInfo.texture) {\n        var url = matInfo.texture\n        if (!(url in self._texURLtoTerrainID)) {\n            self._texURLtoTerrainID[url] = self._idCounter++\n        }\n        return self._texURLtoTerrainID[url]\n    }\n\n    // plain color materials with an alpha value are unique by alpha\n    var alpha = matInfo.alpha\n    if (alpha > 0 && alpha < 1) return 10 + Math.round(alpha * 100)\n\n    // the only remaining case is the baseline, which always reuses one fixed ID\n    return 1\n}\n\n\n/** \n * Create (choose) a material for a given set of block material properties\n * @param {TerrainMatManager} self \n*/\nfunction createTerrainMat(self, blockMatID = 0) {\n    var matInfo = self.noa.registry.getMaterialData(blockMatID)\n\n    // custom render mats are just reused\n    if (matInfo.renderMat) return matInfo.renderMat\n\n    // if no texture: use a basic flat material, possibly with alpha\n    if (!matInfo.texture) {\n        var needsAlpha = (matInfo.alpha > 0 && matInfo.alpha < 1)\n        if (!needsAlpha) return self._defaultMat\n        var matName = 'terrain-alpha-' + blockMatID\n        var plainMat = self.noa.rendering.makeStandardMaterial(matName)\n        plainMat.alpha = matInfo.alpha\n        plainMat.freeze()\n        return plainMat\n    }\n\n    // remaining case is a new material with a diffuse texture\n    var scene = self.noa.rendering.getScene()\n    var mat = self.noa.rendering.makeStandardMaterial('terrain-textured-' + blockMatID)\n    var texURL = matInfo.texture\n    var sampling = Texture.NEAREST_SAMPLINGMODE\n    var tex = new Texture(texURL, scene, true, false, sampling)\n    if (matInfo.texHasAlpha) tex.hasAlpha = true\n    mat.diffuseTexture = tex\n\n    // it texture is an atlas, apply material plugin\n    // and check whether any material for the atlas needs alpha\n    if (matInfo.atlasIndex >= 0) {\n        new TerrainMaterialPlugin(mat, tex)\n        if (self.noa.registry._textureNeedsAlpha(matInfo.texture)) {\n            tex.hasAlpha = true\n        }\n    }\n\n    mat.freeze()\n    return mat\n}\n\n\n\n\n\n\n\n\n\n\n\n/**\n * \n *      Babylon material plugin - twiddles the defines/shaders/etc so that\n *      a standard material can use textures from a 2D texture atlas.\n * \n*/\n\nclass TerrainMaterialPlugin extends MaterialPluginBase {\n    constructor(material, texture) {\n        var priority = 200\n        var defines = { 'NOA_TWOD_ARRAY_TEXTURE': false }\n        super(material, 'TestPlugin', priority, defines)\n        this._enable(true)\n        this._atlasTextureArray = null\n\n        texture.onLoadObservable.add((tex) => {\n            this.setTextureArrayData(tex)\n        })\n    }\n\n    setTextureArrayData(texture) {\n        var { width, height } = texture.getSize()\n        var numLayers = Math.round(height / width)\n        height = width\n        var data = texture._readPixelsSync()\n\n        var format = Engine.TEXTUREFORMAT_RGBA\n        var genMipMaps = true\n        var invertY = false\n        var mode = Texture.NEAREST_SAMPLINGMODE\n        var scene = texture.getScene()\n\n        this._atlasTextureArray = new RawTexture2DArray(\n            data, width, height, numLayers,\n            format, scene, genMipMaps, invertY, mode,\n        )\n    }\n\n    prepareDefines(defines, scene, mesh) {\n        defines['NOA_TWOD_ARRAY_TEXTURE'] = true\n    }\n\n    getClassName() {\n        return 'TerrainMaterialPluginName'\n    }\n\n    getSamplers(samplers) {\n        samplers.push('atlasTexture')\n    }\n\n    getAttributes(attributes) {\n        attributes.push('texAtlasIndices')\n    }\n\n    getUniforms() {\n        return { ubo: [] }\n    }\n\n    bindForSubMesh(uniformBuffer, scene, engine, subMesh) {\n        if (this._atlasTextureArray) {\n            uniformBuffer.setTexture('atlasTexture', this._atlasTextureArray)\n        }\n    }\n\n    getCustomCode(shaderType) {\n        if (shaderType === 'vertex') return {\n            'CUSTOM_VERTEX_MAIN_BEGIN': `\n                texAtlasIndex = texAtlasIndices;\n            `,\n            'CUSTOM_VERTEX_DEFINITIONS': `\n                uniform highp sampler2DArray atlasTexture;\n                attribute float texAtlasIndices;\n                varying float texAtlasIndex;\n            `,\n        }\n        if (shaderType === 'fragment') return {\n            '!baseColor\\\\=texture2D\\\\(diffuseSampler,vDiffuseUV\\\\+uvOffset\\\\);':\n                `baseColor = texture(atlasTexture, vec3(vDiffuseUV, texAtlasIndex));`,\n            'CUSTOM_FRAGMENT_DEFINITIONS': `\n                uniform highp sampler2DArray atlasTexture;\n                varying float texAtlasIndex;\n            `,\n        }\n        return null\n    }\n}\n", "\n\nvar defaults = {\n    texturePath: ''\n}\n\n// voxel ID now uses the whole Uint16Array element\nvar MAX_BLOCK_ID = (1 << 16) - 1\n\n\n\n\n\n/**\n * `noa.registry` - Where you register your voxel types, \n * materials, properties, and events.\n * \n * This module uses the following default options (from the options\n * object passed to the {@link Engine}):\n * \n * ```js\n * var defaults = {\n *     texturePath: ''\n * }\n * ```\n*/\n\nexport class Registry {\n\n\n    /** \n     * @internal \n     * @param {import('../index').Engine} noa\n    */\n    constructor(noa, opts) {\n        opts = Object.assign({}, defaults, opts)\n        /** @internal */\n        this.noa = noa\n\n        /** @internal */\n        this._texturePath = opts.texturePath\n\n        /** Maps block face material names to matIDs\n         * @type {Object.<string, number>} */\n        var matIDs = {}\n\n        // lookup arrays for block props and flags - all keyed by blockID\n        // fill in first value for the air block with id=0\n        var blockSolidity = [false]\n        var blockOpacity = [false]\n        var blockIsFluid = [false]\n        var blockIsObject = [false]\n        var blockProps = [null]     // less-often accessed properties\n        var blockMeshes = [null]    // custom mesh objects\n        var blockHandlers = [null]  // block event handlers\n        var blockIsPlain = [false]  // true if voxel is \"boring\" - solid/opaque, no special props\n\n        // this one is keyed by `blockID*6 + faceNumber`\n        var blockMats = [0, 0, 0, 0, 0, 0]\n\n        // and these are keyed by material id\n        var matColorLookup = [null]\n        var matAtlasIndexLookup = [-1]\n\n        /** \n         * Lookup array of block face material properties - keyed by matID (not blockID)\n         * @typedef MatDef\n         * @prop {number[]} color\n         * @prop {number} alpha\n         * @prop {string} texture\n         * @prop {boolean} texHasAlpha\n         * @prop {number} atlasIndex\n         * @prop {*} renderMat\n         */\n        /** @type {MatDef[]} */\n        var matDefs = []\n\n\n        /* \n         * \n         *      Block registration methods\n         * \n        */\n\n\n\n        /**\n         * Register (by integer ID) a block type and its parameters.\n         *  `id` param: integer, currently 1..65535. Generally you should \n         * specify sequential values for blocks, without gaps, but this \n         * isn't technically necessary.\n         * \n         * @param {number} id - sequential integer ID (from 1)\n         * @param {Partial<BlockOptions>} [options] \n         * @returns the `id` value specified\n         */\n        this.registerBlock = function (id = 1, options = null) {\n            var defaults = new BlockOptions(options && options.fluid)\n            var opts = Object.assign({}, defaults, options || {})\n\n            // console.log('register block: ', id, opts)\n            if (id < 1 || id > MAX_BLOCK_ID) throw 'Block id out of range: ' + id\n\n            // if block ID is greater than current highest ID, \n            // register fake blocks to avoid holes in lookup arrays\n            while (id > blockSolidity.length) {\n                this.registerBlock(blockSolidity.length, {})\n            }\n\n            // flags default to solid, opaque, nonfluid\n            blockSolidity[id] = !!opts.solid\n            blockOpacity[id] = !!opts.opaque\n            blockIsFluid[id] = !!opts.fluid\n\n            // store any custom mesh\n            blockIsObject[id] = !!opts.blockMesh\n            blockMeshes[id] = opts.blockMesh || null\n\n            // parse out material parameter\n            // always store 6 material IDs per blockID, so material lookup is monomorphic\n            var mat = opts.material || null\n            var mats\n            if (!mat) {\n                mats = [null, null, null, null, null, null]\n            } else if (typeof mat == 'string') {\n                mats = [mat, mat, mat, mat, mat, mat]\n            } else if (mat.length && mat.length == 2) {\n                // interpret as [top/bottom, sides]\n                mats = [mat[1], mat[1], mat[0], mat[0], mat[1], mat[1]]\n            } else if (mat.length && mat.length == 3) {\n                // interpret as [top, bottom, sides]\n                mats = [mat[2], mat[2], mat[0], mat[1], mat[2], mat[2]]\n            } else if (mat.length && mat.length == 6) {\n                // interpret as [-x, +x, -y, +y, -z, +z]\n                mats = mat\n            } else throw 'Invalid material parameter: ' + mat\n\n            // argument is material name, but store as material id, allocating one if needed\n            for (var i = 0; i < 6; ++i) {\n                blockMats[id * 6 + i] = getMaterialId(this, matIDs, mats[i], true)\n            }\n\n            // props data object - currently only used for fluid properties\n            blockProps[id] = {}\n\n            // if block is fluid, initialize properties if needed\n            if (blockIsFluid[id]) {\n                blockProps[id].fluidDensity = opts.fluidDensity\n                blockProps[id].viscosity = opts.viscosity\n            }\n\n            // event callbacks\n            var hasHandler = opts.onLoad || opts.onUnload || opts.onSet || opts.onUnset || opts.onCustomMeshCreate\n            blockHandlers[id] = (hasHandler) ? new BlockCallbackHolder(opts) : null\n\n            // special lookup for \"plain\"-ness\n            // plain means solid, opaque, not fluid, no mesh or events\n            var isPlain = blockSolidity[id] && blockOpacity[id]\n                && !hasHandler && !blockIsFluid[id] && !blockIsObject[id]\n            blockIsPlain[id] = isPlain\n\n            return id\n        }\n\n\n\n\n        /**\n         * Register (by name) a material and its parameters.\n         * \n         * @param {string} name of this material\n         * @param {Partial<MaterialOptions>} [options]\n         */\n\n        this.registerMaterial = function (name = '?', options = null) {\n            // catch calls to earlier signature\n            if (Array.isArray(options)) {\n                throw 'This API changed signatures in v0.33, please use: `noa.registry.registerMaterial(\"name\", optionsObj)`'\n            }\n\n            var opts = Object.assign(new MaterialOptions(), options || {})\n            var matID = matIDs[name] || matDefs.length\n            matIDs[name] = matID\n\n            var texURL = opts.textureURL ? this._texturePath + opts.textureURL : ''\n            var alpha = 1.0\n            var color = opts.color || [1.0, 1.0, 1.0]\n            if (color.length === 4) alpha = color.pop()\n            if (texURL) color = null\n\n            // populate lookup arrays for terrain meshing\n            matColorLookup[matID] = color\n            matAtlasIndexLookup[matID] = opts.atlasIndex\n\n            matDefs[matID] = {\n                color,\n                alpha,\n                texture: texURL,\n                texHasAlpha: !!opts.texHasAlpha,\n                atlasIndex: opts.atlasIndex,\n                renderMat: opts.renderMaterial,\n            }\n            return matID\n        }\n\n\n\n        /*\n         *      quick accessors for querying block ID stuff\n         */\n\n        /** \n         * block solidity (as in physics) \n         * @param id\n         */\n        this.getBlockSolidity = function (id) {\n            return blockSolidity[id]\n        }\n\n        /**\n         * block opacity - whether it obscures the whole voxel (dirt) or \n         * can be partially seen through (like a fencepost, etc)\n         * @param id\n         */\n        this.getBlockOpacity = function (id) {\n            return blockOpacity[id]\n        }\n\n        /** \n         * block is fluid or not\n         * @param id\n         */\n        this.getBlockFluidity = function (id) {\n            return blockIsFluid[id]\n        }\n\n        /** \n         * Get block property object passed in at registration\n         * @param id\n         */\n        this.getBlockProps = function (id) {\n            return blockProps[id]\n        }\n\n        // look up a block ID's face material\n        // dir is a value 0..5: [ +x, -x, +y, -y, +z, -z ]\n        this.getBlockFaceMaterial = function (blockId, dir) {\n            return blockMats[blockId * 6 + dir]\n        }\n\n\n        /**\n         * General lookup for all properties of a block material\n         * @param {number} matID \n         * @returns {MatDef}\n         */\n        this.getMaterialData = function (matID) {\n            return matDefs[matID]\n        }\n\n\n        /**\n         * Given a texture URL, does any material using that \n         * texture need alpha?\n         * @internal\n         * @returns {boolean}\n         */\n        this._textureNeedsAlpha = function (tex = '') {\n            return matDefs.some(def => {\n                if (def.texture !== tex) return false\n                return def.texHasAlpha\n            })\n        }\n\n\n\n\n\n        /*\n         * \n         *   Meant for internal use within the engine\n         * \n         */\n\n\n        // internal access to lookup arrays\n        /** @internal */\n        this._solidityLookup = blockSolidity\n        /** @internal */\n        this._opacityLookup = blockOpacity\n        /** @internal */\n        this._fluidityLookup = blockIsFluid\n        /** @internal */\n        this._objectLookup = blockIsObject\n        /** @internal */\n        this._blockMeshLookup = blockMeshes\n        /** @internal */\n        this._blockHandlerLookup = blockHandlers\n        /** @internal */\n        this._blockIsPlainLookup = blockIsPlain\n        /** @internal */\n        this._materialColorLookup = matColorLookup\n        /** @internal */\n        this._matAtlasIndexLookup = matAtlasIndexLookup\n\n\n\n        /*\n         * \n         *      default initialization\n         * \n         */\n\n        // add a default material and set ID=1 to it\n        // this is safe since registering new block data overwrites the old\n        this.registerMaterial('dirt', { color: [0.4, 0.3, 0] })\n        this.registerBlock(1, { material: 'dirt' })\n\n    }\n\n}\n\n/*\n * \n *          helpers\n * \n*/\n\n\n\n// look up material ID given its name\n// if lazy is set, pre-register the name and return an ID\nfunction getMaterialId(reg, matIDs, name, lazyInit) {\n    if (!name) return 0\n    var id = matIDs[name]\n    if (id === undefined && lazyInit) id = reg.registerMaterial(name)\n    return id\n}\n\n\n\n// data class for holding block callback references\nfunction BlockCallbackHolder(opts) {\n    this.onLoad = opts.onLoad || null\n    this.onUnload = opts.onUnload || null\n    this.onSet = opts.onSet || null\n    this.onUnset = opts.onUnset || null\n    this.onCustomMeshCreate = opts.onCustomMeshCreate || null\n}\n\n\n\n\n/**\n * Default options when registering a block type\n */\nfunction BlockOptions(isFluid = false) {\n    /** Solidity for physics purposes */\n    this.solid = (isFluid) ? false : true\n    /** Whether the block fully obscures neighboring blocks */\n    this.opaque = (isFluid) ? false : true\n    /** whether a nonsolid block is a fluid (buoyant, viscous..) */\n    this.fluid = false\n    /** The block material(s) for this voxel's faces. May be:\n     *   * one (String) material name\n     *   * array of 2 names: [top/bottom, sides]\n     *   * array of 3 names: [top, bottom, sides]\n     *   * array of 6 names: [-x, +x, -y, +y, -z, +z]\n     * @type {string|string[]}\n    */\n    this.material = null\n    /** Specifies a custom mesh for this voxel, instead of terrain  */\n    this.blockMesh = null\n    /** Fluid parameter for fluid blocks */\n    this.fluidDensity = 1.0\n    /** Fluid parameter for fluid blocks */\n    this.viscosity = 0.5\n    /** @type {(x:number, y:number, z:number) => void} */\n    this.onLoad = null\n    /** @type {(x:number, y:number, z:number) => void} */\n    this.onUnload = null\n    /** @type {(x:number, y:number, z:number) => void} */\n    this.onSet = null\n    /** @type {(x:number, y:number, z:number) => void} */\n    this.onUnset = null\n    /** @type {(mesh:TransformNode, x:number, y:number, z:number) => void} */\n    this.onCustomMeshCreate = null\n}\n\n/** @typedef {import('@babylonjs/core/Meshes').TransformNode} TransformNode */\n\n\n/**\n * Default options when registering a Block Material\n */\nfunction MaterialOptions() {\n    /** An array of 0..1 floats, either [R,G,B] or [R,G,B,A]\n     * @type {number[]}\n     */\n    this.color = null\n    /** Filename of texture image, if any\n     * @type {string}\n     */\n    this.textureURL = null\n    /** Whether the texture image has alpha */\n    this.texHasAlpha = false\n    /** Index into a (vertical strip) texture atlas, if applicable */\n    this.atlasIndex = -1\n    /**\n     * An optional Babylon.js `Material`. If specified, terrain for this voxel\n     * will be rendered with the supplied material (this can impact performance).\n     */\n    this.renderMaterial = null\n}\n", "\nimport glvec3 from 'gl-vec3'\nimport { makeProfileHook } from './util'\n\nimport { SceneOctreeManager } from './sceneOctreeManager'\n\nimport { Scene, ScenePerformancePriority } from '@babylonjs/core/scene'\nimport { FreeCamera } from '@babylonjs/core/Cameras/freeCamera'\nimport { Engine } from '@babylonjs/core/Engines/engine'\nimport { DirectionalLight } from '@babylonjs/core/Lights/directionalLight'\nimport { StandardMaterial } from '@babylonjs/core/Materials/standardMaterial'\nimport { Color3, Color4 } from '@babylonjs/core/Maths/math.color'\nimport { Vector3 } from '@babylonjs/core/Maths/math.vector'\nimport { TransformNode } from '@babylonjs/core/Meshes/transformNode'\nimport { CreateLines } from '@babylonjs/core/Meshes/Builders/linesBuilder'\nimport { CreatePlane } from '@babylonjs/core/Meshes/Builders/planeBuilder'\n\n\n\n\n// profiling flag\nvar PROFILE = 0\n\n\n\nvar defaults = {\n    showFPS: false,\n    antiAlias: true,\n    clearColor: [0.8, 0.9, 1],\n    ambientColor: [0.5, 0.5, 0.5],\n    lightDiffuse: [1, 1, 1],\n    lightSpecular: [1, 1, 1],\n    lightVector: [1, -1, 0.5],\n    useAO: true,\n    AOmultipliers: [0.93, 0.8, 0.5],\n    reverseAOmultiplier: 1.0,\n    preserveDrawingBuffer: true,\n    octreeBlockSize: 2,\n    renderOnResize: true,\n}\n\n\n\n/**\n * `noa.rendering` - \n * Manages all rendering, and the BABYLON scene, materials, etc.\n * \n * This module uses the following default options (from the options\n * object passed to the {@link Engine}):\n * ```js\n * {\n *     showFPS: false,\n *     antiAlias: true,\n *     clearColor: [0.8, 0.9, 1],\n *     ambientColor: [0.5, 0.5, 0.5],\n *     lightDiffuse: [1, 1, 1],\n *     lightSpecular: [1, 1, 1],\n *     lightVector: [1, -1, 0.5],\n *     useAO: true,\n *     AOmultipliers: [0.93, 0.8, 0.5],\n *     reverseAOmultiplier: 1.0,\n *     preserveDrawingBuffer: true,\n *     octreeBlockSize: 2,\n *     renderOnResize: true,\n * }\n * ```\n*/\n\nexport class Rendering {\n\n    /** \n     * @internal \n     * @param {import('../index').Engine} noa  \n    */\n    constructor(noa, opts, canvas) {\n        opts = Object.assign({}, defaults, opts)\n        /** @internal */\n        this.noa = noa\n\n        // settings\n        /** Whether to redraw the screen when the game is resized while paused */\n        this.renderOnResize = !!opts.renderOnResize\n\n        // internals\n        /** @internal */\n        this.useAO = !!opts.useAO\n        /** @internal */\n        this.aoVals = opts.AOmultipliers\n        /** @internal */\n        this.revAoVal = opts.reverseAOmultiplier\n        /** @internal */\n        this.meshingCutoffTime = 6 // ms\n\n        /** the Babylon.js Engine object for the scene */\n        this.engine = null\n        /** the Babylon.js Scene object for the world */\n        this.scene = null\n        /** a Babylon.js DirectionalLight that is added to the scene */\n        this.light = null\n        /** the Babylon.js FreeCamera that renders the scene */\n        this.camera = null\n\n        // sets up babylon scene, lights, etc\n        this._initScene(canvas, opts)\n\n        // for debugging\n        if (opts.showFPS) setUpFPS()\n    }\n\n\n\n\n    /**\n     * Constructor helper - set up the Babylon.js scene and basic components\n     * @internal\n     */\n    _initScene(canvas, opts) {\n\n        // init internal properties\n        this.engine = new Engine(canvas, opts.antiAlias, {\n            preserveDrawingBuffer: opts.preserveDrawingBuffer,\n        })\n        var scene = new Scene(this.engine)\n        this.scene = scene\n        // remove built-in listeners\n        scene.detachControl()\n\n        // this disables a few babylon features that noa doesn't use\n        scene.performancePriority = ScenePerformancePriority.Intermediate\n        scene.autoClear = true\n\n        // octree manager class\n        var blockSize = Math.round(opts.octreeBlockSize)\n        /** @internal */\n        this._octreeManager = new SceneOctreeManager(this, blockSize)\n\n        // camera, and a node to hold it and accumulate rotations\n        /** @internal */\n        this._cameraHolder = new TransformNode('camHolder', scene)\n        this.camera = new FreeCamera('camera', new Vector3(0, 0, 0), scene)\n        this.camera.parent = this._cameraHolder\n        this.camera.minZ = .01\n\n        // plane obscuring the camera - for overlaying an effect on the whole view\n        /** @internal */\n        this._camScreen = CreatePlane('camScreen', { size: 10 }, scene)\n        this.addMeshToScene(this._camScreen)\n        this._camScreen.position.z = .1\n        this._camScreen.parent = this.camera\n        /** @internal */\n        this._camScreenMat = this.makeStandardMaterial('camera_screen_mat')\n        this._camScreen.material = this._camScreenMat\n        this._camScreen.setEnabled(false)\n        this._camScreenMat.freeze()\n        /** @internal */\n        this._camLocBlock = 0\n\n        // apply some defaults\n        scene.clearColor = Color4.FromArray(opts.clearColor)\n        scene.ambientColor = Color3.FromArray(opts.ambientColor)\n\n        var lightVec = Vector3.FromArray(opts.lightVector)\n        this.light = new DirectionalLight('light', lightVec, scene)\n        this.light.diffuse = Color3.FromArray(opts.lightDiffuse)\n        this.light.specular = Color3.FromArray(opts.lightSpecular)\n\n        // scene options\n        scene.skipPointerMovePicking = true\n    }\n}\n\n\n\n/*\n *   PUBLIC API \n */\n\n\n/** The Babylon `scene` object representing the game world. */\nRendering.prototype.getScene = function () {\n    return this.scene\n}\n\n// per-tick listener for rendering-related stuff\n/** @internal */\nRendering.prototype.tick = function (dt) {\n    // nothing here at the moment\n}\n\n\n\n\n/** @internal */\nRendering.prototype.render = function () {\n    profile_hook('start')\n    updateCameraForRender(this)\n    profile_hook('updateCamera')\n    this.engine.beginFrame()\n    profile_hook('beginFrame')\n    this.scene.render()\n    profile_hook('render')\n    fps_hook()\n    this.engine.endFrame()\n    profile_hook('endFrame')\n    profile_hook('end')\n}\n\n\n/** @internal */\nRendering.prototype.postRender = function () {\n    // nothing currently\n}\n\n\n/** @internal */\nRendering.prototype.resize = function () {\n    this.engine.resize()\n    if (this.noa._paused && this.renderOnResize) {\n        this.scene.render()\n    }\n}\n\n\n/** @internal */\nRendering.prototype.highlightBlockFace = function (show, posArr, normArr) {\n    var m = getHighlightMesh(this)\n    if (show) {\n        // floored local coords for highlight mesh\n        this.noa.globalToLocal(posArr, null, hlpos)\n        // offset to avoid z-fighting, bigger when camera is far away\n        var dist = glvec3.dist(this.noa.camera._localGetPosition(), hlpos)\n        var slop = 0.001 + 0.001 * dist\n        for (var i = 0; i < 3; i++) {\n            if (normArr[i] === 0) {\n                hlpos[i] += 0.5\n            } else {\n                hlpos[i] += (normArr[i] > 0) ? 1 + slop : -slop\n            }\n        }\n        m.position.copyFromFloats(hlpos[0], hlpos[1], hlpos[2])\n        m.rotation.x = (normArr[1]) ? Math.PI / 2 : 0\n        m.rotation.y = (normArr[0]) ? Math.PI / 2 : 0\n    }\n    m.setEnabled(show)\n}\nvar hlpos = []\n\n\n\n\n/**\n * Adds a mesh to the engine's selection/octree logic so that it renders.\n * \n * @param mesh the mesh to add to the scene\n * @param isStatic pass in true if mesh never moves (i.e. never changes chunks)\n * @param pos (optional) global position where the mesh should be\n * @param containingChunk (optional) chunk to which the mesh is statically bound\n */\nRendering.prototype.addMeshToScene = function (mesh, isStatic = false, pos = null, containingChunk = null) {\n    if (!mesh.metadata) mesh.metadata = {}\n\n    // if mesh is already added, just make sure it's visisble\n    if (mesh.metadata[addedToSceneFlag]) {\n        this._octreeManager.setMeshVisibility(mesh, true)\n        return\n    }\n    mesh.metadata[addedToSceneFlag] = true\n\n    // find local position for mesh and move it there (unless it's parented)\n    if (!mesh.parent) {\n        if (!pos) pos = mesh.position.asArray()\n        var lpos = this.noa.globalToLocal(pos, null, [])\n        mesh.position.fromArray(lpos)\n    }\n\n    // add to the octree, and remove again on disposal\n    this._octreeManager.addMesh(mesh, isStatic, pos, containingChunk)\n    mesh.onDisposeObservable.add(() => {\n        this._octreeManager.removeMesh(mesh)\n        mesh.metadata[addedToSceneFlag] = false\n    })\n}\nvar addedToSceneFlag = 'noa_added_to_scene'\n\n\n\n\n/**\n * Use this to toggle the visibility of a mesh without disposing it or\n * removing it from the scene.\n * \n * @param {import('@babylonjs/core/Meshes').Mesh} mesh\n * @param {boolean} visible\n */\nRendering.prototype.setMeshVisibility = function (mesh, visible = false) {\n    if (!mesh.metadata) mesh.metadata = {}\n    if (mesh.metadata[addedToSceneFlag]) {\n        this._octreeManager.setMeshVisibility(mesh, visible)\n    } else {\n        if (visible) this.addMeshToScene(mesh)\n    }\n}\n\n\n\n\n\n\n\n\n/**\n * Create a default standardMaterial:      \n * flat, nonspecular, fully reflects diffuse and ambient light\n * @returns {StandardMaterial}\n */\nRendering.prototype.makeStandardMaterial = function (name) {\n    var mat = new StandardMaterial(name, this.scene)\n    mat.specularColor.copyFromFloats(0, 0, 0)\n    mat.ambientColor.copyFromFloats(1, 1, 1)\n    mat.diffuseColor.copyFromFloats(1, 1, 1)\n    return mat\n}\n\n\n\n\n\n\n\n/*\n *\n *   INTERNALS\n *\n */\n\n\n\n\n\n/*\n *\n * \n *   ACCESSORS FOR CHUNK ADD/REMOVAL/MESHING\n *\n * \n */\n/** @internal */\nRendering.prototype.prepareChunkForRendering = function (chunk) {\n    // currently no logic needed here, but I may need it again...\n}\n\n/** @internal */\nRendering.prototype.disposeChunkForRendering = function (chunk) {\n    // nothing currently\n}\n\n\n\n\n\n\n// change world origin offset, and rebase everything with a position\n/** @internal */\nRendering.prototype._rebaseOrigin = function (delta) {\n    var dvec = new Vector3(delta[0], delta[1], delta[2])\n\n    this.scene.meshes.forEach(mesh => {\n        // parented meshes don't live in the world coord system\n        if (mesh.parent) return\n\n        // move each mesh by delta (even though most are managed by components)\n        mesh.position.subtractInPlace(dvec)\n\n        if (mesh.isWorldMatrixFrozen) {\n            // paradoxically this unfreezes, then re-freezes the matrix\n            mesh.freezeWorldMatrix()\n        }\n    })\n\n    // updates position of all octree blocks\n    this._octreeManager.rebase(dvec)\n}\n\n\n\n\n\n// updates camera position/rotation to match settings from noa.camera\n\nfunction updateCameraForRender(self) {\n    var cam = self.noa.camera\n    var tgtLoc = cam._localGetTargetPosition()\n    self._cameraHolder.position.copyFromFloats(tgtLoc[0], tgtLoc[1], tgtLoc[2])\n    self._cameraHolder.rotation.x = cam.pitch\n    self._cameraHolder.rotation.y = cam.heading\n    self.camera.position.z = -cam.currentZoom\n\n    // applies screen effect when camera is inside a transparent voxel\n    var cloc = cam._localGetPosition()\n    var off = self.noa.worldOriginOffset\n    var cx = Math.floor(cloc[0] + off[0])\n    var cy = Math.floor(cloc[1] + off[1])\n    var cz = Math.floor(cloc[2] + off[2])\n    var id = self.noa.getBlock(cx, cy, cz)\n    checkCameraEffect(self, id)\n}\n\n\n\n//  If camera's current location block id has alpha color (e.g. water), apply/remove an effect\n\nfunction checkCameraEffect(self, id) {\n    if (id === self._camLocBlock) return\n    if (id === 0) {\n        self._camScreen.setEnabled(false)\n    } else {\n        var matId = self.noa.registry.getBlockFaceMaterial(id, 0)\n        if (matId) {\n            var matData = self.noa.registry.getMaterialData(matId)\n            var col = matData.color\n            var alpha = matData.alpha\n            if (col && alpha && alpha < 1) {\n                self._camScreenMat.diffuseColor.set(0, 0, 0)\n                self._camScreenMat.ambientColor.set(col[0], col[1], col[2])\n                self._camScreenMat.alpha = alpha\n                self._camScreen.setEnabled(true)\n            }\n        }\n    }\n    self._camLocBlock = id\n}\n\n\n\n\n\n\n// make or get a mesh for highlighting active voxel\nfunction getHighlightMesh(rendering) {\n    var mesh = rendering._highlightMesh\n    if (!mesh) {\n        mesh = CreatePlane(\"highlight\", { size: 1.0 }, rendering.scene)\n        var hlm = rendering.makeStandardMaterial('block_highlight_mat')\n        hlm.backFaceCulling = false\n        hlm.emissiveColor = new Color3(1, 1, 1)\n        hlm.alpha = 0.2\n        hlm.freeze()\n        mesh.material = hlm\n\n        // outline\n        var s = 0.5\n        var lines = CreateLines(\"hightlightLines\", {\n            points: [\n                new Vector3(s, s, 0),\n                new Vector3(s, -s, 0),\n                new Vector3(-s, -s, 0),\n                new Vector3(-s, s, 0),\n                new Vector3(s, s, 0)\n            ]\n        }, rendering.scene)\n        lines.color = new Color3(1, 1, 1)\n        lines.parent = mesh\n\n        rendering.addMeshToScene(mesh)\n        rendering.addMeshToScene(lines)\n        rendering._highlightMesh = mesh\n    }\n    return mesh\n}\n\n\n\n\n\n\n\n\n\n\n/*\n * \n *      sanity checks:\n * \n */\n/** @internal */\nRendering.prototype.debug_SceneCheck = function () {\n    var meshes = this.scene.meshes\n    var octree = this.scene._selectionOctree\n    var dyns = octree.dynamicContent\n    var octs = []\n    var numOcts = 0\n    var numSubs = 0\n    var mats = this.scene.materials\n    var allmats = []\n    mats.forEach(mat => {\n        // @ts-ignore\n        if (mat.subMaterials) mat.subMaterials.forEach(mat => allmats.push(mat))\n        else allmats.push(mat)\n    })\n    octree.blocks.forEach(function (block) {\n        numOcts++\n        block.entries.forEach(m => octs.push(m))\n    })\n    meshes.forEach(function (m) {\n        if (m.isDisposed()) warn(m, 'disposed mesh in scene')\n        if (empty(m)) return\n        if (missing(m, dyns, octs)) warn(m, 'non-empty mesh missing from octree')\n        if (!m.material) { warn(m, 'non-empty scene mesh with no material'); return }\n        numSubs += (m.subMeshes) ? m.subMeshes.length : 1\n        // @ts-ignore\n        var mats = m.material.subMaterials || [m.material]\n        mats.forEach(function (mat) {\n            if (missing(mat, mats)) warn(mat, 'mesh material not in scene')\n        })\n    })\n    var unusedMats = []\n    allmats.forEach(mat => {\n        var used = false\n        meshes.forEach(mesh => {\n            if (mesh.material === mat) used = true\n            if (!mesh.material) return\n            // @ts-ignore\n            var mats = mesh.material.subMaterials || [mesh.material]\n            if (mats.includes(mat)) used = true\n        })\n        if (!used) unusedMats.push(mat.name)\n    })\n    if (unusedMats.length) {\n        console.warn('Materials unused by any mesh: ', unusedMats.join(', '))\n    }\n    dyns.forEach(function (m) {\n        if (missing(m, meshes)) warn(m, 'octree/dynamic mesh not in scene')\n    })\n    octs.forEach(function (m) {\n        if (missing(m, meshes)) warn(m, 'octree block mesh not in scene')\n    })\n    var avgPerOct = Math.round(10 * octs.length / numOcts) / 10\n    console.log('meshes - octree:', octs.length, '  dynamic:', dyns.length,\n        '   subMeshes:', numSubs,\n        '   avg meshes/octreeBlock:', avgPerOct)\n\n    function warn(obj, msg) { console.warn(obj.name + ' --- ' + msg) }\n\n    function empty(mesh) { return (mesh.getIndices().length === 0) }\n\n    function missing(obj, list1, list2) {\n        if (!obj) return false\n        if (list1.includes(obj)) return false\n        if (list2 && list2.includes(obj)) return false\n        return true\n    }\n    return 'done.'\n}\n\n\n/** @internal */\nRendering.prototype.debug_MeshCount = function () {\n    var ct = {}\n    this.scene.meshes.forEach(m => {\n        var n = m.name || ''\n        n = n.replace(/-\\d+.*/, '#')\n        n = n.replace(/\\d+.*/, '#')\n        n = n.replace(/(rotHolder|camHolder|camScreen)/, 'rendering use')\n        n = n.replace(/atlas sprite .*/, 'atlas sprites')\n        ct[n] = ct[n] || 0\n        ct[n]++\n    })\n    for (var s in ct) console.log('   ' + (ct[s] + '       ').substr(0, 7) + s)\n}\n\n\n\n\n\n\n\nvar profile_hook = (PROFILE) ?\n    makeProfileHook(200, 'render internals') : () => { }\n\n\n\nvar fps_hook = function () { }\n\nfunction setUpFPS() {\n    var div = document.createElement('div')\n    div.id = 'noa_fps'\n    div.style.position = 'absolute'\n    div.style.top = '0'\n    div.style.right = '0'\n    div.style.zIndex = '0'\n    div.style.color = 'white'\n    div.style.backgroundColor = 'rgba(0,0,0,0.5)'\n    div.style.font = '14px monospace'\n    div.style.textAlign = 'center'\n    div.style.minWidth = '2em'\n    div.style.margin = '4px'\n    document.body.appendChild(div)\n    var every = 1000\n    var ct = 0\n    var longest = 0\n    var start = performance.now()\n    var last = start\n    fps_hook = function () {\n        ct++\n        var nt = performance.now()\n        if (nt - last > longest) longest = nt - last\n        last = nt\n        if (nt - start < every) return\n        var fps = Math.round(ct / (nt - start) * 1000)\n        var min = Math.round(1 / longest * 1000)\n        div.innerHTML = fps + '<br>' + min\n        ct = 0\n        longest = 0\n        start = nt\n    }\n}\n", "import type { SmartArrayNoDuplicate } from \"../../Misc/smartArray\";\r\nimport { Vector3 } from \"../../Maths/math.vector\";\r\nimport type { Ray } from \"../../Culling/ray\";\r\nimport { BoundingBox } from \"../../Culling/boundingBox\";\r\nimport type { Plane } from \"../../Maths/math.plane\";\r\n\r\n/**\r\n * Contains an array of blocks representing the octree\r\n */\r\nexport interface IOctreeContainer<T> {\r\n    /**\r\n     * Blocks within the octree\r\n     */\r\n    blocks: Array<OctreeBlock<T>>;\r\n}\r\n\r\n/**\r\n * Class used to store a cell in an octree\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/optimizeOctrees\r\n */\r\nexport class OctreeBlock<T> {\r\n    /**\r\n     * Gets the content of the current block\r\n     */\r\n    public entries: T[] = [];\r\n\r\n    /**\r\n     * Gets the list of block children\r\n     */\r\n    public blocks: Array<OctreeBlock<T>>;\r\n\r\n    private _depth: number;\r\n    private _maxDepth: number;\r\n    private _capacity: number;\r\n    private _minPoint: Vector3;\r\n    private _maxPoint: Vector3;\r\n    private _boundingVectors = new Array<Vector3>();\r\n    private _creationFunc: (entry: T, block: OctreeBlock<T>) => void;\r\n\r\n    /**\r\n     * Creates a new block\r\n     * @param minPoint defines the minimum vector (in world space) of the block's bounding box\r\n     * @param maxPoint defines the maximum vector (in world space) of the block's bounding box\r\n     * @param capacity defines the maximum capacity of this block (if capacity is reached the block will be split into sub blocks)\r\n     * @param depth defines the current depth of this block in the octree\r\n     * @param maxDepth defines the maximal depth allowed (beyond this value, the capacity is ignored)\r\n     * @param creationFunc defines a callback to call when an element is added to the block\r\n     */\r\n    constructor(minPoint: Vector3, maxPoint: Vector3, capacity: number, depth: number, maxDepth: number, creationFunc: (entry: T, block: OctreeBlock<T>) => void) {\r\n        this._capacity = capacity;\r\n        this._depth = depth;\r\n        this._maxDepth = maxDepth;\r\n        this._creationFunc = creationFunc;\r\n\r\n        this._minPoint = minPoint;\r\n        this._maxPoint = maxPoint;\r\n\r\n        this._boundingVectors.push(minPoint.clone());\r\n        this._boundingVectors.push(maxPoint.clone());\r\n\r\n        this._boundingVectors.push(minPoint.clone());\r\n        this._boundingVectors[2].x = maxPoint.x;\r\n\r\n        this._boundingVectors.push(minPoint.clone());\r\n        this._boundingVectors[3].y = maxPoint.y;\r\n\r\n        this._boundingVectors.push(minPoint.clone());\r\n        this._boundingVectors[4].z = maxPoint.z;\r\n\r\n        this._boundingVectors.push(maxPoint.clone());\r\n        this._boundingVectors[5].z = minPoint.z;\r\n\r\n        this._boundingVectors.push(maxPoint.clone());\r\n        this._boundingVectors[6].x = minPoint.x;\r\n\r\n        this._boundingVectors.push(maxPoint.clone());\r\n        this._boundingVectors[7].y = minPoint.y;\r\n    }\r\n\r\n    // Property\r\n\r\n    /**\r\n     * Gets the maximum capacity of this block (if capacity is reached the block will be split into sub blocks)\r\n     */\r\n    public get capacity(): number {\r\n        return this._capacity;\r\n    }\r\n\r\n    /**\r\n     * Gets the minimum vector (in world space) of the block's bounding box\r\n     */\r\n    public get minPoint(): Vector3 {\r\n        return this._minPoint;\r\n    }\r\n\r\n    /**\r\n     * Gets the maximum vector (in world space) of the block's bounding box\r\n     */\r\n    public get maxPoint(): Vector3 {\r\n        return this._maxPoint;\r\n    }\r\n\r\n    // Methods\r\n\r\n    /**\r\n     * Add a new element to this block\r\n     * @param entry defines the element to add\r\n     */\r\n    public addEntry(entry: T): void {\r\n        if (this.blocks) {\r\n            for (let index = 0; index < this.blocks.length; index++) {\r\n                const block = this.blocks[index];\r\n                block.addEntry(entry);\r\n            }\r\n            return;\r\n        }\r\n\r\n        this._creationFunc(entry, this);\r\n\r\n        if (this.entries.length > this.capacity && this._depth < this._maxDepth) {\r\n            this.createInnerBlocks();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove an element from this block\r\n     * @param entry defines the element to remove\r\n     */\r\n    public removeEntry(entry: T): void {\r\n        if (this.blocks) {\r\n            for (let index = 0; index < this.blocks.length; index++) {\r\n                const block = this.blocks[index];\r\n                block.removeEntry(entry);\r\n            }\r\n            return;\r\n        }\r\n\r\n        const entryIndex = this.entries.indexOf(entry);\r\n\r\n        if (entryIndex > -1) {\r\n            this.entries.splice(entryIndex, 1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Add an array of elements to this block\r\n     * @param entries defines the array of elements to add\r\n     */\r\n    public addEntries(entries: T[]): void {\r\n        for (let index = 0; index < entries.length; index++) {\r\n            const mesh = entries[index];\r\n            this.addEntry(mesh);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Test if the current block intersects the frustum planes and if yes, then add its content to the selection array\r\n     * @param frustumPlanes defines the frustum planes to test\r\n     * @param selection defines the array to store current content if selection is positive\r\n     * @param allowDuplicate defines if the selection array can contains duplicated entries\r\n     */\r\n    public select(frustumPlanes: Plane[], selection: SmartArrayNoDuplicate<T>, allowDuplicate?: boolean): void {\r\n        if (BoundingBox.IsInFrustum(this._boundingVectors, frustumPlanes)) {\r\n            if (this.blocks) {\r\n                for (let index = 0; index < this.blocks.length; index++) {\r\n                    const block = this.blocks[index];\r\n                    block.select(frustumPlanes, selection, allowDuplicate);\r\n                }\r\n                return;\r\n            }\r\n\r\n            if (allowDuplicate) {\r\n                selection.concat(this.entries);\r\n            } else {\r\n                selection.concatWithNoDuplicate(this.entries);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Test if the current block intersect with the given bounding sphere and if yes, then add its content to the selection array\r\n     * @param sphereCenter defines the bounding sphere center\r\n     * @param sphereRadius defines the bounding sphere radius\r\n     * @param selection defines the array to store current content if selection is positive\r\n     * @param allowDuplicate defines if the selection array can contains duplicated entries\r\n     */\r\n    public intersects(sphereCenter: Vector3, sphereRadius: number, selection: SmartArrayNoDuplicate<T>, allowDuplicate?: boolean): void {\r\n        if (BoundingBox.IntersectsSphere(this._minPoint, this._maxPoint, sphereCenter, sphereRadius)) {\r\n            if (this.blocks) {\r\n                for (let index = 0; index < this.blocks.length; index++) {\r\n                    const block = this.blocks[index];\r\n                    block.intersects(sphereCenter, sphereRadius, selection, allowDuplicate);\r\n                }\r\n                return;\r\n            }\r\n\r\n            if (allowDuplicate) {\r\n                selection.concat(this.entries);\r\n            } else {\r\n                selection.concatWithNoDuplicate(this.entries);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Test if the current block intersect with the given ray and if yes, then add its content to the selection array\r\n     * @param ray defines the ray to test with\r\n     * @param selection defines the array to store current content if selection is positive\r\n     */\r\n    public intersectsRay(ray: Ray, selection: SmartArrayNoDuplicate<T>): void {\r\n        if (ray.intersectsBoxMinMax(this._minPoint, this._maxPoint)) {\r\n            if (this.blocks) {\r\n                for (let index = 0; index < this.blocks.length; index++) {\r\n                    const block = this.blocks[index];\r\n                    block.intersectsRay(ray, selection);\r\n                }\r\n                return;\r\n            }\r\n            selection.concatWithNoDuplicate(this.entries);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Subdivide the content into child blocks (this block will then be empty)\r\n     */\r\n    public createInnerBlocks(): void {\r\n        OctreeBlock._CreateBlocks(this._minPoint, this._maxPoint, this.entries, this._capacity, this._depth, this._maxDepth, this, this._creationFunc);\r\n        this.entries.splice(0);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public static _CreateBlocks<T>(\r\n        worldMin: Vector3,\r\n        worldMax: Vector3,\r\n        entries: T[],\r\n        maxBlockCapacity: number,\r\n        currentDepth: number,\r\n        maxDepth: number,\r\n        target: IOctreeContainer<T>,\r\n        creationFunc: (entry: T, block: OctreeBlock<T>) => void\r\n    ): void {\r\n        target.blocks = new Array<OctreeBlock<T>>();\r\n        const blockSize = new Vector3((worldMax.x - worldMin.x) / 2, (worldMax.y - worldMin.y) / 2, (worldMax.z - worldMin.z) / 2);\r\n\r\n        // Segmenting space\r\n        for (let x = 0; x < 2; x++) {\r\n            for (let y = 0; y < 2; y++) {\r\n                for (let z = 0; z < 2; z++) {\r\n                    const localMin = worldMin.add(blockSize.multiplyByFloats(x, y, z));\r\n                    const localMax = worldMin.add(blockSize.multiplyByFloats(x + 1, y + 1, z + 1));\r\n\r\n                    const block = new OctreeBlock<T>(localMin, localMax, maxBlockCapacity, currentDepth + 1, maxDepth, creationFunc);\r\n                    block.addEntries(entries);\r\n                    target.blocks.push(block);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n", "import type { SmartArray } from \"../../Misc/smartArray\";\r\nimport { SmartArrayNoDuplicate } from \"../../Misc/smartArray\";\r\nimport type { Vector3 } from \"../../Maths/math.vector\";\r\nimport type { SubMesh } from \"../../Meshes/subMesh\";\r\nimport type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport type { Ray } from \"../../Culling/ray\";\r\nimport { OctreeBlock } from \"./octreeBlock\";\r\nimport type { Plane } from \"../../Maths/math.plane\";\r\n\r\n/**\r\n * Octrees are a really powerful data structure that can quickly select entities based on space coordinates.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/optimizeOctrees\r\n */\r\nexport class Octree<T> {\r\n    /**\r\n     * Blocks within the octree containing objects\r\n     */\r\n    public blocks: Array<OctreeBlock<T>>;\r\n    /**\r\n     * Content stored in the octree\r\n     */\r\n    public dynamicContent: T[] = [];\r\n\r\n    private _maxBlockCapacity: number;\r\n    private _selectionContent: SmartArrayNoDuplicate<T>;\r\n    private _creationFunc: (entry: T, block: OctreeBlock<T>) => void;\r\n\r\n    /**\r\n     * Creates a octree\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/optimizeOctrees\r\n     * @param creationFunc function to be used to instantiate the octree\r\n     * @param maxBlockCapacity defines the maximum number of meshes you want on your octree's leaves (default: 64)\r\n     * @param maxDepth defines the maximum depth (sub-levels) for your octree. Default value is 2, which means 8 8 8 = 512 blocks :) (This parameter takes precedence over capacity.)\r\n     */\r\n    constructor(\r\n        creationFunc: (entry: T, block: OctreeBlock<T>) => void,\r\n        maxBlockCapacity?: number,\r\n        /** Defines the maximum depth (sub-levels) for your octree. Default value is 2, which means 8 8 8 = 512 blocks :) (This parameter takes precedence over capacity.) */\r\n        public maxDepth = 2\r\n    ) {\r\n        this._maxBlockCapacity = maxBlockCapacity || 64;\r\n        this._selectionContent = new SmartArrayNoDuplicate<T>(1024);\r\n        this._creationFunc = creationFunc;\r\n    }\r\n\r\n    // Methods\r\n    /**\r\n     * Updates the octree by adding blocks for the passed in meshes within the min and max world parameters\r\n     * @param worldMin worldMin for the octree blocks var blockSize = new Vector3((worldMax.x - worldMin.x) / 2, (worldMax.y - worldMin.y) / 2, (worldMax.z - worldMin.z) / 2);\r\n     * @param worldMax worldMax for the octree blocks var blockSize = new Vector3((worldMax.x - worldMin.x) / 2, (worldMax.y - worldMin.y) / 2, (worldMax.z - worldMin.z) / 2);\r\n     * @param entries meshes to be added to the octree blocks\r\n     */\r\n    public update(worldMin: Vector3, worldMax: Vector3, entries: T[]): void {\r\n        OctreeBlock._CreateBlocks(worldMin, worldMax, entries, this._maxBlockCapacity, 0, this.maxDepth, this, this._creationFunc);\r\n    }\r\n\r\n    /**\r\n     * Adds a mesh to the octree\r\n     * @param entry Mesh to add to the octree\r\n     */\r\n    public addMesh(entry: T): void {\r\n        for (let index = 0; index < this.blocks.length; index++) {\r\n            const block = this.blocks[index];\r\n            block.addEntry(entry);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove an element from the octree\r\n     * @param entry defines the element to remove\r\n     */\r\n    public removeMesh(entry: T): void {\r\n        for (let index = 0; index < this.blocks.length; index++) {\r\n            const block = this.blocks[index];\r\n            block.removeEntry(entry);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Selects an array of meshes within the frustum\r\n     * @param frustumPlanes The frustum planes to use which will select all meshes within it\r\n     * @param allowDuplicate If duplicate objects are allowed in the resulting object array\r\n     * @returns array of meshes within the frustum\r\n     */\r\n    public select(frustumPlanes: Plane[], allowDuplicate?: boolean): SmartArray<T> {\r\n        this._selectionContent.reset();\r\n\r\n        for (let index = 0; index < this.blocks.length; index++) {\r\n            const block = this.blocks[index];\r\n            block.select(frustumPlanes, this._selectionContent, allowDuplicate);\r\n        }\r\n\r\n        if (allowDuplicate) {\r\n            this._selectionContent.concat(this.dynamicContent);\r\n        } else {\r\n            this._selectionContent.concatWithNoDuplicate(this.dynamicContent);\r\n        }\r\n\r\n        return this._selectionContent;\r\n    }\r\n\r\n    /**\r\n     * Test if the octree intersect with the given bounding sphere and if yes, then add its content to the selection array\r\n     * @param sphereCenter defines the bounding sphere center\r\n     * @param sphereRadius defines the bounding sphere radius\r\n     * @param allowDuplicate defines if the selection array can contains duplicated entries\r\n     * @returns an array of objects that intersect the sphere\r\n     */\r\n    public intersects(sphereCenter: Vector3, sphereRadius: number, allowDuplicate?: boolean): SmartArray<T> {\r\n        this._selectionContent.reset();\r\n\r\n        for (let index = 0; index < this.blocks.length; index++) {\r\n            const block = this.blocks[index];\r\n            block.intersects(sphereCenter, sphereRadius, this._selectionContent, allowDuplicate);\r\n        }\r\n\r\n        if (allowDuplicate) {\r\n            this._selectionContent.concat(this.dynamicContent);\r\n        } else {\r\n            this._selectionContent.concatWithNoDuplicate(this.dynamicContent);\r\n        }\r\n\r\n        return this._selectionContent;\r\n    }\r\n\r\n    /**\r\n     * Test if the octree intersect with the given ray and if yes, then add its content to resulting array\r\n     * @param ray defines the ray to test with\r\n     * @returns array of intersected objects\r\n     */\r\n    public intersectsRay(ray: Ray): SmartArray<T> {\r\n        this._selectionContent.reset();\r\n\r\n        for (let index = 0; index < this.blocks.length; index++) {\r\n            const block = this.blocks[index];\r\n            block.intersectsRay(ray, this._selectionContent);\r\n        }\r\n\r\n        this._selectionContent.concatWithNoDuplicate(this.dynamicContent);\r\n\r\n        return this._selectionContent;\r\n    }\r\n\r\n    /**\r\n     * Adds a mesh into the octree block if it intersects the block\r\n     * @param entry defines the mesh to try to add to the block\r\n     * @param block defines the block where the mesh should be added\r\n     */\r\n    public static CreationFuncForMeshes = (entry: AbstractMesh, block: OctreeBlock<AbstractMesh>): void => {\r\n        const boundingInfo = entry.getBoundingInfo();\r\n        if (!entry.isBlocked && boundingInfo.boundingBox.intersectsMinMax(block.minPoint, block.maxPoint)) {\r\n            block.entries.push(entry);\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Adds a submesh into the octree block if it intersects the block\r\n     * @param entry defines the submesh to try to add to the block\r\n     * @param block defines the block where the submesh should be added\r\n     */\r\n    public static CreationFuncForSubMeshes = (entry: SubMesh, block: OctreeBlock<SubMesh>): void => {\r\n        const boundingInfo = entry.getBoundingInfo();\r\n        if (boundingInfo.boundingBox.intersectsMinMax(block.minPoint, block.maxPoint)) {\r\n            block.entries.push(entry);\r\n        }\r\n    };\r\n}\r\n", "import type { DeepImmutable, Nullable, float } from \"../types\";\r\nimport { ArrayTools } from \"../Misc/arrayTools\";\r\nimport { Matrix, Vector3, TmpVectors } from \"../Maths/math.vector\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { PickingInfo } from \"../Collisions/pickingInfo\";\r\nimport { IntersectionInfo } from \"../Collisions/intersectionInfo\";\r\nimport type { BoundingBox } from \"./boundingBox\";\r\nimport type { BoundingSphere } from \"./boundingSphere\";\r\nimport { Scene } from \"../scene\";\r\nimport { Camera } from \"../Cameras/camera\";\r\nimport type { Plane } from \"../Maths/math.plane\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\n\r\nimport type { Mesh } from \"../Meshes/mesh\";\r\nimport { Epsilon } from \"core/Maths/math.constants\";\r\n\r\n/**\r\n * Class representing a ray with position and direction\r\n */\r\nexport class Ray {\r\n    private static readonly _TmpVector3 = ArrayTools.BuildArray(6, Vector3.Zero);\r\n    private static _RayDistant = Ray.Zero();\r\n    private _tmpRay: Ray;\r\n\r\n    /**\r\n     * Creates a new ray\r\n     * @param origin origin point\r\n     * @param direction direction\r\n     * @param length length of the ray\r\n     * @param epsilon The epsilon value to use when calculating the ray/triangle intersection (default: 0)\r\n     */\r\n    constructor(\r\n        /** origin point */\r\n        public origin: Vector3,\r\n        /** direction */\r\n        public direction: Vector3,\r\n        /** length of the ray */\r\n        public length: number = Number.MAX_VALUE,\r\n        /** The epsilon value to use when calculating the ray/triangle intersection (default: Epsilon from math constants) */\r\n        public epsilon: number = Epsilon\r\n    ) {}\r\n\r\n    // Methods\r\n\r\n    /**\r\n     * Clone the current ray\r\n     * @returns a new ray\r\n     */\r\n    public clone(): Ray {\r\n        return new Ray(this.origin.clone(), this.direction.clone(), this.length);\r\n    }\r\n\r\n    /**\r\n     * Checks if the ray intersects a box\r\n     * This does not account for the ray length by design to improve perfs.\r\n     * @param minimum bound of the box\r\n     * @param maximum bound of the box\r\n     * @param intersectionTreshold extra extend to be added to the box in all direction\r\n     * @returns if the box was hit\r\n     */\r\n    public intersectsBoxMinMax(minimum: DeepImmutable<Vector3>, maximum: DeepImmutable<Vector3>, intersectionTreshold: number = 0): boolean {\r\n        const newMinimum = Ray._TmpVector3[0].copyFromFloats(minimum.x - intersectionTreshold, minimum.y - intersectionTreshold, minimum.z - intersectionTreshold);\r\n        const newMaximum = Ray._TmpVector3[1].copyFromFloats(maximum.x + intersectionTreshold, maximum.y + intersectionTreshold, maximum.z + intersectionTreshold);\r\n        let d = 0.0;\r\n        let maxValue = Number.MAX_VALUE;\r\n        let inv: number;\r\n        let min: number;\r\n        let max: number;\r\n        let temp: number;\r\n        if (Math.abs(this.direction.x) < 0.0000001) {\r\n            if (this.origin.x < newMinimum.x || this.origin.x > newMaximum.x) {\r\n                return false;\r\n            }\r\n        } else {\r\n            inv = 1.0 / this.direction.x;\r\n            min = (newMinimum.x - this.origin.x) * inv;\r\n            max = (newMaximum.x - this.origin.x) * inv;\r\n            if (max === -Infinity) {\r\n                max = Infinity;\r\n            }\r\n\r\n            if (min > max) {\r\n                temp = min;\r\n                min = max;\r\n                max = temp;\r\n            }\r\n\r\n            d = Math.max(min, d);\r\n            maxValue = Math.min(max, maxValue);\r\n\r\n            if (d > maxValue) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        if (Math.abs(this.direction.y) < 0.0000001) {\r\n            if (this.origin.y < newMinimum.y || this.origin.y > newMaximum.y) {\r\n                return false;\r\n            }\r\n        } else {\r\n            inv = 1.0 / this.direction.y;\r\n            min = (newMinimum.y - this.origin.y) * inv;\r\n            max = (newMaximum.y - this.origin.y) * inv;\r\n\r\n            if (max === -Infinity) {\r\n                max = Infinity;\r\n            }\r\n\r\n            if (min > max) {\r\n                temp = min;\r\n                min = max;\r\n                max = temp;\r\n            }\r\n\r\n            d = Math.max(min, d);\r\n            maxValue = Math.min(max, maxValue);\r\n\r\n            if (d > maxValue) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        if (Math.abs(this.direction.z) < 0.0000001) {\r\n            if (this.origin.z < newMinimum.z || this.origin.z > newMaximum.z) {\r\n                return false;\r\n            }\r\n        } else {\r\n            inv = 1.0 / this.direction.z;\r\n            min = (newMinimum.z - this.origin.z) * inv;\r\n            max = (newMaximum.z - this.origin.z) * inv;\r\n\r\n            if (max === -Infinity) {\r\n                max = Infinity;\r\n            }\r\n\r\n            if (min > max) {\r\n                temp = min;\r\n                min = max;\r\n                max = temp;\r\n            }\r\n\r\n            d = Math.max(min, d);\r\n            maxValue = Math.min(max, maxValue);\r\n\r\n            if (d > maxValue) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Checks if the ray intersects a box\r\n     * This does not account for the ray lenght by design to improve perfs.\r\n     * @param box the bounding box to check\r\n     * @param intersectionTreshold extra extend to be added to the BoundingBox in all direction\r\n     * @returns if the box was hit\r\n     */\r\n    public intersectsBox(box: DeepImmutable<BoundingBox>, intersectionTreshold: number = 0): boolean {\r\n        return this.intersectsBoxMinMax(box.minimum, box.maximum, intersectionTreshold);\r\n    }\r\n\r\n    /**\r\n     * If the ray hits a sphere\r\n     * @param sphere the bounding sphere to check\r\n     * @param intersectionTreshold extra extend to be added to the BoundingSphere in all direction\r\n     * @returns true if it hits the sphere\r\n     */\r\n    public intersectsSphere(sphere: DeepImmutable<BoundingSphere>, intersectionTreshold: number = 0): boolean {\r\n        const x = sphere.center.x - this.origin.x;\r\n        const y = sphere.center.y - this.origin.y;\r\n        const z = sphere.center.z - this.origin.z;\r\n        const pyth = x * x + y * y + z * z;\r\n        const radius = sphere.radius + intersectionTreshold;\r\n        const rr = radius * radius;\r\n\r\n        if (pyth <= rr) {\r\n            return true;\r\n        }\r\n\r\n        const dot = x * this.direction.x + y * this.direction.y + z * this.direction.z;\r\n        if (dot < 0.0) {\r\n            return false;\r\n        }\r\n\r\n        const temp = pyth - dot * dot;\r\n\r\n        return temp <= rr;\r\n    }\r\n\r\n    /**\r\n     * If the ray hits a triange\r\n     * @param vertex0 triangle vertex\r\n     * @param vertex1 triangle vertex\r\n     * @param vertex2 triangle vertex\r\n     * @returns intersection information if hit\r\n     */\r\n    public intersectsTriangle(vertex0: DeepImmutable<Vector3>, vertex1: DeepImmutable<Vector3>, vertex2: DeepImmutable<Vector3>): Nullable<IntersectionInfo> {\r\n        const edge1 = Ray._TmpVector3[0];\r\n        const edge2 = Ray._TmpVector3[1];\r\n        const pvec = Ray._TmpVector3[2];\r\n        const tvec = Ray._TmpVector3[3];\r\n        const qvec = Ray._TmpVector3[4];\r\n\r\n        vertex1.subtractToRef(vertex0, edge1);\r\n        vertex2.subtractToRef(vertex0, edge2);\r\n        Vector3.CrossToRef(this.direction, edge2, pvec);\r\n        const det = Vector3.Dot(edge1, pvec);\r\n\r\n        if (det === 0) {\r\n            return null;\r\n        }\r\n\r\n        const invdet = 1 / det;\r\n\r\n        this.origin.subtractToRef(vertex0, tvec);\r\n\r\n        const bv = Vector3.Dot(tvec, pvec) * invdet;\r\n\r\n        if (bv < -this.epsilon || bv > 1.0 + this.epsilon) {\r\n            return null;\r\n        }\r\n\r\n        Vector3.CrossToRef(tvec, edge1, qvec);\r\n\r\n        const bw = Vector3.Dot(this.direction, qvec) * invdet;\r\n\r\n        if (bw < -this.epsilon || bv + bw > 1.0 + this.epsilon) {\r\n            return null;\r\n        }\r\n\r\n        //check if the distance is longer than the predefined length.\r\n        const distance = Vector3.Dot(edge2, qvec) * invdet;\r\n        if (distance > this.length) {\r\n            return null;\r\n        }\r\n\r\n        return new IntersectionInfo(1 - bv - bw, bv, distance);\r\n    }\r\n\r\n    /**\r\n     * Checks if ray intersects a plane\r\n     * @param plane the plane to check\r\n     * @returns the distance away it was hit\r\n     */\r\n    public intersectsPlane(plane: DeepImmutable<Plane>): Nullable<number> {\r\n        let distance: number;\r\n        const result1 = Vector3.Dot(plane.normal, this.direction);\r\n        if (Math.abs(result1) < 9.99999997475243e-7) {\r\n            return null;\r\n        } else {\r\n            const result2 = Vector3.Dot(plane.normal, this.origin);\r\n            distance = (-plane.d - result2) / result1;\r\n            if (distance < 0.0) {\r\n                if (distance < -9.99999997475243e-7) {\r\n                    return null;\r\n                } else {\r\n                    return 0;\r\n                }\r\n            }\r\n\r\n            return distance;\r\n        }\r\n    }\r\n    /**\r\n     * Calculate the intercept of a ray on a given axis\r\n     * @param axis to check 'x' | 'y' | 'z'\r\n     * @param offset from axis interception (i.e. an offset of 1y is intercepted above ground)\r\n     * @returns a vector containing the coordinates where 'axis' is equal to zero (else offset), or null if there is no intercept.\r\n     */\r\n    public intersectsAxis(axis: string, offset: number = 0): Nullable<Vector3> {\r\n        switch (axis) {\r\n            case \"y\": {\r\n                const t = (this.origin.y - offset) / this.direction.y;\r\n                if (t > 0) {\r\n                    return null;\r\n                }\r\n                return new Vector3(this.origin.x + this.direction.x * -t, offset, this.origin.z + this.direction.z * -t);\r\n            }\r\n            case \"x\": {\r\n                const t = (this.origin.x - offset) / this.direction.x;\r\n                if (t > 0) {\r\n                    return null;\r\n                }\r\n                return new Vector3(offset, this.origin.y + this.direction.y * -t, this.origin.z + this.direction.z * -t);\r\n            }\r\n            case \"z\": {\r\n                const t = (this.origin.z - offset) / this.direction.z;\r\n                if (t > 0) {\r\n                    return null;\r\n                }\r\n                return new Vector3(this.origin.x + this.direction.x * -t, this.origin.y + this.direction.y * -t, offset);\r\n            }\r\n            default:\r\n                return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Checks if ray intersects a mesh. The ray is defined in WORLD space. A mesh triangle can be picked both from its front and back sides,\r\n     * irrespective of orientation.\r\n     * @param mesh the mesh to check\r\n     * @param fastCheck defines if the first intersection will be used (and not the closest)\r\n     * @param trianglePredicate defines an optional predicate used to select faces when a mesh intersection is detected\r\n     * @param onlyBoundingInfo defines a boolean indicating if picking should only happen using bounding info (false by default)\r\n     * @param worldToUse defines the world matrix to use to get the world coordinate of the intersection point\r\n     * @param skipBoundingInfo a boolean indicating if we should skip the bounding info check\r\n     * @returns picking info of the intersection\r\n     */\r\n    public intersectsMesh(\r\n        mesh: DeepImmutable<AbstractMesh>,\r\n        fastCheck?: boolean,\r\n        trianglePredicate?: TrianglePickingPredicate,\r\n        onlyBoundingInfo = false,\r\n        worldToUse?: Matrix,\r\n        skipBoundingInfo = false\r\n    ): PickingInfo {\r\n        const tm = TmpVectors.Matrix[0];\r\n\r\n        mesh.getWorldMatrix().invertToRef(tm);\r\n\r\n        if (this._tmpRay) {\r\n            Ray.TransformToRef(this, tm, this._tmpRay);\r\n        } else {\r\n            this._tmpRay = Ray.Transform(this, tm);\r\n        }\r\n\r\n        return mesh.intersects(this._tmpRay, fastCheck, trianglePredicate, onlyBoundingInfo, worldToUse, skipBoundingInfo);\r\n    }\r\n\r\n    /**\r\n     * Checks if ray intersects a mesh\r\n     * @param meshes the meshes to check\r\n     * @param fastCheck defines if the first intersection will be used (and not the closest)\r\n     * @param results array to store result in\r\n     * @returns Array of picking infos\r\n     */\r\n    public intersectsMeshes(meshes: Array<DeepImmutable<AbstractMesh>>, fastCheck?: boolean, results?: Array<PickingInfo>): Array<PickingInfo> {\r\n        if (results) {\r\n            results.length = 0;\r\n        } else {\r\n            results = [];\r\n        }\r\n\r\n        for (let i = 0; i < meshes.length; i++) {\r\n            const pickInfo = this.intersectsMesh(meshes[i], fastCheck);\r\n\r\n            if (pickInfo.hit) {\r\n                results.push(pickInfo);\r\n            }\r\n        }\r\n\r\n        results.sort(this._comparePickingInfo);\r\n\r\n        return results;\r\n    }\r\n\r\n    private _comparePickingInfo(pickingInfoA: DeepImmutable<PickingInfo>, pickingInfoB: DeepImmutable<PickingInfo>): number {\r\n        if (pickingInfoA.distance < pickingInfoB.distance) {\r\n            return -1;\r\n        } else if (pickingInfoA.distance > pickingInfoB.distance) {\r\n            return 1;\r\n        } else {\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    private static _Smallnum = 0.00000001;\r\n    private static _Rayl = 10e8;\r\n\r\n    /**\r\n     * Intersection test between the ray and a given segment within a given tolerance (threshold)\r\n     * @param sega the first point of the segment to test the intersection against\r\n     * @param segb the second point of the segment to test the intersection against\r\n     * @param threshold the tolerance margin, if the ray doesn't intersect the segment but is close to the given threshold, the intersection is successful\r\n     * @returns the distance from the ray origin to the intersection point if there's intersection, or -1 if there's no intersection\r\n     */\r\n    intersectionSegment(sega: DeepImmutable<Vector3>, segb: DeepImmutable<Vector3>, threshold: number): number {\r\n        const o = this.origin;\r\n        const u = TmpVectors.Vector3[0];\r\n        const rsegb = TmpVectors.Vector3[1];\r\n        const v = TmpVectors.Vector3[2];\r\n        const w = TmpVectors.Vector3[3];\r\n\r\n        segb.subtractToRef(sega, u);\r\n\r\n        this.direction.scaleToRef(Ray._Rayl, v);\r\n        o.addToRef(v, rsegb);\r\n\r\n        sega.subtractToRef(o, w);\r\n\r\n        const a = Vector3.Dot(u, u); // always >= 0\r\n        const b = Vector3.Dot(u, v);\r\n        const c = Vector3.Dot(v, v); // always >= 0\r\n        const d = Vector3.Dot(u, w);\r\n        const e = Vector3.Dot(v, w);\r\n        const D = a * c - b * b; // always >= 0\r\n        let sN: number,\r\n            sD = D; // sc = sN / sD, default sD = D >= 0\r\n        let tN: number,\r\n            tD = D; // tc = tN / tD, default tD = D >= 0\r\n\r\n        // compute the line parameters of the two closest points\r\n        if (D < Ray._Smallnum) {\r\n            // the lines are almost parallel\r\n            sN = 0.0; // force using point P0 on segment S1\r\n            sD = 1.0; // to prevent possible division by 0.0 later\r\n            tN = e;\r\n            tD = c;\r\n        } else {\r\n            // get the closest points on the infinite lines\r\n            sN = b * e - c * d;\r\n            tN = a * e - b * d;\r\n            if (sN < 0.0) {\r\n                // sc < 0 => the s=0 edge is visible\r\n                sN = 0.0;\r\n                tN = e;\r\n                tD = c;\r\n            } else if (sN > sD) {\r\n                // sc > 1 => the s=1 edge is visible\r\n                sN = sD;\r\n                tN = e + b;\r\n                tD = c;\r\n            }\r\n        }\r\n\r\n        if (tN < 0.0) {\r\n            // tc < 0 => the t=0 edge is visible\r\n            tN = 0.0;\r\n            // recompute sc for this edge\r\n            if (-d < 0.0) {\r\n                sN = 0.0;\r\n            } else if (-d > a) {\r\n                sN = sD;\r\n            } else {\r\n                sN = -d;\r\n                sD = a;\r\n            }\r\n        } else if (tN > tD) {\r\n            // tc > 1 => the t=1 edge is visible\r\n            tN = tD;\r\n            // recompute sc for this edge\r\n            if (-d + b < 0.0) {\r\n                sN = 0;\r\n            } else if (-d + b > a) {\r\n                sN = sD;\r\n            } else {\r\n                sN = -d + b;\r\n                sD = a;\r\n            }\r\n        }\r\n        // finally do the division to get sc and tc\r\n        const sc = Math.abs(sN) < Ray._Smallnum ? 0.0 : sN / sD;\r\n        const tc = Math.abs(tN) < Ray._Smallnum ? 0.0 : tN / tD;\r\n\r\n        // get the difference of the two closest points\r\n        const qtc = TmpVectors.Vector3[4];\r\n        v.scaleToRef(tc, qtc);\r\n        const qsc = TmpVectors.Vector3[5];\r\n        u.scaleToRef(sc, qsc);\r\n        qsc.addInPlace(w);\r\n        const dP = TmpVectors.Vector3[6];\r\n        qsc.subtractToRef(qtc, dP); // = S1(sc) - S2(tc)\r\n\r\n        const isIntersected = tc > 0 && tc <= this.length && dP.lengthSquared() < threshold * threshold; // return intersection result\r\n\r\n        if (isIntersected) {\r\n            return qsc.length();\r\n        }\r\n        return -1;\r\n    }\r\n\r\n    /**\r\n     * Update the ray from viewport position\r\n     * @param x position\r\n     * @param y y position\r\n     * @param viewportWidth viewport width\r\n     * @param viewportHeight viewport height\r\n     * @param world world matrix\r\n     * @param view view matrix\r\n     * @param projection projection matrix\r\n     * @param enableDistantPicking defines if picking should handle large values for mesh position/scaling (false by default)\r\n     * @returns this ray updated\r\n     */\r\n    public update(\r\n        x: number,\r\n        y: number,\r\n        viewportWidth: number,\r\n        viewportHeight: number,\r\n        world: DeepImmutable<Matrix>,\r\n        view: DeepImmutable<Matrix>,\r\n        projection: DeepImmutable<Matrix>,\r\n        enableDistantPicking: boolean = false\r\n    ): Ray {\r\n        if (enableDistantPicking) {\r\n            // With world matrices having great values (like 8000000000 on 1 or more scaling or position axis),\r\n            // multiplying view/projection/world and doing invert will result in loss of float precision in the matrix.\r\n            // One way to fix it is to compute the ray with world at identity then transform the ray in object space.\r\n            // This is slower (2 matrix inverts instead of 1) but precision is preserved.\r\n            // This is hidden behind `EnableDistantPicking` flag (default is false)\r\n            if (!Ray._RayDistant) {\r\n                Ray._RayDistant = Ray.Zero();\r\n            }\r\n\r\n            Ray._RayDistant.unprojectRayToRef(x, y, viewportWidth, viewportHeight, Matrix.IdentityReadOnly, view, projection);\r\n\r\n            const tm = TmpVectors.Matrix[0];\r\n            world.invertToRef(tm);\r\n            Ray.TransformToRef(Ray._RayDistant, tm, this);\r\n        } else {\r\n            this.unprojectRayToRef(x, y, viewportWidth, viewportHeight, world, view, projection);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    // Statics\r\n    /**\r\n     * Creates a ray with origin and direction of 0,0,0\r\n     * @returns the new ray\r\n     */\r\n    public static Zero(): Ray {\r\n        return new Ray(Vector3.Zero(), Vector3.Zero());\r\n    }\r\n\r\n    /**\r\n     * Creates a new ray from screen space and viewport\r\n     * @param x position\r\n     * @param y y position\r\n     * @param viewportWidth viewport width\r\n     * @param viewportHeight viewport height\r\n     * @param world world matrix\r\n     * @param view view matrix\r\n     * @param projection projection matrix\r\n     * @returns new ray\r\n     */\r\n    public static CreateNew(\r\n        x: number,\r\n        y: number,\r\n        viewportWidth: number,\r\n        viewportHeight: number,\r\n        world: DeepImmutable<Matrix>,\r\n        view: DeepImmutable<Matrix>,\r\n        projection: DeepImmutable<Matrix>\r\n    ): Ray {\r\n        const result = Ray.Zero();\r\n\r\n        return result.update(x, y, viewportWidth, viewportHeight, world, view, projection);\r\n    }\r\n\r\n    /**\r\n     * Function will create a new transformed ray starting from origin and ending at the end point. Ray's length will be set, and ray will be\r\n     * transformed to the given world matrix.\r\n     * @param origin The origin point\r\n     * @param end The end point\r\n     * @param world a matrix to transform the ray to. Default is the identity matrix.\r\n     * @returns the new ray\r\n     */\r\n    public static CreateNewFromTo(origin: Vector3, end: Vector3, world: DeepImmutable<Matrix> = Matrix.IdentityReadOnly): Ray {\r\n        const result = new Ray(new Vector3(0, 0, 0), new Vector3(0, 0, 0));\r\n        return Ray.CreateFromToToRef(origin, end, result, world);\r\n    }\r\n\r\n    /**\r\n     * Function will update a transformed ray starting from origin and ending at the end point. Ray's length will be set, and ray will be\r\n     * transformed to the given world matrix.\r\n     * @param origin The origin point\r\n     * @param end The end point\r\n     * @param result the object to store the result\r\n     * @param world a matrix to transform the ray to. Default is the identity matrix.\r\n     * @returns the ref ray\r\n     */\r\n    public static CreateFromToToRef(origin: Vector3, end: Vector3, result: Ray, world: DeepImmutable<Matrix> = Matrix.IdentityReadOnly): Ray {\r\n        result.origin.copyFrom(origin);\r\n        const direction = end.subtractToRef(origin, result.direction);\r\n        const length = Math.sqrt(direction.x * direction.x + direction.y * direction.y + direction.z * direction.z);\r\n        result.length = length;\r\n        result.direction.normalize();\r\n\r\n        return Ray.TransformToRef(result, world, result);\r\n    }\r\n\r\n    /**\r\n     * Transforms a ray by a matrix\r\n     * @param ray ray to transform\r\n     * @param matrix matrix to apply\r\n     * @returns the resulting new ray\r\n     */\r\n    public static Transform(ray: DeepImmutable<Ray>, matrix: DeepImmutable<Matrix>): Ray {\r\n        const result = new Ray(new Vector3(0, 0, 0), new Vector3(0, 0, 0));\r\n        Ray.TransformToRef(ray, matrix, result);\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Transforms a ray by a matrix\r\n     * @param ray ray to transform\r\n     * @param matrix matrix to apply\r\n     * @param result ray to store result in\r\n     * @returns the updated result ray\r\n     */\r\n    public static TransformToRef(ray: DeepImmutable<Ray>, matrix: DeepImmutable<Matrix>, result: Ray): Ray {\r\n        Vector3.TransformCoordinatesToRef(ray.origin, matrix, result.origin);\r\n        Vector3.TransformNormalToRef(ray.direction, matrix, result.direction);\r\n        result.length = ray.length;\r\n        result.epsilon = ray.epsilon;\r\n\r\n        const dir = result.direction;\r\n        const len = dir.length();\r\n\r\n        if (!(len === 0 || len === 1)) {\r\n            const num = 1.0 / len;\r\n            dir.x *= num;\r\n            dir.y *= num;\r\n            dir.z *= num;\r\n            result.length *= len;\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Unproject a ray from screen space to object space\r\n     * @param sourceX defines the screen space x coordinate to use\r\n     * @param sourceY defines the screen space y coordinate to use\r\n     * @param viewportWidth defines the current width of the viewport\r\n     * @param viewportHeight defines the current height of the viewport\r\n     * @param world defines the world matrix to use (can be set to Identity to go to world space)\r\n     * @param view defines the view matrix to use\r\n     * @param projection defines the projection matrix to use\r\n     */\r\n    public unprojectRayToRef(\r\n        sourceX: float,\r\n        sourceY: float,\r\n        viewportWidth: number,\r\n        viewportHeight: number,\r\n        world: DeepImmutable<Matrix>,\r\n        view: DeepImmutable<Matrix>,\r\n        projection: DeepImmutable<Matrix>\r\n    ): void {\r\n        const matrix = TmpVectors.Matrix[0];\r\n        world.multiplyToRef(view, matrix);\r\n        matrix.multiplyToRef(projection, matrix);\r\n        matrix.invert();\r\n\r\n        const engine = EngineStore.LastCreatedEngine;\r\n        const nearScreenSource = TmpVectors.Vector3[0];\r\n        nearScreenSource.x = (sourceX / viewportWidth) * 2 - 1;\r\n        nearScreenSource.y = -((sourceY / viewportHeight) * 2 - 1);\r\n        nearScreenSource.z = engine?.useReverseDepthBuffer ? 1 : engine?.isNDCHalfZRange ? 0 : -1;\r\n\r\n        // far Z need to be close but < to 1 or camera projection matrix with maxZ = 0 will NaN\r\n        const farScreenSource = TmpVectors.Vector3[1].copyFromFloats(nearScreenSource.x, nearScreenSource.y, 1.0 - 1e-8);\r\n        const nearVec3 = TmpVectors.Vector3[2];\r\n        const farVec3 = TmpVectors.Vector3[3];\r\n        Vector3._UnprojectFromInvertedMatrixToRef(nearScreenSource, matrix, nearVec3);\r\n        Vector3._UnprojectFromInvertedMatrixToRef(farScreenSource, matrix, farVec3);\r\n\r\n        this.origin.copyFrom(nearVec3);\r\n        farVec3.subtractToRef(nearVec3, this.direction);\r\n        this.direction.normalize();\r\n    }\r\n}\r\n\r\n// Picking\r\n/**\r\n * Type used to define predicate used to select faces when a mesh intersection is detected\r\n */\r\nexport type TrianglePickingPredicate = (p0: Vector3, p1: Vector3, p2: Vector3, ray: Ray, i0: number, i1: number, i2: number) => boolean;\r\n\r\ndeclare module \"../scene\" {\r\n    export interface Scene {\r\n        /** @internal */\r\n        _tempPickingRay: Nullable<Ray>;\r\n\r\n        /** @internal */\r\n        _cachedRayForTransform: Ray;\r\n\r\n        /** @internal */\r\n        _pickWithRayInverseMatrix: Matrix;\r\n\r\n        /** @internal */\r\n        _internalPick(\r\n            rayFunction: (world: Matrix, enableDistantPicking: boolean) => Ray,\r\n            predicate?: (mesh: AbstractMesh) => boolean,\r\n            fastCheck?: boolean,\r\n            onlyBoundingInfo?: boolean,\r\n            trianglePredicate?: TrianglePickingPredicate\r\n        ): PickingInfo;\r\n\r\n        /** @internal */\r\n        _internalMultiPick(\r\n            rayFunction: (world: Matrix, enableDistantPicking: boolean) => Ray,\r\n            predicate?: (mesh: AbstractMesh) => boolean,\r\n            trianglePredicate?: TrianglePickingPredicate\r\n        ): Nullable<PickingInfo[]>;\r\n\r\n        /** @internal */\r\n        _internalPickForMesh(\r\n            pickingInfo: Nullable<PickingInfo>,\r\n            rayFunction: (world: Matrix, enableDistantPicking: boolean) => Ray,\r\n            mesh: AbstractMesh,\r\n            world: Matrix,\r\n            fastCheck?: boolean,\r\n            onlyBoundingInfo?: boolean,\r\n            trianglePredicate?: TrianglePickingPredicate,\r\n            skipBoundingInfo?: boolean\r\n        ): Nullable<PickingInfo>;\r\n    }\r\n}\r\n\r\nScene.prototype.createPickingRay = function (x: number, y: number, world: Nullable<Matrix>, camera: Nullable<Camera>, cameraViewSpace = false): Ray {\r\n    const result = Ray.Zero();\r\n\r\n    this.createPickingRayToRef(x, y, world, result, camera, cameraViewSpace);\r\n\r\n    return result;\r\n};\r\n\r\nScene.prototype.createPickingRayToRef = function (\r\n    x: number,\r\n    y: number,\r\n    world: Nullable<Matrix>,\r\n    result: Ray,\r\n    camera: Nullable<Camera>,\r\n    cameraViewSpace = false,\r\n    enableDistantPicking = false\r\n): Scene {\r\n    const engine = this.getEngine();\r\n\r\n    if (!camera && !(camera = this.activeCamera!)) {\r\n        return this;\r\n    }\r\n\r\n    const cameraViewport = camera.viewport;\r\n    const renderHeight = engine.getRenderHeight();\r\n    const { x: vx, y: vy, width, height } = cameraViewport.toGlobal(engine.getRenderWidth(), renderHeight);\r\n\r\n    // Moving coordinates to local viewport world\r\n    const levelInv = 1 / engine.getHardwareScalingLevel();\r\n    x = x * levelInv - vx;\r\n    y = y * levelInv - (renderHeight - vy - height);\r\n\r\n    result.update(\r\n        x,\r\n        y,\r\n        width,\r\n        height,\r\n        world ? world : Matrix.IdentityReadOnly,\r\n        cameraViewSpace ? Matrix.IdentityReadOnly : camera.getViewMatrix(),\r\n        camera.getProjectionMatrix(),\r\n        enableDistantPicking\r\n    );\r\n    return this;\r\n};\r\n\r\nScene.prototype.createPickingRayInCameraSpace = function (x: number, y: number, camera?: Camera): Ray {\r\n    const result = Ray.Zero();\r\n\r\n    this.createPickingRayInCameraSpaceToRef(x, y, result, camera);\r\n\r\n    return result;\r\n};\r\n\r\nScene.prototype.createPickingRayInCameraSpaceToRef = function (x: number, y: number, result: Ray, camera?: Camera): Scene {\r\n    if (!PickingInfo) {\r\n        return this;\r\n    }\r\n\r\n    const engine = this.getEngine();\r\n\r\n    if (!camera && !(camera = this.activeCamera!)) {\r\n        throw new Error(\"Active camera not set\");\r\n    }\r\n\r\n    const cameraViewport = camera.viewport;\r\n    const renderHeight = engine.getRenderHeight();\r\n    const { x: vx, y: vy, width, height } = cameraViewport.toGlobal(engine.getRenderWidth(), renderHeight);\r\n    const identity = Matrix.Identity();\r\n\r\n    // Moving coordinates to local viewport world\r\n    const levelInv = 1 / engine.getHardwareScalingLevel();\r\n    x = x * levelInv - vx;\r\n    y = y * levelInv - (renderHeight - vy - height);\r\n    result.update(x, y, width, height, identity, identity, camera.getProjectionMatrix());\r\n    return this;\r\n};\r\n\r\nScene.prototype._internalPickForMesh = function (\r\n    pickingInfo: Nullable<PickingInfo>,\r\n    rayFunction: (world: Matrix, enableDistantPicking: boolean) => Ray,\r\n    mesh: AbstractMesh,\r\n    world: Matrix,\r\n    fastCheck?: boolean,\r\n    onlyBoundingInfo?: boolean,\r\n    trianglePredicate?: TrianglePickingPredicate,\r\n    skipBoundingInfo?: boolean\r\n) {\r\n    const ray = rayFunction(world, mesh.enableDistantPicking);\r\n\r\n    const result = mesh.intersects(ray, fastCheck, trianglePredicate, onlyBoundingInfo, world, skipBoundingInfo);\r\n    if (!result || !result.hit) {\r\n        return null;\r\n    }\r\n\r\n    if (!fastCheck && pickingInfo != null && result.distance >= pickingInfo.distance) {\r\n        return null;\r\n    }\r\n\r\n    return result;\r\n};\r\n\r\nScene.prototype._internalPick = function (\r\n    rayFunction: (world: Matrix, enableDistantPicking: boolean) => Ray,\r\n    predicate?: (mesh: AbstractMesh) => boolean,\r\n    fastCheck?: boolean,\r\n    onlyBoundingInfo?: boolean,\r\n    trianglePredicate?: TrianglePickingPredicate\r\n): PickingInfo {\r\n    let pickingInfo = null;\r\n\r\n    const computeWorldMatrixForCamera = !!(this.activeCameras && this.activeCameras.length > 1 && this.cameraToUseForPointers !== this.activeCamera);\r\n    const currentCamera = this.cameraToUseForPointers || this.activeCamera;\r\n\r\n    for (let meshIndex = 0; meshIndex < this.meshes.length; meshIndex++) {\r\n        const mesh = this.meshes[meshIndex];\r\n\r\n        if (predicate) {\r\n            if (!predicate(mesh)) {\r\n                continue;\r\n            }\r\n        } else if (!mesh.isEnabled() || !mesh.isVisible || !mesh.isPickable) {\r\n            continue;\r\n        }\r\n\r\n        const forceCompute = computeWorldMatrixForCamera && mesh.isWorldMatrixCameraDependent();\r\n        const world = mesh.computeWorldMatrix(forceCompute, currentCamera);\r\n\r\n        if (mesh.hasThinInstances && (mesh as Mesh).thinInstanceEnablePicking) {\r\n            // first check if the ray intersects the whole bounding box/sphere of the mesh\r\n            const result = this._internalPickForMesh(pickingInfo, rayFunction, mesh, world, true, true, trianglePredicate);\r\n            if (result) {\r\n                if (onlyBoundingInfo) {\r\n                    // the user only asked for a bounding info check so we can return\r\n                    return result;\r\n                }\r\n                const tmpMatrix = TmpVectors.Matrix[1];\r\n                const thinMatrices = (mesh as Mesh).thinInstanceGetWorldMatrices();\r\n                for (let index = 0; index < thinMatrices.length; index++) {\r\n                    const thinMatrix = thinMatrices[index];\r\n                    thinMatrix.multiplyToRef(world, tmpMatrix);\r\n                    const result = this._internalPickForMesh(pickingInfo, rayFunction, mesh, tmpMatrix, fastCheck, onlyBoundingInfo, trianglePredicate, true);\r\n\r\n                    if (result) {\r\n                        pickingInfo = result;\r\n                        pickingInfo.thinInstanceIndex = index;\r\n\r\n                        if (fastCheck) {\r\n                            return pickingInfo;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            const result = this._internalPickForMesh(pickingInfo, rayFunction, mesh, world, fastCheck, onlyBoundingInfo, trianglePredicate);\r\n\r\n            if (result) {\r\n                pickingInfo = result;\r\n\r\n                if (fastCheck) {\r\n                    return pickingInfo;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    return pickingInfo || new PickingInfo();\r\n};\r\n\r\nScene.prototype._internalMultiPick = function (\r\n    rayFunction: (world: Matrix, enableDistantPicking: boolean) => Ray,\r\n    predicate?: (mesh: AbstractMesh) => boolean,\r\n    trianglePredicate?: TrianglePickingPredicate\r\n): Nullable<PickingInfo[]> {\r\n    if (!PickingInfo) {\r\n        return null;\r\n    }\r\n    const pickingInfos: PickingInfo[] = [];\r\n    const computeWorldMatrixForCamera = !!(this.activeCameras && this.activeCameras.length > 1 && this.cameraToUseForPointers !== this.activeCamera);\r\n    const currentCamera = this.cameraToUseForPointers || this.activeCamera;\r\n\r\n    for (let meshIndex = 0; meshIndex < this.meshes.length; meshIndex++) {\r\n        const mesh = this.meshes[meshIndex];\r\n\r\n        if (predicate) {\r\n            if (!predicate(mesh)) {\r\n                continue;\r\n            }\r\n        } else if (!mesh.isEnabled() || !mesh.isVisible || !mesh.isPickable) {\r\n            continue;\r\n        }\r\n\r\n        const forceCompute = computeWorldMatrixForCamera && mesh.isWorldMatrixCameraDependent();\r\n        const world = mesh.computeWorldMatrix(forceCompute, currentCamera);\r\n\r\n        if (mesh.hasThinInstances && (mesh as Mesh).thinInstanceEnablePicking) {\r\n            const result = this._internalPickForMesh(null, rayFunction, mesh, world, true, true, trianglePredicate);\r\n            if (result) {\r\n                const tmpMatrix = TmpVectors.Matrix[1];\r\n                const thinMatrices = (mesh as Mesh).thinInstanceGetWorldMatrices();\r\n                for (let index = 0; index < thinMatrices.length; index++) {\r\n                    const thinMatrix = thinMatrices[index];\r\n                    thinMatrix.multiplyToRef(world, tmpMatrix);\r\n                    const result = this._internalPickForMesh(null, rayFunction, mesh, tmpMatrix, false, false, trianglePredicate, true);\r\n\r\n                    if (result) {\r\n                        result.thinInstanceIndex = index;\r\n                        pickingInfos.push(result);\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            const result = this._internalPickForMesh(null, rayFunction, mesh, world, false, false, trianglePredicate);\r\n\r\n            if (result) {\r\n                pickingInfos.push(result);\r\n            }\r\n        }\r\n    }\r\n\r\n    return pickingInfos;\r\n};\r\n\r\nScene.prototype.pickWithBoundingInfo = function (\r\n    x: number,\r\n    y: number,\r\n    predicate?: (mesh: AbstractMesh) => boolean,\r\n    fastCheck?: boolean,\r\n    camera?: Nullable<Camera>\r\n): Nullable<PickingInfo> {\r\n    if (!PickingInfo) {\r\n        return null;\r\n    }\r\n    const result = this._internalPick(\r\n        (world) => {\r\n            if (!this._tempPickingRay) {\r\n                this._tempPickingRay = Ray.Zero();\r\n            }\r\n\r\n            this.createPickingRayToRef(x, y, world, this._tempPickingRay, camera || null);\r\n            return this._tempPickingRay;\r\n        },\r\n        predicate,\r\n        fastCheck,\r\n        true\r\n    );\r\n    if (result) {\r\n        result.ray = this.createPickingRay(x, y, Matrix.Identity(), camera || null);\r\n    }\r\n    return result;\r\n};\r\n\r\nObject.defineProperty(Scene.prototype, \"_pickingAvailable\", {\r\n    get: () => true,\r\n    enumerable: false,\r\n    configurable: false,\r\n});\r\n\r\nScene.prototype.pick = function (\r\n    x: number,\r\n    y: number,\r\n    predicate?: (mesh: AbstractMesh) => boolean,\r\n    fastCheck?: boolean,\r\n    camera?: Nullable<Camera>,\r\n    trianglePredicate?: TrianglePickingPredicate,\r\n    _enableDistantPicking = false\r\n): PickingInfo {\r\n    const result = this._internalPick(\r\n        (world, enableDistantPicking) => {\r\n            if (!this._tempPickingRay) {\r\n                this._tempPickingRay = Ray.Zero();\r\n            }\r\n\r\n            this.createPickingRayToRef(x, y, world, this._tempPickingRay, camera || null, false, enableDistantPicking);\r\n            return this._tempPickingRay;\r\n        },\r\n        predicate,\r\n        fastCheck,\r\n        false,\r\n        trianglePredicate\r\n    );\r\n    if (result) {\r\n        result.ray = this.createPickingRay(x, y, Matrix.Identity(), camera || null);\r\n    }\r\n    return result;\r\n};\r\n\r\nScene.prototype.pickWithRay = function (\r\n    ray: Ray,\r\n    predicate?: (mesh: AbstractMesh) => boolean,\r\n    fastCheck?: boolean,\r\n    trianglePredicate?: TrianglePickingPredicate\r\n): Nullable<PickingInfo> {\r\n    const result = this._internalPick(\r\n        (world) => {\r\n            if (!this._pickWithRayInverseMatrix) {\r\n                this._pickWithRayInverseMatrix = Matrix.Identity();\r\n            }\r\n            world.invertToRef(this._pickWithRayInverseMatrix);\r\n\r\n            if (!this._cachedRayForTransform) {\r\n                this._cachedRayForTransform = Ray.Zero();\r\n            }\r\n\r\n            Ray.TransformToRef(ray, this._pickWithRayInverseMatrix, this._cachedRayForTransform);\r\n            return this._cachedRayForTransform;\r\n        },\r\n        predicate,\r\n        fastCheck,\r\n        false,\r\n        trianglePredicate\r\n    );\r\n    if (result) {\r\n        result.ray = ray;\r\n    }\r\n    return result;\r\n};\r\n\r\nScene.prototype.multiPick = function (\r\n    x: number,\r\n    y: number,\r\n    predicate?: (mesh: AbstractMesh) => boolean,\r\n    camera?: Camera,\r\n    trianglePredicate?: TrianglePickingPredicate\r\n): Nullable<PickingInfo[]> {\r\n    return this._internalMultiPick((world) => this.createPickingRay(x, y, world, camera || null), predicate, trianglePredicate);\r\n};\r\n\r\nScene.prototype.multiPickWithRay = function (ray: Ray, predicate?: (mesh: AbstractMesh) => boolean, trianglePredicate?: TrianglePickingPredicate): Nullable<PickingInfo[]> {\r\n    return this._internalMultiPick(\r\n        (world) => {\r\n            if (!this._pickWithRayInverseMatrix) {\r\n                this._pickWithRayInverseMatrix = Matrix.Identity();\r\n            }\r\n            world.invertToRef(this._pickWithRayInverseMatrix);\r\n\r\n            if (!this._cachedRayForTransform) {\r\n                this._cachedRayForTransform = Ray.Zero();\r\n            }\r\n\r\n            Ray.TransformToRef(ray, this._pickWithRayInverseMatrix, this._cachedRayForTransform);\r\n            return this._cachedRayForTransform;\r\n        },\r\n        predicate,\r\n        trianglePredicate\r\n    );\r\n};\r\n\r\nCamera.prototype.getForwardRay = function (length = 100, transform?: Matrix, origin?: Vector3): Ray {\r\n    return this.getForwardRayToRef(new Ray(Vector3.Zero(), Vector3.Zero(), length), length, transform, origin);\r\n};\r\n\r\nCamera.prototype.getForwardRayToRef = function (refRay: Ray, length = 100, transform?: Matrix, origin?: Vector3): Ray {\r\n    if (!transform) {\r\n        transform = this.getWorldMatrix();\r\n    }\r\n    refRay.length = length;\r\n\r\n    if (origin) {\r\n        refRay.origin.copyFrom(origin);\r\n    } else {\r\n        refRay.origin.copyFrom(this.position);\r\n    }\r\n    const forward = TmpVectors.Vector3[2];\r\n    forward.set(0, 0, this._scene.useRightHandedSystem ? -1 : 1);\r\n    const worldForward = TmpVectors.Vector3[3];\r\n    Vector3.TransformNormalToRef(forward, transform, worldForward);\r\n    Vector3.NormalizeToRef(worldForward, refRay.direction);\r\n\r\n    return refRay;\r\n};\r\n", "import type { ISmartArrayLike } from \"../../Misc/smartArray\";\r\nimport { Scene } from \"../../scene\";\r\nimport { Vector3 } from \"../../Maths/math.vector\";\r\nimport type { SubMesh } from \"../../Meshes/subMesh\";\r\nimport { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport { Ray } from \"../../Culling/ray\";\r\nimport { SceneComponentConstants } from \"../../sceneComponent\";\r\n\r\nimport { Octree } from \"./octree\";\r\nimport { EngineStore } from \"../../Engines/engineStore\";\r\n\r\nimport type { Collider } from \"../../Collisions/collider\";\r\n\r\ndeclare module \"../../scene\" {\r\n    export interface Scene {\r\n        /**\r\n         * @internal\r\n         * Backing Filed\r\n         */\r\n        _selectionOctree: Octree<AbstractMesh>;\r\n\r\n        /**\r\n         * Gets the octree used to boost mesh selection (picking)\r\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/optimizeOctrees\r\n         */\r\n        selectionOctree: Octree<AbstractMesh>;\r\n\r\n        /**\r\n         * Creates or updates the octree used to boost selection (picking)\r\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/optimizeOctrees\r\n         * @param maxCapacity defines the maximum capacity per leaf\r\n         * @param maxDepth defines the maximum depth of the octree\r\n         * @returns an octree of AbstractMesh\r\n         */\r\n        createOrUpdateSelectionOctree(maxCapacity?: number, maxDepth?: number): Octree<AbstractMesh>;\r\n    }\r\n}\r\n\r\nScene.prototype.createOrUpdateSelectionOctree = function (maxCapacity = 64, maxDepth = 2): Octree<AbstractMesh> {\r\n    let component = this._getComponent(SceneComponentConstants.NAME_OCTREE);\r\n    if (!component) {\r\n        component = new OctreeSceneComponent(this);\r\n        this._addComponent(component);\r\n    }\r\n\r\n    if (!this._selectionOctree) {\r\n        this._selectionOctree = new Octree<AbstractMesh>(Octree.CreationFuncForMeshes, maxCapacity, maxDepth);\r\n    }\r\n\r\n    const worldExtends = this.getWorldExtends();\r\n\r\n    // Update octree\r\n    this._selectionOctree.update(worldExtends.min, worldExtends.max, this.meshes);\r\n\r\n    return this._selectionOctree;\r\n};\r\n\r\nObject.defineProperty(Scene.prototype, \"selectionOctree\", {\r\n    get: function (this: Scene) {\r\n        return this._selectionOctree;\r\n    },\r\n    enumerable: true,\r\n    configurable: true,\r\n});\r\n\r\ndeclare module \"../../Meshes/abstractMesh\" {\r\n    export interface AbstractMesh {\r\n        /**\r\n         * @internal\r\n         * Backing Field\r\n         */\r\n        _submeshesOctree: Octree<SubMesh>;\r\n\r\n        /**\r\n         * This function will create an octree to help to select the right submeshes for rendering, picking and collision computations.\r\n         * Please note that you must have a decent number of submeshes to get performance improvements when using an octree\r\n         * @param maxCapacity defines the maximum size of each block (64 by default)\r\n         * @param maxDepth defines the maximum depth to use (no more than 2 levels by default)\r\n         * @returns the new octree\r\n         * @see https://www.babylonjs-playground.com/#NA4OQ#12\r\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/optimizeOctrees\r\n         */\r\n        createOrUpdateSubmeshesOctree(maxCapacity?: number, maxDepth?: number): Octree<SubMesh>;\r\n    }\r\n}\r\n\r\n/**\r\n * This function will create an octree to help to select the right submeshes for rendering, picking and collision computations.\r\n * Please note that you must have a decent number of submeshes to get performance improvements when using an octree\r\n * @param maxCapacity defines the maximum size of each block (64 by default)\r\n * @param maxDepth defines the maximum depth to use (no more than 2 levels by default)\r\n * @returns the new octree\r\n * @see https://www.babylonjs-playground.com/#NA4OQ#12\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/optimizeOctrees\r\n */\r\nAbstractMesh.prototype.createOrUpdateSubmeshesOctree = function (maxCapacity = 64, maxDepth = 2): Octree<SubMesh> {\r\n    const scene = this.getScene();\r\n    let component = scene._getComponent(SceneComponentConstants.NAME_OCTREE);\r\n    if (!component) {\r\n        component = new OctreeSceneComponent(scene);\r\n        scene._addComponent(component);\r\n    }\r\n\r\n    if (!this._submeshesOctree) {\r\n        this._submeshesOctree = new Octree<SubMesh>(Octree.CreationFuncForSubMeshes, maxCapacity, maxDepth);\r\n    }\r\n\r\n    this.computeWorldMatrix(true);\r\n\r\n    const boundingInfo = this.getBoundingInfo();\r\n\r\n    // Update octree\r\n    const bbox = boundingInfo.boundingBox;\r\n    this._submeshesOctree.update(bbox.minimumWorld, bbox.maximumWorld, this.subMeshes);\r\n\r\n    return this._submeshesOctree;\r\n};\r\n\r\n/**\r\n * Defines the octree scene component responsible to manage any octrees\r\n * in a given scene.\r\n */\r\nexport class OctreeSceneComponent {\r\n    /**\r\n     * The component name help to identify the component in the list of scene components.\r\n     */\r\n    public readonly name = SceneComponentConstants.NAME_OCTREE;\r\n\r\n    /**\r\n     * The scene the component belongs to.\r\n     */\r\n    public scene: Scene;\r\n\r\n    /**\r\n     * Indicates if the meshes have been checked to make sure they are isEnabled()\r\n     */\r\n    public readonly checksIsEnabled = true;\r\n\r\n    /**\r\n     * Creates a new instance of the component for the given scene\r\n     * @param scene Defines the scene to register the component in\r\n     */\r\n    constructor(scene?: Scene) {\r\n        scene = scene || <Scene>EngineStore.LastCreatedScene;\r\n        if (!scene) {\r\n            return;\r\n        }\r\n        this.scene = scene;\r\n\r\n        this.scene.getActiveMeshCandidates = () => this.getActiveMeshCandidates();\r\n        this.scene.getActiveSubMeshCandidates = (mesh: AbstractMesh) => this.getActiveSubMeshCandidates(mesh);\r\n        this.scene.getCollidingSubMeshCandidates = (mesh: AbstractMesh, collider: Collider) => this.getCollidingSubMeshCandidates(mesh, collider);\r\n        this.scene.getIntersectingSubMeshCandidates = (mesh: AbstractMesh, localRay: Ray) => this.getIntersectingSubMeshCandidates(mesh, localRay);\r\n    }\r\n\r\n    /**\r\n     * Registers the component in a given scene\r\n     */\r\n    public register(): void {\r\n        this.scene.onMeshRemovedObservable.add((mesh: AbstractMesh) => {\r\n            const sceneOctree = this.scene.selectionOctree;\r\n            if (sceneOctree !== undefined && sceneOctree !== null) {\r\n                const index = sceneOctree.dynamicContent.indexOf(mesh);\r\n\r\n                if (index !== -1) {\r\n                    sceneOctree.dynamicContent.splice(index, 1);\r\n                }\r\n            }\r\n        });\r\n\r\n        this.scene.onMeshImportedObservable.add((mesh: AbstractMesh) => {\r\n            const sceneOctree = this.scene.selectionOctree;\r\n            if (sceneOctree !== undefined && sceneOctree !== null) {\r\n                sceneOctree.addMesh(mesh);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Return the list of active meshes\r\n     * @returns the list of active meshes\r\n     */\r\n    public getActiveMeshCandidates(): ISmartArrayLike<AbstractMesh> {\r\n        return this.scene._selectionOctree?.select(this.scene.frustumPlanes) || this.scene._getDefaultMeshCandidates();\r\n    }\r\n\r\n    /**\r\n     * Return the list of active sub meshes\r\n     * @param mesh The mesh to get the candidates sub meshes from\r\n     * @returns the list of active sub meshes\r\n     */\r\n    public getActiveSubMeshCandidates(mesh: AbstractMesh): ISmartArrayLike<SubMesh> {\r\n        if (mesh._submeshesOctree && mesh.useOctreeForRenderingSelection) {\r\n            const intersections = mesh._submeshesOctree.select(this.scene.frustumPlanes);\r\n            return intersections;\r\n        }\r\n        return this.scene._getDefaultSubMeshCandidates(mesh);\r\n    }\r\n\r\n    private _tempRay = new Ray(Vector3.Zero(), new Vector3(1, 1, 1));\r\n    /**\r\n     * Return the list of sub meshes intersecting with a given local ray\r\n     * @param mesh defines the mesh to find the submesh for\r\n     * @param localRay defines the ray in local space\r\n     * @returns the list of intersecting sub meshes\r\n     */\r\n    public getIntersectingSubMeshCandidates(mesh: AbstractMesh, localRay: Ray): ISmartArrayLike<SubMesh> {\r\n        if (mesh._submeshesOctree && mesh.useOctreeForPicking) {\r\n            Ray.TransformToRef(localRay, mesh.getWorldMatrix(), this._tempRay);\r\n            const intersections = mesh._submeshesOctree.intersectsRay(this._tempRay);\r\n\r\n            return intersections;\r\n        }\r\n        return this.scene._getDefaultSubMeshCandidates(mesh);\r\n    }\r\n\r\n    /**\r\n     * Return the list of sub meshes colliding with a collider\r\n     * @param mesh defines the mesh to find the submesh for\r\n     * @param collider defines the collider to evaluate the collision against\r\n     * @returns the list of colliding sub meshes\r\n     */\r\n    public getCollidingSubMeshCandidates(mesh: AbstractMesh, collider: Collider): ISmartArrayLike<SubMesh> {\r\n        if (mesh._submeshesOctree && mesh.useOctreeForCollisions) {\r\n            const radius = collider._velocityWorldLength + Math.max(collider._radius.x, collider._radius.y, collider._radius.z);\r\n            const intersections = mesh._submeshesOctree.intersects(collider._basePointWorld, radius);\r\n\r\n            return intersections;\r\n        }\r\n        return this.scene._getDefaultSubMeshCandidates(mesh);\r\n    }\r\n\r\n    /**\r\n     * Rebuilds the elements related to this component in case of\r\n     * context lost for instance.\r\n     */\r\n    public rebuild(): void {\r\n        // Nothing to do here.\r\n    }\r\n\r\n    /**\r\n     * Disposes the component and the associated resources.\r\n     */\r\n    public dispose(): void {\r\n        // Nothing to do here.\r\n    }\r\n}\r\n", "\nimport { Vector3 } from '@babylonjs/core/Maths/math.vector'\nimport { Octree } from '@babylonjs/core/Culling/Octrees/octree'\nimport { OctreeBlock } from '@babylonjs/core/Culling/Octrees/octreeBlock'\nimport { OctreeSceneComponent } from '@babylonjs/core/Culling/Octrees/octreeSceneComponent'\n\nimport { locationHasher, removeUnorderedListItem } from './util'\n\n\n/*\n * \n * \n * \n *          simple class to manage scene octree and octreeBlocks\n * \n * \n * \n*/\n\n/** @internal */\nexport class SceneOctreeManager {\n\n    /** @internal */\n    constructor(rendering, blockSize) {\n        var scene = rendering.scene\n        scene._addComponent(new OctreeSceneComponent(scene))\n\n        // mesh metadata flags\n        var octreeBlock = 'noa_octree_block'\n        var inDynamicList = 'noa_in_dynamic_list'\n        var inOctreeBlock = 'noa_in_octree_block'\n\n        // the root octree object\n        var octree = new Octree(NOP)\n        scene._selectionOctree = octree\n        octree.blocks = []\n        var octBlocksHash = {}\n\n\n        /*\n         * \n         *          public API\n         * \n        */\n\n        this.rebase = (offset) => { recurseRebaseBlocks(octree, offset) }\n\n        this.addMesh = (mesh, isStatic, pos, chunk) => {\n            if (!mesh.metadata) mesh.metadata = {}\n\n            // dynamic content is just rendered from a list on the octree\n            if (!isStatic) {\n                if (mesh.metadata[inDynamicList]) return\n                octree.dynamicContent.push(mesh)\n                mesh.metadata[inDynamicList] = true\n                return\n            }\n\n            // octreeBlock-space integer coords of mesh position, and hashed key\n            var ci = Math.floor(pos[0] / bs)\n            var cj = Math.floor(pos[1] / bs)\n            var ck = Math.floor(pos[2] / bs)\n            var mapKey = locationHasher(ci, cj, ck)\n\n            // get or create octreeBlock\n            var block = octBlocksHash[mapKey]\n            if (!block) {\n                // lower corner of new octree block position, in global/local\n                var gloc = [ci * bs, cj * bs, ck * bs]\n                var loc = [0, 0, 0]\n                rendering.noa.globalToLocal(gloc, null, loc)\n                // make the new octree block and store it\n                block = makeOctreeBlock(loc, bs)\n                octree.blocks.push(block)\n                octBlocksHash[mapKey] = block\n                block._noaMapKey = mapKey\n            }\n\n            // do the actual adding logic\n            block.entries.push(mesh)\n            mesh.metadata[octreeBlock] = block\n            mesh.metadata[inOctreeBlock] = true\n\n            // rely on octrees for selection, skipping bounds checks\n            mesh.alwaysSelectAsActiveMesh = true\n        }\n\n\n\n        this.removeMesh = (mesh) => {\n            if (!mesh.metadata) return\n\n            if (mesh.metadata[inDynamicList]) {\n                removeUnorderedListItem(octree.dynamicContent, mesh)\n                mesh.metadata[inDynamicList] = false\n            }\n            if (mesh.metadata[inOctreeBlock]) {\n                var block = mesh.metadata[octreeBlock]\n                if (block && block.entries) {\n                    removeUnorderedListItem(block.entries, mesh)\n                    if (block.entries.length === 0) {\n                        delete octBlocksHash[block._noaMapKey]\n                        removeUnorderedListItem(octree.blocks, block)\n                    }\n                }\n                mesh.metadata[octreeBlock] = null\n                mesh.metadata[inOctreeBlock] = false\n            }\n        }\n\n\n\n        // experimental helper\n        this.setMeshVisibility = (mesh, visible = false) => {\n            if (mesh.metadata[octreeBlock]) {\n                // mesh is static\n                if (mesh.metadata[inOctreeBlock] === visible) return\n                var block = mesh.metadata[octreeBlock]\n                if (block && block.entries) {\n                    if (visible) {\n                        block.entries.push(mesh)\n                    } else {\n                        removeUnorderedListItem(block.entries, mesh)\n                    }\n                }\n                mesh.metadata[inOctreeBlock] = visible\n            } else {\n                // mesh is dynamic\n                if (mesh.metadata[inDynamicList] === visible) return\n                if (visible) {\n                    octree.dynamicContent.push(mesh)\n                } else {\n                    removeUnorderedListItem(octree.dynamicContent, mesh)\n                }\n                mesh.metadata[inDynamicList] = visible\n            }\n        }\n\n        /*\n         * \n         *          internals\n         * \n        */\n\n        var NOP = () => { }\n        var bs = blockSize * rendering.noa.world._chunkSize\n\n        var recurseRebaseBlocks = (parent, offset) => {\n            parent.blocks.forEach(child => {\n                child.minPoint.subtractInPlace(offset)\n                child.maxPoint.subtractInPlace(offset)\n                child._boundingVectors.forEach(v => v.subtractInPlace(offset))\n                if (child.blocks) recurseRebaseBlocks(child, offset)\n            })\n        }\n\n        var makeOctreeBlock = (minPt, size) => {\n            var min = new Vector3(minPt[0], minPt[1], minPt[2])\n            var max = new Vector3(minPt[0] + size, minPt[1] + size, minPt[2] + size)\n            return new OctreeBlock(min, max, undefined, undefined, undefined, NOP)\n        }\n\n    }\n\n}\n", "import { serialize, serializeAsVector3, serializeAsMeshReference } from \"../Misc/decorators\";\r\nimport type { Nullable } from \"../types\";\r\nimport { Camera } from \"./camera\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Quaternion, Matrix, Vector3, Vector2, TmpVectors } from \"../Maths/math.vector\";\r\nimport { Epsilon } from \"../Maths/math.constants\";\r\nimport { Axis } from \"../Maths/math.axis\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { Node } from \"../node\";\r\n\r\nNode.AddNodeConstructor(\"TargetCamera\", (name, scene) => {\r\n    return () => new TargetCamera(name, Vector3.Zero(), scene);\r\n});\r\n\r\n/**\r\n * A target camera takes a mesh or position as a target and continues to look at it while it moves.\r\n * This is the base of the follow, arc rotate cameras and Free camera\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras\r\n */\r\nexport class TargetCamera extends Camera {\r\n    private static _RigCamTransformMatrix = new Matrix();\r\n    private static _TargetTransformMatrix = new Matrix();\r\n    private static _TargetFocalPoint = new Vector3();\r\n\r\n    private _tmpUpVector = Vector3.Zero();\r\n    private _tmpTargetVector = Vector3.Zero();\r\n\r\n    /**\r\n     * Define the current direction the camera is moving to\r\n     */\r\n    public cameraDirection = new Vector3(0, 0, 0);\r\n    /**\r\n     * Define the current rotation the camera is rotating to\r\n     */\r\n    public cameraRotation = new Vector2(0, 0);\r\n\r\n    /** Gets or sets a boolean indicating that the scaling of the parent hierarchy will not be taken in account by the camera */\r\n    public ignoreParentScaling = false;\r\n\r\n    /**\r\n     * When set, the up vector of the camera will be updated by the rotation of the camera\r\n     */\r\n    public updateUpVectorFromRotation = false;\r\n    private _tmpQuaternion = new Quaternion();\r\n\r\n    /**\r\n     * Define the current rotation of the camera\r\n     */\r\n    @serializeAsVector3()\r\n    public rotation = new Vector3(0, 0, 0);\r\n\r\n    /**\r\n     * Define the current rotation of the camera as a quaternion to prevent Gimbal lock\r\n     */\r\n    public rotationQuaternion: Quaternion;\r\n\r\n    /**\r\n     * Define the current speed of the camera\r\n     */\r\n    @serialize()\r\n    public speed = 2.0;\r\n\r\n    /**\r\n     * Add constraint to the camera to prevent it to move freely in all directions and\r\n     * around all axis.\r\n     */\r\n    public noRotationConstraint = false;\r\n\r\n    /**\r\n     * Reverses mouselook direction to 'natural' panning as opposed to traditional direct\r\n     * panning\r\n     */\r\n    public invertRotation = false;\r\n\r\n    /**\r\n     * Speed multiplier for inverse camera panning\r\n     */\r\n    public inverseRotationSpeed = 0.2;\r\n\r\n    /**\r\n     * Define the current target of the camera as an object or a position.\r\n     * Please note that locking a target will disable panning.\r\n     */\r\n    @serializeAsMeshReference(\"lockedTargetId\")\r\n    public lockedTarget: any = null;\r\n\r\n    /** @internal */\r\n    public _currentTarget = Vector3.Zero();\r\n    /** @internal */\r\n    public _initialFocalDistance = 1;\r\n    /** @internal */\r\n    public _viewMatrix = Matrix.Zero();\r\n    /** @internal */\r\n    public _camMatrix = Matrix.Zero();\r\n    /** @internal */\r\n    public _cameraTransformMatrix = Matrix.Zero();\r\n    /** @internal */\r\n    public _cameraRotationMatrix = Matrix.Zero();\r\n\r\n    /** @internal */\r\n    public _referencePoint = new Vector3(0, 0, 1);\r\n    /** @internal */\r\n    public _transformedReferencePoint = Vector3.Zero();\r\n\r\n    protected _deferredPositionUpdate = new Vector3();\r\n    protected _deferredRotationQuaternionUpdate = new Quaternion();\r\n    protected _deferredRotationUpdate = new Vector3();\r\n    protected _deferredUpdated = false;\r\n    protected _deferOnly: boolean = false;\r\n\r\n    /** @internal */\r\n    public _reset: () => void;\r\n\r\n    private _defaultUp = Vector3.Up();\r\n\r\n    /**\r\n     * Instantiates a target camera that takes a mesh or position as a target and continues to look at it while it moves.\r\n     * This is the base of the follow, arc rotate cameras and Free camera\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras\r\n     * @param name Defines the name of the camera in the scene\r\n     * @param position Defines the start position of the camera in the scene\r\n     * @param scene Defines the scene the camera belongs to\r\n     * @param setActiveOnSceneIfNoneActive Defines whether the camera should be marked as active if not other active cameras have been defined\r\n     */\r\n    constructor(name: string, position: Vector3, scene?: Scene, setActiveOnSceneIfNoneActive = true) {\r\n        super(name, position, scene, setActiveOnSceneIfNoneActive);\r\n    }\r\n\r\n    /**\r\n     * Gets the position in front of the camera at a given distance.\r\n     * @param distance The distance from the camera we want the position to be\r\n     * @returns the position\r\n     */\r\n    public getFrontPosition(distance: number): Vector3 {\r\n        this.getWorldMatrix();\r\n        const direction = this.getTarget().subtract(this.position);\r\n        direction.normalize();\r\n        direction.scaleInPlace(distance);\r\n        return this.globalPosition.add(direction);\r\n    }\r\n\r\n    /** @internal */\r\n    public _getLockedTargetPosition(): Nullable<Vector3> {\r\n        if (!this.lockedTarget) {\r\n            return null;\r\n        }\r\n\r\n        if (this.lockedTarget.absolutePosition) {\r\n            const lockedTarget = this.lockedTarget as AbstractMesh;\r\n            const m = lockedTarget.computeWorldMatrix();\r\n            // in some cases the absolute position resets externally, but doesn't update since the matrix is cached.\r\n            m.getTranslationToRef(lockedTarget.absolutePosition);\r\n        }\r\n\r\n        return this.lockedTarget.absolutePosition || this.lockedTarget;\r\n    }\r\n\r\n    private _storedPosition: Vector3;\r\n    private _storedRotation: Vector3;\r\n    private _storedRotationQuaternion: Quaternion;\r\n\r\n    /**\r\n     * Store current camera state of the camera (fov, position, rotation, etc..)\r\n     * @returns the camera\r\n     */\r\n    public storeState(): Camera {\r\n        this._storedPosition = this.position.clone();\r\n        this._storedRotation = this.rotation.clone();\r\n        if (this.rotationQuaternion) {\r\n            this._storedRotationQuaternion = this.rotationQuaternion.clone();\r\n        }\r\n\r\n        return super.storeState();\r\n    }\r\n\r\n    /**\r\n     * Restored camera state. You must call storeState() first\r\n     * @returns whether it was successful or not\r\n     * @internal\r\n     */\r\n    public _restoreStateValues(): boolean {\r\n        if (!super._restoreStateValues()) {\r\n            return false;\r\n        }\r\n\r\n        this.position = this._storedPosition.clone();\r\n        this.rotation = this._storedRotation.clone();\r\n\r\n        if (this.rotationQuaternion) {\r\n            this.rotationQuaternion = this._storedRotationQuaternion.clone();\r\n        }\r\n\r\n        this.cameraDirection.copyFromFloats(0, 0, 0);\r\n        this.cameraRotation.copyFromFloats(0, 0);\r\n\r\n        return true;\r\n    }\r\n\r\n    /** @internal */\r\n    public _initCache() {\r\n        super._initCache();\r\n        this._cache.lockedTarget = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\r\n        this._cache.rotation = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\r\n        this._cache.rotationQuaternion = new Quaternion(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _updateCache(ignoreParentClass?: boolean): void {\r\n        if (!ignoreParentClass) {\r\n            super._updateCache();\r\n        }\r\n\r\n        const lockedTargetPosition = this._getLockedTargetPosition();\r\n        if (!lockedTargetPosition) {\r\n            this._cache.lockedTarget = null;\r\n        } else {\r\n            if (!this._cache.lockedTarget) {\r\n                this._cache.lockedTarget = lockedTargetPosition.clone();\r\n            } else {\r\n                this._cache.lockedTarget.copyFrom(lockedTargetPosition);\r\n            }\r\n        }\r\n\r\n        this._cache.rotation.copyFrom(this.rotation);\r\n        if (this.rotationQuaternion) {\r\n            this._cache.rotationQuaternion.copyFrom(this.rotationQuaternion);\r\n        }\r\n    }\r\n\r\n    // Synchronized\r\n    /** @internal */\r\n    public _isSynchronizedViewMatrix(): boolean {\r\n        if (!super._isSynchronizedViewMatrix()) {\r\n            return false;\r\n        }\r\n\r\n        const lockedTargetPosition = this._getLockedTargetPosition();\r\n\r\n        return (\r\n            (this._cache.lockedTarget ? this._cache.lockedTarget.equals(lockedTargetPosition) : !lockedTargetPosition) &&\r\n            (this.rotationQuaternion ? this.rotationQuaternion.equals(this._cache.rotationQuaternion) : this._cache.rotation.equals(this.rotation))\r\n        );\r\n    }\r\n\r\n    // Methods\r\n    /** @internal */\r\n    public _computeLocalCameraSpeed(): number {\r\n        const engine = this.getEngine();\r\n        return this.speed * Math.sqrt(engine.getDeltaTime() / (engine.getFps() * 100.0));\r\n    }\r\n\r\n    // Target\r\n\r\n    /**\r\n     * Defines the target the camera should look at.\r\n     * @param target Defines the new target as a Vector\r\n     */\r\n    public setTarget(target: Vector3): void {\r\n        this.upVector.normalize();\r\n\r\n        this._initialFocalDistance = target.subtract(this.position).length();\r\n\r\n        if (this.position.z === target.z) {\r\n            this.position.z += Epsilon;\r\n        }\r\n\r\n        this._referencePoint.normalize().scaleInPlace(this._initialFocalDistance);\r\n\r\n        Matrix.LookAtLHToRef(this.position, target, this._defaultUp, this._camMatrix);\r\n        this._camMatrix.invert();\r\n\r\n        this.rotation.x = Math.atan(this._camMatrix.m[6] / this._camMatrix.m[10]);\r\n\r\n        const vDir = target.subtract(this.position);\r\n\r\n        if (vDir.x >= 0.0) {\r\n            this.rotation.y = -Math.atan(vDir.z / vDir.x) + Math.PI / 2.0;\r\n        } else {\r\n            this.rotation.y = -Math.atan(vDir.z / vDir.x) - Math.PI / 2.0;\r\n        }\r\n\r\n        this.rotation.z = 0;\r\n\r\n        if (isNaN(this.rotation.x)) {\r\n            this.rotation.x = 0;\r\n        }\r\n\r\n        if (isNaN(this.rotation.y)) {\r\n            this.rotation.y = 0;\r\n        }\r\n\r\n        if (isNaN(this.rotation.z)) {\r\n            this.rotation.z = 0;\r\n        }\r\n\r\n        if (this.rotationQuaternion) {\r\n            Quaternion.RotationYawPitchRollToRef(this.rotation.y, this.rotation.x, this.rotation.z, this.rotationQuaternion);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Defines the target point of the camera.\r\n     * The camera looks towards it form the radius distance.\r\n     */\r\n    public get target(): Vector3 {\r\n        return this.getTarget();\r\n    }\r\n    public set target(value: Vector3) {\r\n        this.setTarget(value);\r\n    }\r\n\r\n    /**\r\n     * Return the current target position of the camera. This value is expressed in local space.\r\n     * @returns the target position\r\n     */\r\n    public getTarget(): Vector3 {\r\n        return this._currentTarget;\r\n    }\r\n\r\n    /** @internal */\r\n    public _decideIfNeedsToMove(): boolean {\r\n        return Math.abs(this.cameraDirection.x) > 0 || Math.abs(this.cameraDirection.y) > 0 || Math.abs(this.cameraDirection.z) > 0;\r\n    }\r\n\r\n    /** @internal */\r\n    public _updatePosition(): void {\r\n        if (this.parent) {\r\n            this.parent.getWorldMatrix().invertToRef(TmpVectors.Matrix[0]);\r\n            Vector3.TransformNormalToRef(this.cameraDirection, TmpVectors.Matrix[0], TmpVectors.Vector3[0]);\r\n            this._deferredPositionUpdate.addInPlace(TmpVectors.Vector3[0]);\r\n            if (!this._deferOnly) {\r\n                this.position.copyFrom(this._deferredPositionUpdate);\r\n            } else {\r\n                this._deferredUpdated = true;\r\n            }\r\n            return;\r\n        }\r\n        this._deferredPositionUpdate.addInPlace(this.cameraDirection);\r\n        if (!this._deferOnly) {\r\n            this.position.copyFrom(this._deferredPositionUpdate);\r\n        } else {\r\n            this._deferredUpdated = true;\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public _checkInputs(): void {\r\n        const directionMultiplier = this.invertRotation ? -this.inverseRotationSpeed : 1.0;\r\n        const needToMove = this._decideIfNeedsToMove();\r\n        const needToRotate = this.cameraRotation.x || this.cameraRotation.y;\r\n\r\n        this._deferredUpdated = false;\r\n        this._deferredRotationUpdate.copyFrom(this.rotation);\r\n        this._deferredPositionUpdate.copyFrom(this.position);\r\n        if (this.rotationQuaternion) {\r\n            this._deferredRotationQuaternionUpdate.copyFrom(this.rotationQuaternion);\r\n        }\r\n\r\n        // Move\r\n        if (needToMove) {\r\n            this._updatePosition();\r\n        }\r\n\r\n        // Rotate\r\n        if (needToRotate) {\r\n            //rotate, if quaternion is set and rotation was used\r\n            if (this.rotationQuaternion) {\r\n                this.rotationQuaternion.toEulerAnglesToRef(this._deferredRotationUpdate);\r\n            }\r\n\r\n            this._deferredRotationUpdate.x += this.cameraRotation.x * directionMultiplier;\r\n            this._deferredRotationUpdate.y += this.cameraRotation.y * directionMultiplier;\r\n\r\n            // Apply constraints\r\n            if (!this.noRotationConstraint) {\r\n                const limit = 1.570796;\r\n\r\n                if (this._deferredRotationUpdate.x > limit) {\r\n                    this._deferredRotationUpdate.x = limit;\r\n                }\r\n                if (this._deferredRotationUpdate.x < -limit) {\r\n                    this._deferredRotationUpdate.x = -limit;\r\n                }\r\n            }\r\n\r\n            if (!this._deferOnly) {\r\n                this.rotation.copyFrom(this._deferredRotationUpdate);\r\n            } else {\r\n                this._deferredUpdated = true;\r\n            }\r\n\r\n            //rotate, if quaternion is set and rotation was used\r\n            if (this.rotationQuaternion) {\r\n                const len = this._deferredRotationUpdate.lengthSquared();\r\n                if (len) {\r\n                    Quaternion.RotationYawPitchRollToRef(\r\n                        this._deferredRotationUpdate.y,\r\n                        this._deferredRotationUpdate.x,\r\n                        this._deferredRotationUpdate.z,\r\n                        this._deferredRotationQuaternionUpdate\r\n                    );\r\n                    if (!this._deferOnly) {\r\n                        this.rotationQuaternion.copyFrom(this._deferredRotationQuaternionUpdate);\r\n                    } else {\r\n                        this._deferredUpdated = true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Inertia\r\n        if (needToMove) {\r\n            if (Math.abs(this.cameraDirection.x) < this.speed * Epsilon) {\r\n                this.cameraDirection.x = 0;\r\n            }\r\n\r\n            if (Math.abs(this.cameraDirection.y) < this.speed * Epsilon) {\r\n                this.cameraDirection.y = 0;\r\n            }\r\n\r\n            if (Math.abs(this.cameraDirection.z) < this.speed * Epsilon) {\r\n                this.cameraDirection.z = 0;\r\n            }\r\n\r\n            this.cameraDirection.scaleInPlace(this.inertia);\r\n        }\r\n        if (needToRotate) {\r\n            if (Math.abs(this.cameraRotation.x) < this.speed * Epsilon) {\r\n                this.cameraRotation.x = 0;\r\n            }\r\n\r\n            if (Math.abs(this.cameraRotation.y) < this.speed * Epsilon) {\r\n                this.cameraRotation.y = 0;\r\n            }\r\n            this.cameraRotation.scaleInPlace(this.inertia);\r\n        }\r\n\r\n        super._checkInputs();\r\n    }\r\n\r\n    protected _updateCameraRotationMatrix() {\r\n        if (this.rotationQuaternion) {\r\n            this.rotationQuaternion.toRotationMatrix(this._cameraRotationMatrix);\r\n        } else {\r\n            Matrix.RotationYawPitchRollToRef(this.rotation.y, this.rotation.x, this.rotation.z, this._cameraRotationMatrix);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Update the up vector to apply the rotation of the camera (So if you changed the camera rotation.z this will let you update the up vector as well)\r\n     * @returns the current camera\r\n     */\r\n    private _rotateUpVectorWithCameraRotationMatrix(): TargetCamera {\r\n        Vector3.TransformNormalToRef(this._defaultUp, this._cameraRotationMatrix, this.upVector);\r\n        return this;\r\n    }\r\n\r\n    private _cachedRotationZ = 0;\r\n    private _cachedQuaternionRotationZ = 0;\r\n    /** @internal */\r\n    public _getViewMatrix(): Matrix {\r\n        if (this.lockedTarget) {\r\n            this.setTarget(this._getLockedTargetPosition()!);\r\n        }\r\n\r\n        // Compute\r\n        this._updateCameraRotationMatrix();\r\n\r\n        // Apply the changed rotation to the upVector\r\n        if (this.rotationQuaternion && this._cachedQuaternionRotationZ != this.rotationQuaternion.z) {\r\n            this._rotateUpVectorWithCameraRotationMatrix();\r\n            this._cachedQuaternionRotationZ = this.rotationQuaternion.z;\r\n        } else if (this._cachedRotationZ !== this.rotation.z) {\r\n            this._rotateUpVectorWithCameraRotationMatrix();\r\n            this._cachedRotationZ = this.rotation.z;\r\n        }\r\n\r\n        Vector3.TransformCoordinatesToRef(this._referencePoint, this._cameraRotationMatrix, this._transformedReferencePoint);\r\n\r\n        // Computing target and final matrix\r\n        this.position.addToRef(this._transformedReferencePoint, this._currentTarget);\r\n        if (this.updateUpVectorFromRotation) {\r\n            if (this.rotationQuaternion) {\r\n                Axis.Y.rotateByQuaternionToRef(this.rotationQuaternion, this.upVector);\r\n            } else {\r\n                Quaternion.FromEulerVectorToRef(this.rotation, this._tmpQuaternion);\r\n                Axis.Y.rotateByQuaternionToRef(this._tmpQuaternion, this.upVector);\r\n            }\r\n        }\r\n        this._computeViewMatrix(this.position, this._currentTarget, this.upVector);\r\n        return this._viewMatrix;\r\n    }\r\n\r\n    protected _computeViewMatrix(position: Vector3, target: Vector3, up: Vector3): void {\r\n        if (this.ignoreParentScaling) {\r\n            if (this.parent) {\r\n                const parentWorldMatrix = this.parent.getWorldMatrix();\r\n                Vector3.TransformCoordinatesToRef(position, parentWorldMatrix, this._globalPosition);\r\n                Vector3.TransformCoordinatesToRef(target, parentWorldMatrix, this._tmpTargetVector);\r\n                Vector3.TransformNormalToRef(up, parentWorldMatrix, this._tmpUpVector);\r\n                this._markSyncedWithParent();\r\n            } else {\r\n                this._globalPosition.copyFrom(position);\r\n                this._tmpTargetVector.copyFrom(target);\r\n                this._tmpUpVector.copyFrom(up);\r\n            }\r\n\r\n            if (this.getScene().useRightHandedSystem) {\r\n                Matrix.LookAtRHToRef(this._globalPosition, this._tmpTargetVector, this._tmpUpVector, this._viewMatrix);\r\n            } else {\r\n                Matrix.LookAtLHToRef(this._globalPosition, this._tmpTargetVector, this._tmpUpVector, this._viewMatrix);\r\n            }\r\n            return;\r\n        }\r\n\r\n        if (this.getScene().useRightHandedSystem) {\r\n            Matrix.LookAtRHToRef(position, target, up, this._viewMatrix);\r\n        } else {\r\n            Matrix.LookAtLHToRef(position, target, up, this._viewMatrix);\r\n        }\r\n\r\n        if (this.parent) {\r\n            const parentWorldMatrix = this.parent.getWorldMatrix();\r\n            this._viewMatrix.invert();\r\n            this._viewMatrix.multiplyToRef(parentWorldMatrix, this._viewMatrix);\r\n            this._viewMatrix.getTranslationToRef(this._globalPosition);\r\n            this._viewMatrix.invert();\r\n            this._markSyncedWithParent();\r\n        } else {\r\n            this._globalPosition.copyFrom(position);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public createRigCamera(name: string, cameraIndex: number): Nullable<Camera> {\r\n        if (this.cameraRigMode !== Camera.RIG_MODE_NONE) {\r\n            const rigCamera = new TargetCamera(name, this.position.clone(), this.getScene());\r\n            rigCamera.isRigCamera = true;\r\n            rigCamera.rigParent = this;\r\n            if (this.cameraRigMode === Camera.RIG_MODE_VR) {\r\n                if (!this.rotationQuaternion) {\r\n                    this.rotationQuaternion = new Quaternion();\r\n                }\r\n                rigCamera._cameraRigParams = {};\r\n                rigCamera.rotationQuaternion = new Quaternion();\r\n            }\r\n\r\n            rigCamera.mode = this.mode;\r\n            rigCamera.orthoLeft = this.orthoLeft;\r\n            rigCamera.orthoRight = this.orthoRight;\r\n            rigCamera.orthoTop = this.orthoTop;\r\n            rigCamera.orthoBottom = this.orthoBottom;\r\n\r\n            return rigCamera;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _updateRigCameras() {\r\n        const camLeft = <TargetCamera>this._rigCameras[0];\r\n        const camRight = <TargetCamera>this._rigCameras[1];\r\n\r\n        this.computeWorldMatrix();\r\n\r\n        switch (this.cameraRigMode) {\r\n            case Camera.RIG_MODE_STEREOSCOPIC_ANAGLYPH:\r\n            case Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL:\r\n            case Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED:\r\n            case Camera.RIG_MODE_STEREOSCOPIC_OVERUNDER:\r\n            case Camera.RIG_MODE_STEREOSCOPIC_INTERLACED: {\r\n                //provisionnaly using _cameraRigParams.stereoHalfAngle instead of calculations based on _cameraRigParams.interaxialDistance:\r\n                const leftSign = this.cameraRigMode === Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED ? 1 : -1;\r\n                const rightSign = this.cameraRigMode === Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED ? -1 : 1;\r\n                this._getRigCamPositionAndTarget(this._cameraRigParams.stereoHalfAngle * leftSign, camLeft);\r\n                this._getRigCamPositionAndTarget(this._cameraRigParams.stereoHalfAngle * rightSign, camRight);\r\n                break;\r\n            }\r\n            case Camera.RIG_MODE_VR:\r\n                if (camLeft.rotationQuaternion) {\r\n                    camLeft.rotationQuaternion.copyFrom(this.rotationQuaternion);\r\n                    camRight.rotationQuaternion.copyFrom(this.rotationQuaternion);\r\n                } else {\r\n                    camLeft.rotation.copyFrom(this.rotation);\r\n                    camRight.rotation.copyFrom(this.rotation);\r\n                }\r\n                camLeft.position.copyFrom(this.position);\r\n                camRight.position.copyFrom(this.position);\r\n\r\n                break;\r\n        }\r\n        super._updateRigCameras();\r\n    }\r\n\r\n    private _getRigCamPositionAndTarget(halfSpace: number, rigCamera: TargetCamera) {\r\n        const target = this.getTarget();\r\n        target.subtractToRef(this.position, TargetCamera._TargetFocalPoint);\r\n\r\n        TargetCamera._TargetFocalPoint.normalize().scaleInPlace(this._initialFocalDistance);\r\n        const newFocalTarget = TargetCamera._TargetFocalPoint.addInPlace(this.position);\r\n\r\n        Matrix.TranslationToRef(-newFocalTarget.x, -newFocalTarget.y, -newFocalTarget.z, TargetCamera._TargetTransformMatrix);\r\n        TargetCamera._TargetTransformMatrix.multiplyToRef(Matrix.RotationAxis(rigCamera.upVector, halfSpace), TargetCamera._RigCamTransformMatrix);\r\n        Matrix.TranslationToRef(newFocalTarget.x, newFocalTarget.y, newFocalTarget.z, TargetCamera._TargetTransformMatrix);\r\n\r\n        TargetCamera._RigCamTransformMatrix.multiplyToRef(TargetCamera._TargetTransformMatrix, TargetCamera._RigCamTransformMatrix);\r\n\r\n        Vector3.TransformCoordinatesToRef(this.position, TargetCamera._RigCamTransformMatrix, rigCamera.position);\r\n        rigCamera.setTarget(newFocalTarget);\r\n    }\r\n\r\n    /**\r\n     * Gets the current object class name.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"TargetCamera\";\r\n    }\r\n}\r\n", "import { Logger } from \"../Misc/logger\";\r\nimport { SerializationHelper } from \"../Misc/decorators.serialization\";\r\nimport type { Nullable } from \"../types\";\r\nimport { Camera } from \"./camera\";\r\n/**\r\n * @ignore\r\n * This is a list of all the different input types that are available in the application.\r\n * Fo instance: ArcRotateCameraGamepadInput...\r\n */\r\n// eslint-disable-next-line no-var, @typescript-eslint/naming-convention\r\nexport var CameraInputTypes = {};\r\n\r\n/**\r\n * This is the contract to implement in order to create a new input class.\r\n * Inputs are dealing with listening to user actions and moving the camera accordingly.\r\n */\r\nexport interface ICameraInput<TCamera extends Camera> {\r\n    /**\r\n     * Defines the camera the input is attached to.\r\n     */\r\n    camera: Nullable<TCamera>;\r\n    /**\r\n     * Gets the class name of the current input.\r\n     * @returns the class name\r\n     */\r\n    getClassName(): string;\r\n    /**\r\n     * Get the friendly name associated with the input class.\r\n     * @returns the input friendly name\r\n     */\r\n    getSimpleName(): string;\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    attachControl(noPreventDefault?: boolean): void;\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     */\r\n    detachControl(): void;\r\n    /**\r\n     * Update the current camera state depending on the inputs that have been used this frame.\r\n     * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.\r\n     */\r\n    checkInputs?: () => void;\r\n}\r\n\r\n/**\r\n * Represents a map of input types to input instance or input index to input instance.\r\n */\r\nexport interface CameraInputsMap<TCamera extends Camera> {\r\n    /**\r\n     * Accessor to the input by input type.\r\n     */\r\n    [name: string]: ICameraInput<TCamera>;\r\n    /**\r\n     * Accessor to the input by input index.\r\n     */\r\n    [idx: number]: ICameraInput<TCamera>;\r\n}\r\n\r\n/**\r\n * This represents the input manager used within a camera.\r\n * It helps dealing with all the different kind of input attached to a camera.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n */\r\nexport class CameraInputsManager<TCamera extends Camera> {\r\n    /**\r\n     * Defines the list of inputs attached to the camera.\r\n     */\r\n    public attached: CameraInputsMap<TCamera>;\r\n\r\n    /**\r\n     * Defines the dom element the camera is collecting inputs from.\r\n     * This is null if the controls have not been attached.\r\n     */\r\n    public attachedToElement: boolean = false;\r\n\r\n    /**\r\n     * Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public noPreventDefault: boolean;\r\n\r\n    /**\r\n     * Defined the camera the input manager belongs to.\r\n     */\r\n    public camera: TCamera;\r\n\r\n    /**\r\n     * Update the current camera state depending on the inputs that have been used this frame.\r\n     * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.\r\n     */\r\n    public checkInputs: () => void;\r\n\r\n    /**\r\n     * Instantiate a new Camera Input Manager.\r\n     * @param camera Defines the camera the input manager belongs to\r\n     */\r\n    constructor(camera: TCamera) {\r\n        this.attached = {};\r\n        this.camera = camera;\r\n        this.checkInputs = () => {};\r\n    }\r\n\r\n    /**\r\n     * Add an input method to a camera\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n     * @param input Camera input method\r\n     */\r\n    public add(input: ICameraInput<TCamera>): void {\r\n        const type = input.getSimpleName();\r\n        if (this.attached[type]) {\r\n            Logger.Warn(\"camera input of type \" + type + \" already exists on camera\");\r\n            return;\r\n        }\r\n\r\n        this.attached[type] = input;\r\n\r\n        input.camera = this.camera;\r\n\r\n        // for checkInputs, we are dynamically creating a function\r\n        // the goal is to avoid the performance penalty of looping for inputs in the render loop\r\n        if (input.checkInputs) {\r\n            this.checkInputs = this._addCheckInputs(input.checkInputs.bind(input));\r\n        }\r\n\r\n        if (this.attachedToElement) {\r\n            input.attachControl(this.noPreventDefault);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove a specific input method from a camera\r\n     * example: camera.inputs.remove(camera.inputs.attached.mouse);\r\n     * @param inputToRemove camera input method\r\n     */\r\n    public remove(inputToRemove: ICameraInput<TCamera>): void {\r\n        for (const cam in this.attached) {\r\n            const input = this.attached[cam];\r\n            if (input === inputToRemove) {\r\n                input.detachControl();\r\n                input.camera = null;\r\n                delete this.attached[cam];\r\n                this.rebuildInputCheck();\r\n\r\n                return;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove a specific input type from a camera\r\n     * example: camera.inputs.remove(\"ArcRotateCameraGamepadInput\");\r\n     * @param inputType the type of the input to remove\r\n     */\r\n    public removeByType(inputType: string): void {\r\n        for (const cam in this.attached) {\r\n            const input = this.attached[cam];\r\n            if (input.getClassName() === inputType) {\r\n                input.detachControl();\r\n                input.camera = null;\r\n                delete this.attached[cam];\r\n                this.rebuildInputCheck();\r\n            }\r\n        }\r\n    }\r\n\r\n    private _addCheckInputs(fn: () => void) {\r\n        const current = this.checkInputs;\r\n        return () => {\r\n            current();\r\n            fn();\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Attach the input controls to the currently attached dom element to listen the events from.\r\n     * @param input Defines the input to attach\r\n     */\r\n    public attachInput(input: ICameraInput<TCamera>): void {\r\n        if (this.attachedToElement) {\r\n            input.attachControl(this.noPreventDefault);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Attach the current manager inputs controls to a specific dom element to listen the events from.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachElement(noPreventDefault: boolean = false): void {\r\n        if (this.attachedToElement) {\r\n            return;\r\n        }\r\n\r\n        noPreventDefault = Camera.ForceAttachControlToAlwaysPreventDefault ? false : noPreventDefault;\r\n        this.attachedToElement = true;\r\n        this.noPreventDefault = noPreventDefault;\r\n\r\n        for (const cam in this.attached) {\r\n            this.attached[cam].attachControl(noPreventDefault);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Detach the current manager inputs controls from a specific dom element.\r\n     * @param disconnect Defines whether the input should be removed from the current list of attached inputs\r\n     */\r\n    public detachElement(disconnect = false): void {\r\n        for (const cam in this.attached) {\r\n            this.attached[cam].detachControl();\r\n\r\n            if (disconnect) {\r\n                this.attached[cam].camera = null;\r\n            }\r\n        }\r\n        this.attachedToElement = false;\r\n    }\r\n\r\n    /**\r\n     * Rebuild the dynamic inputCheck function from the current list of\r\n     * defined inputs in the manager.\r\n     */\r\n    public rebuildInputCheck(): void {\r\n        this.checkInputs = () => {};\r\n\r\n        for (const cam in this.attached) {\r\n            const input = this.attached[cam];\r\n            if (input.checkInputs) {\r\n                this.checkInputs = this._addCheckInputs(input.checkInputs.bind(input));\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove all attached input methods from a camera\r\n     */\r\n    public clear(): void {\r\n        if (this.attachedToElement) {\r\n            this.detachElement(true);\r\n        }\r\n        this.attached = {};\r\n        this.attachedToElement = false;\r\n        this.checkInputs = () => {};\r\n    }\r\n\r\n    /**\r\n     * Serialize the current input manager attached to a camera.\r\n     * This ensures than once parsed,\r\n     * the input associated to the camera will be identical to the current ones\r\n     * @param serializedCamera Defines the camera serialization JSON the input serialization should write to\r\n     */\r\n    public serialize(serializedCamera: any): void {\r\n        const inputs: { [key: string]: any } = {};\r\n        for (const cam in this.attached) {\r\n            const input = this.attached[cam];\r\n            const res = SerializationHelper.Serialize(input);\r\n            inputs[input.getClassName()] = res;\r\n        }\r\n\r\n        serializedCamera.inputsmgr = inputs;\r\n    }\r\n\r\n    /**\r\n     * Parses an input manager serialized JSON to restore the previous list of inputs\r\n     * and states associated to a camera.\r\n     * @param parsedCamera Defines the JSON to parse\r\n     */\r\n    public parse(parsedCamera: any): void {\r\n        const parsedInputs = parsedCamera.inputsmgr;\r\n        if (parsedInputs) {\r\n            this.clear();\r\n\r\n            for (const n in parsedInputs) {\r\n                const construct = (<any>CameraInputTypes)[n];\r\n                if (construct) {\r\n                    const parsedinput = parsedInputs[n];\r\n                    const input = SerializationHelper.Parse(\r\n                        () => {\r\n                            return new construct();\r\n                        },\r\n                        parsedinput,\r\n                        null\r\n                    );\r\n                    this.add(input as any);\r\n                }\r\n            }\r\n        } else {\r\n            //2016-03-08 this part is for managing backward compatibility\r\n            for (const n in this.attached) {\r\n                const construct = (<any>CameraInputTypes)[this.attached[n].getClassName()];\r\n                if (construct) {\r\n                    const input = SerializationHelper.Parse(\r\n                        () => {\r\n                            return new construct();\r\n                        },\r\n                        parsedCamera,\r\n                        null\r\n                    );\r\n                    this.remove(this.attached[n]);\r\n                    this.add(input as any);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n", "import { serialize } from \"../../Misc/decorators\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { ICameraInput } from \"../../Cameras/cameraInputsManager\";\r\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager\";\r\nimport type { FreeCamera } from \"../../Cameras/freeCamera\";\r\nimport type { KeyboardInfo } from \"../../Events/keyboardEvents\";\r\nimport { KeyboardEventTypes } from \"../../Events/keyboardEvents\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { Vector3 } from \"../../Maths/math.vector\";\r\nimport type { Engine } from \"../../Engines/engine\";\r\nimport { Tools } from \"../../Misc/tools\";\r\n/**\r\n * Manage the keyboard inputs to control the movement of a free camera.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n */\r\nexport class FreeCameraKeyboardMoveInput implements ICameraInput<FreeCamera> {\r\n    /**\r\n     * Defines the camera the input is attached to.\r\n     */\r\n    public camera: FreeCamera;\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the forward move of the camera.\r\n     */\r\n    @serialize()\r\n    public keysUp = [38];\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the upward move of the camera.\r\n     */\r\n    @serialize()\r\n    public keysUpward = [33];\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the backward move of the camera.\r\n     */\r\n    @serialize()\r\n    public keysDown = [40];\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the downward move of the camera.\r\n     */\r\n    @serialize()\r\n    public keysDownward = [34];\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the left strafe move of the camera.\r\n     */\r\n    @serialize()\r\n    public keysLeft = [37];\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the right strafe move of the camera.\r\n     */\r\n    @serialize()\r\n    public keysRight = [39];\r\n\r\n    /**\r\n     * Defines the pointer angular sensibility  along the X and Y axis or how fast is the camera rotating.\r\n     */\r\n    @serialize()\r\n    public rotationSpeed = 0.5;\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the left rotation move of the camera.\r\n     */\r\n    @serialize()\r\n    public keysRotateLeft: number[] = [];\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the right rotation move of the camera.\r\n     */\r\n    @serialize()\r\n    public keysRotateRight: number[] = [];\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the up rotation move of the camera.\r\n     */\r\n    @serialize()\r\n    public keysRotateUp: number[] = [];\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the down rotation move of the camera.\r\n     */\r\n    @serialize()\r\n    public keysRotateDown: number[] = [];\r\n\r\n    private _keys = new Array<number>();\r\n    private _onCanvasBlurObserver: Nullable<Observer<Engine>>;\r\n    private _onKeyboardObserver: Nullable<Observer<KeyboardInfo>>;\r\n    private _engine: Engine;\r\n    private _scene: Scene;\r\n\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachControl(noPreventDefault?: boolean): void {\r\n        // eslint-disable-next-line prefer-rest-params\r\n        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\r\n        if (this._onCanvasBlurObserver) {\r\n            return;\r\n        }\r\n\r\n        this._scene = this.camera.getScene();\r\n        this._engine = this._scene.getEngine();\r\n\r\n        this._onCanvasBlurObserver = this._engine.onCanvasBlurObservable.add(() => {\r\n            this._keys.length = 0;\r\n        });\r\n\r\n        this._onKeyboardObserver = this._scene.onKeyboardObservable.add((info) => {\r\n            const evt = info.event;\r\n            if (!evt.metaKey) {\r\n                if (info.type === KeyboardEventTypes.KEYDOWN) {\r\n                    if (\r\n                        this.keysUp.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysDown.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysLeft.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysRight.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysUpward.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysDownward.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysRotateLeft.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysRotateRight.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysRotateUp.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysRotateDown.indexOf(evt.keyCode) !== -1\r\n                    ) {\r\n                        const index = this._keys.indexOf(evt.keyCode);\r\n\r\n                        if (index === -1) {\r\n                            this._keys.push(evt.keyCode);\r\n                        }\r\n                        if (!noPreventDefault) {\r\n                            evt.preventDefault();\r\n                        }\r\n                    }\r\n                } else {\r\n                    if (\r\n                        this.keysUp.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysDown.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysLeft.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysRight.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysUpward.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysDownward.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysRotateLeft.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysRotateRight.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysRotateUp.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysRotateDown.indexOf(evt.keyCode) !== -1\r\n                    ) {\r\n                        const index = this._keys.indexOf(evt.keyCode);\r\n\r\n                        if (index >= 0) {\r\n                            this._keys.splice(index, 1);\r\n                        }\r\n                        if (!noPreventDefault) {\r\n                            evt.preventDefault();\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     */\r\n    public detachControl(): void {\r\n        if (this._scene) {\r\n            if (this._onKeyboardObserver) {\r\n                this._scene.onKeyboardObservable.remove(this._onKeyboardObserver);\r\n            }\r\n\r\n            if (this._onCanvasBlurObserver) {\r\n                this._engine.onCanvasBlurObservable.remove(this._onCanvasBlurObserver);\r\n            }\r\n            this._onKeyboardObserver = null;\r\n            this._onCanvasBlurObserver = null;\r\n        }\r\n        this._keys.length = 0;\r\n    }\r\n\r\n    /**\r\n     * Update the current camera state depending on the inputs that have been used this frame.\r\n     * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.\r\n     */\r\n    public checkInputs(): void {\r\n        if (this._onKeyboardObserver) {\r\n            const camera = this.camera;\r\n            // Keyboard\r\n            for (let index = 0; index < this._keys.length; index++) {\r\n                const keyCode = this._keys[index];\r\n                const speed = camera._computeLocalCameraSpeed();\r\n\r\n                if (this.keysLeft.indexOf(keyCode) !== -1) {\r\n                    camera._localDirection.copyFromFloats(-speed, 0, 0);\r\n                } else if (this.keysUp.indexOf(keyCode) !== -1) {\r\n                    camera._localDirection.copyFromFloats(0, 0, speed);\r\n                } else if (this.keysRight.indexOf(keyCode) !== -1) {\r\n                    camera._localDirection.copyFromFloats(speed, 0, 0);\r\n                } else if (this.keysDown.indexOf(keyCode) !== -1) {\r\n                    camera._localDirection.copyFromFloats(0, 0, -speed);\r\n                } else if (this.keysUpward.indexOf(keyCode) !== -1) {\r\n                    camera._localDirection.copyFromFloats(0, speed, 0);\r\n                } else if (this.keysDownward.indexOf(keyCode) !== -1) {\r\n                    camera._localDirection.copyFromFloats(0, -speed, 0);\r\n                } else if (this.keysRotateLeft.indexOf(keyCode) !== -1) {\r\n                    camera._localDirection.copyFromFloats(0, 0, 0);\r\n                    camera.cameraRotation.y -= this._getLocalRotation();\r\n                } else if (this.keysRotateRight.indexOf(keyCode) !== -1) {\r\n                    camera._localDirection.copyFromFloats(0, 0, 0);\r\n                    camera.cameraRotation.y += this._getLocalRotation();\r\n                } else if (this.keysRotateUp.indexOf(keyCode) !== -1) {\r\n                    camera._localDirection.copyFromFloats(0, 0, 0);\r\n                    camera.cameraRotation.x -= this._getLocalRotation();\r\n                } else if (this.keysRotateDown.indexOf(keyCode) !== -1) {\r\n                    camera._localDirection.copyFromFloats(0, 0, 0);\r\n                    camera.cameraRotation.x += this._getLocalRotation();\r\n                }\r\n\r\n                if (camera.getScene().useRightHandedSystem) {\r\n                    camera._localDirection.z *= -1;\r\n                }\r\n\r\n                camera.getViewMatrix().invertToRef(camera._cameraTransformMatrix);\r\n                Vector3.TransformNormalToRef(camera._localDirection, camera._cameraTransformMatrix, camera._transformedDirection);\r\n                camera.cameraDirection.addInPlace(camera._transformedDirection);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the current input.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"FreeCameraKeyboardMoveInput\";\r\n    }\r\n\r\n    /** @internal */\r\n    public _onLostFocus(): void {\r\n        this._keys.length = 0;\r\n    }\r\n\r\n    /**\r\n     * Get the friendly name associated with the input class.\r\n     * @returns the input friendly name\r\n     */\r\n    public getSimpleName(): string {\r\n        return \"keyboard\";\r\n    }\r\n\r\n    private _getLocalRotation(): number {\r\n        const handednessMultiplier = this.camera._calculateHandednessMultiplier();\r\n        const rotation = ((this.rotationSpeed * this._engine.getDeltaTime()) / 1000) * handednessMultiplier;\r\n\r\n        return rotation;\r\n    }\r\n}\r\n\r\n(<any>CameraInputTypes)[\"FreeCameraKeyboardMoveInput\"] = FreeCameraKeyboardMoveInput;\r\n", "import type { Observer, EventState } from \"../../Misc/observable\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport { serialize } from \"../../Misc/decorators\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { ICameraInput } from \"../../Cameras/cameraInputsManager\";\r\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager\";\r\nimport type { FreeCamera } from \"../../Cameras/freeCamera\";\r\nimport type { PointerInfo } from \"../../Events/pointerEvents\";\r\nimport { PointerEventTypes } from \"../../Events/pointerEvents\";\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport type { IMouseEvent, IPointerEvent } from \"../../Events/deviceInputEvents\";\r\n/**\r\n * Manage the mouse inputs to control the movement of a free camera.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n */\r\nexport class FreeCameraMouseInput implements ICameraInput<FreeCamera> {\r\n    /**\r\n     * Defines the camera the input is attached to.\r\n     */\r\n    public camera: FreeCamera;\r\n\r\n    /**\r\n     * Defines the buttons associated with the input to handle camera move.\r\n     */\r\n    @serialize()\r\n    public buttons = [0, 1, 2];\r\n\r\n    /**\r\n     * Defines the pointer angular sensibility  along the X and Y axis or how fast is the camera rotating.\r\n     */\r\n    @serialize()\r\n    public angularSensibility = 2000.0;\r\n\r\n    private _pointerInput: (p: PointerInfo, s: EventState) => void;\r\n    private _onMouseMove: Nullable<(e: IMouseEvent) => any>;\r\n    private _observer: Nullable<Observer<PointerInfo>>;\r\n    private _previousPosition: Nullable<{ x: number; y: number }> = null;\r\n\r\n    /**\r\n     * Observable for when a pointer move event occurs containing the move offset\r\n     */\r\n    public onPointerMovedObservable = new Observable<{ offsetX: number; offsetY: number }>();\r\n    /**\r\n     * @internal\r\n     * If the camera should be rotated automatically based on pointer movement\r\n     */\r\n    public _allowCameraRotation = true;\r\n\r\n    private _currentActiveButton: number = -1;\r\n    private _activePointerId: number = -1;\r\n    private _contextMenuBind: (evt: MouseEvent) => void;\r\n\r\n    /**\r\n     * Manage the mouse inputs to control the movement of a free camera.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n     * @param touchEnabled Defines if touch is enabled or not\r\n     */\r\n    constructor(\r\n        /**\r\n         * Define if touch is enabled in the mouse input\r\n         */\r\n        public touchEnabled = true\r\n    ) {}\r\n\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachControl(noPreventDefault?: boolean): void {\r\n        // eslint-disable-next-line prefer-rest-params\r\n        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\r\n        const engine = this.camera.getEngine();\r\n        const element = engine.getInputElement();\r\n\r\n        if (!this._pointerInput) {\r\n            this._pointerInput = (p) => {\r\n                const evt = <IPointerEvent>p.event;\r\n                const isTouch = evt.pointerType === \"touch\";\r\n\r\n                if (!this.touchEnabled && isTouch) {\r\n                    return;\r\n                }\r\n\r\n                if (p.type !== PointerEventTypes.POINTERMOVE && this.buttons.indexOf(evt.button) === -1) {\r\n                    return;\r\n                }\r\n\r\n                const srcElement = <HTMLElement>evt.target;\r\n\r\n                if (p.type === PointerEventTypes.POINTERDOWN) {\r\n                    // If the input is touch with more than one touch OR if the input is mouse and there is already an active button, return\r\n                    if ((isTouch && this._activePointerId !== -1) || (!isTouch && this._currentActiveButton !== -1)) {\r\n                        return;\r\n                    }\r\n\r\n                    this._activePointerId = evt.pointerId;\r\n                    try {\r\n                        srcElement?.setPointerCapture(evt.pointerId);\r\n                    } catch (e) {\r\n                        //Nothing to do with the error. Execution will continue.\r\n                    }\r\n\r\n                    if (this._currentActiveButton === -1) {\r\n                        this._currentActiveButton = evt.button;\r\n                    }\r\n\r\n                    this._previousPosition = {\r\n                        x: evt.clientX,\r\n                        y: evt.clientY,\r\n                    };\r\n\r\n                    if (!noPreventDefault) {\r\n                        evt.preventDefault();\r\n                        element && element.focus();\r\n                    }\r\n\r\n                    // This is required to move while pointer button is down\r\n                    if (engine.isPointerLock && this._onMouseMove) {\r\n                        this._onMouseMove(p.event);\r\n                    }\r\n                } else if (p.type === PointerEventTypes.POINTERUP) {\r\n                    // If input is touch with a different touch id OR if input is mouse with a different button, return\r\n                    if ((isTouch && this._activePointerId !== evt.pointerId) || (!isTouch && this._currentActiveButton !== evt.button)) {\r\n                        return;\r\n                    }\r\n\r\n                    try {\r\n                        srcElement?.releasePointerCapture(evt.pointerId);\r\n                    } catch (e) {\r\n                        //Nothing to do with the error.\r\n                    }\r\n                    this._currentActiveButton = -1;\r\n\r\n                    this._previousPosition = null;\r\n                    if (!noPreventDefault) {\r\n                        evt.preventDefault();\r\n                    }\r\n\r\n                    this._activePointerId = -1;\r\n                } else if (p.type === PointerEventTypes.POINTERMOVE && (this._activePointerId === evt.pointerId || !isTouch)) {\r\n                    if (engine.isPointerLock && this._onMouseMove) {\r\n                        this._onMouseMove(p.event);\r\n                    } else if (this._previousPosition) {\r\n                        const handednessMultiplier = this.camera._calculateHandednessMultiplier();\r\n                        const offsetX = (evt.clientX - this._previousPosition.x) * handednessMultiplier;\r\n                        const offsetY = evt.clientY - this._previousPosition.y;\r\n\r\n                        if (this._allowCameraRotation) {\r\n                            this.camera.cameraRotation.y += offsetX / this.angularSensibility;\r\n                            this.camera.cameraRotation.x += offsetY / this.angularSensibility;\r\n                        }\r\n                        this.onPointerMovedObservable.notifyObservers({ offsetX: offsetX, offsetY: offsetY });\r\n\r\n                        this._previousPosition = {\r\n                            x: evt.clientX,\r\n                            y: evt.clientY,\r\n                        };\r\n\r\n                        if (!noPreventDefault) {\r\n                            evt.preventDefault();\r\n                        }\r\n                    }\r\n                }\r\n            };\r\n        }\r\n\r\n        this._onMouseMove = (evt) => {\r\n            if (!engine.isPointerLock) {\r\n                return;\r\n            }\r\n\r\n            const handednessMultiplier = this.camera._calculateHandednessMultiplier();\r\n            const offsetX = evt.movementX * handednessMultiplier;\r\n\r\n            this.camera.cameraRotation.y += offsetX / this.angularSensibility;\r\n\r\n            const offsetY = evt.movementY;\r\n            this.camera.cameraRotation.x += offsetY / this.angularSensibility;\r\n\r\n            this._previousPosition = null;\r\n\r\n            if (!noPreventDefault) {\r\n                evt.preventDefault();\r\n            }\r\n        };\r\n\r\n        this._observer = this.camera\r\n            .getScene()\r\n            ._inputManager._addCameraPointerObserver(this._pointerInput, PointerEventTypes.POINTERDOWN | PointerEventTypes.POINTERUP | PointerEventTypes.POINTERMOVE);\r\n\r\n        if (element) {\r\n            this._contextMenuBind = (evt: MouseEvent) => this.onContextMenu(evt as PointerEvent);\r\n            element.addEventListener(\"contextmenu\", this._contextMenuBind, false); // TODO: We need to figure out how to handle this for Native\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Called on JS contextmenu event.\r\n     * Override this method to provide functionality.\r\n     * @param evt the context menu event\r\n     */\r\n    public onContextMenu(evt: PointerEvent): void {\r\n        evt.preventDefault();\r\n    }\r\n\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     */\r\n    public detachControl(): void {\r\n        if (this._observer) {\r\n            this.camera.getScene()._inputManager._removeCameraPointerObserver(this._observer);\r\n\r\n            if (this._contextMenuBind) {\r\n                const engine = this.camera.getEngine();\r\n                const element = engine.getInputElement();\r\n                element && element.removeEventListener(\"contextmenu\", this._contextMenuBind);\r\n            }\r\n\r\n            if (this.onPointerMovedObservable) {\r\n                this.onPointerMovedObservable.clear();\r\n            }\r\n\r\n            this._observer = null;\r\n            this._onMouseMove = null;\r\n            this._previousPosition = null;\r\n        }\r\n\r\n        this._activePointerId = -1;\r\n        this._currentActiveButton = -1;\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the current input.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"FreeCameraMouseInput\";\r\n    }\r\n\r\n    /**\r\n     * Get the friendly name associated with the input class.\r\n     * @returns the input friendly name\r\n     */\r\n    public getSimpleName(): string {\r\n        return \"mouse\";\r\n    }\r\n}\r\n\r\n(<any>CameraInputTypes)[\"FreeCameraMouseInput\"] = FreeCameraMouseInput;\r\n", "import type { Nullable } from \"../../types\";\r\nimport { serialize } from \"../../Misc/decorators\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport type { Camera } from \"../../Cameras/camera\";\r\nimport type { ICameraInput } from \"../../Cameras/cameraInputsManager\";\r\nimport type { PointerInfo } from \"../../Events/pointerEvents\";\r\nimport { PointerEventTypes } from \"../../Events/pointerEvents\";\r\nimport type { IWheelEvent } from \"../../Events/deviceInputEvents\";\r\nimport { EventConstants } from \"../../Events/deviceInputEvents\";\r\nimport { Tools } from \"../../Misc/tools\";\r\n\r\n/**\r\n * Base class for mouse wheel input..\r\n * See FollowCameraMouseWheelInput in src/Cameras/Inputs/freeCameraMouseWheelInput.ts\r\n * for example usage.\r\n */\r\nexport abstract class BaseCameraMouseWheelInput implements ICameraInput<Camera> {\r\n    /**\r\n     * Defines the camera the input is attached to.\r\n     */\r\n    public abstract camera: Camera;\r\n\r\n    /**\r\n     * How fast is the camera moves in relation to X axis mouseWheel events.\r\n     * Use negative value to reverse direction.\r\n     */\r\n    @serialize()\r\n    public wheelPrecisionX = 3.0;\r\n\r\n    /**\r\n     * How fast is the camera moves in relation to Y axis mouseWheel events.\r\n     * Use negative value to reverse direction.\r\n     */\r\n    @serialize()\r\n    public wheelPrecisionY = 3.0;\r\n\r\n    /**\r\n     * How fast is the camera moves in relation to Z axis mouseWheel events.\r\n     * Use negative value to reverse direction.\r\n     */\r\n    @serialize()\r\n    public wheelPrecisionZ = 3.0;\r\n\r\n    /**\r\n     * Observable for when a mouse wheel move event occurs.\r\n     */\r\n    public onChangedObservable = new Observable<{ wheelDeltaX: number; wheelDeltaY: number; wheelDeltaZ: number }>();\r\n\r\n    private _wheel: Nullable<(pointer: PointerInfo) => void>;\r\n    private _observer: Nullable<Observer<PointerInfo>>;\r\n\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param noPreventDefault Defines whether event caught by the controls\r\n     *   should call preventdefault().\r\n     *   (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachControl(noPreventDefault?: boolean): void {\r\n        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\r\n\r\n        this._wheel = (pointer) => {\r\n            // sanity check - this should be a PointerWheel event.\r\n            if (pointer.type !== PointerEventTypes.POINTERWHEEL) {\r\n                return;\r\n            }\r\n\r\n            const event = <IWheelEvent>pointer.event;\r\n\r\n            const platformScale = event.deltaMode === EventConstants.DOM_DELTA_LINE ? this._ffMultiplier : 1; // If this happens to be set to DOM_DELTA_LINE, adjust accordingly\r\n\r\n            this._wheelDeltaX += (this.wheelPrecisionX * platformScale * event.deltaX) / this._normalize;\r\n            this._wheelDeltaY -= (this.wheelPrecisionY * platformScale * event.deltaY) / this._normalize;\r\n            this._wheelDeltaZ += (this.wheelPrecisionZ * platformScale * event.deltaZ) / this._normalize;\r\n\r\n            if (event.preventDefault) {\r\n                if (!noPreventDefault) {\r\n                    event.preventDefault();\r\n                }\r\n            }\r\n        };\r\n\r\n        this._observer = this.camera.getScene()._inputManager._addCameraPointerObserver(this._wheel, PointerEventTypes.POINTERWHEEL);\r\n    }\r\n\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     */\r\n    public detachControl(): void {\r\n        if (this._observer) {\r\n            this.camera.getScene()._inputManager._removeCameraPointerObserver(this._observer);\r\n            this._observer = null;\r\n            this._wheel = null;\r\n        }\r\n        if (this.onChangedObservable) {\r\n            this.onChangedObservable.clear();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Called for each rendered frame.\r\n     */\r\n    public checkInputs(): void {\r\n        this.onChangedObservable.notifyObservers({\r\n            wheelDeltaX: this._wheelDeltaX,\r\n            wheelDeltaY: this._wheelDeltaY,\r\n            wheelDeltaZ: this._wheelDeltaZ,\r\n        });\r\n\r\n        // Clear deltas.\r\n        this._wheelDeltaX = 0;\r\n        this._wheelDeltaY = 0;\r\n        this._wheelDeltaZ = 0;\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the current input.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"BaseCameraMouseWheelInput\";\r\n    }\r\n\r\n    /**\r\n     * Get the friendly name associated with the input class.\r\n     * @returns the input friendly name\r\n     */\r\n    public getSimpleName(): string {\r\n        return \"mousewheel\";\r\n    }\r\n\r\n    /**\r\n     * Incremental value of multiple mouse wheel movements of the X axis.\r\n     * Should be zero-ed when read.\r\n     */\r\n    protected _wheelDeltaX: number = 0;\r\n\r\n    /**\r\n     * Incremental value of multiple mouse wheel movements of the Y axis.\r\n     * Should be zero-ed when read.\r\n     */\r\n    protected _wheelDeltaY: number = 0;\r\n\r\n    /**\r\n     * Incremental value of multiple mouse wheel movements of the Z axis.\r\n     * Should be zero-ed when read.\r\n     */\r\n    protected _wheelDeltaZ: number = 0;\r\n\r\n    /**\r\n     * Firefox uses a different scheme to report scroll distances to other\r\n     * browsers. Rather than use complicated methods to calculate the exact\r\n     * multiple we need to apply, let's just cheat and use a constant.\r\n     * https://developer.mozilla.org/en-US/docs/Web/API/WheelEvent/deltaMode\r\n     * https://stackoverflow.com/questions/20110224/what-is-the-height-of-a-line-in-a-wheel-event-deltamode-dom-delta-line\r\n     */\r\n    private readonly _ffMultiplier = 12;\r\n\r\n    /**\r\n     * Different event attributes for wheel data fall into a few set ranges.\r\n     * Some relevant but dated date here:\r\n     * https://stackoverflow.com/questions/5527601/normalizing-mousewheel-speed-across-browsers\r\n     */\r\n    private readonly _normalize = 120;\r\n}\r\n", "import type { Nullable } from \"../../types\";\r\nimport { serialize } from \"../../Misc/decorators\";\r\nimport type { FreeCamera } from \"../../Cameras/freeCamera\";\r\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager\";\r\nimport { BaseCameraMouseWheelInput } from \"../../Cameras/Inputs/BaseCameraMouseWheelInput\";\r\nimport { Matrix, Vector3 } from \"../../Maths/math.vector\";\r\nimport { Coordinate } from \"../../Maths/math.axis\";\r\n\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nenum _CameraProperty {\r\n    MoveRelative,\r\n    RotateRelative,\r\n    MoveScene,\r\n}\r\n\r\n/**\r\n * Manage the mouse wheel inputs to control a free camera.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n */\r\nexport class FreeCameraMouseWheelInput extends BaseCameraMouseWheelInput {\r\n    /**\r\n     * Defines the camera the input is attached to.\r\n     */\r\n    public camera: FreeCamera;\r\n\r\n    /**\r\n     * Gets the class name of the current input.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"FreeCameraMouseWheelInput\";\r\n    }\r\n\r\n    /**\r\n     * Set which movement axis (relative to camera's orientation) the mouse\r\n     * wheel's X axis controls.\r\n     * @param axis The axis to be moved. Set null to clear.\r\n     */\r\n    @serialize()\r\n    public set wheelXMoveRelative(axis: Nullable<Coordinate>) {\r\n        if (axis === null && this._wheelXAction !== _CameraProperty.MoveRelative) {\r\n            // Attempting to clear different _wheelXAction.\r\n            return;\r\n        }\r\n        this._wheelXAction = _CameraProperty.MoveRelative;\r\n        this._wheelXActionCoordinate = axis;\r\n    }\r\n\r\n    /**\r\n     * Get the configured movement axis (relative to camera's orientation) the\r\n     * mouse wheel's X axis controls.\r\n     * @returns The configured axis or null if none.\r\n     */\r\n    public get wheelXMoveRelative(): Nullable<Coordinate> {\r\n        if (this._wheelXAction !== _CameraProperty.MoveRelative) {\r\n            return null;\r\n        }\r\n        return this._wheelXActionCoordinate;\r\n    }\r\n\r\n    /**\r\n     * Set which movement axis (relative to camera's orientation) the mouse\r\n     * wheel's Y axis controls.\r\n     * @param axis The axis to be moved. Set null to clear.\r\n     */\r\n    @serialize()\r\n    public set wheelYMoveRelative(axis: Nullable<Coordinate>) {\r\n        if (axis === null && this._wheelYAction !== _CameraProperty.MoveRelative) {\r\n            // Attempting to clear different _wheelYAction.\r\n            return;\r\n        }\r\n        this._wheelYAction = _CameraProperty.MoveRelative;\r\n        this._wheelYActionCoordinate = axis;\r\n    }\r\n\r\n    /**\r\n     * Get the configured movement axis (relative to camera's orientation) the\r\n     * mouse wheel's Y axis controls.\r\n     * @returns The configured axis or null if none.\r\n     */\r\n    public get wheelYMoveRelative(): Nullable<Coordinate> {\r\n        if (this._wheelYAction !== _CameraProperty.MoveRelative) {\r\n            return null;\r\n        }\r\n        return this._wheelYActionCoordinate;\r\n    }\r\n\r\n    /**\r\n     * Set which movement axis (relative to camera's orientation) the mouse\r\n     * wheel's Z axis controls.\r\n     * @param axis The axis to be moved. Set null to clear.\r\n     */\r\n    @serialize()\r\n    public set wheelZMoveRelative(axis: Nullable<Coordinate>) {\r\n        if (axis === null && this._wheelZAction !== _CameraProperty.MoveRelative) {\r\n            // Attempting to clear different _wheelZAction.\r\n            return;\r\n        }\r\n        this._wheelZAction = _CameraProperty.MoveRelative;\r\n        this._wheelZActionCoordinate = axis;\r\n    }\r\n\r\n    /**\r\n     * Get the configured movement axis (relative to camera's orientation) the\r\n     * mouse wheel's Z axis controls.\r\n     * @returns The configured axis or null if none.\r\n     */\r\n    public get wheelZMoveRelative(): Nullable<Coordinate> {\r\n        if (this._wheelZAction !== _CameraProperty.MoveRelative) {\r\n            return null;\r\n        }\r\n        return this._wheelZActionCoordinate;\r\n    }\r\n\r\n    /**\r\n     * Set which rotation axis (relative to camera's orientation) the mouse\r\n     * wheel's X axis controls.\r\n     * @param axis The axis to be moved. Set null to clear.\r\n     */\r\n    @serialize()\r\n    public set wheelXRotateRelative(axis: Nullable<Coordinate>) {\r\n        if (axis === null && this._wheelXAction !== _CameraProperty.RotateRelative) {\r\n            // Attempting to clear different _wheelXAction.\r\n            return;\r\n        }\r\n        this._wheelXAction = _CameraProperty.RotateRelative;\r\n        this._wheelXActionCoordinate = axis;\r\n    }\r\n\r\n    /**\r\n     * Get the configured rotation axis (relative to camera's orientation) the\r\n     * mouse wheel's X axis controls.\r\n     * @returns The configured axis or null if none.\r\n     */\r\n    public get wheelXRotateRelative(): Nullable<Coordinate> {\r\n        if (this._wheelXAction !== _CameraProperty.RotateRelative) {\r\n            return null;\r\n        }\r\n        return this._wheelXActionCoordinate;\r\n    }\r\n\r\n    /**\r\n     * Set which rotation axis (relative to camera's orientation) the mouse\r\n     * wheel's Y axis controls.\r\n     * @param axis The axis to be moved. Set null to clear.\r\n     */\r\n    @serialize()\r\n    public set wheelYRotateRelative(axis: Nullable<Coordinate>) {\r\n        if (axis === null && this._wheelYAction !== _CameraProperty.RotateRelative) {\r\n            // Attempting to clear different _wheelYAction.\r\n            return;\r\n        }\r\n        this._wheelYAction = _CameraProperty.RotateRelative;\r\n        this._wheelYActionCoordinate = axis;\r\n    }\r\n\r\n    /**\r\n     * Get the configured rotation axis (relative to camera's orientation) the\r\n     * mouse wheel's Y axis controls.\r\n     * @returns The configured axis or null if none.\r\n     */\r\n    public get wheelYRotateRelative(): Nullable<Coordinate> {\r\n        if (this._wheelYAction !== _CameraProperty.RotateRelative) {\r\n            return null;\r\n        }\r\n        return this._wheelYActionCoordinate;\r\n    }\r\n\r\n    /**\r\n     * Set which rotation axis (relative to camera's orientation) the mouse\r\n     * wheel's Z axis controls.\r\n     * @param axis The axis to be moved. Set null to clear.\r\n     */\r\n    @serialize()\r\n    public set wheelZRotateRelative(axis: Nullable<Coordinate>) {\r\n        if (axis === null && this._wheelZAction !== _CameraProperty.RotateRelative) {\r\n            // Attempting to clear different _wheelZAction.\r\n            return;\r\n        }\r\n        this._wheelZAction = _CameraProperty.RotateRelative;\r\n        this._wheelZActionCoordinate = axis;\r\n    }\r\n\r\n    /**\r\n     * Get the configured rotation axis (relative to camera's orientation) the\r\n     * mouse wheel's Z axis controls.\r\n     * @returns The configured axis or null if none.\r\n     */\r\n    public get wheelZRotateRelative(): Nullable<Coordinate> {\r\n        if (this._wheelZAction !== _CameraProperty.RotateRelative) {\r\n            return null;\r\n        }\r\n        return this._wheelZActionCoordinate;\r\n    }\r\n\r\n    /**\r\n     * Set which movement axis (relative to the scene) the mouse wheel's X axis\r\n     * controls.\r\n     * @param axis The axis to be moved. Set null to clear.\r\n     */\r\n    @serialize()\r\n    public set wheelXMoveScene(axis: Nullable<Coordinate>) {\r\n        if (axis === null && this._wheelXAction !== _CameraProperty.MoveScene) {\r\n            // Attempting to clear different _wheelXAction.\r\n            return;\r\n        }\r\n        this._wheelXAction = _CameraProperty.MoveScene;\r\n        this._wheelXActionCoordinate = axis;\r\n    }\r\n\r\n    /**\r\n     * Get the configured movement axis (relative to the scene) the mouse wheel's\r\n     * X axis controls.\r\n     * @returns The configured axis or null if none.\r\n     */\r\n    public get wheelXMoveScene(): Nullable<Coordinate> {\r\n        if (this._wheelXAction !== _CameraProperty.MoveScene) {\r\n            return null;\r\n        }\r\n        return this._wheelXActionCoordinate;\r\n    }\r\n\r\n    /**\r\n     * Set which movement axis (relative to the scene) the mouse wheel's Y axis\r\n     * controls.\r\n     * @param axis The axis to be moved. Set null to clear.\r\n     */\r\n    @serialize()\r\n    public set wheelYMoveScene(axis: Nullable<Coordinate>) {\r\n        if (axis === null && this._wheelYAction !== _CameraProperty.MoveScene) {\r\n            // Attempting to clear different _wheelYAction.\r\n            return;\r\n        }\r\n        this._wheelYAction = _CameraProperty.MoveScene;\r\n        this._wheelYActionCoordinate = axis;\r\n    }\r\n\r\n    /**\r\n     * Get the configured movement axis (relative to the scene) the mouse wheel's\r\n     * Y axis controls.\r\n     * @returns The configured axis or null if none.\r\n     */\r\n    public get wheelYMoveScene(): Nullable<Coordinate> {\r\n        if (this._wheelYAction !== _CameraProperty.MoveScene) {\r\n            return null;\r\n        }\r\n        return this._wheelYActionCoordinate;\r\n    }\r\n\r\n    /**\r\n     * Set which movement axis (relative to the scene) the mouse wheel's Z axis\r\n     * controls.\r\n     * @param axis The axis to be moved. Set null to clear.\r\n     */\r\n    @serialize()\r\n    public set wheelZMoveScene(axis: Nullable<Coordinate>) {\r\n        if (axis === null && this._wheelZAction !== _CameraProperty.MoveScene) {\r\n            // Attempting to clear different _wheelZAction.\r\n            return;\r\n        }\r\n        this._wheelZAction = _CameraProperty.MoveScene;\r\n        this._wheelZActionCoordinate = axis;\r\n    }\r\n\r\n    /**\r\n     * Get the configured movement axis (relative to the scene) the mouse wheel's\r\n     * Z axis controls.\r\n     * @returns The configured axis or null if none.\r\n     */\r\n    public get wheelZMoveScene(): Nullable<Coordinate> {\r\n        if (this._wheelZAction !== _CameraProperty.MoveScene) {\r\n            return null;\r\n        }\r\n        return this._wheelZActionCoordinate;\r\n    }\r\n\r\n    /**\r\n     * Called for each rendered frame.\r\n     */\r\n    public checkInputs(): void {\r\n        if (this._wheelDeltaX === 0 && this._wheelDeltaY === 0 && this._wheelDeltaZ == 0) {\r\n            return;\r\n        }\r\n\r\n        // Clear the camera properties that we might be updating.\r\n        this._moveRelative.setAll(0);\r\n        this._rotateRelative.setAll(0);\r\n        this._moveScene.setAll(0);\r\n\r\n        // Set the camera properties that are to be updated.\r\n        this._updateCamera();\r\n\r\n        if (this.camera.getScene().useRightHandedSystem) {\r\n            // TODO: Does this need done for worldUpdate too?\r\n            this._moveRelative.z *= -1;\r\n        }\r\n\r\n        // Convert updates relative to camera to world position update.\r\n        const cameraTransformMatrix = Matrix.Zero();\r\n        this.camera.getViewMatrix().invertToRef(cameraTransformMatrix);\r\n\r\n        const transformedDirection = Vector3.Zero();\r\n        Vector3.TransformNormalToRef(this._moveRelative, cameraTransformMatrix, transformedDirection);\r\n\r\n        // Apply updates to camera position.\r\n        this.camera.cameraRotation.x += this._rotateRelative.x / 200;\r\n        this.camera.cameraRotation.y += this._rotateRelative.y / 200;\r\n        this.camera.cameraDirection.addInPlace(transformedDirection);\r\n        this.camera.cameraDirection.addInPlace(this._moveScene);\r\n\r\n        // Call the base class implementation to handle observers and do cleanup.\r\n        super.checkInputs();\r\n    }\r\n\r\n    private _moveRelative = Vector3.Zero();\r\n    private _rotateRelative = Vector3.Zero();\r\n    private _moveScene = Vector3.Zero();\r\n\r\n    /**\r\n     * These are set to the desired default behaviour.\r\n     */\r\n    private _wheelXAction: Nullable<_CameraProperty> = _CameraProperty.MoveRelative;\r\n    private _wheelXActionCoordinate: Nullable<Coordinate> = Coordinate.X;\r\n    private _wheelYAction: Nullable<_CameraProperty> = _CameraProperty.MoveRelative;\r\n    private _wheelYActionCoordinate: Nullable<Coordinate> = Coordinate.Z;\r\n    private _wheelZAction: Nullable<_CameraProperty> = null;\r\n    private _wheelZActionCoordinate: Nullable<Coordinate> = null;\r\n\r\n    /**\r\n     * Update the camera according to any configured properties for the 3\r\n     * mouse-wheel axis.\r\n     */\r\n    private _updateCamera(): void {\r\n        // Do the camera updates for each of the 3 touch-wheel axis.\r\n        this._updateCameraProperty(this._wheelDeltaX, this._wheelXAction, this._wheelXActionCoordinate);\r\n        this._updateCameraProperty(this._wheelDeltaY, this._wheelYAction, this._wheelYActionCoordinate);\r\n        this._updateCameraProperty(this._wheelDeltaZ, this._wheelZAction, this._wheelZActionCoordinate);\r\n    }\r\n\r\n    /**\r\n     * Update one property of the camera.\r\n     * @param value\r\n     * @param cameraProperty\r\n     * @param coordinate\r\n     */\r\n    private _updateCameraProperty(\r\n        /* Mouse-wheel delta. */\r\n        value: number,\r\n        /* Camera property to be changed. */\r\n        cameraProperty: Nullable<_CameraProperty>,\r\n        /* Axis of Camera property to be changed. */\r\n        coordinate: Nullable<Coordinate>\r\n    ): void {\r\n        if (value === 0) {\r\n            // Mouse wheel has not moved.\r\n            return;\r\n        }\r\n        if (cameraProperty === null || coordinate === null) {\r\n            // Mouse wheel axis not configured.\r\n            return;\r\n        }\r\n\r\n        let action = null;\r\n        switch (cameraProperty) {\r\n            case _CameraProperty.MoveRelative:\r\n                action = this._moveRelative;\r\n                break;\r\n            case _CameraProperty.RotateRelative:\r\n                action = this._rotateRelative;\r\n                break;\r\n            case _CameraProperty.MoveScene:\r\n                action = this._moveScene;\r\n                break;\r\n        }\r\n\r\n        switch (coordinate) {\r\n            case Coordinate.X:\r\n                action.set(value, 0, 0);\r\n                break;\r\n            case Coordinate.Y:\r\n                action.set(0, value, 0);\r\n                break;\r\n            case Coordinate.Z:\r\n                action.set(0, 0, value);\r\n                break;\r\n        }\r\n    }\r\n}\r\n\r\n(<any>CameraInputTypes)[\"FreeCameraMouseWheelInput\"] = FreeCameraMouseWheelInput;\r\n", "import { serialize } from \"../../Misc/decorators\";\r\nimport type { Observer, EventState } from \"../../Misc/observable\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { ICameraInput } from \"../../Cameras/cameraInputsManager\";\r\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager\";\r\nimport type { FreeCamera } from \"../../Cameras/freeCamera\";\r\nimport type { PointerInfo } from \"../../Events/pointerEvents\";\r\nimport { PointerEventTypes } from \"../../Events/pointerEvents\";\r\nimport { Matrix, Vector3 } from \"../../Maths/math.vector\";\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport type { IPointerEvent } from \"../../Events/deviceInputEvents\";\r\n/**\r\n * Manage the touch inputs to control the movement of a free camera.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n */\r\nexport class FreeCameraTouchInput implements ICameraInput<FreeCamera> {\r\n    /**\r\n     * Defines the camera the input is attached to.\r\n     */\r\n    public camera: FreeCamera;\r\n\r\n    /**\r\n     * Defines the touch sensibility for rotation.\r\n     * The lower the faster.\r\n     */\r\n    @serialize()\r\n    public touchAngularSensibility: number = 200000.0;\r\n\r\n    /**\r\n     * Defines the touch sensibility for move.\r\n     * The lower the faster.\r\n     */\r\n    @serialize()\r\n    public touchMoveSensibility: number = 250.0;\r\n\r\n    /**\r\n     * Swap touch actions so that one touch is used for rotation and multiple for movement\r\n     */\r\n    public singleFingerRotate: boolean = false;\r\n\r\n    private _offsetX: Nullable<number> = null;\r\n    private _offsetY: Nullable<number> = null;\r\n\r\n    private _pointerPressed = new Array<number>();\r\n    private _pointerInput?: (p: PointerInfo, s: EventState) => void;\r\n    private _observer: Nullable<Observer<PointerInfo>>;\r\n    private _onLostFocus: Nullable<(e: FocusEvent) => any>;\r\n    private _isSafari: boolean;\r\n\r\n    /**\r\n     * Manage the touch inputs to control the movement of a free camera.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n     * @param allowMouse Defines if mouse events can be treated as touch events\r\n     */\r\n    constructor(\r\n        /**\r\n         * Define if mouse events can be treated as touch events\r\n         */\r\n        public allowMouse = false\r\n    ) {\r\n        this._isSafari = Tools.IsSafari();\r\n    }\r\n\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachControl(noPreventDefault?: boolean): void {\r\n        // eslint-disable-next-line prefer-rest-params\r\n        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\r\n        let previousPosition: Nullable<{ x: number; y: number }> = null;\r\n\r\n        if (this._pointerInput === undefined) {\r\n            this._onLostFocus = () => {\r\n                this._offsetX = null;\r\n                this._offsetY = null;\r\n            };\r\n\r\n            this._pointerInput = (p) => {\r\n                const evt = <IPointerEvent>p.event;\r\n\r\n                const isMouseEvent = evt.pointerType === \"mouse\" || (this._isSafari && typeof evt.pointerType === \"undefined\");\r\n\r\n                if (!this.allowMouse && isMouseEvent) {\r\n                    return;\r\n                }\r\n\r\n                if (p.type === PointerEventTypes.POINTERDOWN) {\r\n                    if (!noPreventDefault) {\r\n                        evt.preventDefault();\r\n                    }\r\n\r\n                    this._pointerPressed.push(evt.pointerId);\r\n\r\n                    if (this._pointerPressed.length !== 1) {\r\n                        return;\r\n                    }\r\n\r\n                    previousPosition = {\r\n                        x: evt.clientX,\r\n                        y: evt.clientY,\r\n                    };\r\n                } else if (p.type === PointerEventTypes.POINTERUP) {\r\n                    if (!noPreventDefault) {\r\n                        evt.preventDefault();\r\n                    }\r\n\r\n                    const index: number = this._pointerPressed.indexOf(evt.pointerId);\r\n\r\n                    if (index === -1) {\r\n                        return;\r\n                    }\r\n                    this._pointerPressed.splice(index, 1);\r\n\r\n                    if (index != 0) {\r\n                        return;\r\n                    }\r\n                    previousPosition = null;\r\n                    this._offsetX = null;\r\n                    this._offsetY = null;\r\n                } else if (p.type === PointerEventTypes.POINTERMOVE) {\r\n                    if (!noPreventDefault) {\r\n                        evt.preventDefault();\r\n                    }\r\n\r\n                    if (!previousPosition) {\r\n                        return;\r\n                    }\r\n\r\n                    const index: number = this._pointerPressed.indexOf(evt.pointerId);\r\n\r\n                    if (index != 0) {\r\n                        return;\r\n                    }\r\n\r\n                    this._offsetX = evt.clientX - previousPosition.x;\r\n                    this._offsetY = -(evt.clientY - previousPosition.y);\r\n                }\r\n            };\r\n        }\r\n\r\n        this._observer = this.camera\r\n            .getScene()\r\n            ._inputManager._addCameraPointerObserver(this._pointerInput, PointerEventTypes.POINTERDOWN | PointerEventTypes.POINTERUP | PointerEventTypes.POINTERMOVE);\r\n\r\n        if (this._onLostFocus) {\r\n            const engine = this.camera.getEngine();\r\n            const element = engine.getInputElement();\r\n            element && element.addEventListener(\"blur\", this._onLostFocus);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     */\r\n    public detachControl(): void {\r\n        if (this._pointerInput) {\r\n            if (this._observer) {\r\n                this.camera.getScene()._inputManager._removeCameraPointerObserver(this._observer);\r\n                this._observer = null;\r\n            }\r\n\r\n            if (this._onLostFocus) {\r\n                const engine = this.camera.getEngine();\r\n                const element = engine.getInputElement();\r\n                element && element.removeEventListener(\"blur\", this._onLostFocus);\r\n                this._onLostFocus = null;\r\n            }\r\n            this._pointerPressed.length = 0;\r\n            this._offsetX = null;\r\n            this._offsetY = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Update the current camera state depending on the inputs that have been used this frame.\r\n     * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.\r\n     */\r\n    public checkInputs(): void {\r\n        if (this._offsetX === null || this._offsetY === null) {\r\n            return;\r\n        }\r\n        if (this._offsetX === 0 && this._offsetY === 0) {\r\n            return;\r\n        }\r\n\r\n        const camera = this.camera;\r\n        const handednessMultiplier = camera._calculateHandednessMultiplier();\r\n        camera.cameraRotation.y = (handednessMultiplier * this._offsetX) / this.touchAngularSensibility;\r\n\r\n        const rotateCamera = (this.singleFingerRotate && this._pointerPressed.length === 1) || (!this.singleFingerRotate && this._pointerPressed.length > 1);\r\n\r\n        if (rotateCamera) {\r\n            camera.cameraRotation.x = -this._offsetY / this.touchAngularSensibility;\r\n        } else {\r\n            const speed = camera._computeLocalCameraSpeed();\r\n            const direction = new Vector3(0, 0, this.touchMoveSensibility !== 0 ? (speed * this._offsetY) / this.touchMoveSensibility : 0);\r\n\r\n            Matrix.RotationYawPitchRollToRef(camera.rotation.y, camera.rotation.x, 0, camera._cameraRotationMatrix);\r\n            camera.cameraDirection.addInPlace(Vector3.TransformCoordinates(direction, camera._cameraRotationMatrix));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the current input.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"FreeCameraTouchInput\";\r\n    }\r\n\r\n    /**\r\n     * Get the friendly name associated with the input class.\r\n     * @returns the input friendly name\r\n     */\r\n    public getSimpleName(): string {\r\n        return \"touch\";\r\n    }\r\n}\r\n\r\n(<any>CameraInputTypes)[\"FreeCameraTouchInput\"] = FreeCameraTouchInput;\r\n", "import type { FreeCamera } from \"./freeCamera\";\r\nimport { CameraInputsManager } from \"./cameraInputsManager\";\r\nimport { FreeCameraKeyboardMoveInput } from \"../Cameras/Inputs/freeCameraKeyboardMoveInput\";\r\nimport { FreeCameraMouseInput } from \"../Cameras/Inputs/freeCameraMouseInput\";\r\nimport { FreeCameraMouseWheelInput } from \"../Cameras/Inputs/freeCameraMouseWheelInput\";\r\nimport { FreeCameraTouchInput } from \"../Cameras/Inputs/freeCameraTouchInput\";\r\nimport type { Nullable } from \"../types\";\r\n\r\n/**\r\n * Default Inputs manager for the FreeCamera.\r\n * It groups all the default supported inputs for ease of use.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n */\r\nexport class FreeCameraInputsManager extends CameraInputsManager<FreeCamera> {\r\n    /**\r\n     * @internal\r\n     */\r\n    public _mouseInput: Nullable<FreeCameraMouseInput> = null;\r\n    /**\r\n     * @internal\r\n     */\r\n    public _mouseWheelInput: Nullable<FreeCameraMouseWheelInput> = null;\r\n    /**\r\n     * Instantiates a new FreeCameraInputsManager.\r\n     * @param camera Defines the camera the inputs belong to\r\n     */\r\n    constructor(camera: FreeCamera) {\r\n        super(camera);\r\n    }\r\n\r\n    /**\r\n     * Add keyboard input support to the input manager.\r\n     * @returns the current input manager\r\n     */\r\n    addKeyboard(): FreeCameraInputsManager {\r\n        this.add(new FreeCameraKeyboardMoveInput());\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Add mouse input support to the input manager.\r\n     * @param touchEnabled if the FreeCameraMouseInput should support touch (default: true)\r\n     * @returns the current input manager\r\n     */\r\n    addMouse(touchEnabled = true): FreeCameraInputsManager {\r\n        if (!this._mouseInput) {\r\n            this._mouseInput = new FreeCameraMouseInput(touchEnabled);\r\n            this.add(this._mouseInput);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Removes the mouse input support from the manager\r\n     * @returns the current input manager\r\n     */\r\n    removeMouse(): FreeCameraInputsManager {\r\n        if (this._mouseInput) {\r\n            this.remove(this._mouseInput);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Add mouse wheel input support to the input manager.\r\n     * @returns the current input manager\r\n     */\r\n    addMouseWheel(): FreeCameraInputsManager {\r\n        if (!this._mouseWheelInput) {\r\n            this._mouseWheelInput = new FreeCameraMouseWheelInput();\r\n            this.add(this._mouseWheelInput);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Removes the mouse wheel input support from the manager\r\n     * @returns the current input manager\r\n     */\r\n    removeMouseWheel(): FreeCameraInputsManager {\r\n        if (this._mouseWheelInput) {\r\n            this.remove(this._mouseWheelInput);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Add touch input support to the input manager.\r\n     * @returns the current input manager\r\n     */\r\n    addTouch(): FreeCameraInputsManager {\r\n        this.add(new FreeCameraTouchInput());\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Remove all attached input methods from a camera\r\n     */\r\n    public clear(): void {\r\n        super.clear();\r\n        this._mouseInput = null;\r\n    }\r\n}\r\n", "import type { Nullable } from \"../types\";\r\nimport { serializeAsVector3, serialize } from \"../Misc/decorators\";\r\nimport { Vector3, Vector2 } from \"../Maths/math.vector\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Engine } from \"../Engines/engine\";\r\nimport { TargetCamera } from \"./targetCamera\";\r\nimport { FreeCameraInputsManager } from \"./freeCameraInputsManager\";\r\nimport type { FreeCameraMouseInput } from \"../Cameras/Inputs/freeCameraMouseInput\";\r\nimport type { FreeCameraKeyboardMoveInput } from \"../Cameras/Inputs/freeCameraKeyboardMoveInput\";\r\nimport { Tools } from \"../Misc/tools\";\r\n\r\nimport type { Collider } from \"../Collisions/collider\";\r\n\r\n/**\r\n * This represents a free type of camera. It can be useful in First Person Shooter game for instance.\r\n * Please consider using the new UniversalCamera instead as it adds more functionality like the gamepad.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_introduction#universal-camera\r\n */\r\nexport class FreeCamera extends TargetCamera {\r\n    /**\r\n     * Define the collision ellipsoid of the camera.\r\n     * This is helpful to simulate a camera body like the player body around the camera\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_collisions#arcrotatecamera\r\n     */\r\n    @serializeAsVector3()\r\n    public ellipsoid = new Vector3(0.5, 1, 0.5);\r\n\r\n    /**\r\n     * Define an offset for the position of the ellipsoid around the camera.\r\n     * This can be helpful to determine the center of the body near the gravity center of the body\r\n     * instead of its head.\r\n     */\r\n    @serializeAsVector3()\r\n    public ellipsoidOffset = new Vector3(0, 0, 0);\r\n\r\n    /**\r\n     * Enable or disable collisions of the camera with the rest of the scene objects.\r\n     */\r\n    @serialize()\r\n    public checkCollisions = false;\r\n\r\n    /**\r\n     * Enable or disable gravity on the camera.\r\n     */\r\n    @serialize()\r\n    public applyGravity = false;\r\n\r\n    /**\r\n     * Define the input manager associated to the camera.\r\n     */\r\n    public inputs: FreeCameraInputsManager;\r\n\r\n    /**\r\n     * Gets the input sensibility for a mouse input. (default is 2000.0)\r\n     * Higher values reduce sensitivity.\r\n     */\r\n    public get angularSensibility(): number {\r\n        const mouse = <FreeCameraMouseInput>this.inputs.attached[\"mouse\"];\r\n        if (mouse) {\r\n            return mouse.angularSensibility;\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Sets the input sensibility for a mouse input. (default is 2000.0)\r\n     * Higher values reduce sensitivity.\r\n     */\r\n    public set angularSensibility(value: number) {\r\n        const mouse = <FreeCameraMouseInput>this.inputs.attached[\"mouse\"];\r\n        if (mouse) {\r\n            mouse.angularSensibility = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the forward move of the camera.\r\n     */\r\n    public get keysUp(): number[] {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysUp;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysUp(value: number[]) {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysUp = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the upward move of the camera.\r\n     */\r\n    public get keysUpward(): number[] {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysUpward;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysUpward(value: number[]) {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysUpward = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the backward move of the camera.\r\n     */\r\n    public get keysDown(): number[] {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysDown;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysDown(value: number[]) {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysDown = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the downward move of the camera.\r\n     */\r\n    public get keysDownward(): number[] {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysDownward;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysDownward(value: number[]) {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysDownward = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the left strafe move of the camera.\r\n     */\r\n    public get keysLeft(): number[] {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysLeft;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysLeft(value: number[]) {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysLeft = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the right strafe move of the camera.\r\n     */\r\n    public get keysRight(): number[] {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysRight;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysRight(value: number[]) {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysRight = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the left rotation move of the camera.\r\n     */\r\n    public get keysRotateLeft(): number[] {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysRotateLeft;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysRotateLeft(value: number[]) {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysRotateLeft = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the right rotation move of the camera.\r\n     */\r\n    public get keysRotateRight(): number[] {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysRotateRight;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysRotateRight(value: number[]) {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysRotateRight = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the up rotation move of the camera.\r\n     */\r\n    public get keysRotateUp(): number[] {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysRotateUp;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysRotateUp(value: number[]) {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysRotateUp = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the down rotation move of the camera.\r\n     */\r\n    public get keysRotateDown(): number[] {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysRotateDown;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysRotateDown(value: number[]) {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysRotateDown = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Event raised when the camera collide with a mesh in the scene.\r\n     */\r\n    public onCollide: (collidedMesh: AbstractMesh) => void;\r\n\r\n    private _collider: Collider;\r\n    private _needMoveForGravity = false;\r\n    private _oldPosition = Vector3.Zero();\r\n    private _diffPosition = Vector3.Zero();\r\n    private _newPosition = Vector3.Zero();\r\n\r\n    /** @internal */\r\n    public _localDirection: Vector3;\r\n    /** @internal */\r\n    public _transformedDirection: Vector3;\r\n\r\n    /**\r\n     * Instantiates a Free Camera.\r\n     * This represents a free type of camera. It can be useful in First Person Shooter game for instance.\r\n     * Please consider using the new UniversalCamera instead as it adds more functionality like touch to this camera.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_introduction#universal-camera\r\n     * @param name Define the name of the camera in the scene\r\n     * @param position Define the start position of the camera in the scene\r\n     * @param scene Define the scene the camera belongs to\r\n     * @param setActiveOnSceneIfNoneActive Defines whether the camera should be marked as active if not other active cameras have been defined\r\n     */\r\n    constructor(name: string, position: Vector3, scene?: Scene, setActiveOnSceneIfNoneActive = true) {\r\n        super(name, position, scene, setActiveOnSceneIfNoneActive);\r\n        this.inputs = new FreeCameraInputsManager(this);\r\n        this.inputs.addKeyboard().addMouse();\r\n    }\r\n\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachControl(noPreventDefault?: boolean): void;\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param ignored defines an ignored parameter kept for backward compatibility.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     * BACK COMPAT SIGNATURE ONLY.\r\n     */\r\n    public attachControl(ignored: any, noPreventDefault?: boolean): void;\r\n    /**\r\n     * Attached controls to the current camera.\r\n     * @param ignored defines an ignored parameter kept for backward compatibility.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachControl(ignored?: any, noPreventDefault?: boolean): void {\r\n        // eslint-disable-next-line prefer-rest-params\r\n        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\r\n        this.inputs.attachElement(noPreventDefault);\r\n    }\r\n\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     */\r\n    public detachControl(): void {\r\n        this.inputs.detachElement();\r\n\r\n        this.cameraDirection = new Vector3(0, 0, 0);\r\n        this.cameraRotation = new Vector2(0, 0);\r\n    }\r\n\r\n    // Collisions\r\n    private _collisionMask = -1;\r\n\r\n    /**\r\n     * Define a collision mask to limit the list of object the camera can collide with\r\n     */\r\n    public get collisionMask(): number {\r\n        return this._collisionMask;\r\n    }\r\n\r\n    public set collisionMask(mask: number) {\r\n        this._collisionMask = !isNaN(mask) ? mask : -1;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _collideWithWorld(displacement: Vector3): void {\r\n        let globalPosition: Vector3;\r\n\r\n        if (this.parent) {\r\n            globalPosition = Vector3.TransformCoordinates(this.position, this.parent.getWorldMatrix());\r\n        } else {\r\n            globalPosition = this.position;\r\n        }\r\n\r\n        globalPosition.subtractFromFloatsToRef(0, this.ellipsoid.y, 0, this._oldPosition);\r\n        this._oldPosition.addInPlace(this.ellipsoidOffset);\r\n\r\n        const coordinator = this.getScene().collisionCoordinator;\r\n        if (!this._collider) {\r\n            this._collider = coordinator.createCollider();\r\n        }\r\n\r\n        this._collider._radius = this.ellipsoid;\r\n        this._collider.collisionMask = this._collisionMask;\r\n\r\n        //no need for clone, as long as gravity is not on.\r\n        let actualDisplacement = displacement;\r\n\r\n        //add gravity to the direction to prevent the dual-collision checking\r\n        if (this.applyGravity) {\r\n            //this prevents mending with cameraDirection, a global variable of the free camera class.\r\n            actualDisplacement = displacement.add(this.getScene().gravity);\r\n        }\r\n\r\n        coordinator.getNewPosition(this._oldPosition, actualDisplacement, this._collider, 3, null, this._onCollisionPositionChange, this.uniqueId);\r\n    }\r\n\r\n    private _onCollisionPositionChange = (collisionId: number, newPosition: Vector3, collidedMesh: Nullable<AbstractMesh> = null) => {\r\n        this._newPosition.copyFrom(newPosition);\r\n\r\n        this._newPosition.subtractToRef(this._oldPosition, this._diffPosition);\r\n\r\n        if (this._diffPosition.length() > Engine.CollisionsEpsilon) {\r\n            this.position.addToRef(this._diffPosition, this._deferredPositionUpdate);\r\n            if (!this._deferOnly) {\r\n                this.position.copyFrom(this._deferredPositionUpdate);\r\n            } else {\r\n                this._deferredUpdated = true;\r\n            }\r\n            // call onCollide, if defined. Note that in case of deferred update, the actual position change might happen in the next frame.\r\n            if (this.onCollide && collidedMesh) {\r\n                this.onCollide(collidedMesh);\r\n            }\r\n        }\r\n    };\r\n\r\n    /** @internal */\r\n    public _checkInputs(): void {\r\n        if (!this._localDirection) {\r\n            this._localDirection = Vector3.Zero();\r\n            this._transformedDirection = Vector3.Zero();\r\n        }\r\n\r\n        this.inputs.checkInputs();\r\n\r\n        super._checkInputs();\r\n    }\r\n\r\n    /**\r\n     * Enable movement without a user input. This allows gravity to always be applied.\r\n     */\r\n    public set needMoveForGravity(value: boolean) {\r\n        this._needMoveForGravity = value;\r\n    }\r\n\r\n    /**\r\n     * When true, gravity is applied whether there is user input or not.\r\n     */\r\n    public get needMoveForGravity(): boolean {\r\n        return this._needMoveForGravity;\r\n    }\r\n\r\n    /** @internal */\r\n    public _decideIfNeedsToMove(): boolean {\r\n        return this._needMoveForGravity || Math.abs(this.cameraDirection.x) > 0 || Math.abs(this.cameraDirection.y) > 0 || Math.abs(this.cameraDirection.z) > 0;\r\n    }\r\n\r\n    /** @internal */\r\n    public _updatePosition(): void {\r\n        if (this.checkCollisions && this.getScene().collisionsEnabled) {\r\n            this._collideWithWorld(this.cameraDirection);\r\n        } else {\r\n            super._updatePosition();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Destroy the camera and release the current resources hold by it.\r\n     */\r\n    public dispose(): void {\r\n        this.inputs.clear();\r\n        super.dispose();\r\n    }\r\n\r\n    /**\r\n     * Gets the current object class name.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"FreeCamera\";\r\n    }\r\n}\r\n", "import { serialize, serializeAsColor3, expandToProperty } from \"../Misc/decorators\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { Matrix } from \"../Maths/math.vector\";\r\nimport { Vector3 } from \"../Maths/math.vector\";\r\nimport { Color3, TmpColors } from \"../Maths/math.color\";\r\nimport { Node } from \"../node\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport { UniformBuffer } from \"../Materials/uniformBuffer\";\r\nimport type { IShadowGenerator } from \"./Shadows/shadowGenerator\";\r\nimport { GetClass } from \"../Misc/typeStore\";\r\nimport type { ISortableLight } from \"./lightConstants\";\r\nimport { LightConstants } from \"./lightConstants\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport { SerializationHelper } from \"../Misc/decorators.serialization\";\r\n\r\n/**\r\n * Base class of all the lights in Babylon. It groups all the generic information about lights.\r\n * Lights are used, as you would expect, to affect how meshes are seen, in terms of both illumination and colour.\r\n * All meshes allow light to pass through them unless shadow generation is activated. The default number of lights allowed is four but this can be increased.\r\n */\r\nexport abstract class Light extends Node implements ISortableLight {\r\n    /**\r\n     * Falloff Default: light is falling off following the material specification:\r\n     * standard material is using standard falloff whereas pbr material can request special falloff per materials.\r\n     */\r\n    public static readonly FALLOFF_DEFAULT = LightConstants.FALLOFF_DEFAULT;\r\n\r\n    /**\r\n     * Falloff Physical: light is falling off following the inverse squared distance law.\r\n     */\r\n    public static readonly FALLOFF_PHYSICAL = LightConstants.FALLOFF_PHYSICAL;\r\n\r\n    /**\r\n     * Falloff gltf: light is falling off as described in the gltf moving to PBR document\r\n     * to enhance interoperability with other engines.\r\n     */\r\n    public static readonly FALLOFF_GLTF = LightConstants.FALLOFF_GLTF;\r\n\r\n    /**\r\n     * Falloff Standard: light is falling off like in the standard material\r\n     * to enhance interoperability with other materials.\r\n     */\r\n    public static readonly FALLOFF_STANDARD = LightConstants.FALLOFF_STANDARD;\r\n\r\n    //lightmapMode Consts\r\n    /**\r\n     * If every light affecting the material is in this lightmapMode,\r\n     * material.lightmapTexture adds or multiplies\r\n     * (depends on material.useLightmapAsShadowmap)\r\n     * after every other light calculations.\r\n     */\r\n    public static readonly LIGHTMAP_DEFAULT = LightConstants.LIGHTMAP_DEFAULT;\r\n    /**\r\n     * material.lightmapTexture as only diffuse lighting from this light\r\n     * adds only specular lighting from this light\r\n     * adds dynamic shadows\r\n     */\r\n    public static readonly LIGHTMAP_SPECULAR = LightConstants.LIGHTMAP_SPECULAR;\r\n    /**\r\n     * material.lightmapTexture as only lighting\r\n     * no light calculation from this light\r\n     * only adds dynamic shadows from this light\r\n     */\r\n    public static readonly LIGHTMAP_SHADOWSONLY = LightConstants.LIGHTMAP_SHADOWSONLY;\r\n\r\n    // Intensity Mode Consts\r\n    /**\r\n     * Each light type uses the default quantity according to its type:\r\n     *      point/spot lights use luminous intensity\r\n     *      directional lights use illuminance\r\n     */\r\n    public static readonly INTENSITYMODE_AUTOMATIC = LightConstants.INTENSITYMODE_AUTOMATIC;\r\n    /**\r\n     * lumen (lm)\r\n     */\r\n    public static readonly INTENSITYMODE_LUMINOUSPOWER = LightConstants.INTENSITYMODE_LUMINOUSPOWER;\r\n    /**\r\n     * candela (lm/sr)\r\n     */\r\n    public static readonly INTENSITYMODE_LUMINOUSINTENSITY = LightConstants.INTENSITYMODE_LUMINOUSINTENSITY;\r\n    /**\r\n     * lux (lm/m^2)\r\n     */\r\n    public static readonly INTENSITYMODE_ILLUMINANCE = LightConstants.INTENSITYMODE_ILLUMINANCE;\r\n    /**\r\n     * nit (cd/m^2)\r\n     */\r\n    public static readonly INTENSITYMODE_LUMINANCE = LightConstants.INTENSITYMODE_LUMINANCE;\r\n\r\n    // Light types ids const.\r\n    /**\r\n     * Light type const id of the point light.\r\n     */\r\n    public static readonly LIGHTTYPEID_POINTLIGHT = LightConstants.LIGHTTYPEID_POINTLIGHT;\r\n    /**\r\n     * Light type const id of the directional light.\r\n     */\r\n    public static readonly LIGHTTYPEID_DIRECTIONALLIGHT = LightConstants.LIGHTTYPEID_DIRECTIONALLIGHT;\r\n    /**\r\n     * Light type const id of the spot light.\r\n     */\r\n    public static readonly LIGHTTYPEID_SPOTLIGHT = LightConstants.LIGHTTYPEID_SPOTLIGHT;\r\n    /**\r\n     * Light type const id of the hemispheric light.\r\n     */\r\n    public static readonly LIGHTTYPEID_HEMISPHERICLIGHT = LightConstants.LIGHTTYPEID_HEMISPHERICLIGHT;\r\n\r\n    /**\r\n     * Diffuse gives the basic color to an object.\r\n     */\r\n    @serializeAsColor3()\r\n    public diffuse = new Color3(1.0, 1.0, 1.0);\r\n\r\n    /**\r\n     * Specular produces a highlight color on an object.\r\n     * Note: This is not affecting PBR materials.\r\n     */\r\n    @serializeAsColor3()\r\n    public specular = new Color3(1.0, 1.0, 1.0);\r\n\r\n    /**\r\n     * Defines the falloff type for this light. This lets overriding how punctual light are\r\n     * falling off base on range or angle.\r\n     * This can be set to any values in Light.FALLOFF_x.\r\n     *\r\n     * Note: This is only useful for PBR Materials at the moment. This could be extended if required to\r\n     * other types of materials.\r\n     */\r\n    @serialize()\r\n    public falloffType = Light.FALLOFF_DEFAULT;\r\n\r\n    /**\r\n     * Strength of the light.\r\n     * Note: By default it is define in the framework own unit.\r\n     * Note: In PBR materials the intensityMode can be use to chose what unit the intensity is defined in.\r\n     */\r\n    @serialize()\r\n    public intensity = 1.0;\r\n\r\n    private _range = Number.MAX_VALUE;\r\n    protected _inverseSquaredRange = 0;\r\n\r\n    /**\r\n     * Defines how far from the source the light is impacting in scene units.\r\n     * Note: Unused in PBR material as the distance light falloff is defined following the inverse squared falloff.\r\n     */\r\n    @serialize()\r\n    public get range(): number {\r\n        return this._range;\r\n    }\r\n    /**\r\n     * Defines how far from the source the light is impacting in scene units.\r\n     * Note: Unused in PBR material as the distance light falloff is defined following the inverse squared falloff.\r\n     */\r\n    public set range(value: number) {\r\n        this._range = value;\r\n        this._inverseSquaredRange = 1.0 / (this.range * this.range);\r\n    }\r\n\r\n    /**\r\n     * Cached photometric scale default to 1.0 as the automatic intensity mode defaults to 1.0 for every type\r\n     * of light.\r\n     */\r\n    private _photometricScale = 1.0;\r\n\r\n    private _intensityMode: number = Light.INTENSITYMODE_AUTOMATIC;\r\n    /**\r\n     * Gets the photometric scale used to interpret the intensity.\r\n     * This is only relevant with PBR Materials where the light intensity can be defined in a physical way.\r\n     */\r\n    @serialize()\r\n    public get intensityMode(): number {\r\n        return this._intensityMode;\r\n    }\r\n    /**\r\n     * Sets the photometric scale used to interpret the intensity.\r\n     * This is only relevant with PBR Materials where the light intensity can be defined in a physical way.\r\n     */\r\n    public set intensityMode(value: number) {\r\n        this._intensityMode = value;\r\n        this._computePhotometricScale();\r\n    }\r\n\r\n    private _radius = 0.00001;\r\n    /**\r\n     * Gets the light radius used by PBR Materials to simulate soft area lights.\r\n     */\r\n    @serialize()\r\n    public get radius(): number {\r\n        return this._radius;\r\n    }\r\n    /**\r\n     * sets the light radius used by PBR Materials to simulate soft area lights.\r\n     */\r\n    public set radius(value: number) {\r\n        this._radius = value;\r\n        this._computePhotometricScale();\r\n    }\r\n\r\n    @serialize()\r\n    private _renderPriority: number;\r\n    /**\r\n     * Defines the rendering priority of the lights. It can help in case of fallback or number of lights\r\n     * exceeding the number allowed of the materials.\r\n     */\r\n    @expandToProperty(\"_reorderLightsInScene\")\r\n    public renderPriority: number = 0;\r\n\r\n    @serialize(\"shadowEnabled\")\r\n    private _shadowEnabled: boolean = true;\r\n    /**\r\n     * Gets whether or not the shadows are enabled for this light. This can help turning off/on shadow without detaching\r\n     * the current shadow generator.\r\n     */\r\n    public get shadowEnabled(): boolean {\r\n        return this._shadowEnabled;\r\n    }\r\n    /**\r\n     * Sets whether or not the shadows are enabled for this light. This can help turning off/on shadow without detaching\r\n     * the current shadow generator.\r\n     */\r\n    public set shadowEnabled(value: boolean) {\r\n        if (this._shadowEnabled === value) {\r\n            return;\r\n        }\r\n\r\n        this._shadowEnabled = value;\r\n        this._markMeshesAsLightDirty();\r\n    }\r\n\r\n    private _includedOnlyMeshes: AbstractMesh[];\r\n    /**\r\n     * Gets the only meshes impacted by this light.\r\n     */\r\n    public get includedOnlyMeshes(): AbstractMesh[] {\r\n        return this._includedOnlyMeshes;\r\n    }\r\n    /**\r\n     * Sets the only meshes impacted by this light.\r\n     */\r\n    public set includedOnlyMeshes(value: AbstractMesh[]) {\r\n        this._includedOnlyMeshes = value;\r\n        this._hookArrayForIncludedOnly(value);\r\n    }\r\n\r\n    private _excludedMeshes: AbstractMesh[];\r\n    /**\r\n     * Gets the meshes not impacted by this light.\r\n     */\r\n    public get excludedMeshes(): AbstractMesh[] {\r\n        return this._excludedMeshes;\r\n    }\r\n    /**\r\n     * Sets the meshes not impacted by this light.\r\n     */\r\n    public set excludedMeshes(value: AbstractMesh[]) {\r\n        this._excludedMeshes = value;\r\n        this._hookArrayForExcluded(value);\r\n    }\r\n\r\n    @serialize(\"excludeWithLayerMask\")\r\n    private _excludeWithLayerMask = 0;\r\n    /**\r\n     * Gets the layer id use to find what meshes are not impacted by the light.\r\n     * Inactive if 0\r\n     */\r\n    public get excludeWithLayerMask(): number {\r\n        return this._excludeWithLayerMask;\r\n    }\r\n    /**\r\n     * Sets the layer id use to find what meshes are not impacted by the light.\r\n     * Inactive if 0\r\n     */\r\n    public set excludeWithLayerMask(value: number) {\r\n        this._excludeWithLayerMask = value;\r\n        this._resyncMeshes();\r\n    }\r\n\r\n    @serialize(\"includeOnlyWithLayerMask\")\r\n    private _includeOnlyWithLayerMask = 0;\r\n    /**\r\n     * Gets the layer id use to find what meshes are impacted by the light.\r\n     * Inactive if 0\r\n     */\r\n    public get includeOnlyWithLayerMask(): number {\r\n        return this._includeOnlyWithLayerMask;\r\n    }\r\n    /**\r\n     * Sets the layer id use to find what meshes are impacted by the light.\r\n     * Inactive if 0\r\n     */\r\n    public set includeOnlyWithLayerMask(value: number) {\r\n        this._includeOnlyWithLayerMask = value;\r\n        this._resyncMeshes();\r\n    }\r\n\r\n    @serialize(\"lightmapMode\")\r\n    private _lightmapMode = 0;\r\n    /**\r\n     * Gets the lightmap mode of this light (should be one of the constants defined by Light.LIGHTMAP_x)\r\n     */\r\n    public get lightmapMode(): number {\r\n        return this._lightmapMode;\r\n    }\r\n    /**\r\n     * Sets the lightmap mode of this light (should be one of the constants defined by Light.LIGHTMAP_x)\r\n     */\r\n    public set lightmapMode(value: number) {\r\n        if (this._lightmapMode === value) {\r\n            return;\r\n        }\r\n\r\n        this._lightmapMode = value;\r\n        this._markMeshesAsLightDirty();\r\n    }\r\n\r\n    /**\r\n     * Returns the view matrix.\r\n     * @param _faceIndex The index of the face for which we want to extract the view matrix. Only used for point light types.\r\n     * @returns The view matrix. Can be null, if a view matrix cannot be defined for the type of light considered (as for a hemispherical light, for example).\r\n     */\r\n    public getViewMatrix(_faceIndex?: number): Nullable<Matrix> {\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Returns the projection matrix.\r\n     * Note that viewMatrix and renderList are optional and are only used by lights that calculate the projection matrix from a list of meshes (e.g. directional lights with automatic extents calculation).\r\n     * @param _viewMatrix The view transform matrix of the light (optional).\r\n     * @param _renderList The list of meshes to take into account when calculating the projection matrix (optional).\r\n     * @returns The projection matrix. Can be null, if a projection matrix cannot be defined for the type of light considered (as for a hemispherical light, for example).\r\n     */\r\n    public getProjectionMatrix(_viewMatrix?: Matrix, _renderList?: Array<AbstractMesh>): Nullable<Matrix> {\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Shadow generators associated to the light.\r\n     * @internal Internal use only.\r\n     */\r\n    public _shadowGenerators: Nullable<Map<Nullable<Camera>, IShadowGenerator>> = null;\r\n\r\n    /**\r\n     * @internal Internal use only.\r\n     */\r\n    public _excludedMeshesIds = new Array<string>();\r\n\r\n    /**\r\n     * @internal Internal use only.\r\n     */\r\n    public _includedOnlyMeshesIds = new Array<string>();\r\n\r\n    /**\r\n     * The current light uniform buffer.\r\n     * @internal Internal use only.\r\n     */\r\n    public _uniformBuffer: UniformBuffer;\r\n\r\n    /** @internal */\r\n    public _renderId: number;\r\n\r\n    private _lastUseSpecular: boolean;\r\n\r\n    /**\r\n     * Creates a Light object in the scene.\r\n     * Documentation : https://doc.babylonjs.com/features/featuresDeepDive/lights/lights_introduction\r\n     * @param name The friendly name of the light\r\n     * @param scene The scene the light belongs too\r\n     */\r\n    constructor(name: string, scene?: Scene) {\r\n        super(name, scene);\r\n        this.getScene().addLight(this);\r\n        this._uniformBuffer = new UniformBuffer(this.getScene().getEngine(), undefined, undefined, name);\r\n        this._buildUniformLayout();\r\n\r\n        this.includedOnlyMeshes = [] as AbstractMesh[];\r\n        this.excludedMeshes = [] as AbstractMesh[];\r\n\r\n        this._resyncMeshes();\r\n    }\r\n\r\n    protected abstract _buildUniformLayout(): void;\r\n\r\n    /**\r\n     * Sets the passed Effect \"effect\" with the Light information.\r\n     * @param effect The effect to update\r\n     * @param lightIndex The index of the light in the effect to update\r\n     * @returns The light\r\n     */\r\n    public abstract transferToEffect(effect: Effect, lightIndex: string): Light;\r\n\r\n    /**\r\n     * Sets the passed Effect \"effect\" with the Light textures.\r\n     * @param effect The effect to update\r\n     * @param lightIndex The index of the light in the effect to update\r\n     * @returns The light\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public transferTexturesToEffect(effect: Effect, lightIndex: string): Light {\r\n        // Do nothing by default.\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Binds the lights information from the scene to the effect for the given mesh.\r\n     * @param lightIndex Light index\r\n     * @param scene The scene where the light belongs to\r\n     * @param effect The effect we are binding the data to\r\n     * @param useSpecular Defines if specular is supported\r\n     * @param receiveShadows Defines if the effect (mesh) we bind the light for receives shadows\r\n     */\r\n    public _bindLight(lightIndex: number, scene: Scene, effect: Effect, useSpecular: boolean, receiveShadows = true): void {\r\n        const iAsString = lightIndex.toString();\r\n        let needUpdate = false;\r\n\r\n        this._uniformBuffer.bindToEffect(effect, \"Light\" + iAsString);\r\n\r\n        if (this._renderId !== scene.getRenderId() || this._lastUseSpecular !== useSpecular || !this._uniformBuffer.useUbo) {\r\n            this._renderId = scene.getRenderId();\r\n            this._lastUseSpecular = useSpecular;\r\n\r\n            const scaledIntensity = this.getScaledIntensity();\r\n\r\n            this.transferToEffect(effect, iAsString);\r\n\r\n            this.diffuse.scaleToRef(scaledIntensity, TmpColors.Color3[0]);\r\n            this._uniformBuffer.updateColor4(\"vLightDiffuse\", TmpColors.Color3[0], this.range, iAsString);\r\n            if (useSpecular) {\r\n                this.specular.scaleToRef(scaledIntensity, TmpColors.Color3[1]);\r\n                this._uniformBuffer.updateColor4(\"vLightSpecular\", TmpColors.Color3[1], this.radius, iAsString);\r\n            }\r\n            needUpdate = true;\r\n        }\r\n\r\n        // Textures might still need to be rebound.\r\n        this.transferTexturesToEffect(effect, iAsString);\r\n\r\n        // Shadows\r\n        if (scene.shadowsEnabled && this.shadowEnabled && receiveShadows) {\r\n            const shadowGenerator = this.getShadowGenerator(scene.activeCamera) ?? this.getShadowGenerator();\r\n            if (shadowGenerator) {\r\n                shadowGenerator.bindShadowLight(iAsString, effect);\r\n                needUpdate = true;\r\n            }\r\n        }\r\n\r\n        if (needUpdate) {\r\n            this._uniformBuffer.update();\r\n        } else {\r\n            this._uniformBuffer.bindUniformBuffer();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the passed Effect \"effect\" with the Light information.\r\n     * @param effect The effect to update\r\n     * @param lightDataUniformName The uniform used to store light data (position or direction)\r\n     * @returns The light\r\n     */\r\n    public abstract transferToNodeMaterialEffect(effect: Effect, lightDataUniformName: string): Light;\r\n\r\n    /**\r\n     * Returns the string \"Light\".\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"Light\";\r\n    }\r\n\r\n    /** @internal */\r\n    public readonly _isLight = true;\r\n\r\n    /**\r\n     * Converts the light information to a readable string for debug purpose.\r\n     * @param fullDetails Supports for multiple levels of logging within scene loading\r\n     * @returns the human readable light info\r\n     */\r\n    public toString(fullDetails?: boolean): string {\r\n        let ret = \"Name: \" + this.name;\r\n        ret += \", type: \" + [\"Point\", \"Directional\", \"Spot\", \"Hemispheric\"][this.getTypeID()];\r\n        if (this.animations) {\r\n            for (let i = 0; i < this.animations.length; i++) {\r\n                ret += \", animation[0]: \" + this.animations[i].toString(fullDetails);\r\n            }\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    /** @internal */\r\n    protected _syncParentEnabledState() {\r\n        super._syncParentEnabledState();\r\n        if (!this.isDisposed()) {\r\n            this._resyncMeshes();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set the enabled state of this node.\r\n     * @param value - the new enabled state\r\n     */\r\n    public setEnabled(value: boolean): void {\r\n        super.setEnabled(value);\r\n\r\n        this._resyncMeshes();\r\n    }\r\n\r\n    /**\r\n     * Returns the Light associated shadow generator if any.\r\n     * @param camera Camera for which the shadow generator should be retrieved (default: null). If null, retrieves the default shadow generator\r\n     * @returns the associated shadow generator.\r\n     */\r\n    public getShadowGenerator(camera: Nullable<Camera> = null): Nullable<IShadowGenerator> {\r\n        if (this._shadowGenerators === null) {\r\n            return null;\r\n        }\r\n\r\n        return this._shadowGenerators.get(camera) ?? null;\r\n    }\r\n\r\n    /**\r\n     * Returns all the shadow generators associated to this light\r\n     * @returns\r\n     */\r\n    public getShadowGenerators(): Nullable<Map<Nullable<Camera>, IShadowGenerator>> {\r\n        return this._shadowGenerators;\r\n    }\r\n\r\n    /**\r\n     * Returns a Vector3, the absolute light position in the World.\r\n     * @returns the world space position of the light\r\n     */\r\n    public getAbsolutePosition(): Vector3 {\r\n        return Vector3.Zero();\r\n    }\r\n\r\n    /**\r\n     * Specifies if the light will affect the passed mesh.\r\n     * @param mesh The mesh to test against the light\r\n     * @returns true the mesh is affected otherwise, false.\r\n     */\r\n    public canAffectMesh(mesh: AbstractMesh): boolean {\r\n        if (!mesh) {\r\n            return true;\r\n        }\r\n\r\n        if (this.includedOnlyMeshes && this.includedOnlyMeshes.length > 0 && this.includedOnlyMeshes.indexOf(mesh) === -1) {\r\n            return false;\r\n        }\r\n\r\n        if (this.excludedMeshes && this.excludedMeshes.length > 0 && this.excludedMeshes.indexOf(mesh) !== -1) {\r\n            return false;\r\n        }\r\n\r\n        if (this.includeOnlyWithLayerMask !== 0 && (this.includeOnlyWithLayerMask & mesh.layerMask) === 0) {\r\n            return false;\r\n        }\r\n\r\n        if (this.excludeWithLayerMask !== 0 && this.excludeWithLayerMask & mesh.layerMask) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Releases resources associated with this node.\r\n     * @param doNotRecurse Set to true to not recurse into each children (recurse into each children by default)\r\n     * @param disposeMaterialAndTextures Set to true to also dispose referenced materials and textures (false by default)\r\n     */\r\n    public dispose(doNotRecurse?: boolean, disposeMaterialAndTextures = false): void {\r\n        if (this._shadowGenerators) {\r\n            const iterator = this._shadowGenerators.values();\r\n            for (let key = iterator.next(); key.done !== true; key = iterator.next()) {\r\n                const shadowGenerator = key.value;\r\n                shadowGenerator.dispose();\r\n            }\r\n            this._shadowGenerators = null;\r\n        }\r\n\r\n        // Animations\r\n        this.getScene().stopAnimation(this);\r\n\r\n        if (this._parentContainer) {\r\n            const index = this._parentContainer.lights.indexOf(this);\r\n            if (index > -1) {\r\n                this._parentContainer.lights.splice(index, 1);\r\n            }\r\n            this._parentContainer = null;\r\n        }\r\n\r\n        // Remove from meshes\r\n        for (const mesh of this.getScene().meshes) {\r\n            mesh._removeLightSource(this, true);\r\n        }\r\n\r\n        this._uniformBuffer.dispose();\r\n\r\n        // Remove from scene\r\n        this.getScene().removeLight(this);\r\n        super.dispose(doNotRecurse, disposeMaterialAndTextures);\r\n    }\r\n\r\n    /**\r\n     * Returns the light type ID (integer).\r\n     * @returns The light Type id as a constant defines in Light.LIGHTTYPEID_x\r\n     */\r\n    public getTypeID(): number {\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Returns the intensity scaled by the Photometric Scale according to the light type and intensity mode.\r\n     * @returns the scaled intensity in intensity mode unit\r\n     */\r\n    public getScaledIntensity() {\r\n        return this._photometricScale * this.intensity;\r\n    }\r\n\r\n    /**\r\n     * Returns a new Light object, named \"name\", from the current one.\r\n     * @param name The name of the cloned light\r\n     * @param newParent The parent of this light, if it has one\r\n     * @returns the new created light\r\n     */\r\n    public clone(name: string, newParent: Nullable<Node> = null): Nullable<Light> {\r\n        const constructor = Light.GetConstructorFromName(this.getTypeID(), name, this.getScene());\r\n\r\n        if (!constructor) {\r\n            return null;\r\n        }\r\n        const clonedLight = SerializationHelper.Clone(constructor, this);\r\n        if (name) {\r\n            clonedLight.name = name;\r\n        }\r\n        if (newParent) {\r\n            clonedLight.parent = newParent;\r\n        }\r\n        clonedLight.setEnabled(this.isEnabled());\r\n\r\n        this.onClonedObservable.notifyObservers(clonedLight);\r\n\r\n        return clonedLight;\r\n    }\r\n\r\n    /**\r\n     * Serializes the current light into a Serialization object.\r\n     * @returns the serialized object.\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject = SerializationHelper.Serialize(this);\r\n        serializationObject.uniqueId = this.uniqueId;\r\n\r\n        // Type\r\n        serializationObject.type = this.getTypeID();\r\n\r\n        // Parent\r\n        if (this.parent) {\r\n            this.parent._serializeAsParent(serializationObject);\r\n        }\r\n\r\n        // Inclusion / exclusions\r\n        if (this.excludedMeshes.length > 0) {\r\n            serializationObject.excludedMeshesIds = [];\r\n            this.excludedMeshes.forEach((mesh: AbstractMesh) => {\r\n                serializationObject.excludedMeshesIds.push(mesh.id);\r\n            });\r\n        }\r\n\r\n        if (this.includedOnlyMeshes.length > 0) {\r\n            serializationObject.includedOnlyMeshesIds = [];\r\n            this.includedOnlyMeshes.forEach((mesh: AbstractMesh) => {\r\n                serializationObject.includedOnlyMeshesIds.push(mesh.id);\r\n            });\r\n        }\r\n\r\n        // Animations\r\n        SerializationHelper.AppendSerializedAnimations(this, serializationObject);\r\n        serializationObject.ranges = this.serializeAnimationRanges();\r\n\r\n        serializationObject.isEnabled = this.isEnabled();\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Creates a new typed light from the passed type (integer) : point light = 0, directional light = 1, spot light = 2, hemispheric light = 3.\r\n     * This new light is named \"name\" and added to the passed scene.\r\n     * @param type Type according to the types available in Light.LIGHTTYPEID_x\r\n     * @param name The friendly name of the light\r\n     * @param scene The scene the new light will belong to\r\n     * @returns the constructor function\r\n     */\r\n    static GetConstructorFromName(type: number, name: string, scene: Scene): Nullable<() => Light> {\r\n        const constructorFunc = Node.Construct(\"Light_Type_\" + type, name, scene);\r\n\r\n        if (constructorFunc) {\r\n            return <() => Light>constructorFunc;\r\n        }\r\n\r\n        // Default to no light for none present once.\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Parses the passed \"parsedLight\" and returns a new instanced Light from this parsing.\r\n     * @param parsedLight The JSON representation of the light\r\n     * @param scene The scene to create the parsed light in\r\n     * @returns the created light after parsing\r\n     */\r\n    public static Parse(parsedLight: any, scene: Scene): Nullable<Light> {\r\n        const constructor = Light.GetConstructorFromName(parsedLight.type, parsedLight.name, scene);\r\n\r\n        if (!constructor) {\r\n            return null;\r\n        }\r\n\r\n        const light = SerializationHelper.Parse(constructor, parsedLight, scene);\r\n\r\n        // Inclusion / exclusions\r\n        if (parsedLight.excludedMeshesIds) {\r\n            light._excludedMeshesIds = parsedLight.excludedMeshesIds;\r\n        }\r\n\r\n        if (parsedLight.includedOnlyMeshesIds) {\r\n            light._includedOnlyMeshesIds = parsedLight.includedOnlyMeshesIds;\r\n        }\r\n\r\n        // Parent\r\n        if (parsedLight.parentId !== undefined) {\r\n            light._waitingParentId = parsedLight.parentId;\r\n        }\r\n\r\n        if (parsedLight.parentInstanceIndex !== undefined) {\r\n            light._waitingParentInstanceIndex = parsedLight.parentInstanceIndex;\r\n        }\r\n\r\n        // Falloff\r\n        if (parsedLight.falloffType !== undefined) {\r\n            light.falloffType = parsedLight.falloffType;\r\n        }\r\n\r\n        // Lightmaps\r\n        if (parsedLight.lightmapMode !== undefined) {\r\n            light.lightmapMode = parsedLight.lightmapMode;\r\n        }\r\n\r\n        // Animations\r\n        if (parsedLight.animations) {\r\n            for (let animationIndex = 0; animationIndex < parsedLight.animations.length; animationIndex++) {\r\n                const parsedAnimation = parsedLight.animations[animationIndex];\r\n                const internalClass = GetClass(\"BABYLON.Animation\");\r\n                if (internalClass) {\r\n                    light.animations.push(internalClass.Parse(parsedAnimation));\r\n                }\r\n            }\r\n            Node.ParseAnimationRanges(light, parsedLight, scene);\r\n        }\r\n\r\n        if (parsedLight.autoAnimate) {\r\n            scene.beginAnimation(light, parsedLight.autoAnimateFrom, parsedLight.autoAnimateTo, parsedLight.autoAnimateLoop, parsedLight.autoAnimateSpeed || 1.0);\r\n        }\r\n\r\n        // Check if isEnabled is defined to be back compatible with prior serialized versions.\r\n        if (parsedLight.isEnabled !== undefined) {\r\n            light.setEnabled(parsedLight.isEnabled);\r\n        }\r\n\r\n        return light;\r\n    }\r\n\r\n    private _hookArrayForExcluded(array: AbstractMesh[]): void {\r\n        const oldPush = array.push;\r\n        array.push = (...items: AbstractMesh[]) => {\r\n            const result = oldPush.apply(array, items);\r\n\r\n            for (const item of items) {\r\n                item._resyncLightSource(this);\r\n            }\r\n\r\n            return result;\r\n        };\r\n\r\n        const oldSplice = array.splice;\r\n        array.splice = (index: number, deleteCount?: number) => {\r\n            const deleted = oldSplice.apply(array, [index, deleteCount]);\r\n\r\n            for (const item of deleted) {\r\n                item._resyncLightSource(this);\r\n            }\r\n\r\n            return deleted;\r\n        };\r\n\r\n        for (const item of array) {\r\n            item._resyncLightSource(this);\r\n        }\r\n    }\r\n\r\n    private _hookArrayForIncludedOnly(array: AbstractMesh[]): void {\r\n        const oldPush = array.push;\r\n        array.push = (...items: AbstractMesh[]) => {\r\n            const result = oldPush.apply(array, items);\r\n\r\n            this._resyncMeshes();\r\n\r\n            return result;\r\n        };\r\n\r\n        const oldSplice = array.splice;\r\n        array.splice = (index: number, deleteCount?: number) => {\r\n            const deleted = oldSplice.apply(array, [index, deleteCount]);\r\n\r\n            this._resyncMeshes();\r\n\r\n            return deleted;\r\n        };\r\n\r\n        this._resyncMeshes();\r\n    }\r\n\r\n    private _resyncMeshes() {\r\n        for (const mesh of this.getScene().meshes) {\r\n            mesh._resyncLightSource(this);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Forces the meshes to update their light related information in their rendering used effects\r\n     * @internal Internal Use Only\r\n     */\r\n    public _markMeshesAsLightDirty() {\r\n        for (const mesh of this.getScene().meshes) {\r\n            if (mesh.lightSources.indexOf(this) !== -1) {\r\n                mesh._markSubMeshesAsLightDirty();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Recomputes the cached photometric scale if needed.\r\n     */\r\n    private _computePhotometricScale(): void {\r\n        this._photometricScale = this._getPhotometricScale();\r\n        this.getScene().resetCachedMaterial();\r\n    }\r\n\r\n    /**\r\n     * @returns the Photometric Scale according to the light type and intensity mode.\r\n     */\r\n    private _getPhotometricScale() {\r\n        let photometricScale = 0.0;\r\n        const lightTypeID = this.getTypeID();\r\n\r\n        //get photometric mode\r\n        let photometricMode = this.intensityMode;\r\n        if (photometricMode === Light.INTENSITYMODE_AUTOMATIC) {\r\n            if (lightTypeID === Light.LIGHTTYPEID_DIRECTIONALLIGHT) {\r\n                photometricMode = Light.INTENSITYMODE_ILLUMINANCE;\r\n            } else {\r\n                photometricMode = Light.INTENSITYMODE_LUMINOUSINTENSITY;\r\n            }\r\n        }\r\n\r\n        //compute photometric scale\r\n        switch (lightTypeID) {\r\n            case Light.LIGHTTYPEID_POINTLIGHT:\r\n            case Light.LIGHTTYPEID_SPOTLIGHT:\r\n                switch (photometricMode) {\r\n                    case Light.INTENSITYMODE_LUMINOUSPOWER:\r\n                        photometricScale = 1.0 / (4.0 * Math.PI);\r\n                        break;\r\n                    case Light.INTENSITYMODE_LUMINOUSINTENSITY:\r\n                        photometricScale = 1.0;\r\n                        break;\r\n                    case Light.INTENSITYMODE_LUMINANCE:\r\n                        photometricScale = this.radius * this.radius;\r\n                        break;\r\n                }\r\n                break;\r\n\r\n            case Light.LIGHTTYPEID_DIRECTIONALLIGHT:\r\n                switch (photometricMode) {\r\n                    case Light.INTENSITYMODE_ILLUMINANCE:\r\n                        photometricScale = 1.0;\r\n                        break;\r\n                    case Light.INTENSITYMODE_LUMINANCE: {\r\n                        // When radius (and therefore solid angle) is non-zero a directional lights brightness can be specified via central (peak) luminance.\r\n                        // For a directional light the 'radius' defines the angular radius (in radians) rather than world-space radius (e.g. in metres).\r\n                        let apexAngleRadians = this.radius;\r\n                        // Impose a minimum light angular size to avoid the light becoming an infinitely small angular light source (i.e. a dirac delta function).\r\n                        apexAngleRadians = Math.max(apexAngleRadians, 0.001);\r\n                        const solidAngle = 2.0 * Math.PI * (1.0 - Math.cos(apexAngleRadians));\r\n                        photometricScale = solidAngle;\r\n                        break;\r\n                    }\r\n                }\r\n                break;\r\n\r\n            case Light.LIGHTTYPEID_HEMISPHERICLIGHT:\r\n                // No fall off in hemispheric light.\r\n                photometricScale = 1.0;\r\n                break;\r\n        }\r\n        return photometricScale;\r\n    }\r\n\r\n    /**\r\n     * Reorder the light in the scene according to their defined priority.\r\n     * @internal Internal Use Only\r\n     */\r\n    public _reorderLightsInScene(): void {\r\n        const scene = this.getScene();\r\n        if (this._renderPriority != 0) {\r\n            scene.requireLightSorting = true;\r\n        }\r\n        this.getScene().sortLightsByPriority();\r\n    }\r\n\r\n    /**\r\n     * Prepares the list of defines specific to the light type.\r\n     * @param defines the list of defines\r\n     * @param lightIndex defines the index of the light for the effect\r\n     */\r\n    public abstract prepareLightSpecificDefines(defines: any, lightIndex: number): void;\r\n}\r\n", "import { serialize, serializeAsVector3 } from \"../Misc/decorators\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Matrix, TmpVectors, Vector3 } from \"../Maths/math.vector\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { Light } from \"./light\";\r\nimport { Axis } from \"../Maths/math.axis\";\r\nimport type { Nullable } from \"core/types\";\r\n/**\r\n * Interface describing all the common properties and methods a shadow light needs to implement.\r\n * This helps both the shadow generator and materials to generate the corresponding shadow maps\r\n * as well as binding the different shadow properties to the effects.\r\n */\r\nexport interface IShadowLight extends Light {\r\n    /**\r\n     * The light id in the scene (used in scene.getLightById for instance)\r\n     */\r\n    id: string;\r\n    /**\r\n     * The position the shadow will be casted from.\r\n     */\r\n    position: Vector3;\r\n    /**\r\n     * In 2d mode (needCube being false), the direction used to cast the shadow.\r\n     */\r\n    direction: Vector3;\r\n    /**\r\n     * The transformed position. Position of the light in world space taking parenting in account.\r\n     */\r\n    transformedPosition: Vector3;\r\n    /**\r\n     * The transformed direction. Direction of the light in world space taking parenting in account.\r\n     */\r\n    transformedDirection: Vector3;\r\n    /**\r\n     * The friendly name of the light in the scene.\r\n     */\r\n    name: string;\r\n    /**\r\n     * Defines the shadow projection clipping minimum z value.\r\n     */\r\n    shadowMinZ: number;\r\n    /**\r\n     * Defines the shadow projection clipping maximum z value.\r\n     */\r\n    shadowMaxZ: number;\r\n\r\n    /**\r\n     * Computes the transformed information (transformedPosition and transformedDirection in World space) of the current light\r\n     * @returns true if the information has been computed, false if it does not need to (no parenting)\r\n     */\r\n    computeTransformedInformation(): boolean;\r\n\r\n    /**\r\n     * Gets the scene the light belongs to.\r\n     * @returns The scene\r\n     */\r\n    getScene(): Scene;\r\n\r\n    /**\r\n     * Callback defining a custom Projection Matrix Builder.\r\n     * This can be used to override the default projection matrix computation.\r\n     */\r\n    customProjectionMatrixBuilder: (viewMatrix: Matrix, renderList: Array<AbstractMesh>, result: Matrix) => void;\r\n\r\n    /**\r\n     * Sets the shadow projection matrix in parameter to the generated projection matrix.\r\n     * @param matrix The matrix to update with the projection information\r\n     * @param viewMatrix The transform matrix of the light\r\n     * @param renderList The list of mesh to render in the map\r\n     * @returns The current light\r\n     */\r\n    setShadowProjectionMatrix(matrix: Matrix, viewMatrix: Matrix, renderList: Array<AbstractMesh>): IShadowLight;\r\n\r\n    /**\r\n     * Gets the current depth scale used in ESM.\r\n     * @returns The scale\r\n     */\r\n    getDepthScale(): number;\r\n\r\n    /**\r\n     * Returns whether or not the shadow generation require a cube texture or a 2d texture.\r\n     * @returns true if a cube texture needs to be use\r\n     */\r\n    needCube(): boolean;\r\n\r\n    /**\r\n     * Detects if the projection matrix requires to be recomputed this frame.\r\n     * @returns true if it requires to be recomputed otherwise, false.\r\n     */\r\n    needProjectionMatrixCompute(): boolean;\r\n\r\n    /**\r\n     * Forces the shadow generator to recompute the projection matrix even if position and direction did not changed.\r\n     */\r\n    forceProjectionMatrixCompute(): void;\r\n\r\n    /**\r\n     * Get the direction to use to render the shadow map. In case of cube texture, the face index can be passed.\r\n     * @param faceIndex The index of the face we are computed the direction to generate shadow\r\n     * @returns The set direction in 2d mode otherwise the direction to the cubemap face if needCube() is true\r\n     */\r\n    getShadowDirection(faceIndex?: number): Vector3;\r\n\r\n    /**\r\n     * Gets the minZ used for shadow according to both the scene and the light.\r\n     * @param activeCamera The camera we are returning the min for\r\n     * @returns the depth min z\r\n     */\r\n    getDepthMinZ(activeCamera: Camera): number;\r\n\r\n    /**\r\n     * Gets the maxZ used for shadow according to both the scene and the light.\r\n     * @param activeCamera The camera we are returning the max for\r\n     * @returns the depth max z\r\n     */\r\n    getDepthMaxZ(activeCamera: Camera): number;\r\n}\r\n\r\n/**\r\n * Base implementation IShadowLight\r\n * It groups all the common behaviour in order to reduce duplication and better follow the DRY pattern.\r\n */\r\nexport abstract class ShadowLight extends Light implements IShadowLight {\r\n    protected abstract _setDefaultShadowProjectionMatrix(matrix: Matrix, viewMatrix: Matrix, renderList: Array<AbstractMesh>): void;\r\n\r\n    protected _position: Vector3;\r\n    protected _setPosition(value: Vector3) {\r\n        this._position = value;\r\n    }\r\n    /**\r\n     * Sets the position the shadow will be casted from. Also use as the light position for both\r\n     * point and spot lights.\r\n     */\r\n    @serializeAsVector3()\r\n    public get position(): Vector3 {\r\n        return this._position;\r\n    }\r\n    /**\r\n     * Sets the position the shadow will be casted from. Also use as the light position for both\r\n     * point and spot lights.\r\n     */\r\n    public set position(value: Vector3) {\r\n        this._setPosition(value);\r\n    }\r\n\r\n    protected _direction: Vector3;\r\n    protected _setDirection(value: Vector3) {\r\n        this._direction = value;\r\n    }\r\n    /**\r\n     * In 2d mode (needCube being false), gets the direction used to cast the shadow.\r\n     * Also use as the light direction on spot and directional lights.\r\n     */\r\n    @serializeAsVector3()\r\n    public get direction(): Vector3 {\r\n        return this._direction;\r\n    }\r\n    /**\r\n     * In 2d mode (needCube being false), sets the direction used to cast the shadow.\r\n     * Also use as the light direction on spot and directional lights.\r\n     */\r\n    public set direction(value: Vector3) {\r\n        this._setDirection(value);\r\n    }\r\n\r\n    protected _shadowMinZ: number;\r\n    /**\r\n     * Gets the shadow projection clipping minimum z value.\r\n     */\r\n    @serialize()\r\n    public get shadowMinZ(): number {\r\n        return this._shadowMinZ;\r\n    }\r\n    /**\r\n     * Sets the shadow projection clipping minimum z value.\r\n     */\r\n    public set shadowMinZ(value: number) {\r\n        this._shadowMinZ = value;\r\n        this.forceProjectionMatrixCompute();\r\n    }\r\n\r\n    protected _shadowMaxZ: number;\r\n    /**\r\n     * Sets the shadow projection clipping maximum z value.\r\n     */\r\n    @serialize()\r\n    public get shadowMaxZ(): number {\r\n        return this._shadowMaxZ;\r\n    }\r\n    /**\r\n     * Gets the shadow projection clipping maximum z value.\r\n     */\r\n    public set shadowMaxZ(value: number) {\r\n        this._shadowMaxZ = value;\r\n        this.forceProjectionMatrixCompute();\r\n    }\r\n\r\n    /**\r\n     * Callback defining a custom Projection Matrix Builder.\r\n     * This can be used to override the default projection matrix computation.\r\n     */\r\n    public customProjectionMatrixBuilder: (viewMatrix: Matrix, renderList: Array<AbstractMesh>, result: Matrix) => void;\r\n\r\n    /**\r\n     * The transformed position. Position of the light in world space taking parenting in account. Needs to be computed by calling computeTransformedInformation.\r\n     */\r\n    public transformedPosition: Vector3;\r\n\r\n    /**\r\n     * The transformed direction. Direction of the light in world space taking parenting in account.\r\n     */\r\n    public transformedDirection: Vector3;\r\n\r\n    private _needProjectionMatrixCompute: boolean = true;\r\n\r\n    /**\r\n     * Computes the transformed information (transformedPosition and transformedDirection in World space) of the current light\r\n     * @returns true if the information has been computed, false if it does not need to (no parenting)\r\n     */\r\n    public computeTransformedInformation(): boolean {\r\n        if (this.parent && this.parent.getWorldMatrix) {\r\n            if (!this.transformedPosition) {\r\n                this.transformedPosition = Vector3.Zero();\r\n            }\r\n            Vector3.TransformCoordinatesToRef(this.position, this.parent.getWorldMatrix(), this.transformedPosition);\r\n\r\n            // In case the direction is present.\r\n            if (this.direction) {\r\n                if (!this.transformedDirection) {\r\n                    this.transformedDirection = Vector3.Zero();\r\n                }\r\n                Vector3.TransformNormalToRef(this.direction, this.parent.getWorldMatrix(), this.transformedDirection);\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Return the depth scale used for the shadow map.\r\n     * @returns the depth scale.\r\n     */\r\n    public getDepthScale(): number {\r\n        return 50.0;\r\n    }\r\n\r\n    /**\r\n     * Get the direction to use to render the shadow map. In case of cube texture, the face index can be passed.\r\n     * @param faceIndex The index of the face we are computed the direction to generate shadow\r\n     * @returns The set direction in 2d mode otherwise the direction to the cubemap face if needCube() is true\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public getShadowDirection(faceIndex?: number): Vector3 {\r\n        return this.transformedDirection ? this.transformedDirection : this.direction;\r\n    }\r\n\r\n    /**\r\n     * If computeTransformedInformation has been called, returns the ShadowLight absolute position in the world. Otherwise, returns the local position.\r\n     * @returns the position vector in world space\r\n     */\r\n    public getAbsolutePosition(): Vector3 {\r\n        return this.transformedPosition ? this.transformedPosition : this.position;\r\n    }\r\n\r\n    /**\r\n     * Sets the ShadowLight direction toward the passed target.\r\n     * @param target The point to target in local space\r\n     * @returns the updated ShadowLight direction\r\n     */\r\n    public setDirectionToTarget(target: Vector3): Vector3 {\r\n        this.direction = Vector3.Normalize(target.subtract(this.position));\r\n        return this.direction;\r\n    }\r\n\r\n    /**\r\n     * Returns the light rotation in euler definition.\r\n     * @returns the x y z rotation in local space.\r\n     */\r\n    public getRotation(): Vector3 {\r\n        this.direction.normalize();\r\n        const xaxis = Vector3.Cross(this.direction, Axis.Y);\r\n        const yaxis = Vector3.Cross(xaxis, this.direction);\r\n        return Vector3.RotationFromAxis(xaxis, yaxis, this.direction);\r\n    }\r\n\r\n    /**\r\n     * Returns whether or not the shadow generation require a cube texture or a 2d texture.\r\n     * @returns true if a cube texture needs to be use\r\n     */\r\n    public needCube(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Detects if the projection matrix requires to be recomputed this frame.\r\n     * @returns true if it requires to be recomputed otherwise, false.\r\n     */\r\n    public needProjectionMatrixCompute(): boolean {\r\n        return this._needProjectionMatrixCompute;\r\n    }\r\n\r\n    /**\r\n     * Forces the shadow generator to recompute the projection matrix even if position and direction did not changed.\r\n     */\r\n    public forceProjectionMatrixCompute(): void {\r\n        this._needProjectionMatrixCompute = true;\r\n    }\r\n\r\n    /** @internal */\r\n    public _initCache() {\r\n        super._initCache();\r\n\r\n        this._cache.position = Vector3.Zero();\r\n    }\r\n\r\n    /** @internal */\r\n    public _isSynchronized(): boolean {\r\n        if (!this._cache.position.equals(this.position)) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Computes the world matrix of the node\r\n     * @param force defines if the cache version should be invalidated forcing the world matrix to be created from scratch\r\n     * @returns the world matrix\r\n     */\r\n    public computeWorldMatrix(force?: boolean): Matrix {\r\n        if (!force && this.isSynchronized()) {\r\n            this._currentRenderId = this.getScene().getRenderId();\r\n            return this._worldMatrix;\r\n        }\r\n\r\n        this._updateCache();\r\n        this._cache.position.copyFrom(this.position);\r\n\r\n        if (!this._worldMatrix) {\r\n            this._worldMatrix = Matrix.Identity();\r\n        }\r\n\r\n        Matrix.TranslationToRef(this.position.x, this.position.y, this.position.z, this._worldMatrix);\r\n\r\n        if (this.parent && this.parent.getWorldMatrix) {\r\n            this._worldMatrix.multiplyToRef(this.parent.getWorldMatrix(), this._worldMatrix);\r\n\r\n            this._markSyncedWithParent();\r\n        }\r\n\r\n        // Cache the determinant\r\n        this._worldMatrixDeterminantIsDirty = true;\r\n\r\n        return this._worldMatrix;\r\n    }\r\n\r\n    /**\r\n     * Gets the minZ used for shadow according to both the scene and the light.\r\n     * @param activeCamera The camera we are returning the min for\r\n     * @returns the depth min z\r\n     */\r\n    public getDepthMinZ(activeCamera: Camera): number {\r\n        return this.shadowMinZ !== undefined ? this.shadowMinZ : activeCamera.minZ;\r\n    }\r\n\r\n    /**\r\n     * Gets the maxZ used for shadow according to both the scene and the light.\r\n     * @param activeCamera The camera we are returning the max for\r\n     * @returns the depth max z\r\n     */\r\n    public getDepthMaxZ(activeCamera: Camera): number {\r\n        return this.shadowMaxZ !== undefined ? this.shadowMaxZ : activeCamera.maxZ;\r\n    }\r\n\r\n    /**\r\n     * Sets the shadow projection matrix in parameter to the generated projection matrix.\r\n     * @param matrix The matrix to updated with the projection information\r\n     * @param viewMatrix The transform matrix of the light\r\n     * @param renderList The list of mesh to render in the map\r\n     * @returns The current light\r\n     */\r\n    public setShadowProjectionMatrix(matrix: Matrix, viewMatrix: Matrix, renderList: Array<AbstractMesh>): IShadowLight {\r\n        if (this.customProjectionMatrixBuilder) {\r\n            this.customProjectionMatrixBuilder(viewMatrix, renderList, matrix);\r\n        } else {\r\n            this._setDefaultShadowProjectionMatrix(matrix, viewMatrix, renderList);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /** @internal */\r\n    protected _syncParentEnabledState() {\r\n        super._syncParentEnabledState();\r\n        if (!this.parent || !this.parent.getWorldMatrix) {\r\n            (this.transformedPosition as any) = null;\r\n            (this.transformedDirection as any) = null;\r\n        }\r\n    }\r\n\r\n    protected _viewMatrix: Matrix = Matrix.Identity();\r\n    protected _projectionMatrix: Matrix = Matrix.Identity();\r\n\r\n    /**\r\n     * Returns the view matrix.\r\n     * @param faceIndex The index of the face for which we want to extract the view matrix. Only used for point light types.\r\n     * @returns The view matrix. Can be null, if a view matrix cannot be defined for the type of light considered (as for a hemispherical light, for example).\r\n     */\r\n    public getViewMatrix(faceIndex?: number): Nullable<Matrix> {\r\n        const lightDirection = TmpVectors.Vector3[0];\r\n\r\n        let lightPosition = this.position;\r\n        if (this.computeTransformedInformation()) {\r\n            lightPosition = this.transformedPosition;\r\n        }\r\n\r\n        Vector3.NormalizeToRef(this.getShadowDirection(faceIndex), lightDirection);\r\n        if (Math.abs(Vector3.Dot(lightDirection, Vector3.Up())) === 1.0) {\r\n            lightDirection.z = 0.0000000000001; // Required to avoid perfectly perpendicular light\r\n        }\r\n\r\n        const lightTarget = TmpVectors.Vector3[1];\r\n        lightPosition.addToRef(lightDirection, lightTarget);\r\n\r\n        Matrix.LookAtLHToRef(lightPosition, lightTarget, Vector3.Up(), this._viewMatrix);\r\n\r\n        return this._viewMatrix;\r\n    }\r\n\r\n    /**\r\n     * Returns the projection matrix.\r\n     * Note that viewMatrix and renderList are optional and are only used by lights that calculate the projection matrix from a list of meshes (e.g. directional lights with automatic extents calculation).\r\n     * @param viewMatrix The view transform matrix of the light (optional).\r\n     * @param renderList The list of meshes to take into account when calculating the projection matrix (optional).\r\n     * @returns The projection matrix. Can be null, if a projection matrix cannot be defined for the type of light considered (as for a hemispherical light, for example).\r\n     */\r\n    public getProjectionMatrix(viewMatrix?: Matrix, renderList?: Array<AbstractMesh>): Nullable<Matrix> {\r\n        this.setShadowProjectionMatrix(this._projectionMatrix, viewMatrix ?? this._viewMatrix, renderList ?? []);\r\n\r\n        return this._projectionMatrix;\r\n    }\r\n}\r\n", "import { serialize } from \"../Misc/decorators\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Matrix, Vector3 } from \"../Maths/math.vector\";\r\nimport { Node } from \"../node\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { Light } from \"./light\";\r\nimport { ShadowLight } from \"./shadowLight\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nNode.AddNodeConstructor(\"Light_Type_1\", (name, scene) => {\r\n    return () => new DirectionalLight(name, Vector3.Zero(), scene);\r\n});\r\n\r\n/**\r\n * A directional light is defined by a direction (what a surprise!).\r\n * The light is emitted from everywhere in the specified direction, and has an infinite range.\r\n * An example of a directional light is when a distance planet is lit by the apparently parallel lines of light from its sun. Light in a downward direction will light the top of an object.\r\n * Documentation: https://doc.babylonjs.com/features/featuresDeepDive/lights/lights_introduction\r\n */\r\nexport class DirectionalLight extends ShadowLight {\r\n    private _shadowFrustumSize = 0;\r\n    /**\r\n     * Fix frustum size for the shadow generation. This is disabled if the value is 0.\r\n     */\r\n    @serialize()\r\n    public get shadowFrustumSize(): number {\r\n        return this._shadowFrustumSize;\r\n    }\r\n    /**\r\n     * Specifies a fix frustum size for the shadow generation.\r\n     */\r\n    public set shadowFrustumSize(value: number) {\r\n        this._shadowFrustumSize = value;\r\n        this.forceProjectionMatrixCompute();\r\n    }\r\n\r\n    private _shadowOrthoScale = 0.1;\r\n    /**\r\n     * Gets the shadow projection scale against the optimal computed one.\r\n     * 0.1 by default which means that the projection window is increase by 10% from the optimal size.\r\n     * This does not impact in fixed frustum size (shadowFrustumSize being set)\r\n     */\r\n    @serialize()\r\n    public get shadowOrthoScale(): number {\r\n        return this._shadowOrthoScale;\r\n    }\r\n    /**\r\n     * Sets the shadow projection scale against the optimal computed one.\r\n     * 0.1 by default which means that the projection window is increase by 10% from the optimal size.\r\n     * This does not impact in fixed frustum size (shadowFrustumSize being set)\r\n     */\r\n    public set shadowOrthoScale(value: number) {\r\n        this._shadowOrthoScale = value;\r\n        this.forceProjectionMatrixCompute();\r\n    }\r\n\r\n    /**\r\n     * Automatically compute the projection matrix to best fit (including all the casters)\r\n     * on each frame.\r\n     */\r\n    @serialize()\r\n    public autoUpdateExtends = true;\r\n\r\n    /**\r\n     * Automatically compute the shadowMinZ and shadowMaxZ for the projection matrix to best fit (including all the casters)\r\n     * on each frame. autoUpdateExtends must be set to true for this to work\r\n     */\r\n    @serialize()\r\n    public autoCalcShadowZBounds = false;\r\n\r\n    // Cache\r\n    @serialize(\"orthoLeft\")\r\n    private _orthoLeft = Number.MAX_VALUE;\r\n    @serialize(\"orthoRight\")\r\n    private _orthoRight = Number.MIN_VALUE;\r\n    @serialize(\"orthoTop\")\r\n    private _orthoTop = Number.MIN_VALUE;\r\n    @serialize(\"orthoBottom\")\r\n    private _orthoBottom = Number.MAX_VALUE;\r\n\r\n    /**\r\n     * Gets or sets the orthoLeft property used to build the light frustum\r\n     */\r\n    public get orthoLeft(): number {\r\n        return this._orthoLeft;\r\n    }\r\n\r\n    public set orthoLeft(left: number) {\r\n        this._orthoLeft = left;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the orthoRight property used to build the light frustum\r\n     */\r\n    public get orthoRight(): number {\r\n        return this._orthoRight;\r\n    }\r\n\r\n    public set orthoRight(right: number) {\r\n        this._orthoRight = right;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the orthoTop property used to build the light frustum\r\n     */\r\n    public get orthoTop(): number {\r\n        return this._orthoTop;\r\n    }\r\n\r\n    public set orthoTop(top: number) {\r\n        this._orthoTop = top;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the orthoBottom property used to build the light frustum\r\n     */\r\n    public get orthoBottom(): number {\r\n        return this._orthoBottom;\r\n    }\r\n\r\n    public set orthoBottom(bottom: number) {\r\n        this._orthoBottom = bottom;\r\n    }\r\n\r\n    /**\r\n     * Creates a DirectionalLight object in the scene, oriented towards the passed direction (Vector3).\r\n     * The directional light is emitted from everywhere in the given direction.\r\n     * It can cast shadows.\r\n     * Documentation : https://doc.babylonjs.com/features/featuresDeepDive/lights/lights_introduction\r\n     * @param name The friendly name of the light\r\n     * @param direction The direction of the light\r\n     * @param scene The scene the light belongs to\r\n     */\r\n    constructor(name: string, direction: Vector3, scene?: Scene) {\r\n        super(name, scene);\r\n        this.position = direction.scale(-1.0);\r\n        this.direction = direction;\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"DirectionalLight\".\r\n     * @returns The class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"DirectionalLight\";\r\n    }\r\n\r\n    /**\r\n     * Returns the integer 1.\r\n     * @returns The light Type id as a constant defines in Light.LIGHTTYPEID_x\r\n     */\r\n    public getTypeID(): number {\r\n        return Light.LIGHTTYPEID_DIRECTIONALLIGHT;\r\n    }\r\n\r\n    /**\r\n     * Sets the passed matrix \"matrix\" as projection matrix for the shadows cast by the light according to the passed view matrix.\r\n     * Returns the DirectionalLight Shadow projection matrix.\r\n     * @param matrix\r\n     * @param viewMatrix\r\n     * @param renderList\r\n     */\r\n    protected _setDefaultShadowProjectionMatrix(matrix: Matrix, viewMatrix: Matrix, renderList: Array<AbstractMesh>): void {\r\n        if (this.shadowFrustumSize > 0) {\r\n            this._setDefaultFixedFrustumShadowProjectionMatrix(matrix);\r\n        } else {\r\n            this._setDefaultAutoExtendShadowProjectionMatrix(matrix, viewMatrix, renderList);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the passed matrix \"matrix\" as fixed frustum projection matrix for the shadows cast by the light according to the passed view matrix.\r\n     * Returns the DirectionalLight Shadow projection matrix.\r\n     * @param matrix\r\n     */\r\n    protected _setDefaultFixedFrustumShadowProjectionMatrix(matrix: Matrix): void {\r\n        const activeCamera = this.getScene().activeCamera;\r\n\r\n        if (!activeCamera) {\r\n            return;\r\n        }\r\n\r\n        Matrix.OrthoLHToRef(\r\n            this.shadowFrustumSize,\r\n            this.shadowFrustumSize,\r\n            this.shadowMinZ !== undefined ? this.shadowMinZ : activeCamera.minZ,\r\n            this.shadowMaxZ !== undefined ? this.shadowMaxZ : activeCamera.maxZ,\r\n            matrix,\r\n            this.getScene().getEngine().isNDCHalfZRange\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Sets the passed matrix \"matrix\" as auto extend projection matrix for the shadows cast by the light according to the passed view matrix.\r\n     * Returns the DirectionalLight Shadow projection matrix.\r\n     * @param matrix\r\n     * @param viewMatrix\r\n     * @param renderList\r\n     */\r\n    protected _setDefaultAutoExtendShadowProjectionMatrix(matrix: Matrix, viewMatrix: Matrix, renderList: Array<AbstractMesh>): void {\r\n        const activeCamera = this.getScene().activeCamera;\r\n\r\n        if (!activeCamera) {\r\n            return;\r\n        }\r\n\r\n        // Check extends\r\n        if (this.autoUpdateExtends || this._orthoLeft === Number.MAX_VALUE) {\r\n            const tempVector3 = Vector3.Zero();\r\n\r\n            this._orthoLeft = Number.MAX_VALUE;\r\n            this._orthoRight = -Number.MAX_VALUE;\r\n            this._orthoTop = -Number.MAX_VALUE;\r\n            this._orthoBottom = Number.MAX_VALUE;\r\n\r\n            let shadowMinZ = Number.MAX_VALUE;\r\n            let shadowMaxZ = -Number.MAX_VALUE;\r\n\r\n            for (let meshIndex = 0; meshIndex < renderList.length; meshIndex++) {\r\n                const mesh = renderList[meshIndex];\r\n\r\n                if (!mesh) {\r\n                    continue;\r\n                }\r\n\r\n                const boundingInfo = mesh.getBoundingInfo();\r\n                const boundingBox = boundingInfo.boundingBox;\r\n\r\n                for (let index = 0; index < boundingBox.vectorsWorld.length; index++) {\r\n                    Vector3.TransformCoordinatesToRef(boundingBox.vectorsWorld[index], viewMatrix, tempVector3);\r\n\r\n                    if (tempVector3.x < this._orthoLeft) {\r\n                        this._orthoLeft = tempVector3.x;\r\n                    }\r\n                    if (tempVector3.y < this._orthoBottom) {\r\n                        this._orthoBottom = tempVector3.y;\r\n                    }\r\n\r\n                    if (tempVector3.x > this._orthoRight) {\r\n                        this._orthoRight = tempVector3.x;\r\n                    }\r\n                    if (tempVector3.y > this._orthoTop) {\r\n                        this._orthoTop = tempVector3.y;\r\n                    }\r\n                    if (this.autoCalcShadowZBounds) {\r\n                        if (tempVector3.z < shadowMinZ) {\r\n                            shadowMinZ = tempVector3.z;\r\n                        }\r\n                        if (tempVector3.z > shadowMaxZ) {\r\n                            shadowMaxZ = tempVector3.z;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (this.autoCalcShadowZBounds) {\r\n                this._shadowMinZ = shadowMinZ;\r\n                this._shadowMaxZ = shadowMaxZ;\r\n            }\r\n        }\r\n\r\n        const xOffset = this._orthoRight - this._orthoLeft;\r\n        const yOffset = this._orthoTop - this._orthoBottom;\r\n\r\n        const minZ = this.shadowMinZ !== undefined ? this.shadowMinZ : activeCamera.minZ;\r\n        const maxZ = this.shadowMaxZ !== undefined ? this.shadowMaxZ : activeCamera.maxZ;\r\n\r\n        const useReverseDepthBuffer = this.getScene().getEngine().useReverseDepthBuffer;\r\n\r\n        Matrix.OrthoOffCenterLHToRef(\r\n            this._orthoLeft - xOffset * this.shadowOrthoScale,\r\n            this._orthoRight + xOffset * this.shadowOrthoScale,\r\n            this._orthoBottom - yOffset * this.shadowOrthoScale,\r\n            this._orthoTop + yOffset * this.shadowOrthoScale,\r\n            useReverseDepthBuffer ? maxZ : minZ,\r\n            useReverseDepthBuffer ? minZ : maxZ,\r\n            matrix,\r\n            this.getScene().getEngine().isNDCHalfZRange\r\n        );\r\n    }\r\n\r\n    protected _buildUniformLayout(): void {\r\n        this._uniformBuffer.addUniform(\"vLightData\", 4);\r\n        this._uniformBuffer.addUniform(\"vLightDiffuse\", 4);\r\n        this._uniformBuffer.addUniform(\"vLightSpecular\", 4);\r\n        this._uniformBuffer.addUniform(\"shadowsInfo\", 3);\r\n        this._uniformBuffer.addUniform(\"depthValues\", 2);\r\n        this._uniformBuffer.create();\r\n    }\r\n\r\n    /**\r\n     * Sets the passed Effect object with the DirectionalLight transformed position (or position if not parented) and the passed name.\r\n     * @param effect The effect to update\r\n     * @param lightIndex The index of the light in the effect to update\r\n     * @returns The directional light\r\n     */\r\n    public transferToEffect(effect: Effect, lightIndex: string): DirectionalLight {\r\n        if (this.computeTransformedInformation()) {\r\n            this._uniformBuffer.updateFloat4(\"vLightData\", this.transformedDirection.x, this.transformedDirection.y, this.transformedDirection.z, 1, lightIndex);\r\n            return this;\r\n        }\r\n        this._uniformBuffer.updateFloat4(\"vLightData\", this.direction.x, this.direction.y, this.direction.z, 1, lightIndex);\r\n        return this;\r\n    }\r\n\r\n    public transferToNodeMaterialEffect(effect: Effect, lightDataUniformName: string): Light {\r\n        if (this.computeTransformedInformation()) {\r\n            effect.setFloat3(lightDataUniformName, this.transformedDirection.x, this.transformedDirection.y, this.transformedDirection.z);\r\n            return this;\r\n        }\r\n\r\n        effect.setFloat3(lightDataUniformName, this.direction.x, this.direction.y, this.direction.z);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Gets the minZ used for shadow according to both the scene and the light.\r\n     *\r\n     * Values are fixed on directional lights as it relies on an ortho projection hence the need to convert being\r\n     * -1 and 1 to 0 and 1 doing (depth + min) / (min + max) -> (depth + 1) / (1 + 1) -> (depth * 0.5) + 0.5.\r\n     * (when not using reverse depth buffer / NDC half Z range)\r\n     * @param activeCamera The camera we are returning the min for\r\n     * @returns the depth min z\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public getDepthMinZ(activeCamera: Camera): number {\r\n        const engine = this._scene.getEngine();\r\n        return !engine.useReverseDepthBuffer && engine.isNDCHalfZRange ? 0 : 1;\r\n    }\r\n\r\n    /**\r\n     * Gets the maxZ used for shadow according to both the scene and the light.\r\n     *\r\n     * Values are fixed on directional lights as it relies on an ortho projection hence the need to convert being\r\n     * -1 and 1 to 0 and 1 doing (depth + min) / (min + max) -> (depth + 1) / (1 + 1) -> (depth * 0.5) + 0.5.\r\n     * (when not using reverse depth buffer / NDC half Z range)\r\n     * @param activeCamera The camera we are returning the max for\r\n     * @returns the depth max z\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public getDepthMaxZ(activeCamera: Camera): number {\r\n        const engine = this._scene.getEngine();\r\n        return engine.useReverseDepthBuffer && engine.isNDCHalfZRange ? 0 : 1;\r\n    }\r\n\r\n    /**\r\n     * Prepares the list of defines specific to the light type.\r\n     * @param defines the list of defines\r\n     * @param lightIndex defines the index of the light for the effect\r\n     */\r\n    public prepareLightSpecificDefines(defines: any, lightIndex: number): void {\r\n        defines[\"DIRLIGHT\" + lightIndex] = true;\r\n    }\r\n}\r\n", "import type { Matrix } from \"../Maths/math.vector\";\r\nimport type { Mesh } from \"../Meshes/mesh\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport { Constants } from \"../Engines/constants\";\r\n\r\n/**\r\n * Configuration needed for prepass-capable materials\r\n */\r\nexport class PrePassConfiguration {\r\n    /**\r\n     * Previous world matrices of meshes carrying this material\r\n     * Used for computing velocity\r\n     */\r\n    public previousWorldMatrices: { [index: number]: Matrix } = {};\r\n    /**\r\n     * Previous view project matrix\r\n     * Used for computing velocity\r\n     */\r\n    public previousViewProjection: Matrix;\r\n    /**\r\n     * Current view projection matrix\r\n     * Used for computing velocity\r\n     */\r\n    public currentViewProjection: Matrix;\r\n    /**\r\n     * Previous bones of meshes carrying this material\r\n     * Used for computing velocity\r\n     */\r\n    public previousBones: { [index: number]: Float32Array } = {};\r\n\r\n    private _lastUpdateFrameId: number;\r\n\r\n    /**\r\n     * Add the required uniforms to the current list.\r\n     * @param uniforms defines the current uniform list.\r\n     */\r\n    public static AddUniforms(uniforms: string[]): void {\r\n        uniforms.push(\"previousWorld\", \"previousViewProjection\", \"mPreviousBones\");\r\n    }\r\n\r\n    /**\r\n     * Add the required samplers to the current list.\r\n     * @param samplers defines the current sampler list.\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public static AddSamplers(samplers: string[]): void {\r\n        // pass\r\n    }\r\n\r\n    /**\r\n     * Binds the material data.\r\n     * @param effect defines the effect to update\r\n     * @param scene defines the scene the material belongs to.\r\n     * @param mesh The mesh\r\n     * @param world World matrix of this mesh\r\n     * @param isFrozen Is the material frozen\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public bindForSubMesh(effect: Effect, scene: Scene, mesh: Mesh, world: Matrix, isFrozen: boolean): void {\r\n        if (scene.prePassRenderer && scene.prePassRenderer.enabled && scene.prePassRenderer.currentRTisSceneRT) {\r\n            if (scene.prePassRenderer.getIndex(Constants.PREPASS_VELOCITY_TEXTURE_TYPE) !== -1) {\r\n                if (!this.previousWorldMatrices[mesh.uniqueId]) {\r\n                    this.previousWorldMatrices[mesh.uniqueId] = world.clone();\r\n                }\r\n\r\n                if (!this.previousViewProjection) {\r\n                    this.previousViewProjection = scene.getTransformMatrix().clone();\r\n                    this.currentViewProjection = scene.getTransformMatrix().clone();\r\n                }\r\n\r\n                const engine = scene.getEngine();\r\n\r\n                if (this.currentViewProjection.updateFlag !== scene.getTransformMatrix().updateFlag) {\r\n                    // First update of the prepass configuration for this rendering pass\r\n                    this._lastUpdateFrameId = engine.frameId;\r\n                    this.previousViewProjection.copyFrom(this.currentViewProjection);\r\n                    this.currentViewProjection.copyFrom(scene.getTransformMatrix());\r\n                } else if (this._lastUpdateFrameId !== engine.frameId) {\r\n                    // The scene transformation did not change from the previous frame (so no camera motion), we must update previousViewProjection accordingly\r\n                    this._lastUpdateFrameId = engine.frameId;\r\n                    this.previousViewProjection.copyFrom(this.currentViewProjection);\r\n                }\r\n\r\n                effect.setMatrix(\"previousWorld\", this.previousWorldMatrices[mesh.uniqueId]);\r\n                effect.setMatrix(\"previousViewProjection\", this.previousViewProjection);\r\n\r\n                this.previousWorldMatrices[mesh.uniqueId] = world.clone();\r\n            }\r\n        }\r\n    }\r\n}\r\n", "/**\r\n * Manages the defines for the Material\r\n */\r\nexport class MaterialDefines {\r\n    /** @internal */\r\n    protected _keys: string[] = [];\r\n    private _isDirty = true;\r\n    /** @internal */\r\n    public _renderId: number;\r\n\r\n    /** @internal */\r\n    public _areLightsDirty = true;\r\n    /** @internal */\r\n    public _areLightsDisposed = false;\r\n    /** @internal */\r\n    public _areAttributesDirty = true;\r\n    /** @internal */\r\n    public _areTexturesDirty = true;\r\n    /** @internal */\r\n    public _areFresnelDirty = true;\r\n    /** @internal */\r\n    public _areMiscDirty = true;\r\n    /** @internal */\r\n    public _arePrePassDirty = true;\r\n    /** @internal */\r\n    public _areImageProcessingDirty = true;\r\n\r\n    /** @internal */\r\n    public _normals = false;\r\n    /** @internal */\r\n    public _uvs = false;\r\n\r\n    /** @internal */\r\n    public _needNormals = false;\r\n    /** @internal */\r\n    public _needUVs = false;\r\n\r\n    protected _externalProperties?: { [name: string]: { type: string; default: any } };\r\n\r\n    [id: string]: any;\r\n\r\n    /**\r\n     * Creates a new instance\r\n     * @param externalProperties list of external properties to inject into the object\r\n     */\r\n    constructor(externalProperties?: { [name: string]: { type: string; default: any } }) {\r\n        this._externalProperties = externalProperties;\r\n\r\n        // Initialize External Properties\r\n        if (externalProperties) {\r\n            for (const prop in externalProperties) {\r\n                if (Object.prototype.hasOwnProperty.call(externalProperties, prop)) {\r\n                    this._setDefaultValue(prop);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Specifies if the material needs to be re-calculated\r\n     */\r\n    public get isDirty(): boolean {\r\n        return this._isDirty;\r\n    }\r\n\r\n    /**\r\n     * Marks the material to indicate that it has been re-calculated\r\n     */\r\n    public markAsProcessed() {\r\n        this._isDirty = false;\r\n        this._areAttributesDirty = false;\r\n        this._areTexturesDirty = false;\r\n        this._areFresnelDirty = false;\r\n        this._areLightsDirty = false;\r\n        this._areLightsDisposed = false;\r\n        this._areMiscDirty = false;\r\n        this._arePrePassDirty = false;\r\n        this._areImageProcessingDirty = false;\r\n    }\r\n\r\n    /**\r\n     * Marks the material to indicate that it needs to be re-calculated\r\n     */\r\n    public markAsUnprocessed() {\r\n        this._isDirty = true;\r\n    }\r\n\r\n    /**\r\n     * Marks the material to indicate all of its defines need to be re-calculated\r\n     */\r\n    public markAllAsDirty() {\r\n        this._areTexturesDirty = true;\r\n        this._areAttributesDirty = true;\r\n        this._areLightsDirty = true;\r\n        this._areFresnelDirty = true;\r\n        this._areMiscDirty = true;\r\n        this._arePrePassDirty = false;\r\n        this._areImageProcessingDirty = true;\r\n        this._isDirty = true;\r\n    }\r\n\r\n    /**\r\n     * Marks the material to indicate that image processing needs to be re-calculated\r\n     */\r\n    public markAsImageProcessingDirty() {\r\n        this._areImageProcessingDirty = true;\r\n        this._isDirty = true;\r\n    }\r\n\r\n    /**\r\n     * Marks the material to indicate the lights need to be re-calculated\r\n     * @param disposed Defines whether the light is dirty due to dispose or not\r\n     */\r\n    public markAsLightDirty(disposed = false) {\r\n        this._areLightsDirty = true;\r\n        this._areLightsDisposed = this._areLightsDisposed || disposed;\r\n        this._isDirty = true;\r\n    }\r\n\r\n    /**\r\n     * Marks the attribute state as changed\r\n     */\r\n    public markAsAttributesDirty() {\r\n        this._areAttributesDirty = true;\r\n        this._isDirty = true;\r\n    }\r\n\r\n    /**\r\n     * Marks the texture state as changed\r\n     */\r\n    public markAsTexturesDirty() {\r\n        this._areTexturesDirty = true;\r\n        this._isDirty = true;\r\n    }\r\n\r\n    /**\r\n     * Marks the fresnel state as changed\r\n     */\r\n    public markAsFresnelDirty() {\r\n        this._areFresnelDirty = true;\r\n        this._isDirty = true;\r\n    }\r\n\r\n    /**\r\n     * Marks the misc state as changed\r\n     */\r\n    public markAsMiscDirty() {\r\n        this._areMiscDirty = true;\r\n        this._isDirty = true;\r\n    }\r\n\r\n    /**\r\n     * Marks the prepass state as changed\r\n     */\r\n    public markAsPrePassDirty() {\r\n        this._arePrePassDirty = true;\r\n        this._isDirty = true;\r\n    }\r\n\r\n    /**\r\n     * Rebuilds the material defines\r\n     */\r\n    public rebuild() {\r\n        this._keys.length = 0;\r\n\r\n        for (const key of Object.keys(this)) {\r\n            if (key[0] === \"_\") {\r\n                continue;\r\n            }\r\n\r\n            this._keys.push(key);\r\n        }\r\n\r\n        if (this._externalProperties) {\r\n            for (const name in this._externalProperties) {\r\n                if (this._keys.indexOf(name) === -1) {\r\n                    this._keys.push(name);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Specifies if two material defines are equal\r\n     * @param other - A material define instance to compare to\r\n     * @returns - Boolean indicating if the material defines are equal (true) or not (false)\r\n     */\r\n    public isEqual(other: MaterialDefines): boolean {\r\n        if (this._keys.length !== other._keys.length) {\r\n            return false;\r\n        }\r\n\r\n        for (let index = 0; index < this._keys.length; index++) {\r\n            const prop = this._keys[index];\r\n\r\n            if ((<any>this)[prop] !== (<any>other)[prop]) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Clones this instance's defines to another instance\r\n     * @param other - material defines to clone values to\r\n     */\r\n    public cloneTo(other: MaterialDefines): void {\r\n        if (this._keys.length !== other._keys.length) {\r\n            other._keys = this._keys.slice(0);\r\n        }\r\n\r\n        for (let index = 0; index < this._keys.length; index++) {\r\n            const prop = this._keys[index];\r\n\r\n            (<any>other)[prop] = (<any>this)[prop];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Resets the material define values\r\n     */\r\n    public reset(): void {\r\n        this._keys.forEach((prop) => this._setDefaultValue(prop));\r\n    }\r\n\r\n    private _setDefaultValue(prop: string): void {\r\n        const type = this._externalProperties?.[prop]?.type ?? typeof (<any>this)[prop];\r\n        const defValue = this._externalProperties?.[prop]?.default;\r\n\r\n        switch (type) {\r\n            case \"number\":\r\n                (<any>this)[prop] = defValue ?? 0;\r\n                break;\r\n            case \"string\":\r\n                (<any>this)[prop] = defValue ?? \"\";\r\n                break;\r\n            default:\r\n                (<any>this)[prop] = defValue ?? false;\r\n                break;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Converts the material define values to a string\r\n     * @returns - String of material define information\r\n     */\r\n    public toString(): string {\r\n        let result = \"\";\r\n        for (let index = 0; index < this._keys.length; index++) {\r\n            const prop = this._keys[index];\r\n            const value = (<any>this)[prop];\r\n            const type = typeof value;\r\n\r\n            switch (type) {\r\n                case \"number\":\r\n                case \"string\":\r\n                    result += \"#define \" + prop + \" \" + value + \"\\n\";\r\n                    break;\r\n                default:\r\n                    if (value) {\r\n                        result += \"#define \" + prop + \"\\n\";\r\n                    }\r\n                    break;\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n}\r\n", "import type { Nullable } from \"../types\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Matrix } from \"../Maths/math.vector\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { Mesh } from \"../Meshes/mesh\";\r\nimport { Material } from \"../Materials/material\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport type { SubMesh } from \"../Meshes/subMesh\";\r\n/**\r\n * Base class of materials working in push mode in babylon JS\r\n * @internal\r\n */\r\nexport class PushMaterial extends Material {\r\n    protected _activeEffect?: Effect;\r\n\r\n    protected _normalMatrix: Matrix = new Matrix();\r\n\r\n    constructor(name: string, scene?: Scene, storeEffectOnSubMeshes = true) {\r\n        super(name, scene);\r\n        this._storeEffectOnSubMeshes = storeEffectOnSubMeshes;\r\n    }\r\n\r\n    public getEffect(): Effect {\r\n        return this._storeEffectOnSubMeshes ? this._activeEffect! : super.getEffect()!;\r\n    }\r\n\r\n    public isReady(mesh?: AbstractMesh, useInstances?: boolean): boolean {\r\n        if (!mesh) {\r\n            return false;\r\n        }\r\n\r\n        if (!this._storeEffectOnSubMeshes) {\r\n            return true;\r\n        }\r\n\r\n        if (!mesh.subMeshes || mesh.subMeshes.length === 0) {\r\n            return true;\r\n        }\r\n\r\n        return this.isReadyForSubMesh(mesh, mesh.subMeshes[0], useInstances);\r\n    }\r\n\r\n    protected _isReadyForSubMesh(subMesh: SubMesh) {\r\n        const defines = subMesh.materialDefines;\r\n        if (!this.checkReadyOnEveryCall && subMesh.effect && defines) {\r\n            if (defines._renderId === this.getScene().getRenderId()) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Binds the given world matrix to the active effect\r\n     *\r\n     * @param world the matrix to bind\r\n     */\r\n    public bindOnlyWorldMatrix(world: Matrix): void {\r\n        this._activeEffect!.setMatrix(\"world\", world);\r\n    }\r\n\r\n    /**\r\n     * Binds the given normal matrix to the active effect\r\n     *\r\n     * @param normalMatrix the matrix to bind\r\n     */\r\n    public bindOnlyNormalMatrix(normalMatrix: Matrix): void {\r\n        this._activeEffect!.setMatrix(\"normalMatrix\", normalMatrix);\r\n    }\r\n\r\n    public bind(world: Matrix, mesh?: Mesh): void {\r\n        if (!mesh) {\r\n            return;\r\n        }\r\n\r\n        this.bindForSubMesh(world, mesh, mesh.subMeshes[0]);\r\n    }\r\n\r\n    protected _afterBind(mesh?: Mesh, effect: Nullable<Effect> = null, subMesh?: SubMesh): void {\r\n        super._afterBind(mesh, effect, subMesh);\r\n        this.getScene()._cachedEffect = effect;\r\n        if (subMesh) {\r\n            subMesh._drawWrapper._forceRebindOnNextCall = false;\r\n        } else {\r\n            this._drawWrapper._forceRebindOnNextCall = false;\r\n        }\r\n    }\r\n\r\n    protected _mustRebind(scene: Scene, effect: Effect, subMesh: SubMesh, visibility = 1): boolean {\r\n        return subMesh._drawWrapper._forceRebindOnNextCall || scene.isCachedMaterialInvalid(this, effect, visibility);\r\n    }\r\n\r\n    public dispose(forceDisposeEffect?: boolean, forceDisposeTextures?: boolean, notBoundToMesh?: boolean) {\r\n        this._activeEffect = undefined;\r\n        super.dispose(forceDisposeEffect, forceDisposeTextures, notBoundToMesh);\r\n    }\r\n}\r\n", "import { Engine } from \"../Engines/engine\";\r\nimport { Constants } from \"../Engines/constants\";\r\n\r\n/**\r\n * This groups all the flags used to control the materials channel.\r\n */\r\nexport class MaterialFlags {\r\n    // Flags used to enable or disable a type of texture for all Standard Materials\r\n    private static _DiffuseTextureEnabled = true;\r\n    /**\r\n     * Are diffuse textures enabled in the application.\r\n     */\r\n    public static get DiffuseTextureEnabled(): boolean {\r\n        return this._DiffuseTextureEnabled;\r\n    }\r\n    public static set DiffuseTextureEnabled(value: boolean) {\r\n        if (this._DiffuseTextureEnabled === value) {\r\n            return;\r\n        }\r\n\r\n        this._DiffuseTextureEnabled = value;\r\n        Engine.MarkAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag);\r\n    }\r\n\r\n    private static _DetailTextureEnabled = true;\r\n    /**\r\n     * Are detail textures enabled in the application.\r\n     */\r\n    public static get DetailTextureEnabled(): boolean {\r\n        return this._DetailTextureEnabled;\r\n    }\r\n    public static set DetailTextureEnabled(value: boolean) {\r\n        if (this._DetailTextureEnabled === value) {\r\n            return;\r\n        }\r\n\r\n        this._DetailTextureEnabled = value;\r\n        Engine.MarkAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag);\r\n    }\r\n\r\n    private static _DecalMapEnabled = true;\r\n    /**\r\n     * Are decal maps enabled in the application.\r\n     */\r\n    public static get DecalMapEnabled(): boolean {\r\n        return this._DecalMapEnabled;\r\n    }\r\n    public static set DecalMapEnabled(value: boolean) {\r\n        if (this._DecalMapEnabled === value) {\r\n            return;\r\n        }\r\n\r\n        this._DecalMapEnabled = value;\r\n        Engine.MarkAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag);\r\n    }\r\n\r\n    private static _AmbientTextureEnabled = true;\r\n    /**\r\n     * Are ambient textures enabled in the application.\r\n     */\r\n    public static get AmbientTextureEnabled(): boolean {\r\n        return this._AmbientTextureEnabled;\r\n    }\r\n    public static set AmbientTextureEnabled(value: boolean) {\r\n        if (this._AmbientTextureEnabled === value) {\r\n            return;\r\n        }\r\n\r\n        this._AmbientTextureEnabled = value;\r\n        Engine.MarkAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag);\r\n    }\r\n\r\n    private static _OpacityTextureEnabled = true;\r\n    /**\r\n     * Are opacity textures enabled in the application.\r\n     */\r\n    public static get OpacityTextureEnabled(): boolean {\r\n        return this._OpacityTextureEnabled;\r\n    }\r\n    public static set OpacityTextureEnabled(value: boolean) {\r\n        if (this._OpacityTextureEnabled === value) {\r\n            return;\r\n        }\r\n\r\n        this._OpacityTextureEnabled = value;\r\n        Engine.MarkAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag);\r\n    }\r\n\r\n    private static _ReflectionTextureEnabled = true;\r\n    /**\r\n     * Are reflection textures enabled in the application.\r\n     */\r\n    public static get ReflectionTextureEnabled(): boolean {\r\n        return this._ReflectionTextureEnabled;\r\n    }\r\n    public static set ReflectionTextureEnabled(value: boolean) {\r\n        if (this._ReflectionTextureEnabled === value) {\r\n            return;\r\n        }\r\n\r\n        this._ReflectionTextureEnabled = value;\r\n        Engine.MarkAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag);\r\n    }\r\n\r\n    private static _EmissiveTextureEnabled = true;\r\n    /**\r\n     * Are emissive textures enabled in the application.\r\n     */\r\n    public static get EmissiveTextureEnabled(): boolean {\r\n        return this._EmissiveTextureEnabled;\r\n    }\r\n    public static set EmissiveTextureEnabled(value: boolean) {\r\n        if (this._EmissiveTextureEnabled === value) {\r\n            return;\r\n        }\r\n\r\n        this._EmissiveTextureEnabled = value;\r\n        Engine.MarkAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag);\r\n    }\r\n\r\n    private static _SpecularTextureEnabled = true;\r\n    /**\r\n     * Are specular textures enabled in the application.\r\n     */\r\n    public static get SpecularTextureEnabled(): boolean {\r\n        return this._SpecularTextureEnabled;\r\n    }\r\n    public static set SpecularTextureEnabled(value: boolean) {\r\n        if (this._SpecularTextureEnabled === value) {\r\n            return;\r\n        }\r\n\r\n        this._SpecularTextureEnabled = value;\r\n        Engine.MarkAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag);\r\n    }\r\n\r\n    private static _BumpTextureEnabled = true;\r\n    /**\r\n     * Are bump textures enabled in the application.\r\n     */\r\n    public static get BumpTextureEnabled(): boolean {\r\n        return this._BumpTextureEnabled;\r\n    }\r\n    public static set BumpTextureEnabled(value: boolean) {\r\n        if (this._BumpTextureEnabled === value) {\r\n            return;\r\n        }\r\n\r\n        this._BumpTextureEnabled = value;\r\n        Engine.MarkAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag);\r\n    }\r\n\r\n    private static _LightmapTextureEnabled = true;\r\n    /**\r\n     * Are lightmap textures enabled in the application.\r\n     */\r\n    public static get LightmapTextureEnabled(): boolean {\r\n        return this._LightmapTextureEnabled;\r\n    }\r\n    public static set LightmapTextureEnabled(value: boolean) {\r\n        if (this._LightmapTextureEnabled === value) {\r\n            return;\r\n        }\r\n\r\n        this._LightmapTextureEnabled = value;\r\n        Engine.MarkAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag);\r\n    }\r\n\r\n    private static _RefractionTextureEnabled = true;\r\n    /**\r\n     * Are refraction textures enabled in the application.\r\n     */\r\n    public static get RefractionTextureEnabled(): boolean {\r\n        return this._RefractionTextureEnabled;\r\n    }\r\n    public static set RefractionTextureEnabled(value: boolean) {\r\n        if (this._RefractionTextureEnabled === value) {\r\n            return;\r\n        }\r\n\r\n        this._RefractionTextureEnabled = value;\r\n        Engine.MarkAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag);\r\n    }\r\n\r\n    private static _ColorGradingTextureEnabled = true;\r\n    /**\r\n     * Are color grading textures enabled in the application.\r\n     */\r\n    public static get ColorGradingTextureEnabled(): boolean {\r\n        return this._ColorGradingTextureEnabled;\r\n    }\r\n    public static set ColorGradingTextureEnabled(value: boolean) {\r\n        if (this._ColorGradingTextureEnabled === value) {\r\n            return;\r\n        }\r\n\r\n        this._ColorGradingTextureEnabled = value;\r\n        Engine.MarkAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag);\r\n    }\r\n\r\n    private static _FresnelEnabled = true;\r\n    /**\r\n     * Are fresnels enabled in the application.\r\n     */\r\n    public static get FresnelEnabled(): boolean {\r\n        return this._FresnelEnabled;\r\n    }\r\n    public static set FresnelEnabled(value: boolean) {\r\n        if (this._FresnelEnabled === value) {\r\n            return;\r\n        }\r\n\r\n        this._FresnelEnabled = value;\r\n        Engine.MarkAllMaterialsAsDirty(Constants.MATERIAL_FresnelDirtyFlag);\r\n    }\r\n\r\n    private static _ClearCoatTextureEnabled = true;\r\n    /**\r\n     * Are clear coat textures enabled in the application.\r\n     */\r\n    public static get ClearCoatTextureEnabled(): boolean {\r\n        return this._ClearCoatTextureEnabled;\r\n    }\r\n    public static set ClearCoatTextureEnabled(value: boolean) {\r\n        if (this._ClearCoatTextureEnabled === value) {\r\n            return;\r\n        }\r\n\r\n        this._ClearCoatTextureEnabled = value;\r\n        Engine.MarkAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag);\r\n    }\r\n\r\n    private static _ClearCoatBumpTextureEnabled = true;\r\n    /**\r\n     * Are clear coat bump textures enabled in the application.\r\n     */\r\n    public static get ClearCoatBumpTextureEnabled(): boolean {\r\n        return this._ClearCoatBumpTextureEnabled;\r\n    }\r\n    public static set ClearCoatBumpTextureEnabled(value: boolean) {\r\n        if (this._ClearCoatBumpTextureEnabled === value) {\r\n            return;\r\n        }\r\n\r\n        this._ClearCoatBumpTextureEnabled = value;\r\n        Engine.MarkAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag);\r\n    }\r\n\r\n    private static _ClearCoatTintTextureEnabled = true;\r\n    /**\r\n     * Are clear coat tint textures enabled in the application.\r\n     */\r\n    public static get ClearCoatTintTextureEnabled(): boolean {\r\n        return this._ClearCoatTintTextureEnabled;\r\n    }\r\n    public static set ClearCoatTintTextureEnabled(value: boolean) {\r\n        if (this._ClearCoatTintTextureEnabled === value) {\r\n            return;\r\n        }\r\n\r\n        this._ClearCoatTintTextureEnabled = value;\r\n        Engine.MarkAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag);\r\n    }\r\n\r\n    private static _SheenTextureEnabled = true;\r\n    /**\r\n     * Are sheen textures enabled in the application.\r\n     */\r\n    public static get SheenTextureEnabled(): boolean {\r\n        return this._SheenTextureEnabled;\r\n    }\r\n    public static set SheenTextureEnabled(value: boolean) {\r\n        if (this._SheenTextureEnabled === value) {\r\n            return;\r\n        }\r\n\r\n        this._SheenTextureEnabled = value;\r\n        Engine.MarkAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag);\r\n    }\r\n\r\n    private static _AnisotropicTextureEnabled = true;\r\n    /**\r\n     * Are anisotropic textures enabled in the application.\r\n     */\r\n    public static get AnisotropicTextureEnabled(): boolean {\r\n        return this._AnisotropicTextureEnabled;\r\n    }\r\n    public static set AnisotropicTextureEnabled(value: boolean) {\r\n        if (this._AnisotropicTextureEnabled === value) {\r\n            return;\r\n        }\r\n\r\n        this._AnisotropicTextureEnabled = value;\r\n        Engine.MarkAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag);\r\n    }\r\n\r\n    private static _ThicknessTextureEnabled = true;\r\n    /**\r\n     * Are thickness textures enabled in the application.\r\n     */\r\n    public static get ThicknessTextureEnabled(): boolean {\r\n        return this._ThicknessTextureEnabled;\r\n    }\r\n    public static set ThicknessTextureEnabled(value: boolean) {\r\n        if (this._ThicknessTextureEnabled === value) {\r\n            return;\r\n        }\r\n\r\n        this._ThicknessTextureEnabled = value;\r\n        Engine.MarkAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag);\r\n    }\r\n\r\n    private static _RefractionIntensityTextureEnabled = true;\r\n    /**\r\n     * Are refraction intensity textures enabled in the application.\r\n     */\r\n    public static get RefractionIntensityTextureEnabled(): boolean {\r\n        return this._ThicknessTextureEnabled;\r\n    }\r\n    public static set RefractionIntensityTextureEnabled(value: boolean) {\r\n        if (this._RefractionIntensityTextureEnabled === value) {\r\n            return;\r\n        }\r\n\r\n        this._RefractionIntensityTextureEnabled = value;\r\n        Engine.MarkAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag);\r\n    }\r\n\r\n    private static _TranslucencyIntensityTextureEnabled = true;\r\n    /**\r\n     * Are translucency intensity textures enabled in the application.\r\n     */\r\n    public static get TranslucencyIntensityTextureEnabled(): boolean {\r\n        return this._ThicknessTextureEnabled;\r\n    }\r\n    public static set TranslucencyIntensityTextureEnabled(value: boolean) {\r\n        if (this._TranslucencyIntensityTextureEnabled === value) {\r\n            return;\r\n        }\r\n\r\n        this._TranslucencyIntensityTextureEnabled = value;\r\n        Engine.MarkAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag);\r\n    }\r\n\r\n    private static _IridescenceTextureEnabled = true;\r\n    /**\r\n     * Are translucency intensity textures enabled in the application.\r\n     */\r\n    public static get IridescenceTextureEnabled(): boolean {\r\n        return this._IridescenceTextureEnabled;\r\n    }\r\n    public static set IridescenceTextureEnabled(value: boolean) {\r\n        if (this._IridescenceTextureEnabled === value) {\r\n            return;\r\n        }\r\n\r\n        this._IridescenceTextureEnabled = value;\r\n        Engine.MarkAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag);\r\n    }\r\n}\r\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"decalFragmentDeclaration\";\nconst shader = `#ifdef DECAL\nuniform vec4 vDecalInfos;\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const decalFragmentDeclaration = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\nimport \"./decalFragmentDeclaration\";\n\nconst name = \"defaultFragmentDeclaration\";\nconst shader = `uniform vec4 vEyePosition;uniform vec4 vDiffuseColor;\n#ifdef SPECULARTERM\nuniform vec4 vSpecularColor;\n#endif\nuniform vec3 vEmissiveColor;uniform vec3 vAmbientColor;uniform float visibility;\n#ifdef DIFFUSE\nuniform vec2 vDiffuseInfos;\n#endif\n#ifdef AMBIENT\nuniform vec2 vAmbientInfos;\n#endif\n#ifdef OPACITY \nuniform vec2 vOpacityInfos;\n#endif\n#ifdef EMISSIVE\nuniform vec2 vEmissiveInfos;\n#endif\n#ifdef LIGHTMAP\nuniform vec2 vLightmapInfos;\n#endif\n#ifdef BUMP\nuniform vec3 vBumpInfos;uniform vec2 vTangentSpaceParams;\n#endif\n#ifdef ALPHATEST\nuniform float alphaCutOff;\n#endif\n#if defined(REFLECTIONMAP_SPHERICAL) || defined(REFLECTIONMAP_PROJECTION) || defined(REFRACTION) || defined(PREPASS)\nuniform mat4 view;\n#endif\n#ifdef REFRACTION\nuniform vec4 vRefractionInfos;\n#ifndef REFRACTIONMAP_3D\nuniform mat4 refractionMatrix;\n#endif\n#ifdef REFRACTIONFRESNEL\nuniform vec4 refractionLeftColor;uniform vec4 refractionRightColor;\n#endif\n#if defined(USE_LOCAL_REFRACTIONMAP_CUBIC) && defined(REFRACTIONMAP_3D)\nuniform vec3 vRefractionPosition;uniform vec3 vRefractionSize; \n#endif\n#endif\n#if defined(SPECULAR) && defined(SPECULARTERM)\nuniform vec2 vSpecularInfos;\n#endif\n#ifdef DIFFUSEFRESNEL\nuniform vec4 diffuseLeftColor;uniform vec4 diffuseRightColor;\n#endif\n#ifdef OPACITYFRESNEL\nuniform vec4 opacityParts;\n#endif\n#ifdef EMISSIVEFRESNEL\nuniform vec4 emissiveLeftColor;uniform vec4 emissiveRightColor;\n#endif\n#ifdef REFLECTION\nuniform vec2 vReflectionInfos;\n#if defined(REFLECTIONMAP_PLANAR) || defined(REFLECTIONMAP_CUBIC) || defined(REFLECTIONMAP_PROJECTION) || defined(REFLECTIONMAP_EQUIRECTANGULAR) || defined(REFLECTIONMAP_SPHERICAL) || defined(REFLECTIONMAP_SKYBOX)\nuniform mat4 reflectionMatrix;\n#endif\n#ifndef REFLECTIONMAP_SKYBOX\n#if defined(USE_LOCAL_REFLECTIONMAP_CUBIC) && defined(REFLECTIONMAP_CUBIC)\nuniform vec3 vReflectionPosition;uniform vec3 vReflectionSize; \n#endif\n#endif\n#ifdef REFLECTIONFRESNEL\nuniform vec4 reflectionLeftColor;uniform vec4 reflectionRightColor;\n#endif\n#endif\n#ifdef DETAIL\nuniform vec4 vDetailInfos;\n#endif\n#include<decalFragmentDeclaration>\n#define ADDITIONAL_FRAGMENT_DECLARATION\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const defaultFragmentDeclaration = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"sceneUboDeclaration\";\nconst shader = `layout(std140,column_major) uniform;uniform Scene {mat4 viewProjection;\n#ifdef MULTIVIEW\nmat4 viewProjectionR;\n#endif \nmat4 view;mat4 projection;vec4 vEyePosition;};\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const sceneUboDeclaration = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"meshUboDeclaration\";\nconst shader = `#ifdef WEBGL2\nuniform mat4 world;uniform float visibility;\n#else\nlayout(std140,column_major) uniform;uniform Mesh\n{mat4 world;float visibility;};\n#endif\n#define WORLD_UBO\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const meshUboDeclaration = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\nimport \"./sceneUboDeclaration\";\nimport \"./meshUboDeclaration\";\n\nconst name = \"defaultUboDeclaration\";\nconst shader = `layout(std140,column_major) uniform;uniform Material\n{vec4 diffuseLeftColor;vec4 diffuseRightColor;vec4 opacityParts;vec4 reflectionLeftColor;vec4 reflectionRightColor;vec4 refractionLeftColor;vec4 refractionRightColor;vec4 emissiveLeftColor;vec4 emissiveRightColor;vec2 vDiffuseInfos;vec2 vAmbientInfos;vec2 vOpacityInfos;vec2 vReflectionInfos;vec3 vReflectionPosition;vec3 vReflectionSize;vec2 vEmissiveInfos;vec2 vLightmapInfos;vec2 vSpecularInfos;vec3 vBumpInfos;mat4 diffuseMatrix;mat4 ambientMatrix;mat4 opacityMatrix;mat4 reflectionMatrix;mat4 emissiveMatrix;mat4 lightmapMatrix;mat4 specularMatrix;mat4 bumpMatrix;vec2 vTangentSpaceParams;float pointSize;float alphaCutOff;mat4 refractionMatrix;vec4 vRefractionInfos;vec3 vRefractionPosition;vec3 vRefractionSize;vec4 vSpecularColor;vec3 vEmissiveColor;vec4 vDiffuseColor;vec3 vAmbientColor;\n#define ADDITIONAL_UBO_DECLARATION\n};\n#include<sceneUboDeclaration>\n#include<meshUboDeclaration>\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const defaultUboDeclaration = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"prePassDeclaration\";\nconst shader = `#ifdef PREPASS\n#extension GL_EXT_draw_buffers : require\nlayout(location=0) out highp vec4 glFragData[{X}];highp vec4 gl_FragColor;\n#ifdef PREPASS_DEPTH\nvarying highp vec3 vViewPos;\n#endif\n#ifdef PREPASS_VELOCITY\nvarying highp vec4 vCurrentPosition;varying highp vec4 vPreviousPosition;\n#endif\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const prePassDeclaration = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"oitDeclaration\";\nconst shader = `#ifdef ORDER_INDEPENDENT_TRANSPARENCY\n#extension GL_EXT_draw_buffers : require\nlayout(location=0) out vec2 depth; \nlayout(location=1) out vec4 frontColor;layout(location=2) out vec4 backColor;\n#define MAX_DEPTH 99999.0\nhighp vec4 gl_FragColor;uniform sampler2D oitDepthSampler;uniform sampler2D oitFrontColorSampler;\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const oitDeclaration = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"mainUVVaryingDeclaration\";\nconst shader = `#ifdef MAINUV{X}\nvarying vec2 vMainUV{X};\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const mainUVVaryingDeclaration = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"helperFunctions\";\nconst shader = `const float PI=3.1415926535897932384626433832795;const float RECIPROCAL_PI=0.3183098861837907;const float RECIPROCAL_PI2=0.15915494309189535;const float HALF_MIN=5.96046448e-08; \nconst float LinearEncodePowerApprox=2.2;const float GammaEncodePowerApprox=1.0/LinearEncodePowerApprox;const vec3 LuminanceEncodeApprox=vec3(0.2126,0.7152,0.0722);const float Epsilon=0.0000001;\n#define saturate(x) clamp(x,0.0,1.0)\n#define absEps(x) abs(x)+Epsilon\n#define maxEps(x) max(x,Epsilon)\n#define saturateEps(x) clamp(x,Epsilon,1.0)\nmat3 transposeMat3(mat3 inMatrix) {vec3 i0=inMatrix[0];vec3 i1=inMatrix[1];vec3 i2=inMatrix[2];mat3 outMatrix=mat3(\nvec3(i0.x,i1.x,i2.x),\nvec3(i0.y,i1.y,i2.y),\nvec3(i0.z,i1.z,i2.z)\n);return outMatrix;}\nmat3 inverseMat3(mat3 inMatrix) {float a00=inMatrix[0][0],a01=inMatrix[0][1],a02=inMatrix[0][2];float a10=inMatrix[1][0],a11=inMatrix[1][1],a12=inMatrix[1][2];float a20=inMatrix[2][0],a21=inMatrix[2][1],a22=inMatrix[2][2];float b01=a22*a11-a12*a21;float b11=-a22*a10+a12*a20;float b21=a21*a10-a11*a20;float det=a00*b01+a01*b11+a02*b21;return mat3(b01,(-a22*a01+a02*a21),(a12*a01-a02*a11),\nb11,(a22*a00-a02*a20),(-a12*a00+a02*a10),\nb21,(-a21*a00+a01*a20),(a11*a00-a01*a10))/det;}\n#if USE_EXACT_SRGB_CONVERSIONS\nvec3 toLinearSpaceExact(vec3 color)\n{vec3 nearZeroSection=0.0773993808*color;vec3 remainingSection=pow(0.947867299*(color+vec3(0.055)),vec3(2.4));\n#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)\nreturn mix(remainingSection,nearZeroSection,lessThanEqual(color,vec3(0.04045)));\n#else\nreturn\nvec3(\ncolor.r<=0.04045 ? nearZeroSection.r : remainingSection.r,\ncolor.g<=0.04045 ? nearZeroSection.g : remainingSection.g,\ncolor.b<=0.04045 ? nearZeroSection.b : remainingSection.b);\n#endif\n}\nvec3 toGammaSpaceExact(vec3 color)\n{vec3 nearZeroSection=12.92*color;vec3 remainingSection=1.055*pow(color,vec3(0.41666))-vec3(0.055);\n#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)\nreturn mix(remainingSection,nearZeroSection,lessThanEqual(color,vec3(0.0031308)));\n#else\nreturn\nvec3(\ncolor.r<=0.0031308 ? nearZeroSection.r : remainingSection.r,\ncolor.g<=0.0031308 ? nearZeroSection.g : remainingSection.g,\ncolor.b<=0.0031308 ? nearZeroSection.b : remainingSection.b);\n#endif\n}\n#endif\nfloat toLinearSpace(float color)\n{\n#if USE_EXACT_SRGB_CONVERSIONS\nfloat nearZeroSection=0.0773993808*color;float remainingSection=pow(0.947867299*(color+0.055),2.4);return color<=0.04045 ? nearZeroSection : remainingSection;\n#else\nreturn pow(color,LinearEncodePowerApprox);\n#endif\n}\nvec3 toLinearSpace(vec3 color)\n{\n#if USE_EXACT_SRGB_CONVERSIONS\nreturn toLinearSpaceExact(color);\n#else\nreturn pow(color,vec3(LinearEncodePowerApprox));\n#endif\n}\nvec4 toLinearSpace(vec4 color)\n{\n#if USE_EXACT_SRGB_CONVERSIONS\nreturn vec4(toLinearSpaceExact(color.rgb),color.a);\n#else\nreturn vec4(pow(color.rgb,vec3(LinearEncodePowerApprox)),color.a);\n#endif\n}\nfloat toGammaSpace(float color)\n{\n#if USE_EXACT_SRGB_CONVERSIONS\nfloat nearZeroSection=12.92*color;float remainingSection=1.055*pow(color,0.41666)-0.055;return color<=0.0031308 ? nearZeroSection : remainingSection;\n#else\nreturn pow(color,GammaEncodePowerApprox);\n#endif\n}\nvec3 toGammaSpace(vec3 color)\n{\n#if USE_EXACT_SRGB_CONVERSIONS\nreturn toGammaSpaceExact(color);\n#else\nreturn pow(color,vec3(GammaEncodePowerApprox));\n#endif\n}\nvec4 toGammaSpace(vec4 color)\n{\n#if USE_EXACT_SRGB_CONVERSIONS\nreturn vec4(toGammaSpaceExact(color.rgb),color.a);\n#else\nreturn vec4(pow(color.rgb,vec3(GammaEncodePowerApprox)),color.a);\n#endif\n}\nfloat square(float value)\n{return value*value;}\nvec3 square(vec3 value)\n{return value*value;}\nfloat pow5(float value) {float sq=value*value;return sq*sq*value;}\nfloat getLuminance(vec3 color)\n{return clamp(dot(color,LuminanceEncodeApprox),0.,1.);}\nfloat getRand(vec2 seed) {return fract(sin(dot(seed.xy ,vec2(12.9898,78.233)))*43758.5453);}\nfloat dither(vec2 seed,float varianceAmount) {float rand=getRand(seed);float normVariance=varianceAmount/255.0;float dither=mix(-normVariance,normVariance,rand);return dither;}\nconst float rgbdMaxRange=255.0;vec4 toRGBD(vec3 color) {float maxRGB=maxEps(max(color.r,max(color.g,color.b)));float D =max(rgbdMaxRange/maxRGB,1.);D =clamp(floor(D)/255.0,0.,1.);vec3 rgb=color.rgb*D;rgb=toGammaSpace(rgb);return vec4(clamp(rgb,0.,1.),D); }\nvec3 fromRGBD(vec4 rgbd) {rgbd.rgb=toLinearSpace(rgbd.rgb);return rgbd.rgb/rgbd.a;}\nvec3 parallaxCorrectNormal( vec3 vertexPos,vec3 origVec,vec3 cubeSize,vec3 cubePos ) {vec3 invOrigVec=vec3(1.0,1.0,1.0)/origVec;vec3 halfSize=cubeSize*0.5;vec3 intersecAtMaxPlane=(cubePos+halfSize-vertexPos)*invOrigVec;vec3 intersecAtMinPlane=(cubePos-halfSize-vertexPos)*invOrigVec;vec3 largestIntersec=max(intersecAtMaxPlane,intersecAtMinPlane);float distance=min(min(largestIntersec.x,largestIntersec.y),largestIntersec.z);vec3 intersectPositionWS=vertexPos+origVec*distance;return intersectPositionWS-cubePos;}\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const helperFunctions = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"lightFragmentDeclaration\";\nconst shader = `#ifdef LIGHT{X}\nuniform vec4 vLightData{X};uniform vec4 vLightDiffuse{X};\n#ifdef SPECULARTERM\nuniform vec4 vLightSpecular{X};\n#else\nvec4 vLightSpecular{X}=vec4(0.);\n#endif\n#ifdef SHADOW{X}\n#ifdef SHADOWCSM{X}\nuniform mat4 lightMatrix{X}[SHADOWCSMNUM_CASCADES{X}];uniform float viewFrustumZ{X}[SHADOWCSMNUM_CASCADES{X}];uniform float frustumLengths{X}[SHADOWCSMNUM_CASCADES{X}];uniform float cascadeBlendFactor{X};varying vec4 vPositionFromLight{X}[SHADOWCSMNUM_CASCADES{X}];varying float vDepthMetric{X}[SHADOWCSMNUM_CASCADES{X}];varying vec4 vPositionFromCamera{X};\n#if defined(SHADOWPCSS{X})\nuniform highp sampler2DArrayShadow shadowSampler{X};uniform highp sampler2DArray depthSampler{X};uniform vec2 lightSizeUVCorrection{X}[SHADOWCSMNUM_CASCADES{X}];uniform float depthCorrection{X}[SHADOWCSMNUM_CASCADES{X}];uniform float penumbraDarkness{X};\n#elif defined(SHADOWPCF{X})\nuniform highp sampler2DArrayShadow shadowSampler{X};\n#else\nuniform highp sampler2DArray shadowSampler{X};\n#endif\n#ifdef SHADOWCSMDEBUG{X}\nconst vec3 vCascadeColorsMultiplier{X}[8]=vec3[8]\n(\nvec3 ( 1.5,0.0,0.0 ),\nvec3 ( 0.0,1.5,0.0 ),\nvec3 ( 0.0,0.0,5.5 ),\nvec3 ( 1.5,0.0,5.5 ),\nvec3 ( 1.5,1.5,0.0 ),\nvec3 ( 1.0,1.0,1.0 ),\nvec3 ( 0.0,1.0,5.5 ),\nvec3 ( 0.5,3.5,0.75 )\n);vec3 shadowDebug{X};\n#endif\n#ifdef SHADOWCSMUSESHADOWMAXZ{X}\nint index{X}=-1;\n#else\nint index{X}=SHADOWCSMNUM_CASCADES{X}-1;\n#endif\nfloat diff{X}=0.;\n#elif defined(SHADOWCUBE{X})\nuniform samplerCube shadowSampler{X};\n#else\nvarying vec4 vPositionFromLight{X};varying float vDepthMetric{X};\n#if defined(SHADOWPCSS{X})\nuniform highp sampler2DShadow shadowSampler{X};uniform highp sampler2D depthSampler{X};\n#elif defined(SHADOWPCF{X})\nuniform highp sampler2DShadow shadowSampler{X};\n#else\nuniform sampler2D shadowSampler{X};\n#endif\nuniform mat4 lightMatrix{X};\n#endif\nuniform vec4 shadowsInfo{X};uniform vec2 depthValues{X};\n#endif\n#ifdef SPOTLIGHT{X}\nuniform vec4 vLightDirection{X};uniform vec4 vLightFalloff{X};\n#elif defined(POINTLIGHT{X})\nuniform vec4 vLightFalloff{X};\n#elif defined(HEMILIGHT{X})\nuniform vec3 vLightGround{X};\n#endif\n#ifdef PROJECTEDLIGHTTEXTURE{X}\nuniform mat4 textureProjectionMatrix{X};uniform sampler2D projectionLightSampler{X};\n#endif\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const lightFragmentDeclaration = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"lightUboDeclaration\";\nconst shader = `#ifdef LIGHT{X}\nuniform Light{X}\n{vec4 vLightData;vec4 vLightDiffuse;vec4 vLightSpecular;\n#ifdef SPOTLIGHT{X}\nvec4 vLightDirection;vec4 vLightFalloff;\n#elif defined(POINTLIGHT{X})\nvec4 vLightFalloff;\n#elif defined(HEMILIGHT{X})\nvec3 vLightGround;\n#endif\nvec4 shadowsInfo;vec2 depthValues;} light{X};\n#ifdef PROJECTEDLIGHTTEXTURE{X}\nuniform mat4 textureProjectionMatrix{X};uniform sampler2D projectionLightSampler{X};\n#endif\n#ifdef SHADOW{X}\n#ifdef SHADOWCSM{X}\nuniform mat4 lightMatrix{X}[SHADOWCSMNUM_CASCADES{X}];uniform float viewFrustumZ{X}[SHADOWCSMNUM_CASCADES{X}];uniform float frustumLengths{X}[SHADOWCSMNUM_CASCADES{X}];uniform float cascadeBlendFactor{X};varying vec4 vPositionFromLight{X}[SHADOWCSMNUM_CASCADES{X}];varying float vDepthMetric{X}[SHADOWCSMNUM_CASCADES{X}];varying vec4 vPositionFromCamera{X};\n#if defined(SHADOWPCSS{X})\nuniform highp sampler2DArrayShadow shadowSampler{X};uniform highp sampler2DArray depthSampler{X};uniform vec2 lightSizeUVCorrection{X}[SHADOWCSMNUM_CASCADES{X}];uniform float depthCorrection{X}[SHADOWCSMNUM_CASCADES{X}];uniform float penumbraDarkness{X};\n#elif defined(SHADOWPCF{X})\nuniform highp sampler2DArrayShadow shadowSampler{X};\n#else\nuniform highp sampler2DArray shadowSampler{X};\n#endif\n#ifdef SHADOWCSMDEBUG{X}\nconst vec3 vCascadeColorsMultiplier{X}[8]=vec3[8]\n(\nvec3 ( 1.5,0.0,0.0 ),\nvec3 ( 0.0,1.5,0.0 ),\nvec3 ( 0.0,0.0,5.5 ),\nvec3 ( 1.5,0.0,5.5 ),\nvec3 ( 1.5,1.5,0.0 ),\nvec3 ( 1.0,1.0,1.0 ),\nvec3 ( 0.0,1.0,5.5 ),\nvec3 ( 0.5,3.5,0.75 )\n);vec3 shadowDebug{X};\n#endif\n#ifdef SHADOWCSMUSESHADOWMAXZ{X}\nint index{X}=-1;\n#else\nint index{X}=SHADOWCSMNUM_CASCADES{X}-1;\n#endif\nfloat diff{X}=0.;\n#elif defined(SHADOWCUBE{X})\nuniform samplerCube shadowSampler{X}; \n#else\nvarying vec4 vPositionFromLight{X};varying float vDepthMetric{X};\n#if defined(SHADOWPCSS{X})\nuniform highp sampler2DShadow shadowSampler{X};uniform highp sampler2D depthSampler{X};\n#elif defined(SHADOWPCF{X})\nuniform highp sampler2DShadow shadowSampler{X};\n#else\nuniform sampler2D shadowSampler{X};\n#endif\nuniform mat4 lightMatrix{X};\n#endif\n#endif\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const lightUboDeclaration = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"lightsFragmentFunctions\";\nconst shader = `struct lightingInfo\n{vec3 diffuse;\n#ifdef SPECULARTERM\nvec3 specular;\n#endif\n#ifdef NDOTL\nfloat ndl;\n#endif\n};lightingInfo computeLighting(vec3 viewDirectionW,vec3 vNormal,vec4 lightData,vec3 diffuseColor,vec3 specularColor,float range,float glossiness) {lightingInfo result;vec3 lightVectorW;float attenuation=1.0;if (lightData.w==0.)\n{vec3 direction=lightData.xyz-vPositionW;attenuation=max(0.,1.0-length(direction)/range);lightVectorW=normalize(direction);}\nelse\n{lightVectorW=normalize(-lightData.xyz);}\nfloat ndl=max(0.,dot(vNormal,lightVectorW));\n#ifdef NDOTL\nresult.ndl=ndl;\n#endif\nresult.diffuse=ndl*diffuseColor*attenuation;\n#ifdef SPECULARTERM\nvec3 angleW=normalize(viewDirectionW+lightVectorW);float specComp=max(0.,dot(vNormal,angleW));specComp=pow(specComp,max(1.,glossiness));result.specular=specComp*specularColor*attenuation;\n#endif\nreturn result;}\nlightingInfo computeSpotLighting(vec3 viewDirectionW,vec3 vNormal,vec4 lightData,vec4 lightDirection,vec3 diffuseColor,vec3 specularColor,float range,float glossiness) {lightingInfo result;vec3 direction=lightData.xyz-vPositionW;vec3 lightVectorW=normalize(direction);float attenuation=max(0.,1.0-length(direction)/range);float cosAngle=max(0.,dot(lightDirection.xyz,-lightVectorW));if (cosAngle>=lightDirection.w)\n{cosAngle=max(0.,pow(cosAngle,lightData.w));attenuation*=cosAngle;float ndl=max(0.,dot(vNormal,lightVectorW));\n#ifdef NDOTL\nresult.ndl=ndl;\n#endif\nresult.diffuse=ndl*diffuseColor*attenuation;\n#ifdef SPECULARTERM\nvec3 angleW=normalize(viewDirectionW+lightVectorW);float specComp=max(0.,dot(vNormal,angleW));specComp=pow(specComp,max(1.,glossiness));result.specular=specComp*specularColor*attenuation;\n#endif\nreturn result;}\nresult.diffuse=vec3(0.);\n#ifdef SPECULARTERM\nresult.specular=vec3(0.);\n#endif\n#ifdef NDOTL\nresult.ndl=0.;\n#endif\nreturn result;}\nlightingInfo computeHemisphericLighting(vec3 viewDirectionW,vec3 vNormal,vec4 lightData,vec3 diffuseColor,vec3 specularColor,vec3 groundColor,float glossiness) {lightingInfo result;float ndl=dot(vNormal,lightData.xyz)*0.5+0.5;\n#ifdef NDOTL\nresult.ndl=ndl;\n#endif\nresult.diffuse=mix(groundColor,diffuseColor,ndl);\n#ifdef SPECULARTERM\nvec3 angleW=normalize(viewDirectionW+lightData.xyz);float specComp=max(0.,dot(vNormal,angleW));specComp=pow(specComp,max(1.,glossiness));result.specular=specComp*specularColor;\n#endif\nreturn result;}\n#define inline\nvec3 computeProjectionTextureDiffuseLighting(sampler2D projectionLightSampler,mat4 textureProjectionMatrix){vec4 strq=textureProjectionMatrix*vec4(vPositionW,1.0);strq/=strq.w;vec3 textureColor=texture2D(projectionLightSampler,strq.xy).rgb;return textureColor;}`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const lightsFragmentFunctions = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"shadowsFragmentFunctions\";\nconst shader = `#ifdef SHADOWS\n#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)\n#define TEXTUREFUNC(s,c,l) texture2DLodEXT(s,c,l)\n#else\n#define TEXTUREFUNC(s,c,b) texture2D(s,c,b)\n#endif\n#ifndef SHADOWFLOAT\nfloat unpack(vec4 color)\n{const vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(color,bit_shift);}\n#endif\nfloat computeFallOff(float value,vec2 clipSpace,float frustumEdgeFalloff)\n{float mask=smoothstep(1.0-frustumEdgeFalloff,1.00000012,clamp(dot(clipSpace,clipSpace),0.,1.));return mix(value,1.0,mask);}\n#define inline\nfloat computeShadowCube(vec3 worldPos,vec3 lightPosition,samplerCube shadowSampler,float darkness,vec2 depthValues)\n{vec3 directionToLight=worldPos-lightPosition;float depth=length(directionToLight);depth=(depth+depthValues.x)/(depthValues.y);depth=clamp(depth,0.,1.0);directionToLight=normalize(directionToLight);directionToLight.y=-directionToLight.y;\n#ifndef SHADOWFLOAT\nfloat shadow=unpack(textureCube(shadowSampler,directionToLight));\n#else\nfloat shadow=textureCube(shadowSampler,directionToLight).x;\n#endif\nreturn depth>shadow ? darkness : 1.0;}\n#define inline\nfloat computeShadowWithPoissonSamplingCube(vec3 worldPos,vec3 lightPosition,samplerCube shadowSampler,float mapSize,float darkness,vec2 depthValues)\n{vec3 directionToLight=worldPos-lightPosition;float depth=length(directionToLight);depth=(depth+depthValues.x)/(depthValues.y);depth=clamp(depth,0.,1.0);directionToLight=normalize(directionToLight);directionToLight.y=-directionToLight.y;float visibility=1.;vec3 poissonDisk[4];poissonDisk[0]=vec3(-1.0,1.0,-1.0);poissonDisk[1]=vec3(1.0,-1.0,-1.0);poissonDisk[2]=vec3(-1.0,-1.0,-1.0);poissonDisk[3]=vec3(1.0,-1.0,1.0);\n#ifndef SHADOWFLOAT\nif (unpack(textureCube(shadowSampler,directionToLight+poissonDisk[0]*mapSize))<depth) visibility-=0.25;if (unpack(textureCube(shadowSampler,directionToLight+poissonDisk[1]*mapSize))<depth) visibility-=0.25;if (unpack(textureCube(shadowSampler,directionToLight+poissonDisk[2]*mapSize))<depth) visibility-=0.25;if (unpack(textureCube(shadowSampler,directionToLight+poissonDisk[3]*mapSize))<depth) visibility-=0.25;\n#else\nif (textureCube(shadowSampler,directionToLight+poissonDisk[0]*mapSize).x<depth) visibility-=0.25;if (textureCube(shadowSampler,directionToLight+poissonDisk[1]*mapSize).x<depth) visibility-=0.25;if (textureCube(shadowSampler,directionToLight+poissonDisk[2]*mapSize).x<depth) visibility-=0.25;if (textureCube(shadowSampler,directionToLight+poissonDisk[3]*mapSize).x<depth) visibility-=0.25;\n#endif\nreturn min(1.0,visibility+darkness);}\n#define inline\nfloat computeShadowWithESMCube(vec3 worldPos,vec3 lightPosition,samplerCube shadowSampler,float darkness,float depthScale,vec2 depthValues)\n{vec3 directionToLight=worldPos-lightPosition;float depth=length(directionToLight);depth=(depth+depthValues.x)/(depthValues.y);float shadowPixelDepth=clamp(depth,0.,1.0);directionToLight=normalize(directionToLight);directionToLight.y=-directionToLight.y;\n#ifndef SHADOWFLOAT\nfloat shadowMapSample=unpack(textureCube(shadowSampler,directionToLight));\n#else\nfloat shadowMapSample=textureCube(shadowSampler,directionToLight).x;\n#endif\nfloat esm=1.0-clamp(exp(min(87.,depthScale*shadowPixelDepth))*shadowMapSample,0.,1.-darkness);return esm;}\n#define inline\nfloat computeShadowWithCloseESMCube(vec3 worldPos,vec3 lightPosition,samplerCube shadowSampler,float darkness,float depthScale,vec2 depthValues)\n{vec3 directionToLight=worldPos-lightPosition;float depth=length(directionToLight);depth=(depth+depthValues.x)/(depthValues.y);float shadowPixelDepth=clamp(depth,0.,1.0);directionToLight=normalize(directionToLight);directionToLight.y=-directionToLight.y;\n#ifndef SHADOWFLOAT\nfloat shadowMapSample=unpack(textureCube(shadowSampler,directionToLight));\n#else\nfloat shadowMapSample=textureCube(shadowSampler,directionToLight).x;\n#endif\nfloat esm=clamp(exp(min(87.,-depthScale*(shadowPixelDepth-shadowMapSample))),darkness,1.);return esm;}\n#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)\n#define inline\nfloat computeShadowCSM(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray shadowSampler,float darkness,float frustumEdgeFalloff)\n{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec2 uv=0.5*clipSpace.xy+vec2(0.5);vec3 uvLayer=vec3(uv.x,uv.y,layer);float shadowPixelDepth=clamp(depthMetric,0.,1.0);\n#ifndef SHADOWFLOAT\nfloat shadow=unpack(texture2D(shadowSampler,uvLayer));\n#else\nfloat shadow=texture2D(shadowSampler,uvLayer).x;\n#endif\nreturn shadowPixelDepth>shadow ? computeFallOff(darkness,clipSpace.xy,frustumEdgeFalloff) : 1.;}\n#endif\n#define inline\nfloat computeShadow(vec4 vPositionFromLight,float depthMetric,sampler2D shadowSampler,float darkness,float frustumEdgeFalloff)\n{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec2 uv=0.5*clipSpace.xy+vec2(0.5);if (uv.x<0. || uv.x>1.0 || uv.y<0. || uv.y>1.0)\n{return 1.0;}\nelse\n{float shadowPixelDepth=clamp(depthMetric,0.,1.0);\n#ifndef SHADOWFLOAT\nfloat shadow=unpack(TEXTUREFUNC(shadowSampler,uv,0.));\n#else\nfloat shadow=TEXTUREFUNC(shadowSampler,uv,0.).x;\n#endif\nreturn shadowPixelDepth>shadow ? computeFallOff(darkness,clipSpace.xy,frustumEdgeFalloff) : 1.;}}\n#define inline\nfloat computeShadowWithPoissonSampling(vec4 vPositionFromLight,float depthMetric,sampler2D shadowSampler,float mapSize,float darkness,float frustumEdgeFalloff)\n{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec2 uv=0.5*clipSpace.xy+vec2(0.5);if (uv.x<0. || uv.x>1.0 || uv.y<0. || uv.y>1.0)\n{return 1.0;}\nelse\n{float shadowPixelDepth=clamp(depthMetric,0.,1.0);float visibility=1.;vec2 poissonDisk[4];poissonDisk[0]=vec2(-0.94201624,-0.39906216);poissonDisk[1]=vec2(0.94558609,-0.76890725);poissonDisk[2]=vec2(-0.094184101,-0.92938870);poissonDisk[3]=vec2(0.34495938,0.29387760);\n#ifndef SHADOWFLOAT\nif (unpack(TEXTUREFUNC(shadowSampler,uv+poissonDisk[0]*mapSize,0.))<shadowPixelDepth) visibility-=0.25;if (unpack(TEXTUREFUNC(shadowSampler,uv+poissonDisk[1]*mapSize,0.))<shadowPixelDepth) visibility-=0.25;if (unpack(TEXTUREFUNC(shadowSampler,uv+poissonDisk[2]*mapSize,0.))<shadowPixelDepth) visibility-=0.25;if (unpack(TEXTUREFUNC(shadowSampler,uv+poissonDisk[3]*mapSize,0.))<shadowPixelDepth) visibility-=0.25;\n#else\nif (TEXTUREFUNC(shadowSampler,uv+poissonDisk[0]*mapSize,0.).x<shadowPixelDepth) visibility-=0.25;if (TEXTUREFUNC(shadowSampler,uv+poissonDisk[1]*mapSize,0.).x<shadowPixelDepth) visibility-=0.25;if (TEXTUREFUNC(shadowSampler,uv+poissonDisk[2]*mapSize,0.).x<shadowPixelDepth) visibility-=0.25;if (TEXTUREFUNC(shadowSampler,uv+poissonDisk[3]*mapSize,0.).x<shadowPixelDepth) visibility-=0.25;\n#endif\nreturn computeFallOff(min(1.0,visibility+darkness),clipSpace.xy,frustumEdgeFalloff);}}\n#define inline\nfloat computeShadowWithESM(vec4 vPositionFromLight,float depthMetric,sampler2D shadowSampler,float darkness,float depthScale,float frustumEdgeFalloff)\n{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec2 uv=0.5*clipSpace.xy+vec2(0.5);if (uv.x<0. || uv.x>1.0 || uv.y<0. || uv.y>1.0)\n{return 1.0;}\nelse\n{float shadowPixelDepth=clamp(depthMetric,0.,1.0);\n#ifndef SHADOWFLOAT\nfloat shadowMapSample=unpack(TEXTUREFUNC(shadowSampler,uv,0.));\n#else\nfloat shadowMapSample=TEXTUREFUNC(shadowSampler,uv,0.).x;\n#endif\nfloat esm=1.0-clamp(exp(min(87.,depthScale*shadowPixelDepth))*shadowMapSample,0.,1.-darkness);return computeFallOff(esm,clipSpace.xy,frustumEdgeFalloff);}}\n#define inline\nfloat computeShadowWithCloseESM(vec4 vPositionFromLight,float depthMetric,sampler2D shadowSampler,float darkness,float depthScale,float frustumEdgeFalloff)\n{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec2 uv=0.5*clipSpace.xy+vec2(0.5);if (uv.x<0. || uv.x>1.0 || uv.y<0. || uv.y>1.0)\n{return 1.0;}\nelse\n{float shadowPixelDepth=clamp(depthMetric,0.,1.0); \n#ifndef SHADOWFLOAT\nfloat shadowMapSample=unpack(TEXTUREFUNC(shadowSampler,uv,0.));\n#else\nfloat shadowMapSample=TEXTUREFUNC(shadowSampler,uv,0.).x;\n#endif\nfloat esm=clamp(exp(min(87.,-depthScale*(shadowPixelDepth-shadowMapSample))),darkness,1.);return computeFallOff(esm,clipSpace.xy,frustumEdgeFalloff);}}\n#ifdef IS_NDC_HALF_ZRANGE\n#define ZINCLIP clipSpace.z\n#else\n#define ZINCLIP uvDepth.z\n#endif\n#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)\n#define GREATEST_LESS_THAN_ONE 0.99999994\n/* disable_uniformity_analysis */\n#define inline\nfloat computeShadowWithCSMPCF1(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArrayShadow shadowSampler,float darkness,float frustumEdgeFalloff)\n{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));uvDepth.z=clamp(ZINCLIP,0.,GREATEST_LESS_THAN_ONE);vec4 uvDepthLayer=vec4(uvDepth.x,uvDepth.y,layer,uvDepth.z);float shadow=texture2D(shadowSampler,uvDepthLayer);shadow=mix(darkness,1.,shadow);return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);}\n#define inline\nfloat computeShadowWithCSMPCF3(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArrayShadow shadowSampler,vec2 shadowMapSizeAndInverse,float darkness,float frustumEdgeFalloff)\n{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));uvDepth.z=clamp(ZINCLIP,0.,GREATEST_LESS_THAN_ONE);vec2 uv=uvDepth.xy*shadowMapSizeAndInverse.x; \nuv+=0.5; \nvec2 st=fract(uv); \nvec2 base_uv=floor(uv)-0.5; \nbase_uv*=shadowMapSizeAndInverse.y; \nvec2 uvw0=3.-2.*st;vec2 uvw1=1.+2.*st;vec2 u=vec2((2.-st.x)/uvw0.x-1.,st.x/uvw1.x+1.)*shadowMapSizeAndInverse.y;vec2 v=vec2((2.-st.y)/uvw0.y-1.,st.y/uvw1.y+1.)*shadowMapSizeAndInverse.y;float shadow=0.;shadow+=uvw0.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[0]),layer,uvDepth.z));shadow+=uvw1.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[0]),layer,uvDepth.z));shadow+=uvw0.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[1]),layer,uvDepth.z));shadow+=uvw1.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[1]),layer,uvDepth.z));shadow=shadow/16.;shadow=mix(darkness,1.,shadow);return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);}\n#define inline\nfloat computeShadowWithCSMPCF5(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArrayShadow shadowSampler,vec2 shadowMapSizeAndInverse,float darkness,float frustumEdgeFalloff)\n{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));uvDepth.z=clamp(ZINCLIP,0.,GREATEST_LESS_THAN_ONE);vec2 uv=uvDepth.xy*shadowMapSizeAndInverse.x; \nuv+=0.5; \nvec2 st=fract(uv); \nvec2 base_uv=floor(uv)-0.5; \nbase_uv*=shadowMapSizeAndInverse.y; \nvec2 uvw0=4.-3.*st;vec2 uvw1=vec2(7.);vec2 uvw2=1.+3.*st;vec3 u=vec3((3.-2.*st.x)/uvw0.x-2.,(3.+st.x)/uvw1.x,st.x/uvw2.x+2.)*shadowMapSizeAndInverse.y;vec3 v=vec3((3.-2.*st.y)/uvw0.y-2.,(3.+st.y)/uvw1.y,st.y/uvw2.y+2.)*shadowMapSizeAndInverse.y;float shadow=0.;shadow+=uvw0.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[0]),layer,uvDepth.z));shadow+=uvw1.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[0]),layer,uvDepth.z));shadow+=uvw2.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[2],v[0]),layer,uvDepth.z));shadow+=uvw0.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[1]),layer,uvDepth.z));shadow+=uvw1.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[1]),layer,uvDepth.z));shadow+=uvw2.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[2],v[1]),layer,uvDepth.z));shadow+=uvw0.x*uvw2.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[2]),layer,uvDepth.z));shadow+=uvw1.x*uvw2.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[2]),layer,uvDepth.z));shadow+=uvw2.x*uvw2.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[2],v[2]),layer,uvDepth.z));shadow=shadow/144.;shadow=mix(darkness,1.,shadow);return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);}\n#define inline\nfloat computeShadowWithPCF1(vec4 vPositionFromLight,float depthMetric,highp sampler2DShadow shadowSampler,float darkness,float frustumEdgeFalloff)\n{if (depthMetric>1.0 || depthMetric<0.0) {return 1.0;}\nelse\n{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));uvDepth.z=ZINCLIP;float shadow=TEXTUREFUNC(shadowSampler,uvDepth,0.);shadow=mix(darkness,1.,shadow);return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);}}\n#define inline\nfloat computeShadowWithPCF3(vec4 vPositionFromLight,float depthMetric,highp sampler2DShadow shadowSampler,vec2 shadowMapSizeAndInverse,float darkness,float frustumEdgeFalloff)\n{if (depthMetric>1.0 || depthMetric<0.0) {return 1.0;}\nelse\n{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));uvDepth.z=ZINCLIP;vec2 uv=uvDepth.xy*shadowMapSizeAndInverse.x; \nuv+=0.5; \nvec2 st=fract(uv); \nvec2 base_uv=floor(uv)-0.5; \nbase_uv*=shadowMapSizeAndInverse.y; \nvec2 uvw0=3.-2.*st;vec2 uvw1=1.+2.*st;vec2 u=vec2((2.-st.x)/uvw0.x-1.,st.x/uvw1.x+1.)*shadowMapSizeAndInverse.y;vec2 v=vec2((2.-st.y)/uvw0.y-1.,st.y/uvw1.y+1.)*shadowMapSizeAndInverse.y;float shadow=0.;shadow+=uvw0.x*uvw0.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[0]),uvDepth.z),0.);shadow+=uvw1.x*uvw0.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[0]),uvDepth.z),0.);shadow+=uvw0.x*uvw1.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[1]),uvDepth.z),0.);shadow+=uvw1.x*uvw1.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[1]),uvDepth.z),0.);shadow=shadow/16.;shadow=mix(darkness,1.,shadow);return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);}}\n#define inline\nfloat computeShadowWithPCF5(vec4 vPositionFromLight,float depthMetric,highp sampler2DShadow shadowSampler,vec2 shadowMapSizeAndInverse,float darkness,float frustumEdgeFalloff)\n{if (depthMetric>1.0 || depthMetric<0.0) {return 1.0;}\nelse\n{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));uvDepth.z=ZINCLIP;vec2 uv=uvDepth.xy*shadowMapSizeAndInverse.x; \nuv+=0.5; \nvec2 st=fract(uv); \nvec2 base_uv=floor(uv)-0.5; \nbase_uv*=shadowMapSizeAndInverse.y; \nvec2 uvw0=4.-3.*st;vec2 uvw1=vec2(7.);vec2 uvw2=1.+3.*st;vec3 u=vec3((3.-2.*st.x)/uvw0.x-2.,(3.+st.x)/uvw1.x,st.x/uvw2.x+2.)*shadowMapSizeAndInverse.y;vec3 v=vec3((3.-2.*st.y)/uvw0.y-2.,(3.+st.y)/uvw1.y,st.y/uvw2.y+2.)*shadowMapSizeAndInverse.y;float shadow=0.;shadow+=uvw0.x*uvw0.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[0]),uvDepth.z),0.);shadow+=uvw1.x*uvw0.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[0]),uvDepth.z),0.);shadow+=uvw2.x*uvw0.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[2],v[0]),uvDepth.z),0.);shadow+=uvw0.x*uvw1.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[1]),uvDepth.z),0.);shadow+=uvw1.x*uvw1.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[1]),uvDepth.z),0.);shadow+=uvw2.x*uvw1.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[2],v[1]),uvDepth.z),0.);shadow+=uvw0.x*uvw2.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[2]),uvDepth.z),0.);shadow+=uvw1.x*uvw2.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[2]),uvDepth.z),0.);shadow+=uvw2.x*uvw2.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[2],v[2]),uvDepth.z),0.);shadow=shadow/144.;shadow=mix(darkness,1.,shadow);return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);}}\nconst vec3 PoissonSamplers32[64]=vec3[64](\nvec3(0.06407013,0.05409927,0.),\nvec3(0.7366577,0.5789394,0.),\nvec3(-0.6270542,-0.5320278,0.),\nvec3(-0.4096107,0.8411095,0.),\nvec3(0.6849564,-0.4990818,0.),\nvec3(-0.874181,-0.04579735,0.),\nvec3(0.9989998,0.0009880066,0.),\nvec3(-0.004920578,-0.9151649,0.),\nvec3(0.1805763,0.9747483,0.),\nvec3(-0.2138451,0.2635818,0.),\nvec3(0.109845,0.3884785,0.),\nvec3(0.06876755,-0.3581074,0.),\nvec3(0.374073,-0.7661266,0.),\nvec3(0.3079132,-0.1216763,0.),\nvec3(-0.3794335,-0.8271583,0.),\nvec3(-0.203878,-0.07715034,0.),\nvec3(0.5912697,0.1469799,0.),\nvec3(-0.88069,0.3031784,0.),\nvec3(0.5040108,0.8283722,0.),\nvec3(-0.5844124,0.5494877,0.),\nvec3(0.6017799,-0.1726654,0.),\nvec3(-0.5554981,0.1559997,0.),\nvec3(-0.3016369,-0.3900928,0.),\nvec3(-0.5550632,-0.1723762,0.),\nvec3(0.925029,0.2995041,0.),\nvec3(-0.2473137,0.5538505,0.),\nvec3(0.9183037,-0.2862392,0.),\nvec3(0.2469421,0.6718712,0.),\nvec3(0.3916397,-0.4328209,0.),\nvec3(-0.03576927,-0.6220032,0.),\nvec3(-0.04661255,0.7995201,0.),\nvec3(0.4402924,0.3640312,0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.)\n);const vec3 PoissonSamplers64[64]=vec3[64](\nvec3(-0.613392,0.617481,0.),\nvec3(0.170019,-0.040254,0.),\nvec3(-0.299417,0.791925,0.),\nvec3(0.645680,0.493210,0.),\nvec3(-0.651784,0.717887,0.),\nvec3(0.421003,0.027070,0.),\nvec3(-0.817194,-0.271096,0.),\nvec3(-0.705374,-0.668203,0.),\nvec3(0.977050,-0.108615,0.),\nvec3(0.063326,0.142369,0.),\nvec3(0.203528,0.214331,0.),\nvec3(-0.667531,0.326090,0.),\nvec3(-0.098422,-0.295755,0.),\nvec3(-0.885922,0.215369,0.),\nvec3(0.566637,0.605213,0.),\nvec3(0.039766,-0.396100,0.),\nvec3(0.751946,0.453352,0.),\nvec3(0.078707,-0.715323,0.),\nvec3(-0.075838,-0.529344,0.),\nvec3(0.724479,-0.580798,0.),\nvec3(0.222999,-0.215125,0.),\nvec3(-0.467574,-0.405438,0.),\nvec3(-0.248268,-0.814753,0.),\nvec3(0.354411,-0.887570,0.),\nvec3(0.175817,0.382366,0.),\nvec3(0.487472,-0.063082,0.),\nvec3(-0.084078,0.898312,0.),\nvec3(0.488876,-0.783441,0.),\nvec3(0.470016,0.217933,0.),\nvec3(-0.696890,-0.549791,0.),\nvec3(-0.149693,0.605762,0.),\nvec3(0.034211,0.979980,0.),\nvec3(0.503098,-0.308878,0.),\nvec3(-0.016205,-0.872921,0.),\nvec3(0.385784,-0.393902,0.),\nvec3(-0.146886,-0.859249,0.),\nvec3(0.643361,0.164098,0.),\nvec3(0.634388,-0.049471,0.),\nvec3(-0.688894,0.007843,0.),\nvec3(0.464034,-0.188818,0.),\nvec3(-0.440840,0.137486,0.),\nvec3(0.364483,0.511704,0.),\nvec3(0.034028,0.325968,0.),\nvec3(0.099094,-0.308023,0.),\nvec3(0.693960,-0.366253,0.),\nvec3(0.678884,-0.204688,0.),\nvec3(0.001801,0.780328,0.),\nvec3(0.145177,-0.898984,0.),\nvec3(0.062655,-0.611866,0.),\nvec3(0.315226,-0.604297,0.),\nvec3(-0.780145,0.486251,0.),\nvec3(-0.371868,0.882138,0.),\nvec3(0.200476,0.494430,0.),\nvec3(-0.494552,-0.711051,0.),\nvec3(0.612476,0.705252,0.),\nvec3(-0.578845,-0.768792,0.),\nvec3(-0.772454,-0.090976,0.),\nvec3(0.504440,0.372295,0.),\nvec3(0.155736,0.065157,0.),\nvec3(0.391522,0.849605,0.),\nvec3(-0.620106,-0.328104,0.),\nvec3(0.789239,-0.419965,0.),\nvec3(-0.545396,0.538133,0.),\nvec3(-0.178564,-0.596057,0.)\n);\n#define inline\nfloat computeShadowWithCSMPCSS(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray depthSampler,highp sampler2DArrayShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,int searchTapCount,int pcfTapCount,vec3[64] poissonSamplers,vec2 lightSizeUVCorrection,float depthCorrection,float penumbraDarkness)\n{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));uvDepth.z=clamp(ZINCLIP,0.,GREATEST_LESS_THAN_ONE);vec4 uvDepthLayer=vec4(uvDepth.x,uvDepth.y,layer,uvDepth.z);float blockerDepth=0.0;float sumBlockerDepth=0.0;float numBlocker=0.0;for (int i=0; i<searchTapCount; i ++) {blockerDepth=texture2D(depthSampler,vec3(uvDepth.xy+(lightSizeUV*lightSizeUVCorrection*shadowMapSizeInverse*PoissonSamplers32[i].xy),layer)).r;if (blockerDepth<depthMetric) {sumBlockerDepth+=blockerDepth;numBlocker++;}}\nfloat avgBlockerDepth=sumBlockerDepth/numBlocker;float AAOffset=shadowMapSizeInverse*10.;float penumbraRatio=((depthMetric-avgBlockerDepth)*depthCorrection+AAOffset);vec4 filterRadius=vec4(penumbraRatio*lightSizeUV*lightSizeUVCorrection*shadowMapSizeInverse,0.,0.);float random=getRand(vPositionFromLight.xy);float rotationAngle=random*3.1415926;vec2 rotationVector=vec2(cos(rotationAngle),sin(rotationAngle));float shadow=0.;for (int i=0; i<pcfTapCount; i++) {vec4 offset=vec4(poissonSamplers[i],0.);offset=vec4(offset.x*rotationVector.x-offset.y*rotationVector.y,offset.y*rotationVector.x+offset.x*rotationVector.y,0.,0.);shadow+=texture2D(shadowSampler,uvDepthLayer+offset*filterRadius);}\nshadow/=float(pcfTapCount);shadow=mix(shadow,1.,min((depthMetric-avgBlockerDepth)*depthCorrection*penumbraDarkness,1.));shadow=mix(darkness,1.,shadow);if (numBlocker<1.0) {return 1.0;}\nelse\n{return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);}}\n#define inline\nfloat computeShadowWithPCSS(vec4 vPositionFromLight,float depthMetric,sampler2D depthSampler,highp sampler2DShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,int searchTapCount,int pcfTapCount,vec3[64] poissonSamplers)\n{if (depthMetric>1.0 || depthMetric<0.0) {return 1.0;}\nelse\n{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));uvDepth.z=ZINCLIP;float blockerDepth=0.0;float sumBlockerDepth=0.0;float numBlocker=0.0;for (int i=0; i<searchTapCount; i ++) {blockerDepth=TEXTUREFUNC(depthSampler,uvDepth.xy+(lightSizeUV*shadowMapSizeInverse*PoissonSamplers32[i].xy),0.).r;if (blockerDepth<depthMetric) {sumBlockerDepth+=blockerDepth;numBlocker++;}}\nif (numBlocker<1.0) {return 1.0;}\nelse\n{float avgBlockerDepth=sumBlockerDepth/numBlocker;float AAOffset=shadowMapSizeInverse*10.;float penumbraRatio=((depthMetric-avgBlockerDepth)+AAOffset);float filterRadius=penumbraRatio*lightSizeUV*shadowMapSizeInverse;float random=getRand(vPositionFromLight.xy);float rotationAngle=random*3.1415926;vec2 rotationVector=vec2(cos(rotationAngle),sin(rotationAngle));float shadow=0.;for (int i=0; i<pcfTapCount; i++) {vec3 offset=poissonSamplers[i];offset=vec3(offset.x*rotationVector.x-offset.y*rotationVector.y,offset.y*rotationVector.x+offset.x*rotationVector.y,0.);shadow+=TEXTUREFUNC(shadowSampler,uvDepth+offset*filterRadius,0.);}\nshadow/=float(pcfTapCount);shadow=mix(shadow,1.,depthMetric-avgBlockerDepth);shadow=mix(darkness,1.,shadow);return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);}}}\n#define inline\nfloat computeShadowWithPCSS16(vec4 vPositionFromLight,float depthMetric,sampler2D depthSampler,highp sampler2DShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff)\n{return computeShadowWithPCSS(vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,16,16,PoissonSamplers32);}\n#define inline\nfloat computeShadowWithPCSS32(vec4 vPositionFromLight,float depthMetric,sampler2D depthSampler,highp sampler2DShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff)\n{return computeShadowWithPCSS(vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,16,32,PoissonSamplers32);}\n#define inline\nfloat computeShadowWithPCSS64(vec4 vPositionFromLight,float depthMetric,sampler2D depthSampler,highp sampler2DShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff)\n{return computeShadowWithPCSS(vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,32,64,PoissonSamplers64);}\n#define inline\nfloat computeShadowWithCSMPCSS16(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray depthSampler,highp sampler2DArrayShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,vec2 lightSizeUVCorrection,float depthCorrection,float penumbraDarkness)\n{return computeShadowWithCSMPCSS(layer,vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,16,16,PoissonSamplers32,lightSizeUVCorrection,depthCorrection,penumbraDarkness);}\n#define inline\nfloat computeShadowWithCSMPCSS32(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray depthSampler,highp sampler2DArrayShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,vec2 lightSizeUVCorrection,float depthCorrection,float penumbraDarkness)\n{return computeShadowWithCSMPCSS(layer,vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,16,32,PoissonSamplers32,lightSizeUVCorrection,depthCorrection,penumbraDarkness);}\n#define inline\nfloat computeShadowWithCSMPCSS64(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray depthSampler,highp sampler2DArrayShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,vec2 lightSizeUVCorrection,float depthCorrection,float penumbraDarkness)\n{return computeShadowWithCSMPCSS(layer,vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,32,64,PoissonSamplers64,lightSizeUVCorrection,depthCorrection,penumbraDarkness);}\n#endif\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const shadowsFragmentFunctions = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"samplerFragmentDeclaration\";\nconst shader = `#ifdef _DEFINENAME_\n#if _DEFINENAME_DIRECTUV==1\n#define v_VARYINGNAME_UV vMainUV1\n#elif _DEFINENAME_DIRECTUV==2\n#define v_VARYINGNAME_UV vMainUV2\n#elif _DEFINENAME_DIRECTUV==3\n#define v_VARYINGNAME_UV vMainUV3\n#elif _DEFINENAME_DIRECTUV==4\n#define v_VARYINGNAME_UV vMainUV4\n#elif _DEFINENAME_DIRECTUV==5\n#define v_VARYINGNAME_UV vMainUV5\n#elif _DEFINENAME_DIRECTUV==6\n#define v_VARYINGNAME_UV vMainUV6\n#else\nvarying vec2 v_VARYINGNAME_UV;\n#endif\nuniform sampler2D _SAMPLERNAME_Sampler;\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const samplerFragmentDeclaration = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"fresnelFunction\";\nconst shader = `#ifdef FRESNEL\nfloat computeFresnelTerm(vec3 viewDirection,vec3 worldNormal,float bias,float power)\n{float fresnelTerm=pow(bias+abs(dot(viewDirection,worldNormal)),power);return clamp(fresnelTerm,0.,1.);}\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const fresnelFunction = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"reflectionFunction\";\nconst shader = `vec3 computeFixedEquirectangularCoords(vec4 worldPos,vec3 worldNormal,vec3 direction)\n{float lon=atan(direction.z,direction.x);float lat=acos(direction.y);vec2 sphereCoords=vec2(lon,lat)*RECIPROCAL_PI2*2.0;float s=sphereCoords.x*0.5+0.5;float t=sphereCoords.y;return vec3(s,t,0); }\nvec3 computeMirroredFixedEquirectangularCoords(vec4 worldPos,vec3 worldNormal,vec3 direction)\n{float lon=atan(direction.z,direction.x);float lat=acos(direction.y);vec2 sphereCoords=vec2(lon,lat)*RECIPROCAL_PI2*2.0;float s=sphereCoords.x*0.5+0.5;float t=sphereCoords.y;return vec3(1.0-s,t,0); }\nvec3 computeEquirectangularCoords(vec4 worldPos,vec3 worldNormal,vec3 eyePosition,mat4 reflectionMatrix)\n{vec3 cameraToVertex=normalize(worldPos.xyz-eyePosition);vec3 r=normalize(reflect(cameraToVertex,worldNormal));r=vec3(reflectionMatrix*vec4(r,0));float lon=atan(r.z,r.x);float lat=acos(r.y);vec2 sphereCoords=vec2(lon,lat)*RECIPROCAL_PI2*2.0;float s=sphereCoords.x*0.5+0.5;float t=sphereCoords.y;return vec3(s,t,0);}\nvec3 computeSphericalCoords(vec4 worldPos,vec3 worldNormal,mat4 view,mat4 reflectionMatrix)\n{vec3 viewDir=normalize(vec3(view*worldPos));vec3 viewNormal=normalize(vec3(view*vec4(worldNormal,0.0)));vec3 r=reflect(viewDir,viewNormal);r=vec3(reflectionMatrix*vec4(r,0));r.z=r.z-1.0;float m=2.0*length(r);return vec3(r.x/m+0.5,1.0-r.y/m-0.5,0);}\nvec3 computePlanarCoords(vec4 worldPos,vec3 worldNormal,vec3 eyePosition,mat4 reflectionMatrix)\n{vec3 viewDir=worldPos.xyz-eyePosition;vec3 coords=normalize(reflect(viewDir,worldNormal));return vec3(reflectionMatrix*vec4(coords,1));}\nvec3 computeCubicCoords(vec4 worldPos,vec3 worldNormal,vec3 eyePosition,mat4 reflectionMatrix)\n{vec3 viewDir=normalize(worldPos.xyz-eyePosition);vec3 coords=reflect(viewDir,worldNormal);coords=vec3(reflectionMatrix*vec4(coords,0));\n#ifdef INVERTCUBICMAP\ncoords.y*=-1.0;\n#endif\nreturn coords;}\nvec3 computeCubicLocalCoords(vec4 worldPos,vec3 worldNormal,vec3 eyePosition,mat4 reflectionMatrix,vec3 reflectionSize,vec3 reflectionPosition)\n{vec3 viewDir=normalize(worldPos.xyz-eyePosition);vec3 coords=reflect(viewDir,worldNormal);coords=parallaxCorrectNormal(worldPos.xyz,coords,reflectionSize,reflectionPosition);coords=vec3(reflectionMatrix*vec4(coords,0));\n#ifdef INVERTCUBICMAP\ncoords.y*=-1.0;\n#endif\nreturn coords;}\nvec3 computeProjectionCoords(vec4 worldPos,mat4 view,mat4 reflectionMatrix)\n{return vec3(reflectionMatrix*(view*worldPos));}\nvec3 computeSkyBoxCoords(vec3 positionW,mat4 reflectionMatrix)\n{return vec3(reflectionMatrix*vec4(positionW,1.));}\n#ifdef REFLECTION\nvec3 computeReflectionCoords(vec4 worldPos,vec3 worldNormal)\n{\n#ifdef REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED\nvec3 direction=normalize(vDirectionW);return computeMirroredFixedEquirectangularCoords(worldPos,worldNormal,direction);\n#endif\n#ifdef REFLECTIONMAP_EQUIRECTANGULAR_FIXED\nvec3 direction=normalize(vDirectionW);return computeFixedEquirectangularCoords(worldPos,worldNormal,direction);\n#endif\n#ifdef REFLECTIONMAP_EQUIRECTANGULAR\nreturn computeEquirectangularCoords(worldPos,worldNormal,vEyePosition.xyz,reflectionMatrix);\n#endif\n#ifdef REFLECTIONMAP_SPHERICAL\nreturn computeSphericalCoords(worldPos,worldNormal,view,reflectionMatrix);\n#endif\n#ifdef REFLECTIONMAP_PLANAR\nreturn computePlanarCoords(worldPos,worldNormal,vEyePosition.xyz,reflectionMatrix);\n#endif\n#ifdef REFLECTIONMAP_CUBIC\n#ifdef USE_LOCAL_REFLECTIONMAP_CUBIC\nreturn computeCubicLocalCoords(worldPos,worldNormal,vEyePosition.xyz,reflectionMatrix,vReflectionSize,vReflectionPosition);\n#else\nreturn computeCubicCoords(worldPos,worldNormal,vEyePosition.xyz,reflectionMatrix);\n#endif\n#endif\n#ifdef REFLECTIONMAP_PROJECTION\nreturn computeProjectionCoords(worldPos,view,reflectionMatrix);\n#endif\n#ifdef REFLECTIONMAP_SKYBOX\nreturn computeSkyBoxCoords(vPositionUVW,reflectionMatrix);\n#endif\n#ifdef REFLECTIONMAP_EXPLICIT\nreturn vec3(0,0,0);\n#endif\n}\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const reflectionFunction = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"imageProcessingDeclaration\";\nconst shader = `#ifdef EXPOSURE\nuniform float exposureLinear;\n#endif\n#ifdef CONTRAST\nuniform float contrast;\n#endif\n#if defined(VIGNETTE) || defined(DITHER)\nuniform vec2 vInverseScreenSize;\n#endif\n#ifdef VIGNETTE\nuniform vec4 vignetteSettings1;uniform vec4 vignetteSettings2;\n#endif\n#ifdef COLORCURVES\nuniform vec4 vCameraColorCurveNegative;uniform vec4 vCameraColorCurveNeutral;uniform vec4 vCameraColorCurvePositive;\n#endif\n#ifdef COLORGRADING\n#ifdef COLORGRADING3D\nuniform highp sampler3D txColorTransform;\n#else\nuniform sampler2D txColorTransform;\n#endif\nuniform vec4 colorTransformSettings;\n#endif\n#ifdef DITHER\nuniform float ditherIntensity;\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const imageProcessingDeclaration = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"imageProcessingFunctions\";\nconst shader = `#if defined(COLORGRADING) && !defined(COLORGRADING3D)\n/** \n* Polyfill for SAMPLE_TEXTURE_3D,which is unsupported in WebGL.\n* sampler3dSetting.x=textureOffset (0.5/textureSize).\n* sampler3dSetting.y=textureSize.\n*/\n#define inline\nvec3 sampleTexture3D(sampler2D colorTransform,vec3 color,vec2 sampler3dSetting)\n{float sliceSize=2.0*sampler3dSetting.x; \n#ifdef SAMPLER3DGREENDEPTH\nfloat sliceContinuous=(color.g-sampler3dSetting.x)*sampler3dSetting.y;\n#else\nfloat sliceContinuous=(color.b-sampler3dSetting.x)*sampler3dSetting.y;\n#endif\nfloat sliceInteger=floor(sliceContinuous);float sliceFraction=sliceContinuous-sliceInteger;\n#ifdef SAMPLER3DGREENDEPTH\nvec2 sliceUV=color.rb;\n#else\nvec2 sliceUV=color.rg;\n#endif\nsliceUV.x*=sliceSize;sliceUV.x+=sliceInteger*sliceSize;sliceUV=saturate(sliceUV);vec4 slice0Color=texture2D(colorTransform,sliceUV);sliceUV.x+=sliceSize;sliceUV=saturate(sliceUV);vec4 slice1Color=texture2D(colorTransform,sliceUV);vec3 result=mix(slice0Color.rgb,slice1Color.rgb,sliceFraction);\n#ifdef SAMPLER3DBGRMAP\ncolor.rgb=result.rgb;\n#else\ncolor.rgb=result.bgr;\n#endif\nreturn color;}\n#endif\n#ifdef TONEMAPPING_ACES\nconst mat3 ACESInputMat=mat3(\nvec3(0.59719,0.07600,0.02840),\nvec3(0.35458,0.90834,0.13383),\nvec3(0.04823,0.01566,0.83777)\n);const mat3 ACESOutputMat=mat3(\nvec3( 1.60475,-0.10208,-0.00327),\nvec3(-0.53108, 1.10813,-0.07276),\nvec3(-0.07367,-0.00605, 1.07602)\n);vec3 RRTAndODTFit(vec3 v)\n{vec3 a=v*(v+0.0245786)-0.000090537;vec3 b=v*(0.983729*v+0.4329510)+0.238081;return a/b;}\nvec3 ACESFitted(vec3 color)\n{color=ACESInputMat*color;color=RRTAndODTFit(color);color=ACESOutputMat*color;color=saturate(color);return color;}\n#endif\n#define CUSTOM_IMAGEPROCESSINGFUNCTIONS_DEFINITIONS\nvec4 applyImageProcessing(vec4 result) {\n#define CUSTOM_IMAGEPROCESSINGFUNCTIONS_UPDATERESULT_ATSTART\n#ifdef EXPOSURE\nresult.rgb*=exposureLinear;\n#endif\n#ifdef VIGNETTE\nvec2 viewportXY=gl_FragCoord.xy*vInverseScreenSize;viewportXY=viewportXY*2.0-1.0;vec3 vignetteXY1=vec3(viewportXY*vignetteSettings1.xy+vignetteSettings1.zw,1.0);float vignetteTerm=dot(vignetteXY1,vignetteXY1);float vignette=pow(vignetteTerm,vignetteSettings2.w);vec3 vignetteColor=vignetteSettings2.rgb;\n#ifdef VIGNETTEBLENDMODEMULTIPLY\nvec3 vignetteColorMultiplier=mix(vignetteColor,vec3(1,1,1),vignette);result.rgb*=vignetteColorMultiplier;\n#endif\n#ifdef VIGNETTEBLENDMODEOPAQUE\nresult.rgb=mix(vignetteColor,result.rgb,vignette);\n#endif\n#endif\n#ifdef TONEMAPPING\n#ifdef TONEMAPPING_ACES\nresult.rgb=ACESFitted(result.rgb);\n#else\nconst float tonemappingCalibration=1.590579;result.rgb=1.0-exp2(-tonemappingCalibration*result.rgb);\n#endif\n#endif\nresult.rgb=toGammaSpace(result.rgb);result.rgb=saturate(result.rgb);\n#ifdef CONTRAST\nvec3 resultHighContrast=result.rgb*result.rgb*(3.0-2.0*result.rgb);if (contrast<1.0) {result.rgb=mix(vec3(0.5,0.5,0.5),result.rgb,contrast);} else {result.rgb=mix(result.rgb,resultHighContrast,contrast-1.0);}\n#endif\n#ifdef COLORGRADING\nvec3 colorTransformInput=result.rgb*colorTransformSettings.xxx+colorTransformSettings.yyy;\n#ifdef COLORGRADING3D\nvec3 colorTransformOutput=texture(txColorTransform,colorTransformInput).rgb;\n#else\nvec3 colorTransformOutput=sampleTexture3D(txColorTransform,colorTransformInput,colorTransformSettings.yz).rgb;\n#endif\nresult.rgb=mix(result.rgb,colorTransformOutput,colorTransformSettings.www);\n#endif\n#ifdef COLORCURVES\nfloat luma=getLuminance(result.rgb);vec2 curveMix=clamp(vec2(luma*3.0-1.5,luma*-3.0+1.5),vec2(0.0),vec2(1.0));vec4 colorCurve=vCameraColorCurveNeutral+curveMix.x*vCameraColorCurvePositive-curveMix.y*vCameraColorCurveNegative;result.rgb*=colorCurve.rgb;result.rgb=mix(vec3(luma),result.rgb,colorCurve.a);\n#endif\n#ifdef DITHER\nfloat rand=getRand(gl_FragCoord.xy*vInverseScreenSize);float dither=mix(-ditherIntensity,ditherIntensity,rand);result.rgb=saturate(result.rgb+vec3(dither));\n#endif\n#define CUSTOM_IMAGEPROCESSINGFUNCTIONS_UPDATERESULT_ATEND\nreturn result;}`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const imageProcessingFunctions = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"bumpFragmentMainFunctions\";\nconst shader = `#if defined(BUMP) || defined(CLEARCOAT_BUMP) || defined(ANISOTROPIC) || defined(DETAIL)\n#if defined(TANGENT) && defined(NORMAL) \nvarying mat3 vTBN;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\nuniform mat4 normalMatrix;\n#if defined(WEBGL2) || defined(WEBGPU)\nmat4 toNormalMatrix(mat4 wMatrix)\n{mat4 ret=inverse(wMatrix);ret=transpose(ret);ret[0][3]=0.;ret[1][3]=0.;ret[2][3]=0.;ret[3]=vec4(0.,0.,0.,1.);return ret;}\n#else\nmat4 toNormalMatrix(mat4 m)\n{float\na00=m[0][0],a01=m[0][1],a02=m[0][2],a03=m[0][3],\na10=m[1][0],a11=m[1][1],a12=m[1][2],a13=m[1][3],\na20=m[2][0],a21=m[2][1],a22=m[2][2],a23=m[2][3],\na30=m[3][0],a31=m[3][1],a32=m[3][2],a33=m[3][3],\nb00=a00*a11-a01*a10,\nb01=a00*a12-a02*a10,\nb02=a00*a13-a03*a10,\nb03=a01*a12-a02*a11,\nb04=a01*a13-a03*a11,\nb05=a02*a13-a03*a12,\nb06=a20*a31-a21*a30,\nb07=a20*a32-a22*a30,\nb08=a20*a33-a23*a30,\nb09=a21*a32-a22*a31,\nb10=a21*a33-a23*a31,\nb11=a22*a33-a23*a32,\ndet=b00*b11-b01*b10+b02*b09+b03*b08-b04*b07+b05*b06;mat4 mi=mat4(\na11*b11-a12*b10+a13*b09,\na02*b10-a01*b11-a03*b09,\na31*b05-a32*b04+a33*b03,\na22*b04-a21*b05-a23*b03,\na12*b08-a10*b11-a13*b07,\na00*b11-a02*b08+a03*b07,\na32*b02-a30*b05-a33*b01,\na20*b05-a22*b02+a23*b01,\na10*b10-a11*b08+a13*b06,\na01*b08-a00*b10-a03*b06,\na30*b04-a31*b02+a33*b00,\na21*b02-a20*b04-a23*b00,\na11*b07-a10*b09-a12*b06,\na00*b09-a01*b07+a02*b06,\na31*b01-a30*b03-a32*b00,\na20*b03-a21*b01+a22*b00)/det;return mat4(mi[0][0],mi[1][0],mi[2][0],mi[3][0],\nmi[0][1],mi[1][1],mi[2][1],mi[3][1],\nmi[0][2],mi[1][2],mi[2][2],mi[3][2],\nmi[0][3],mi[1][3],mi[2][3],mi[3][3]);}\n#endif\n#endif\nvec3 perturbNormalBase(mat3 cotangentFrame,vec3 normal,float scale)\n{\n#ifdef NORMALXYSCALE\nnormal=normalize(normal*vec3(scale,scale,1.0));\n#endif\nreturn normalize(cotangentFrame*normal);}\nvec3 perturbNormal(mat3 cotangentFrame,vec3 textureSample,float scale)\n{return perturbNormalBase(cotangentFrame,textureSample*2.0-1.0,scale);}\nmat3 cotangent_frame(vec3 normal,vec3 p,vec2 uv,vec2 tangentSpaceParams)\n{vec3 dp1=dFdx(p);vec3 dp2=dFdy(p);vec2 duv1=dFdx(uv);vec2 duv2=dFdy(uv);vec3 dp2perp=cross(dp2,normal);vec3 dp1perp=cross(normal,dp1);vec3 tangent=dp2perp*duv1.x+dp1perp*duv2.x;vec3 bitangent=dp2perp*duv1.y+dp1perp*duv2.y;tangent*=tangentSpaceParams.x;bitangent*=tangentSpaceParams.y;float det=max(dot(tangent,tangent),dot(bitangent,bitangent));float invmax=det==0.0 ? 0.0 : inversesqrt(det);return mat3(tangent*invmax,bitangent*invmax,normal);}\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const bumpFragmentMainFunctions = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\nimport \"./samplerFragmentDeclaration\";\n\nconst name = \"bumpFragmentFunctions\";\nconst shader = `#if defined(BUMP)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,BUMP,_VARYINGNAME_,Bump,_SAMPLERNAME_,bump)\n#endif\n#if defined(DETAIL)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,DETAIL,_VARYINGNAME_,Detail,_SAMPLERNAME_,detail)\n#endif\n#if defined(BUMP) && defined(PARALLAX)\nconst float minSamples=4.;const float maxSamples=15.;const int iMaxSamples=15;vec2 parallaxOcclusion(vec3 vViewDirCoT,vec3 vNormalCoT,vec2 texCoord,float parallaxScale) {float parallaxLimit=length(vViewDirCoT.xy)/vViewDirCoT.z;parallaxLimit*=parallaxScale;vec2 vOffsetDir=normalize(vViewDirCoT.xy);vec2 vMaxOffset=vOffsetDir*parallaxLimit;float numSamples=maxSamples+(dot(vViewDirCoT,vNormalCoT)*(minSamples-maxSamples));float stepSize=1.0/numSamples;float currRayHeight=1.0;vec2 vCurrOffset=vec2(0,0);vec2 vLastOffset=vec2(0,0);float lastSampledHeight=1.0;float currSampledHeight=1.0;bool keepWorking=true;for (int i=0; i<iMaxSamples; i++)\n{currSampledHeight=texture2D(bumpSampler,texCoord+vCurrOffset).w;if (!keepWorking)\n{}\nelse if (currSampledHeight>currRayHeight)\n{float delta1=currSampledHeight-currRayHeight;float delta2=(currRayHeight+stepSize)-lastSampledHeight;float ratio=delta1/(delta1+delta2);vCurrOffset=(ratio)* vLastOffset+(1.0-ratio)*vCurrOffset;keepWorking=false;}\nelse\n{currRayHeight-=stepSize;vLastOffset=vCurrOffset;\n#ifdef PARALLAX_RHS\nvCurrOffset-=stepSize*vMaxOffset;\n#else\nvCurrOffset+=stepSize*vMaxOffset;\n#endif\nlastSampledHeight=currSampledHeight;}}\nreturn vCurrOffset;}\nvec2 parallaxOffset(vec3 viewDir,float heightScale)\n{float height=texture2D(bumpSampler,vBumpUV).w;vec2 texCoordOffset=heightScale*viewDir.xy*height;\n#ifdef PARALLAX_RHS\nreturn texCoordOffset;\n#else\nreturn -texCoordOffset;\n#endif\n}\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const bumpFragmentFunctions = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"clipPlaneFragmentDeclaration\";\nconst shader = `#ifdef CLIPPLANE\nvarying float fClipDistance;\n#endif\n#ifdef CLIPPLANE2\nvarying float fClipDistance2;\n#endif\n#ifdef CLIPPLANE3\nvarying float fClipDistance3;\n#endif\n#ifdef CLIPPLANE4\nvarying float fClipDistance4;\n#endif\n#ifdef CLIPPLANE5\nvarying float fClipDistance5;\n#endif\n#ifdef CLIPPLANE6\nvarying float fClipDistance6;\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const clipPlaneFragmentDeclaration = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"logDepthDeclaration\";\nconst shader = `#ifdef LOGARITHMICDEPTH\nuniform float logarithmicDepthConstant;varying float vFragmentDepth;\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const logDepthDeclaration = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"fogFragmentDeclaration\";\nconst shader = `#ifdef FOG\n#define FOGMODE_NONE 0.\n#define FOGMODE_EXP 1.\n#define FOGMODE_EXP2 2.\n#define FOGMODE_LINEAR 3.\n#define E 2.71828\nuniform vec4 vFogInfos;uniform vec3 vFogColor;varying vec3 vFogDistance;float CalcFogFactor()\n{float fogCoeff=1.0;float fogStart=vFogInfos.y;float fogEnd=vFogInfos.z;float fogDensity=vFogInfos.w;float fogDistance=length(vFogDistance);if (FOGMODE_LINEAR==vFogInfos.x)\n{fogCoeff=(fogEnd-fogDistance)/(fogEnd-fogStart);}\nelse if (FOGMODE_EXP==vFogInfos.x)\n{fogCoeff=1.0/pow(E,fogDistance*fogDensity);}\nelse if (FOGMODE_EXP2==vFogInfos.x)\n{fogCoeff=1.0/pow(E,fogDistance*fogDistance*fogDensity*fogDensity);}\nreturn clamp(fogCoeff,0.0,1.0);}\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const fogFragmentDeclaration = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"clipPlaneFragment\";\nconst shader = `#if defined(CLIPPLANE) || defined(CLIPPLANE2) || defined(CLIPPLANE3) || defined(CLIPPLANE4) || defined(CLIPPLANE5) || defined(CLIPPLANE6)\nif (false) {}\n#endif\n#ifdef CLIPPLANE\nelse if (fClipDistance>0.0)\n{discard;}\n#endif\n#ifdef CLIPPLANE2\nelse if (fClipDistance2>0.0)\n{discard;}\n#endif\n#ifdef CLIPPLANE3\nelse if (fClipDistance3>0.0)\n{discard;}\n#endif\n#ifdef CLIPPLANE4\nelse if (fClipDistance4>0.0)\n{discard;}\n#endif\n#ifdef CLIPPLANE5\nelse if (fClipDistance5>0.0)\n{discard;}\n#endif\n#ifdef CLIPPLANE6\nelse if (fClipDistance6>0.0)\n{discard;}\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const clipPlaneFragment = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"bumpFragment\";\nconst shader = `vec2 uvOffset=vec2(0.0,0.0);\n#if defined(BUMP) || defined(PARALLAX) || defined(DETAIL)\n#ifdef NORMALXYSCALE\nfloat normalScale=1.0;\n#elif defined(BUMP)\nfloat normalScale=vBumpInfos.y;\n#else\nfloat normalScale=1.0;\n#endif\n#if defined(TANGENT) && defined(NORMAL)\nmat3 TBN=vTBN;\n#elif defined(BUMP)\nvec2 TBNUV=gl_FrontFacing ? vBumpUV : -vBumpUV;mat3 TBN=cotangent_frame(normalW*normalScale,vPositionW,TBNUV,vTangentSpaceParams);\n#else\nvec2 TBNUV=gl_FrontFacing ? vDetailUV : -vDetailUV;mat3 TBN=cotangent_frame(normalW*normalScale,vPositionW,TBNUV,vec2(1.,1.));\n#endif\n#elif defined(ANISOTROPIC)\n#if defined(TANGENT) && defined(NORMAL)\nmat3 TBN=vTBN;\n#else\nvec2 TBNUV=gl_FrontFacing ? vMainUV1 : -vMainUV1;mat3 TBN=cotangent_frame(normalW,vPositionW,TBNUV,vec2(1.,1.));\n#endif\n#endif\n#ifdef PARALLAX\nmat3 invTBN=transposeMat3(TBN);\n#ifdef PARALLAXOCCLUSION\nuvOffset=parallaxOcclusion(invTBN*-viewDirectionW,invTBN*normalW,vBumpUV,vBumpInfos.z);\n#else\nuvOffset=parallaxOffset(invTBN*viewDirectionW,vBumpInfos.z);\n#endif\n#endif\n#ifdef DETAIL\nvec4 detailColor=texture2D(detailSampler,vDetailUV+uvOffset);vec2 detailNormalRG=detailColor.wy*2.0-1.0;float detailNormalB=sqrt(1.-saturate(dot(detailNormalRG,detailNormalRG)));vec3 detailNormal=vec3(detailNormalRG,detailNormalB);\n#endif\n#ifdef BUMP\n#ifdef OBJECTSPACE_NORMALMAP\n#define CUSTOM_FRAGMENT_BUMP_FRAGMENT\nnormalW=normalize(texture2D(bumpSampler,vBumpUV).xyz *2.0-1.0);normalW=normalize(mat3(normalMatrix)*normalW);\n#elif !defined(DETAIL)\nnormalW=perturbNormal(TBN,texture2D(bumpSampler,vBumpUV+uvOffset).xyz,vBumpInfos.y);\n#else\nvec3 bumpNormal=texture2D(bumpSampler,vBumpUV+uvOffset).xyz*2.0-1.0;\n#if DETAIL_NORMALBLENDMETHOD==0 \ndetailNormal.xy*=vDetailInfos.z;vec3 blendedNormal=normalize(vec3(bumpNormal.xy+detailNormal.xy,bumpNormal.z*detailNormal.z));\n#elif DETAIL_NORMALBLENDMETHOD==1 \ndetailNormal.xy*=vDetailInfos.z;bumpNormal+=vec3(0.0,0.0,1.0);detailNormal*=vec3(-1.0,-1.0,1.0);vec3 blendedNormal=bumpNormal*dot(bumpNormal,detailNormal)/bumpNormal.z-detailNormal;\n#endif\nnormalW=perturbNormalBase(TBN,blendedNormal,vBumpInfos.y);\n#endif\n#elif defined(DETAIL)\ndetailNormal.xy*=vDetailInfos.z;normalW=perturbNormalBase(TBN,detailNormal,vDetailInfos.z);\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const bumpFragment = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"decalFragment\";\nconst shader = `#ifdef DECAL\n#ifdef GAMMADECAL\ndecalColor.rgb=toLinearSpace(decalColor.rgb);\n#endif\n#ifdef DECAL_SMOOTHALPHA\ndecalColor.a*=decalColor.a;\n#endif\nsurfaceAlbedo.rgb=mix(surfaceAlbedo.rgb,decalColor.rgb,decalColor.a);\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const decalFragment = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"depthPrePass\";\nconst shader = `#ifdef DEPTHPREPASS\ngl_FragColor=vec4(0.,0.,0.,1.0);return;\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const depthPrePass = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"lightFragment\";\nconst shader = `#ifdef LIGHT{X}\n#if defined(SHADOWONLY) || defined(LIGHTMAP) && defined(LIGHTMAPEXCLUDED{X}) && defined(LIGHTMAPNOSPECULAR{X})\n#else\n#ifdef PBR\n#ifdef SPOTLIGHT{X}\npreInfo=computePointAndSpotPreLightingInfo(light{X}.vLightData,viewDirectionW,normalW);\n#elif defined(POINTLIGHT{X})\npreInfo=computePointAndSpotPreLightingInfo(light{X}.vLightData,viewDirectionW,normalW);\n#elif defined(HEMILIGHT{X})\npreInfo=computeHemisphericPreLightingInfo(light{X}.vLightData,viewDirectionW,normalW);\n#elif defined(DIRLIGHT{X})\npreInfo=computeDirectionalPreLightingInfo(light{X}.vLightData,viewDirectionW,normalW);\n#endif\npreInfo.NdotV=NdotV;\n#ifdef SPOTLIGHT{X}\n#ifdef LIGHT_FALLOFF_GLTF{X}\npreInfo.attenuation=computeDistanceLightFalloff_GLTF(preInfo.lightDistanceSquared,light{X}.vLightFalloff.y);preInfo.attenuation*=computeDirectionalLightFalloff_GLTF(light{X}.vLightDirection.xyz,preInfo.L,light{X}.vLightFalloff.z,light{X}.vLightFalloff.w);\n#elif defined(LIGHT_FALLOFF_PHYSICAL{X})\npreInfo.attenuation=computeDistanceLightFalloff_Physical(preInfo.lightDistanceSquared);preInfo.attenuation*=computeDirectionalLightFalloff_Physical(light{X}.vLightDirection.xyz,preInfo.L,light{X}.vLightDirection.w);\n#elif defined(LIGHT_FALLOFF_STANDARD{X})\npreInfo.attenuation=computeDistanceLightFalloff_Standard(preInfo.lightOffset,light{X}.vLightFalloff.x);preInfo.attenuation*=computeDirectionalLightFalloff_Standard(light{X}.vLightDirection.xyz,preInfo.L,light{X}.vLightDirection.w,light{X}.vLightData.w);\n#else\npreInfo.attenuation=computeDistanceLightFalloff(preInfo.lightOffset,preInfo.lightDistanceSquared,light{X}.vLightFalloff.x,light{X}.vLightFalloff.y);preInfo.attenuation*=computeDirectionalLightFalloff(light{X}.vLightDirection.xyz,preInfo.L,light{X}.vLightDirection.w,light{X}.vLightData.w,light{X}.vLightFalloff.z,light{X}.vLightFalloff.w);\n#endif\n#elif defined(POINTLIGHT{X})\n#ifdef LIGHT_FALLOFF_GLTF{X}\npreInfo.attenuation=computeDistanceLightFalloff_GLTF(preInfo.lightDistanceSquared,light{X}.vLightFalloff.y);\n#elif defined(LIGHT_FALLOFF_PHYSICAL{X})\npreInfo.attenuation=computeDistanceLightFalloff_Physical(preInfo.lightDistanceSquared);\n#elif defined(LIGHT_FALLOFF_STANDARD{X})\npreInfo.attenuation=computeDistanceLightFalloff_Standard(preInfo.lightOffset,light{X}.vLightFalloff.x);\n#else\npreInfo.attenuation=computeDistanceLightFalloff(preInfo.lightOffset,preInfo.lightDistanceSquared,light{X}.vLightFalloff.x,light{X}.vLightFalloff.y);\n#endif\n#else\npreInfo.attenuation=1.0;\n#endif\n#ifdef HEMILIGHT{X}\npreInfo.roughness=roughness;\n#else\npreInfo.roughness=adjustRoughnessFromLightProperties(roughness,light{X}.vLightSpecular.a,preInfo.lightDistance);\n#endif\n#ifdef IRIDESCENCE\npreInfo.iridescenceIntensity=iridescenceIntensity;\n#endif\n#ifdef HEMILIGHT{X}\ninfo.diffuse=computeHemisphericDiffuseLighting(preInfo,light{X}.vLightDiffuse.rgb,light{X}.vLightGround);\n#elif defined(SS_TRANSLUCENCY)\ninfo.diffuse=computeDiffuseAndTransmittedLighting(preInfo,light{X}.vLightDiffuse.rgb,subSurfaceOut.transmittance);\n#else\ninfo.diffuse=computeDiffuseLighting(preInfo,light{X}.vLightDiffuse.rgb);\n#endif\n#ifdef SPECULARTERM\n#ifdef ANISOTROPIC\ninfo.specular=computeAnisotropicSpecularLighting(preInfo,viewDirectionW,normalW,anisotropicOut.anisotropicTangent,anisotropicOut.anisotropicBitangent,anisotropicOut.anisotropy,clearcoatOut.specularEnvironmentR0,specularEnvironmentR90,AARoughnessFactors.x,light{X}.vLightDiffuse.rgb);\n#else\ninfo.specular=computeSpecularLighting(preInfo,normalW,clearcoatOut.specularEnvironmentR0,specularEnvironmentR90,AARoughnessFactors.x,light{X}.vLightDiffuse.rgb);\n#endif\n#endif\n#ifdef SHEEN\n#ifdef SHEEN_LINKWITHALBEDO\npreInfo.roughness=sheenOut.sheenIntensity;\n#else\n#ifdef HEMILIGHT{X}\npreInfo.roughness=sheenOut.sheenRoughness;\n#else\npreInfo.roughness=adjustRoughnessFromLightProperties(sheenOut.sheenRoughness,light{X}.vLightSpecular.a,preInfo.lightDistance);\n#endif\n#endif\ninfo.sheen=computeSheenLighting(preInfo,normalW,sheenOut.sheenColor,specularEnvironmentR90,AARoughnessFactors.x,light{X}.vLightDiffuse.rgb);\n#endif\n#ifdef CLEARCOAT\n#ifdef HEMILIGHT{X}\npreInfo.roughness=clearcoatOut.clearCoatRoughness;\n#else\npreInfo.roughness=adjustRoughnessFromLightProperties(clearcoatOut.clearCoatRoughness,light{X}.vLightSpecular.a,preInfo.lightDistance);\n#endif\ninfo.clearCoat=computeClearCoatLighting(preInfo,clearcoatOut.clearCoatNormalW,clearcoatOut.clearCoatAARoughnessFactors.x,clearcoatOut.clearCoatIntensity,light{X}.vLightDiffuse.rgb);\n#ifdef CLEARCOAT_TINT\nabsorption=computeClearCoatLightingAbsorption(clearcoatOut.clearCoatNdotVRefract,preInfo.L,clearcoatOut.clearCoatNormalW,clearcoatOut.clearCoatColor,clearcoatOut.clearCoatThickness,clearcoatOut.clearCoatIntensity);info.diffuse*=absorption;\n#ifdef SPECULARTERM\ninfo.specular*=absorption;\n#endif\n#endif\ninfo.diffuse*=info.clearCoat.w;\n#ifdef SPECULARTERM\ninfo.specular*=info.clearCoat.w;\n#endif\n#ifdef SHEEN\ninfo.sheen*=info.clearCoat.w;\n#endif\n#endif\n#else\n#ifdef SPOTLIGHT{X}\ninfo=computeSpotLighting(viewDirectionW,normalW,light{X}.vLightData,light{X}.vLightDirection,light{X}.vLightDiffuse.rgb,light{X}.vLightSpecular.rgb,light{X}.vLightDiffuse.a,glossiness);\n#elif defined(HEMILIGHT{X})\ninfo=computeHemisphericLighting(viewDirectionW,normalW,light{X}.vLightData,light{X}.vLightDiffuse.rgb,light{X}.vLightSpecular.rgb,light{X}.vLightGround,glossiness);\n#elif defined(POINTLIGHT{X}) || defined(DIRLIGHT{X})\ninfo=computeLighting(viewDirectionW,normalW,light{X}.vLightData,light{X}.vLightDiffuse.rgb,light{X}.vLightSpecular.rgb,light{X}.vLightDiffuse.a,glossiness);\n#endif\n#endif\n#ifdef PROJECTEDLIGHTTEXTURE{X}\ninfo.diffuse*=computeProjectionTextureDiffuseLighting(projectionLightSampler{X},textureProjectionMatrix{X});\n#endif\n#endif\n#ifdef SHADOW{X}\n#ifdef SHADOWCSM{X}\nfor (int i=0; i<SHADOWCSMNUM_CASCADES{X}; i++) \n{\n#ifdef SHADOWCSM_RIGHTHANDED{X}\ndiff{X}=viewFrustumZ{X}[i]+vPositionFromCamera{X}.z;\n#else\ndiff{X}=viewFrustumZ{X}[i]-vPositionFromCamera{X}.z;\n#endif\nif (diff{X}>=0.) {index{X}=i;break;}}\n#ifdef SHADOWCSMUSESHADOWMAXZ{X}\nif (index{X}>=0)\n#endif\n{\n#if defined(SHADOWPCF{X})\n#if defined(SHADOWLOWQUALITY{X})\nshadow=computeShadowWithCSMPCF1(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#elif defined(SHADOWMEDIUMQUALITY{X})\nshadow=computeShadowWithCSMPCF3(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#else\nshadow=computeShadowWithCSMPCF5(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#endif\n#elif defined(SHADOWPCSS{X})\n#if defined(SHADOWLOWQUALITY{X})\nshadow=computeShadowWithCSMPCSS16(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});\n#elif defined(SHADOWMEDIUMQUALITY{X})\nshadow=computeShadowWithCSMPCSS32(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});\n#else\nshadow=computeShadowWithCSMPCSS64(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});\n#endif\n#else\nshadow=computeShadowCSM(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#endif\n#ifdef SHADOWCSMDEBUG{X}\nshadowDebug{X}=vec3(shadow)*vCascadeColorsMultiplier{X}[index{X}];\n#endif\n#ifndef SHADOWCSMNOBLEND{X}\nfloat frustumLength=frustumLengths{X}[index{X}];float diffRatio=clamp(diff{X}/frustumLength,0.,1.)*cascadeBlendFactor{X};if (index{X}<(SHADOWCSMNUM_CASCADES{X}-1) && diffRatio<1.)\n{index{X}+=1;float nextShadow=0.;\n#if defined(SHADOWPCF{X})\n#if defined(SHADOWLOWQUALITY{X})\nnextShadow=computeShadowWithCSMPCF1(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#elif defined(SHADOWMEDIUMQUALITY{X})\nnextShadow=computeShadowWithCSMPCF3(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#else\nnextShadow=computeShadowWithCSMPCF5(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#endif\n#elif defined(SHADOWPCSS{X})\n#if defined(SHADOWLOWQUALITY{X})\nnextShadow=computeShadowWithCSMPCSS16(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});\n#elif defined(SHADOWMEDIUMQUALITY{X})\nnextShadow=computeShadowWithCSMPCSS32(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});\n#else\nnextShadow=computeShadowWithCSMPCSS64(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});\n#endif\n#else\nnextShadow=computeShadowCSM(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#endif\nshadow=mix(nextShadow,shadow,diffRatio);\n#ifdef SHADOWCSMDEBUG{X}\nshadowDebug{X}=mix(vec3(nextShadow)*vCascadeColorsMultiplier{X}[index{X}],shadowDebug{X},diffRatio);\n#endif\n}\n#endif\n}\n#elif defined(SHADOWCLOSEESM{X})\n#if defined(SHADOWCUBE{X})\nshadow=computeShadowWithCloseESMCube(vPositionW,light{X}.vLightData.xyz,shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.z,light{X}.depthValues);\n#else\nshadow=computeShadowWithCloseESM(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.z,light{X}.shadowsInfo.w);\n#endif\n#elif defined(SHADOWESM{X})\n#if defined(SHADOWCUBE{X})\nshadow=computeShadowWithESMCube(vPositionW,light{X}.vLightData.xyz,shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.z,light{X}.depthValues);\n#else\nshadow=computeShadowWithESM(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.z,light{X}.shadowsInfo.w);\n#endif\n#elif defined(SHADOWPOISSON{X})\n#if defined(SHADOWCUBE{X})\nshadow=computeShadowWithPoissonSamplingCube(vPositionW,light{X}.vLightData.xyz,shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.x,light{X}.depthValues);\n#else\nshadow=computeShadowWithPoissonSampling(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#endif\n#elif defined(SHADOWPCF{X})\n#if defined(SHADOWLOWQUALITY{X})\nshadow=computeShadowWithPCF1(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#elif defined(SHADOWMEDIUMQUALITY{X})\nshadow=computeShadowWithPCF3(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#else\nshadow=computeShadowWithPCF5(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#endif\n#elif defined(SHADOWPCSS{X})\n#if defined(SHADOWLOWQUALITY{X})\nshadow=computeShadowWithPCSS16(vPositionFromLight{X},vDepthMetric{X},depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#elif defined(SHADOWMEDIUMQUALITY{X})\nshadow=computeShadowWithPCSS32(vPositionFromLight{X},vDepthMetric{X},depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#else\nshadow=computeShadowWithPCSS64(vPositionFromLight{X},vDepthMetric{X},depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#endif\n#else\n#if defined(SHADOWCUBE{X})\nshadow=computeShadowCube(vPositionW,light{X}.vLightData.xyz,shadowSampler{X},light{X}.shadowsInfo.x,light{X}.depthValues);\n#else\nshadow=computeShadow(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#endif\n#endif\n#ifdef SHADOWONLY\n#ifndef SHADOWINUSE\n#define SHADOWINUSE\n#endif\nglobalShadow+=shadow;shadowLightCount+=1.0;\n#endif\n#else\nshadow=1.;\n#endif\naggShadow+=shadow;numLights+=1.0;\n#ifndef SHADOWONLY\n#ifdef CUSTOMUSERLIGHTING\ndiffuseBase+=computeCustomDiffuseLighting(info,diffuseBase,shadow);\n#ifdef SPECULARTERM\nspecularBase+=computeCustomSpecularLighting(info,specularBase,shadow);\n#endif\n#elif defined(LIGHTMAP) && defined(LIGHTMAPEXCLUDED{X})\ndiffuseBase+=lightmapColor.rgb*shadow;\n#ifdef SPECULARTERM\n#ifndef LIGHTMAPNOSPECULAR{X}\nspecularBase+=info.specular*shadow*lightmapColor.rgb;\n#endif\n#endif\n#ifdef CLEARCOAT\n#ifndef LIGHTMAPNOSPECULAR{X}\nclearCoatBase+=info.clearCoat.rgb*shadow*lightmapColor.rgb;\n#endif\n#endif\n#ifdef SHEEN\n#ifndef LIGHTMAPNOSPECULAR{X}\nsheenBase+=info.sheen.rgb*shadow;\n#endif\n#endif\n#else\n#ifdef SHADOWCSMDEBUG{X}\ndiffuseBase+=info.diffuse*shadowDebug{X};\n#else \ndiffuseBase+=info.diffuse*shadow;\n#endif\n#ifdef SPECULARTERM\nspecularBase+=info.specular*shadow;\n#endif\n#ifdef CLEARCOAT\nclearCoatBase+=info.clearCoat.rgb*shadow;\n#endif\n#ifdef SHEEN\nsheenBase+=info.sheen.rgb*shadow;\n#endif\n#endif\n#endif\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const lightFragment = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"logDepthFragment\";\nconst shader = `#ifdef LOGARITHMICDEPTH\ngl_FragDepthEXT=log2(vFragmentDepth)*logarithmicDepthConstant*0.5;\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const logDepthFragment = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"fogFragment\";\nconst shader = `#ifdef FOG\nfloat fog=CalcFogFactor();\n#ifdef PBR\nfog=toLinearSpace(fog);\n#endif\ncolor.rgb=mix(vFogColor,color.rgb,fog);\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const fogFragment = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"oitFragment\";\nconst shader = `#ifdef ORDER_INDEPENDENT_TRANSPARENCY\nfloat fragDepth=gl_FragCoord.z; \n#ifdef ORDER_INDEPENDENT_TRANSPARENCY_16BITS\nuint halfFloat=packHalf2x16(vec2(fragDepth));vec2 full=unpackHalf2x16(halfFloat);fragDepth=full.x;\n#endif\nivec2 fragCoord=ivec2(gl_FragCoord.xy);vec2 lastDepth=texelFetch(oitDepthSampler,fragCoord,0).rg;vec4 lastFrontColor=texelFetch(oitFrontColorSampler,fragCoord,0);depth.rg=vec2(-MAX_DEPTH);frontColor=lastFrontColor;backColor=vec4(0.0);\n#ifdef USE_REVERSE_DEPTHBUFFER\nfloat furthestDepth=-lastDepth.x;float nearestDepth=lastDepth.y;\n#else\nfloat nearestDepth=-lastDepth.x;float furthestDepth=lastDepth.y;\n#endif\nfloat alphaMultiplier=1.0-lastFrontColor.a;\n#ifdef USE_REVERSE_DEPTHBUFFER\nif (fragDepth>nearestDepth || fragDepth<furthestDepth) {\n#else\nif (fragDepth<nearestDepth || fragDepth>furthestDepth) {\n#endif\nreturn;}\n#ifdef USE_REVERSE_DEPTHBUFFER\nif (fragDepth<nearestDepth && fragDepth>furthestDepth) {\n#else\nif (fragDepth>nearestDepth && fragDepth<furthestDepth) {\n#endif\ndepth.rg=vec2(-fragDepth,fragDepth);return;}\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const oitFragment = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/defaultFragmentDeclaration\";\nimport \"./ShadersInclude/defaultUboDeclaration\";\nimport \"./ShadersInclude/prePassDeclaration\";\nimport \"./ShadersInclude/oitDeclaration\";\nimport \"./ShadersInclude/mainUVVaryingDeclaration\";\nimport \"./ShadersInclude/helperFunctions\";\nimport \"./ShadersInclude/lightFragmentDeclaration\";\nimport \"./ShadersInclude/lightUboDeclaration\";\nimport \"./ShadersInclude/lightsFragmentFunctions\";\nimport \"./ShadersInclude/shadowsFragmentFunctions\";\nimport \"./ShadersInclude/samplerFragmentDeclaration\";\nimport \"./ShadersInclude/fresnelFunction\";\nimport \"./ShadersInclude/reflectionFunction\";\nimport \"./ShadersInclude/imageProcessingDeclaration\";\nimport \"./ShadersInclude/imageProcessingFunctions\";\nimport \"./ShadersInclude/bumpFragmentMainFunctions\";\nimport \"./ShadersInclude/bumpFragmentFunctions\";\nimport \"./ShadersInclude/clipPlaneFragmentDeclaration\";\nimport \"./ShadersInclude/logDepthDeclaration\";\nimport \"./ShadersInclude/fogFragmentDeclaration\";\nimport \"./ShadersInclude/clipPlaneFragment\";\nimport \"./ShadersInclude/bumpFragment\";\nimport \"./ShadersInclude/decalFragment\";\nimport \"./ShadersInclude/depthPrePass\";\nimport \"./ShadersInclude/lightFragment\";\nimport \"./ShadersInclude/logDepthFragment\";\nimport \"./ShadersInclude/fogFragment\";\nimport \"./ShadersInclude/oitFragment\";\n\nconst name = \"defaultPixelShader\";\nconst shader = `#include<__decl__defaultFragment>\n#if defined(BUMP) || !defined(NORMAL)\n#extension GL_OES_standard_derivatives : enable\n#endif\n#include<prePassDeclaration>[SCENE_MRT_COUNT]\n#include<oitDeclaration>\n#define CUSTOM_FRAGMENT_BEGIN\n#ifdef LOGARITHMICDEPTH\n#extension GL_EXT_frag_depth : enable\n#endif\nvarying vec3 vPositionW;\n#ifdef NORMAL\nvarying vec3 vNormalW;\n#endif\n#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nvarying vec4 vColor;\n#endif\n#include<mainUVVaryingDeclaration>[1..7]\n#include<helperFunctions>\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\n#include<lightsFragmentFunctions>\n#include<shadowsFragmentFunctions>\n#include<samplerFragmentDeclaration>(_DEFINENAME_,DIFFUSE,_VARYINGNAME_,Diffuse,_SAMPLERNAME_,diffuse)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,AMBIENT,_VARYINGNAME_,Ambient,_SAMPLERNAME_,ambient)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,OPACITY,_VARYINGNAME_,Opacity,_SAMPLERNAME_,opacity)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,EMISSIVE,_VARYINGNAME_,Emissive,_SAMPLERNAME_,emissive)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,LIGHTMAP,_VARYINGNAME_,Lightmap,_SAMPLERNAME_,lightmap)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,DECAL,_VARYINGNAME_,Decal,_SAMPLERNAME_,decal)\n#ifdef REFRACTION\n#ifdef REFRACTIONMAP_3D\nuniform samplerCube refractionCubeSampler;\n#else\nuniform sampler2D refraction2DSampler;\n#endif\n#endif\n#if defined(SPECULARTERM)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,SPECULAR,_VARYINGNAME_,Specular,_SAMPLERNAME_,specular)\n#endif\n#include<fresnelFunction>\n#ifdef REFLECTION\n#ifdef REFLECTIONMAP_3D\nuniform samplerCube reflectionCubeSampler;\n#else\nuniform sampler2D reflection2DSampler;\n#endif\n#ifdef REFLECTIONMAP_SKYBOX\nvarying vec3 vPositionUVW;\n#else\n#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)\nvarying vec3 vDirectionW;\n#endif\n#endif\n#include<reflectionFunction>\n#endif\n#include<imageProcessingDeclaration>\n#include<imageProcessingFunctions>\n#include<bumpFragmentMainFunctions>\n#include<bumpFragmentFunctions>\n#include<clipPlaneFragmentDeclaration>\n#include<logDepthDeclaration>\n#include<fogFragmentDeclaration>\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_FRAGMENT_MAIN_BEGIN\n#include<clipPlaneFragment>\nvec3 viewDirectionW=normalize(vEyePosition.xyz-vPositionW);vec4 baseColor=vec4(1.,1.,1.,1.);vec3 diffuseColor=vDiffuseColor.rgb;float alpha=vDiffuseColor.a;\n#ifdef NORMAL\nvec3 normalW=normalize(vNormalW);\n#else\nvec3 normalW=normalize(-cross(dFdx(vPositionW),dFdy(vPositionW)));\n#endif\n#include<bumpFragment>\n#ifdef TWOSIDEDLIGHTING\nnormalW=gl_FrontFacing ? normalW : -normalW;\n#endif\n#ifdef DIFFUSE\nbaseColor=texture2D(diffuseSampler,vDiffuseUV+uvOffset);\n#if defined(ALPHATEST) && !defined(ALPHATEST_AFTERALLALPHACOMPUTATIONS)\nif (baseColor.a<alphaCutOff)\ndiscard;\n#endif\n#ifdef ALPHAFROMDIFFUSE\nalpha*=baseColor.a;\n#endif\n#define CUSTOM_FRAGMENT_UPDATE_ALPHA\nbaseColor.rgb*=vDiffuseInfos.y;\n#endif\n#if defined(DECAL) && !defined(DECAL_AFTER_DETAIL)\nvec4 decalColor=texture2D(decalSampler,vDecalUV+uvOffset);\n#include<decalFragment>(surfaceAlbedo,baseColor,GAMMADECAL,_GAMMADECAL_NOTUSED_)\n#endif\n#include<depthPrePass>\n#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nbaseColor.rgb*=vColor.rgb;\n#endif\n#ifdef DETAIL\nbaseColor.rgb=baseColor.rgb*2.0*mix(0.5,detailColor.r,vDetailInfos.y);\n#endif\n#if defined(DECAL) && defined(DECAL_AFTER_DETAIL)\nvec4 decalColor=texture2D(decalSampler,vDecalUV+uvOffset);\n#include<decalFragment>(surfaceAlbedo,baseColor,GAMMADECAL,_GAMMADECAL_NOTUSED_)\n#endif\n#define CUSTOM_FRAGMENT_UPDATE_DIFFUSE\nvec3 baseAmbientColor=vec3(1.,1.,1.);\n#ifdef AMBIENT\nbaseAmbientColor=texture2D(ambientSampler,vAmbientUV+uvOffset).rgb*vAmbientInfos.y;\n#endif\n#define CUSTOM_FRAGMENT_BEFORE_LIGHTS\n#ifdef SPECULARTERM\nfloat glossiness=vSpecularColor.a;vec3 specularColor=vSpecularColor.rgb;\n#ifdef SPECULAR\nvec4 specularMapColor=texture2D(specularSampler,vSpecularUV+uvOffset);specularColor=specularMapColor.rgb;\n#ifdef GLOSSINESS\nglossiness=glossiness*specularMapColor.a;\n#endif\n#endif\n#else\nfloat glossiness=0.;\n#endif\nvec3 diffuseBase=vec3(0.,0.,0.);lightingInfo info;\n#ifdef SPECULARTERM\nvec3 specularBase=vec3(0.,0.,0.);\n#endif\nfloat shadow=1.;float aggShadow=0.;float numLights=0.;\n#ifdef LIGHTMAP\nvec4 lightmapColor=texture2D(lightmapSampler,vLightmapUV+uvOffset);\n#ifdef RGBDLIGHTMAP\nlightmapColor.rgb=fromRGBD(lightmapColor);\n#endif\nlightmapColor.rgb*=vLightmapInfos.y;\n#endif\n#include<lightFragment>[0..maxSimultaneousLights]\naggShadow=aggShadow/numLights;vec4 refractionColor=vec4(0.,0.,0.,1.);\n#ifdef REFRACTION\nvec3 refractionVector=normalize(refract(-viewDirectionW,normalW,vRefractionInfos.y));\n#ifdef REFRACTIONMAP_3D\n#ifdef USE_LOCAL_REFRACTIONMAP_CUBIC\nrefractionVector=parallaxCorrectNormal(vPositionW,refractionVector,vRefractionSize,vRefractionPosition);\n#endif\nrefractionVector.y=refractionVector.y*vRefractionInfos.w;vec4 refractionLookup=textureCube(refractionCubeSampler,refractionVector);if (dot(refractionVector,viewDirectionW)<1.0) {refractionColor=refractionLookup;}\n#else\nvec3 vRefractionUVW=vec3(refractionMatrix*(view*vec4(vPositionW+refractionVector*vRefractionInfos.z,1.0)));vec2 refractionCoords=vRefractionUVW.xy/vRefractionUVW.z;refractionCoords.y=1.0-refractionCoords.y;refractionColor=texture2D(refraction2DSampler,refractionCoords);\n#endif\n#ifdef RGBDREFRACTION\nrefractionColor.rgb=fromRGBD(refractionColor);\n#endif\n#ifdef IS_REFRACTION_LINEAR\nrefractionColor.rgb=toGammaSpace(refractionColor.rgb);\n#endif\nrefractionColor.rgb*=vRefractionInfos.x;\n#endif\nvec4 reflectionColor=vec4(0.,0.,0.,1.);\n#ifdef REFLECTION\nvec3 vReflectionUVW=computeReflectionCoords(vec4(vPositionW,1.0),normalW);\n#ifdef REFLECTIONMAP_OPPOSITEZ\nvReflectionUVW.z*=-1.0;\n#endif\n#ifdef REFLECTIONMAP_3D\n#ifdef ROUGHNESS\nfloat bias=vReflectionInfos.y;\n#ifdef SPECULARTERM\n#ifdef SPECULAR\n#ifdef GLOSSINESS\nbias*=(1.0-specularMapColor.a);\n#endif\n#endif\n#endif\nreflectionColor=textureCube(reflectionCubeSampler,vReflectionUVW,bias);\n#else\nreflectionColor=textureCube(reflectionCubeSampler,vReflectionUVW);\n#endif\n#else\nvec2 coords=vReflectionUVW.xy;\n#ifdef REFLECTIONMAP_PROJECTION\ncoords/=vReflectionUVW.z;\n#endif\ncoords.y=1.0-coords.y;reflectionColor=texture2D(reflection2DSampler,coords);\n#endif\n#ifdef RGBDREFLECTION\nreflectionColor.rgb=fromRGBD(reflectionColor);\n#endif\n#ifdef IS_REFLECTION_LINEAR\nreflectionColor.rgb=toGammaSpace(reflectionColor.rgb);\n#endif\nreflectionColor.rgb*=vReflectionInfos.x;\n#ifdef REFLECTIONFRESNEL\nfloat reflectionFresnelTerm=computeFresnelTerm(viewDirectionW,normalW,reflectionRightColor.a,reflectionLeftColor.a);\n#ifdef REFLECTIONFRESNELFROMSPECULAR\n#ifdef SPECULARTERM\nreflectionColor.rgb*=specularColor.rgb*(1.0-reflectionFresnelTerm)+reflectionFresnelTerm*reflectionRightColor.rgb;\n#else\nreflectionColor.rgb*=reflectionLeftColor.rgb*(1.0-reflectionFresnelTerm)+reflectionFresnelTerm*reflectionRightColor.rgb;\n#endif\n#else\nreflectionColor.rgb*=reflectionLeftColor.rgb*(1.0-reflectionFresnelTerm)+reflectionFresnelTerm*reflectionRightColor.rgb;\n#endif\n#endif\n#endif\n#ifdef REFRACTIONFRESNEL\nfloat refractionFresnelTerm=computeFresnelTerm(viewDirectionW,normalW,refractionRightColor.a,refractionLeftColor.a);refractionColor.rgb*=refractionLeftColor.rgb*(1.0-refractionFresnelTerm)+refractionFresnelTerm*refractionRightColor.rgb;\n#endif\n#ifdef OPACITY\nvec4 opacityMap=texture2D(opacitySampler,vOpacityUV+uvOffset);\n#ifdef OPACITYRGB\nopacityMap.rgb=opacityMap.rgb*vec3(0.3,0.59,0.11);alpha*=(opacityMap.x+opacityMap.y+opacityMap.z)* vOpacityInfos.y;\n#else\nalpha*=opacityMap.a*vOpacityInfos.y;\n#endif\n#endif\n#if defined(VERTEXALPHA) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nalpha*=vColor.a;\n#endif\n#ifdef OPACITYFRESNEL\nfloat opacityFresnelTerm=computeFresnelTerm(viewDirectionW,normalW,opacityParts.z,opacityParts.w);alpha+=opacityParts.x*(1.0-opacityFresnelTerm)+opacityFresnelTerm*opacityParts.y;\n#endif\n#ifdef ALPHATEST\n#ifdef ALPHATEST_AFTERALLALPHACOMPUTATIONS\nif (alpha<alphaCutOff)\ndiscard;\n#endif\n#ifndef ALPHABLEND\nalpha=1.0;\n#endif\n#endif\nvec3 emissiveColor=vEmissiveColor;\n#ifdef EMISSIVE\nemissiveColor+=texture2D(emissiveSampler,vEmissiveUV+uvOffset).rgb*vEmissiveInfos.y;\n#endif\n#ifdef EMISSIVEFRESNEL\nfloat emissiveFresnelTerm=computeFresnelTerm(viewDirectionW,normalW,emissiveRightColor.a,emissiveLeftColor.a);emissiveColor*=emissiveLeftColor.rgb*(1.0-emissiveFresnelTerm)+emissiveFresnelTerm*emissiveRightColor.rgb;\n#endif\n#ifdef DIFFUSEFRESNEL\nfloat diffuseFresnelTerm=computeFresnelTerm(viewDirectionW,normalW,diffuseRightColor.a,diffuseLeftColor.a);diffuseBase*=diffuseLeftColor.rgb*(1.0-diffuseFresnelTerm)+diffuseFresnelTerm*diffuseRightColor.rgb;\n#endif\n#ifdef EMISSIVEASILLUMINATION\nvec3 finalDiffuse=clamp(diffuseBase*diffuseColor+vAmbientColor,0.0,1.0)*baseColor.rgb;\n#else\n#ifdef LINKEMISSIVEWITHDIFFUSE\nvec3 finalDiffuse=clamp((diffuseBase+emissiveColor)*diffuseColor+vAmbientColor,0.0,1.0)*baseColor.rgb;\n#else\nvec3 finalDiffuse=clamp(diffuseBase*diffuseColor+emissiveColor+vAmbientColor,0.0,1.0)*baseColor.rgb;\n#endif\n#endif\n#ifdef SPECULARTERM\nvec3 finalSpecular=specularBase*specularColor;\n#ifdef SPECULAROVERALPHA\nalpha=clamp(alpha+dot(finalSpecular,vec3(0.3,0.59,0.11)),0.,1.);\n#endif\n#else\nvec3 finalSpecular=vec3(0.0);\n#endif\n#ifdef REFLECTIONOVERALPHA\nalpha=clamp(alpha+dot(reflectionColor.rgb,vec3(0.3,0.59,0.11)),0.,1.);\n#endif\n#ifdef EMISSIVEASILLUMINATION\nvec4 color=vec4(clamp(finalDiffuse*baseAmbientColor+finalSpecular+reflectionColor.rgb+emissiveColor+refractionColor.rgb,0.0,1.0),alpha);\n#else\nvec4 color=vec4(finalDiffuse*baseAmbientColor+finalSpecular+reflectionColor.rgb+refractionColor.rgb,alpha);\n#endif\n#ifdef LIGHTMAP\n#ifndef LIGHTMAPEXCLUDED\n#ifdef USELIGHTMAPASSHADOWMAP\ncolor.rgb*=lightmapColor.rgb;\n#else\ncolor.rgb+=lightmapColor.rgb;\n#endif\n#endif\n#endif\n#define CUSTOM_FRAGMENT_BEFORE_FOG\ncolor.rgb=max(color.rgb,0.);\n#include<logDepthFragment>\n#include<fogFragment>\n#ifdef IMAGEPROCESSINGPOSTPROCESS\ncolor.rgb=toLinearSpace(color.rgb);\n#else\n#ifdef IMAGEPROCESSING\ncolor.rgb=toLinearSpace(color.rgb);color=applyImageProcessing(color);\n#endif\n#endif\ncolor.a*=visibility;\n#ifdef PREMULTIPLYALPHA\ncolor.rgb*=color.a;\n#endif\n#define CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR\n#ifdef PREPASS\nfloat writeGeometryInfo=color.a>0.4 ? 1.0 : 0.0;gl_FragData[0]=color; \n#ifdef PREPASS_POSITION\ngl_FragData[PREPASS_POSITION_INDEX]=vec4(vPositionW,writeGeometryInfo);\n#endif\n#ifdef PREPASS_VELOCITY\nvec2 a=(vCurrentPosition.xy/vCurrentPosition.w)*0.5+0.5;vec2 b=(vPreviousPosition.xy/vPreviousPosition.w)*0.5+0.5;vec2 velocity=abs(a-b);velocity=vec2(pow(velocity.x,1.0/3.0),pow(velocity.y,1.0/3.0))*sign(a-b)*0.5+0.5;gl_FragData[PREPASS_VELOCITY_INDEX]=vec4(velocity,0.0,writeGeometryInfo);\n#endif\n#ifdef PREPASS_IRRADIANCE\ngl_FragData[PREPASS_IRRADIANCE_INDEX]=vec4(0.0,0.0,0.0,writeGeometryInfo); \n#endif\n#ifdef PREPASS_DEPTH\ngl_FragData[PREPASS_DEPTH_INDEX]=vec4(vViewPos.z,0.0,0.0,writeGeometryInfo); \n#endif\n#ifdef PREPASS_NORMAL\n#ifdef PREPASS_NORMAL_WORLDSPACE\ngl_FragData[PREPASS_NORMAL_INDEX]=vec4(normalW,writeGeometryInfo); \n#else\ngl_FragData[PREPASS_NORMAL_INDEX]=vec4(normalize((view*vec4(normalW,0.0)).rgb),writeGeometryInfo); \n#endif\n#endif\n#ifdef PREPASS_ALBEDO_SQRT\ngl_FragData[PREPASS_ALBEDO_SQRT_INDEX]=vec4(0.0,0.0,0.0,writeGeometryInfo); \n#endif\n#ifdef PREPASS_REFLECTIVITY\n#if defined(SPECULARTERM)\n#if defined(SPECULAR)\ngl_FragData[PREPASS_REFLECTIVITY_INDEX]=vec4(toLinearSpace(specularMapColor))*writeGeometryInfo; \n#else\ngl_FragData[PREPASS_REFLECTIVITY_INDEX]=vec4(toLinearSpace(specularColor),1.0)*writeGeometryInfo;\n#endif\n#else\ngl_FragData[PREPASS_REFLECTIVITY_INDEX]=vec4(0.0,0.0,0.0,1.0)*writeGeometryInfo;\n#endif\n#endif\n#endif\n#if !defined(PREPASS) || defined(WEBGL2)\ngl_FragColor=color;\n#endif\n#include<oitFragment>\n#if ORDER_INDEPENDENT_TRANSPARENCY\nif (fragDepth==nearestDepth) {frontColor.rgb+=color.rgb*color.a*alphaMultiplier;frontColor.a=1.0-alphaMultiplier*(1.0-color.a);} else {backColor+=color;}\n#endif\n#define CUSTOM_FRAGMENT_MAIN_END\n}\n`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const defaultPixelShader = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"decalVertexDeclaration\";\nconst shader = `#ifdef DECAL\nuniform vec4 vDecalInfos;uniform mat4 decalMatrix;\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const decalVertexDeclaration = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\nimport \"./decalVertexDeclaration\";\n\nconst name = \"defaultVertexDeclaration\";\nconst shader = `uniform mat4 viewProjection;uniform mat4 view;\n#ifdef DIFFUSE\nuniform mat4 diffuseMatrix;uniform vec2 vDiffuseInfos;\n#endif\n#ifdef AMBIENT\nuniform mat4 ambientMatrix;uniform vec2 vAmbientInfos;\n#endif\n#ifdef OPACITY\nuniform mat4 opacityMatrix;uniform vec2 vOpacityInfos;\n#endif\n#ifdef EMISSIVE\nuniform vec2 vEmissiveInfos;uniform mat4 emissiveMatrix;\n#endif\n#ifdef LIGHTMAP\nuniform vec2 vLightmapInfos;uniform mat4 lightmapMatrix;\n#endif\n#if defined(SPECULAR) && defined(SPECULARTERM)\nuniform vec2 vSpecularInfos;uniform mat4 specularMatrix;\n#endif\n#ifdef BUMP\nuniform vec3 vBumpInfos;uniform mat4 bumpMatrix;\n#endif\n#ifdef REFLECTION\nuniform mat4 reflectionMatrix;\n#endif\n#ifdef POINTSIZE\nuniform float pointSize;\n#endif\n#ifdef DETAIL\nuniform vec4 vDetailInfos;uniform mat4 detailMatrix;\n#endif\n#include<decalVertexDeclaration>\n#define ADDITIONAL_VERTEX_DECLARATION\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const defaultVertexDeclaration = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"uvAttributeDeclaration\";\nconst shader = `#ifdef UV{X}\nattribute vec2 uv{X};\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const uvAttributeDeclaration = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"bonesDeclaration\";\nconst shader = `#if NUM_BONE_INFLUENCERS>0\nattribute vec4 matricesIndices;attribute vec4 matricesWeights;\n#if NUM_BONE_INFLUENCERS>4\nattribute vec4 matricesIndicesExtra;attribute vec4 matricesWeightsExtra;\n#endif\n#ifndef BAKED_VERTEX_ANIMATION_TEXTURE\n#ifdef BONETEXTURE\nuniform highp sampler2D boneSampler;uniform float boneTextureWidth;\n#else\nuniform mat4 mBones[BonesPerMesh];\n#endif\n#ifdef BONES_VELOCITY_ENABLED\nuniform mat4 mPreviousBones[BonesPerMesh];\n#endif\n#ifdef BONETEXTURE\n#define inline\nmat4 readMatrixFromRawSampler(sampler2D smp,float index)\n{float offset=index *4.0;float dx=1.0/boneTextureWidth;vec4 m0=texture2D(smp,vec2(dx*(offset+0.5),0.));vec4 m1=texture2D(smp,vec2(dx*(offset+1.5),0.));vec4 m2=texture2D(smp,vec2(dx*(offset+2.5),0.));vec4 m3=texture2D(smp,vec2(dx*(offset+3.5),0.));return mat4(m0,m1,m2,m3);}\n#endif\n#endif\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const bonesDeclaration = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"bakedVertexAnimationDeclaration\";\nconst shader = `#ifdef BAKED_VERTEX_ANIMATION_TEXTURE\nuniform float bakedVertexAnimationTime;uniform vec2 bakedVertexAnimationTextureSizeInverted;uniform vec4 bakedVertexAnimationSettings;uniform sampler2D bakedVertexAnimationTexture;\n#ifdef INSTANCES\nattribute vec4 bakedVertexAnimationSettingsInstanced;\n#endif\n#define inline\nmat4 readMatrixFromRawSamplerVAT(sampler2D smp,float index,float frame)\n{float offset=index*4.0;float frameUV=(frame+0.5)*bakedVertexAnimationTextureSizeInverted.y;float dx=bakedVertexAnimationTextureSizeInverted.x;vec4 m0=texture2D(smp,vec2(dx*(offset+0.5),frameUV));vec4 m1=texture2D(smp,vec2(dx*(offset+1.5),frameUV));vec4 m2=texture2D(smp,vec2(dx*(offset+2.5),frameUV));vec4 m3=texture2D(smp,vec2(dx*(offset+3.5),frameUV));return mat4(m0,m1,m2,m3);}\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const bakedVertexAnimationDeclaration = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"instancesDeclaration\";\nconst shader = `#ifdef INSTANCES\nattribute vec4 world0;attribute vec4 world1;attribute vec4 world2;attribute vec4 world3;\n#ifdef INSTANCESCOLOR\nattribute vec4 instanceColor;\n#endif\n#if defined(THIN_INSTANCES) && !defined(WORLD_UBO)\nuniform mat4 world;\n#endif\n#if defined(VELOCITY) || defined(PREPASS_VELOCITY)\nattribute vec4 previousWorld0;attribute vec4 previousWorld1;attribute vec4 previousWorld2;attribute vec4 previousWorld3;\n#ifdef THIN_INSTANCES\nuniform mat4 previousWorld;\n#endif\n#endif\n#else\n#if !defined(WORLD_UBO)\nuniform mat4 world;\n#endif\n#if defined(VELOCITY) || defined(PREPASS_VELOCITY)\nuniform mat4 previousWorld;\n#endif\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const instancesDeclaration = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"prePassVertexDeclaration\";\nconst shader = `#ifdef PREPASS\n#ifdef PREPASS_DEPTH\nvarying vec3 vViewPos;\n#endif\n#ifdef PREPASS_VELOCITY\nuniform mat4 previousViewProjection;varying vec4 vCurrentPosition;varying vec4 vPreviousPosition;\n#endif\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const prePassVertexDeclaration = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"samplerVertexDeclaration\";\nconst shader = `#if defined(_DEFINENAME_) && _DEFINENAME_DIRECTUV==0\nvarying vec2 v_VARYINGNAME_UV;\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const samplerVertexDeclaration = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"bumpVertexDeclaration\";\nconst shader = `#if defined(BUMP) || defined(PARALLAX) || defined(CLEARCOAT_BUMP) || defined(ANISOTROPIC)\n#if defined(TANGENT) && defined(NORMAL) \nvarying mat3 vTBN;\n#endif\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const bumpVertexDeclaration = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"clipPlaneVertexDeclaration\";\nconst shader = `#ifdef CLIPPLANE\nuniform vec4 vClipPlane;varying float fClipDistance;\n#endif\n#ifdef CLIPPLANE2\nuniform vec4 vClipPlane2;varying float fClipDistance2;\n#endif\n#ifdef CLIPPLANE3\nuniform vec4 vClipPlane3;varying float fClipDistance3;\n#endif\n#ifdef CLIPPLANE4\nuniform vec4 vClipPlane4;varying float fClipDistance4;\n#endif\n#ifdef CLIPPLANE5\nuniform vec4 vClipPlane5;varying float fClipDistance5;\n#endif\n#ifdef CLIPPLANE6\nuniform vec4 vClipPlane6;varying float fClipDistance6;\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const clipPlaneVertexDeclaration = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"fogVertexDeclaration\";\nconst shader = `#ifdef FOG\nvarying vec3 vFogDistance;\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const fogVertexDeclaration = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"lightVxFragmentDeclaration\";\nconst shader = `#ifdef LIGHT{X}\nuniform vec4 vLightData{X};uniform vec4 vLightDiffuse{X};\n#ifdef SPECULARTERM\nuniform vec4 vLightSpecular{X};\n#else\nvec4 vLightSpecular{X}=vec4(0.);\n#endif\n#ifdef SHADOW{X}\n#ifdef SHADOWCSM{X}\nuniform mat4 lightMatrix{X}[SHADOWCSMNUM_CASCADES{X}];varying vec4 vPositionFromLight{X}[SHADOWCSMNUM_CASCADES{X}];varying float vDepthMetric{X}[SHADOWCSMNUM_CASCADES{X}];varying vec4 vPositionFromCamera{X};\n#elif defined(SHADOWCUBE{X})\n#else\nvarying vec4 vPositionFromLight{X};varying float vDepthMetric{X};uniform mat4 lightMatrix{X};\n#endif\nuniform vec4 shadowsInfo{X};uniform vec2 depthValues{X};\n#endif\n#ifdef SPOTLIGHT{X}\nuniform vec4 vLightDirection{X};uniform vec4 vLightFalloff{X};\n#elif defined(POINTLIGHT{X})\nuniform vec4 vLightFalloff{X};\n#elif defined(HEMILIGHT{X})\nuniform vec3 vLightGround{X};\n#endif\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const lightVxFragmentDeclaration = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"lightVxUboDeclaration\";\nconst shader = `#ifdef LIGHT{X}\nuniform Light{X}\n{vec4 vLightData;vec4 vLightDiffuse;vec4 vLightSpecular;\n#ifdef SPOTLIGHT{X}\nvec4 vLightDirection;vec4 vLightFalloff;\n#elif defined(POINTLIGHT{X})\nvec4 vLightFalloff;\n#elif defined(HEMILIGHT{X})\nvec3 vLightGround;\n#endif\nvec4 shadowsInfo;vec2 depthValues;} light{X};\n#ifdef SHADOW{X}\n#ifdef SHADOWCSM{X}\nuniform mat4 lightMatrix{X}[SHADOWCSMNUM_CASCADES{X}];varying vec4 vPositionFromLight{X}[SHADOWCSMNUM_CASCADES{X}];varying float vDepthMetric{X}[SHADOWCSMNUM_CASCADES{X}];varying vec4 vPositionFromCamera{X};\n#elif defined(SHADOWCUBE{X})\n#else\nvarying vec4 vPositionFromLight{X};varying float vDepthMetric{X};uniform mat4 lightMatrix{X};\n#endif\n#endif\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const lightVxUboDeclaration = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"morphTargetsVertexGlobalDeclaration\";\nconst shader = `#ifdef MORPHTARGETS\nuniform float morphTargetInfluences[NUM_MORPH_INFLUENCERS];\n#ifdef MORPHTARGETS_TEXTURE \nuniform float morphTargetTextureIndices[NUM_MORPH_INFLUENCERS];uniform vec3 morphTargetTextureInfo;uniform highp sampler2DArray morphTargets;vec3 readVector3FromRawSampler(int targetIndex,float vertexIndex)\n{ \nfloat y=floor(vertexIndex/morphTargetTextureInfo.y);float x=vertexIndex-y*morphTargetTextureInfo.y;vec3 textureUV=vec3((x+0.5)/morphTargetTextureInfo.y,(y+0.5)/morphTargetTextureInfo.z,morphTargetTextureIndices[targetIndex]);return texture(morphTargets,textureUV).xyz;}\n#endif\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const morphTargetsVertexGlobalDeclaration = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"morphTargetsVertexDeclaration\";\nconst shader = `#ifdef MORPHTARGETS\n#ifndef MORPHTARGETS_TEXTURE\nattribute vec3 position{X};\n#ifdef MORPHTARGETS_NORMAL\nattribute vec3 normal{X};\n#endif\n#ifdef MORPHTARGETS_TANGENT\nattribute vec3 tangent{X};\n#endif\n#ifdef MORPHTARGETS_UV\nattribute vec2 uv_{X};\n#endif\n#elif {X}==0\nuniform int morphTargetCount;\n#endif\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const morphTargetsVertexDeclaration = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"morphTargetsVertexGlobal\";\nconst shader = `#ifdef MORPHTARGETS\n#ifdef MORPHTARGETS_TEXTURE\nfloat vertexID;\n#endif\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const morphTargetsVertexGlobal = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"morphTargetsVertex\";\nconst shader = `#ifdef MORPHTARGETS\n#ifdef MORPHTARGETS_TEXTURE\n#if {X}==0\nfor (int i=0; i<NUM_MORPH_INFLUENCERS; i++) {if (i>=morphTargetCount) break;vertexID=float(gl_VertexID)*morphTargetTextureInfo.x;positionUpdated+=(readVector3FromRawSampler(i,vertexID)-position)*morphTargetInfluences[i];vertexID+=1.0;\n#ifdef MORPHTARGETS_NORMAL\nnormalUpdated+=(readVector3FromRawSampler(i,vertexID) -normal)*morphTargetInfluences[i];vertexID+=1.0;\n#endif\n#ifdef MORPHTARGETS_UV\nuvUpdated+=(readVector3FromRawSampler(i,vertexID).xy-uv)*morphTargetInfluences[i];vertexID+=1.0;\n#endif\n#ifdef MORPHTARGETS_TANGENT\ntangentUpdated.xyz+=(readVector3FromRawSampler(i,vertexID) -tangent.xyz)*morphTargetInfluences[i];\n#endif\n}\n#endif\n#else\npositionUpdated+=(position{X}-position)*morphTargetInfluences[{X}];\n#ifdef MORPHTARGETS_NORMAL\nnormalUpdated+=(normal{X}-normal)*morphTargetInfluences[{X}];\n#endif\n#ifdef MORPHTARGETS_TANGENT\ntangentUpdated.xyz+=(tangent{X}-tangent.xyz)*morphTargetInfluences[{X}];\n#endif\n#ifdef MORPHTARGETS_UV\nuvUpdated+=(uv_{X}-uv)*morphTargetInfluences[{X}];\n#endif\n#endif\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const morphTargetsVertex = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"instancesVertex\";\nconst shader = `#ifdef INSTANCES\nmat4 finalWorld=mat4(world0,world1,world2,world3);\n#if defined(PREPASS_VELOCITY) || defined(VELOCITY)\nmat4 finalPreviousWorld=mat4(previousWorld0,previousWorld1,previousWorld2,previousWorld3);\n#endif\n#ifdef THIN_INSTANCES\nfinalWorld=world*finalWorld;\n#if defined(PREPASS_VELOCITY) || defined(VELOCITY)\nfinalPreviousWorld=previousWorld*finalPreviousWorld;\n#endif\n#endif\n#else\nmat4 finalWorld=world;\n#if defined(PREPASS_VELOCITY) || defined(VELOCITY)\nmat4 finalPreviousWorld=previousWorld;\n#endif\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const instancesVertex = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"bonesVertex\";\nconst shader = `#ifndef BAKED_VERTEX_ANIMATION_TEXTURE\n#if NUM_BONE_INFLUENCERS>0\nmat4 influence;\n#ifdef BONETEXTURE\ninfluence=readMatrixFromRawSampler(boneSampler,matricesIndices[0])*matricesWeights[0];\n#if NUM_BONE_INFLUENCERS>1\ninfluence+=readMatrixFromRawSampler(boneSampler,matricesIndices[1])*matricesWeights[1];\n#endif\n#if NUM_BONE_INFLUENCERS>2\ninfluence+=readMatrixFromRawSampler(boneSampler,matricesIndices[2])*matricesWeights[2];\n#endif\n#if NUM_BONE_INFLUENCERS>3\ninfluence+=readMatrixFromRawSampler(boneSampler,matricesIndices[3])*matricesWeights[3];\n#endif\n#if NUM_BONE_INFLUENCERS>4\ninfluence+=readMatrixFromRawSampler(boneSampler,matricesIndicesExtra[0])*matricesWeightsExtra[0];\n#endif\n#if NUM_BONE_INFLUENCERS>5\ninfluence+=readMatrixFromRawSampler(boneSampler,matricesIndicesExtra[1])*matricesWeightsExtra[1];\n#endif\n#if NUM_BONE_INFLUENCERS>6\ninfluence+=readMatrixFromRawSampler(boneSampler,matricesIndicesExtra[2])*matricesWeightsExtra[2];\n#endif\n#if NUM_BONE_INFLUENCERS>7\ninfluence+=readMatrixFromRawSampler(boneSampler,matricesIndicesExtra[3])*matricesWeightsExtra[3];\n#endif\n#else\ninfluence=mBones[int(matricesIndices[0])]*matricesWeights[0];\n#if NUM_BONE_INFLUENCERS>1\ninfluence+=mBones[int(matricesIndices[1])]*matricesWeights[1];\n#endif\n#if NUM_BONE_INFLUENCERS>2\ninfluence+=mBones[int(matricesIndices[2])]*matricesWeights[2];\n#endif\n#if NUM_BONE_INFLUENCERS>3\ninfluence+=mBones[int(matricesIndices[3])]*matricesWeights[3];\n#endif\n#if NUM_BONE_INFLUENCERS>4\ninfluence+=mBones[int(matricesIndicesExtra[0])]*matricesWeightsExtra[0];\n#endif\n#if NUM_BONE_INFLUENCERS>5\ninfluence+=mBones[int(matricesIndicesExtra[1])]*matricesWeightsExtra[1];\n#endif\n#if NUM_BONE_INFLUENCERS>6\ninfluence+=mBones[int(matricesIndicesExtra[2])]*matricesWeightsExtra[2];\n#endif\n#if NUM_BONE_INFLUENCERS>7\ninfluence+=mBones[int(matricesIndicesExtra[3])]*matricesWeightsExtra[3];\n#endif\n#endif\nfinalWorld=finalWorld*influence;\n#endif\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const bonesVertex = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"bakedVertexAnimation\";\nconst shader = `#ifdef BAKED_VERTEX_ANIMATION_TEXTURE\n{\n#ifdef INSTANCES\n#define BVASNAME bakedVertexAnimationSettingsInstanced\n#else\n#define BVASNAME bakedVertexAnimationSettings\n#endif\nfloat VATStartFrame=BVASNAME.x;float VATEndFrame=BVASNAME.y;float VATOffsetFrame=BVASNAME.z;float VATSpeed=BVASNAME.w;float totalFrames=VATEndFrame-VATStartFrame+1.0;float time=bakedVertexAnimationTime*VATSpeed/totalFrames;float frameCorrection=time<1.0 ? 0.0 : 1.0;float numOfFrames=totalFrames-frameCorrection;float VATFrameNum=fract(time)*numOfFrames;VATFrameNum=mod(VATFrameNum+VATOffsetFrame,numOfFrames);VATFrameNum=floor(VATFrameNum);VATFrameNum+=VATStartFrame+frameCorrection;mat4 VATInfluence;VATInfluence=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndices[0],VATFrameNum)*matricesWeights[0];\n#if NUM_BONE_INFLUENCERS>1\nVATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndices[1],VATFrameNum)*matricesWeights[1];\n#endif\n#if NUM_BONE_INFLUENCERS>2\nVATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndices[2],VATFrameNum)*matricesWeights[2];\n#endif\n#if NUM_BONE_INFLUENCERS>3\nVATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndices[3],VATFrameNum)*matricesWeights[3];\n#endif\n#if NUM_BONE_INFLUENCERS>4\nVATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndicesExtra[0],VATFrameNum)*matricesWeightsExtra[0];\n#endif\n#if NUM_BONE_INFLUENCERS>5\nVATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndicesExtra[1],VATFrameNum)*matricesWeightsExtra[1];\n#endif\n#if NUM_BONE_INFLUENCERS>6\nVATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndicesExtra[2],VATFrameNum)*matricesWeightsExtra[2];\n#endif\n#if NUM_BONE_INFLUENCERS>7\nVATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndicesExtra[3],VATFrameNum)*matricesWeightsExtra[3];\n#endif\nfinalWorld=finalWorld*VATInfluence;}\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const bakedVertexAnimation = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"prePassVertex\";\nconst shader = `#ifdef PREPASS_DEPTH\nvViewPos=(view*worldPos).rgb;\n#endif\n#if defined(PREPASS_VELOCITY) && defined(BONES_VELOCITY_ENABLED)\nvCurrentPosition=viewProjection*worldPos;\n#if NUM_BONE_INFLUENCERS>0\nmat4 previousInfluence;previousInfluence=mPreviousBones[int(matricesIndices[0])]*matricesWeights[0];\n#if NUM_BONE_INFLUENCERS>1\npreviousInfluence+=mPreviousBones[int(matricesIndices[1])]*matricesWeights[1];\n#endif \n#if NUM_BONE_INFLUENCERS>2\npreviousInfluence+=mPreviousBones[int(matricesIndices[2])]*matricesWeights[2];\n#endif \n#if NUM_BONE_INFLUENCERS>3\npreviousInfluence+=mPreviousBones[int(matricesIndices[3])]*matricesWeights[3];\n#endif\n#if NUM_BONE_INFLUENCERS>4\npreviousInfluence+=mPreviousBones[int(matricesIndicesExtra[0])]*matricesWeightsExtra[0];\n#endif \n#if NUM_BONE_INFLUENCERS>5\npreviousInfluence+=mPreviousBones[int(matricesIndicesExtra[1])]*matricesWeightsExtra[1];\n#endif \n#if NUM_BONE_INFLUENCERS>6\npreviousInfluence+=mPreviousBones[int(matricesIndicesExtra[2])]*matricesWeightsExtra[2];\n#endif \n#if NUM_BONE_INFLUENCERS>7\npreviousInfluence+=mPreviousBones[int(matricesIndicesExtra[3])]*matricesWeightsExtra[3];\n#endif\nvPreviousPosition=previousViewProjection*finalPreviousWorld*previousInfluence*vec4(positionUpdated,1.0);\n#else\nvPreviousPosition=previousViewProjection*finalPreviousWorld*vec4(positionUpdated,1.0);\n#endif\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const prePassVertex = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"uvVariableDeclaration\";\nconst shader = `#if !defined(UV{X}) && defined(MAINUV{X})\nvec2 uv{X}=vec2(0.,0.);\n#endif\n#ifdef MAINUV{X}\nvMainUV{X}=uv{X};\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const uvVariableDeclaration = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"samplerVertexImplementation\";\nconst shader = `#if defined(_DEFINENAME_) && _DEFINENAME_DIRECTUV==0\nif (v_INFONAME_==0.)\n{v_VARYINGNAME_UV=vec2(_MATRIXNAME_Matrix*vec4(uvUpdated,1.0,0.0));}\n#ifdef UV2\nelse if (v_INFONAME_==1.)\n{v_VARYINGNAME_UV=vec2(_MATRIXNAME_Matrix*vec4(uv2,1.0,0.0));}\n#endif\n#ifdef UV3\nelse if (v_INFONAME_==2.)\n{v_VARYINGNAME_UV=vec2(_MATRIXNAME_Matrix*vec4(uv3,1.0,0.0));}\n#endif\n#ifdef UV4\nelse if (v_INFONAME_==3.)\n{v_VARYINGNAME_UV=vec2(_MATRIXNAME_Matrix*vec4(uv4,1.0,0.0));}\n#endif\n#ifdef UV5\nelse if (v_INFONAME_==4.)\n{v_VARYINGNAME_UV=vec2(_MATRIXNAME_Matrix*vec4(uv5,1.0,0.0));}\n#endif\n#ifdef UV6\nelse if (v_INFONAME_==5.)\n{v_VARYINGNAME_UV=vec2(_MATRIXNAME_Matrix*vec4(uv6,1.0,0.0));}\n#endif\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const samplerVertexImplementation = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"bumpVertex\";\nconst shader = `#if defined(BUMP) || defined(PARALLAX) || defined(CLEARCOAT_BUMP) || defined(ANISOTROPIC)\n#if defined(TANGENT) && defined(NORMAL)\nvec3 tbnNormal=normalize(normalUpdated);vec3 tbnTangent=normalize(tangentUpdated.xyz);vec3 tbnBitangent=cross(tbnNormal,tbnTangent)*tangentUpdated.w;vTBN=mat3(finalWorld)*mat3(tbnTangent,tbnBitangent,tbnNormal);\n#endif\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const bumpVertex = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"clipPlaneVertex\";\nconst shader = `#ifdef CLIPPLANE\nfClipDistance=dot(worldPos,vClipPlane);\n#endif\n#ifdef CLIPPLANE2\nfClipDistance2=dot(worldPos,vClipPlane2);\n#endif\n#ifdef CLIPPLANE3\nfClipDistance3=dot(worldPos,vClipPlane3);\n#endif\n#ifdef CLIPPLANE4\nfClipDistance4=dot(worldPos,vClipPlane4);\n#endif\n#ifdef CLIPPLANE5\nfClipDistance5=dot(worldPos,vClipPlane5);\n#endif\n#ifdef CLIPPLANE6\nfClipDistance6=dot(worldPos,vClipPlane6);\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const clipPlaneVertex = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"fogVertex\";\nconst shader = `#ifdef FOG\nvFogDistance=(view*worldPos).xyz;\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const fogVertex = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"shadowsVertex\";\nconst shader = `#ifdef SHADOWS\n#if defined(SHADOWCSM{X})\nvPositionFromCamera{X}=view*worldPos;for (int i=0; i<SHADOWCSMNUM_CASCADES{X}; i++) {vPositionFromLight{X}[i]=lightMatrix{X}[i]*worldPos;\n#ifdef USE_REVERSE_DEPTHBUFFER\nvDepthMetric{X}[i]=(-vPositionFromLight{X}[i].z+light{X}.depthValues.x)/light{X}.depthValues.y;\n#else\nvDepthMetric{X}[i]=(vPositionFromLight{X}[i].z+light{X}.depthValues.x)/light{X}.depthValues.y;\n#endif\n}\n#elif defined(SHADOW{X}) && !defined(SHADOWCUBE{X})\nvPositionFromLight{X}=lightMatrix{X}*worldPos;\n#ifdef USE_REVERSE_DEPTHBUFFER\nvDepthMetric{X}=(-vPositionFromLight{X}.z+light{X}.depthValues.x)/light{X}.depthValues.y;\n#else\nvDepthMetric{X}=(vPositionFromLight{X}.z+light{X}.depthValues.x)/light{X}.depthValues.y;\n#endif\n#endif\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const shadowsVertex = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"vertexColorMixing\";\nconst shader = `#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nvColor=vec4(1.0);\n#ifdef VERTEXCOLOR\n#ifdef VERTEXALPHA\nvColor*=color;\n#else\nvColor.rgb*=color.rgb;\n#endif\n#endif\n#ifdef INSTANCESCOLOR\nvColor*=instanceColor;\n#endif\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const vertexColorMixing = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"pointCloudVertex\";\nconst shader = `#if defined(POINTSIZE) && !defined(WEBGPU)\ngl_PointSize=pointSize;\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const pointCloudVertex = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"logDepthVertex\";\nconst shader = `#ifdef LOGARITHMICDEPTH\nvFragmentDepth=1.0+gl_Position.w;gl_Position.z=log2(max(0.000001,vFragmentDepth))*logarithmicDepthConstant;\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const logDepthVertex = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/defaultVertexDeclaration\";\nimport \"./ShadersInclude/defaultUboDeclaration\";\nimport \"./ShadersInclude/uvAttributeDeclaration\";\nimport \"./ShadersInclude/helperFunctions\";\nimport \"./ShadersInclude/bonesDeclaration\";\nimport \"./ShadersInclude/bakedVertexAnimationDeclaration\";\nimport \"./ShadersInclude/instancesDeclaration\";\nimport \"./ShadersInclude/prePassVertexDeclaration\";\nimport \"./ShadersInclude/mainUVVaryingDeclaration\";\nimport \"./ShadersInclude/samplerVertexDeclaration\";\nimport \"./ShadersInclude/bumpVertexDeclaration\";\nimport \"./ShadersInclude/clipPlaneVertexDeclaration\";\nimport \"./ShadersInclude/fogVertexDeclaration\";\nimport \"./ShadersInclude/lightVxFragmentDeclaration\";\nimport \"./ShadersInclude/lightVxUboDeclaration\";\nimport \"./ShadersInclude/morphTargetsVertexGlobalDeclaration\";\nimport \"./ShadersInclude/morphTargetsVertexDeclaration\";\nimport \"./ShadersInclude/logDepthDeclaration\";\nimport \"./ShadersInclude/morphTargetsVertexGlobal\";\nimport \"./ShadersInclude/morphTargetsVertex\";\nimport \"./ShadersInclude/instancesVertex\";\nimport \"./ShadersInclude/bonesVertex\";\nimport \"./ShadersInclude/bakedVertexAnimation\";\nimport \"./ShadersInclude/prePassVertex\";\nimport \"./ShadersInclude/uvVariableDeclaration\";\nimport \"./ShadersInclude/samplerVertexImplementation\";\nimport \"./ShadersInclude/bumpVertex\";\nimport \"./ShadersInclude/clipPlaneVertex\";\nimport \"./ShadersInclude/fogVertex\";\nimport \"./ShadersInclude/shadowsVertex\";\nimport \"./ShadersInclude/vertexColorMixing\";\nimport \"./ShadersInclude/pointCloudVertex\";\nimport \"./ShadersInclude/logDepthVertex\";\n\nconst name = \"defaultVertexShader\";\nconst shader = `#include<__decl__defaultVertex>\n#define CUSTOM_VERTEX_BEGIN\nattribute vec3 position;\n#ifdef NORMAL\nattribute vec3 normal;\n#endif\n#ifdef TANGENT\nattribute vec4 tangent;\n#endif\n#ifdef UV1\nattribute vec2 uv;\n#endif\n#include<uvAttributeDeclaration>[2..7]\n#ifdef VERTEXCOLOR\nattribute vec4 color;\n#endif\n#include<helperFunctions>\n#include<bonesDeclaration>\n#include<bakedVertexAnimationDeclaration>\n#include<instancesDeclaration>\n#include<prePassVertexDeclaration>\n#include<mainUVVaryingDeclaration>[1..7]\n#include<samplerVertexDeclaration>(_DEFINENAME_,DIFFUSE,_VARYINGNAME_,Diffuse)\n#include<samplerVertexDeclaration>(_DEFINENAME_,DETAIL,_VARYINGNAME_,Detail)\n#include<samplerVertexDeclaration>(_DEFINENAME_,AMBIENT,_VARYINGNAME_,Ambient)\n#include<samplerVertexDeclaration>(_DEFINENAME_,OPACITY,_VARYINGNAME_,Opacity)\n#include<samplerVertexDeclaration>(_DEFINENAME_,EMISSIVE,_VARYINGNAME_,Emissive)\n#include<samplerVertexDeclaration>(_DEFINENAME_,LIGHTMAP,_VARYINGNAME_,Lightmap)\n#if defined(SPECULARTERM)\n#include<samplerVertexDeclaration>(_DEFINENAME_,SPECULAR,_VARYINGNAME_,Specular)\n#endif\n#include<samplerVertexDeclaration>(_DEFINENAME_,BUMP,_VARYINGNAME_,Bump)\n#include<samplerVertexDeclaration>(_DEFINENAME_,DECAL,_VARYINGNAME_,Decal)\nvarying vec3 vPositionW;\n#ifdef NORMAL\nvarying vec3 vNormalW;\n#endif\n#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nvarying vec4 vColor;\n#endif\n#include<bumpVertexDeclaration>\n#include<clipPlaneVertexDeclaration>\n#include<fogVertexDeclaration>\n#include<__decl__lightVxFragment>[0..maxSimultaneousLights]\n#include<morphTargetsVertexGlobalDeclaration>\n#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]\n#ifdef REFLECTIONMAP_SKYBOX\nvarying vec3 vPositionUVW;\n#endif\n#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)\nvarying vec3 vDirectionW;\n#endif\n#include<logDepthDeclaration>\n#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_VERTEX_MAIN_BEGIN\nvec3 positionUpdated=position;\n#ifdef NORMAL\nvec3 normalUpdated=normal;\n#endif\n#ifdef TANGENT\nvec4 tangentUpdated=tangent;\n#endif\n#ifdef UV1\nvec2 uvUpdated=uv;\n#endif\n#include<morphTargetsVertexGlobal>\n#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]\n#ifdef REFLECTIONMAP_SKYBOX\nvPositionUVW=positionUpdated;\n#endif\n#define CUSTOM_VERTEX_UPDATE_POSITION\n#define CUSTOM_VERTEX_UPDATE_NORMAL\n#include<instancesVertex>\n#if defined(PREPASS) && defined(PREPASS_VELOCITY) && !defined(BONES_VELOCITY_ENABLED)\nvCurrentPosition=viewProjection*finalWorld*vec4(positionUpdated,1.0);vPreviousPosition=previousViewProjection*finalPreviousWorld*vec4(positionUpdated,1.0);\n#endif\n#include<bonesVertex>\n#include<bakedVertexAnimation>\nvec4 worldPos=finalWorld*vec4(positionUpdated,1.0);\n#ifdef NORMAL\nmat3 normalWorld=mat3(finalWorld);\n#if defined(INSTANCES) && defined(THIN_INSTANCES)\nvNormalW=normalUpdated/vec3(dot(normalWorld[0],normalWorld[0]),dot(normalWorld[1],normalWorld[1]),dot(normalWorld[2],normalWorld[2]));vNormalW=normalize(normalWorld*vNormalW);\n#else\n#ifdef NONUNIFORMSCALING\nnormalWorld=transposeMat3(inverseMat3(normalWorld));\n#endif\nvNormalW=normalize(normalWorld*normalUpdated);\n#endif\n#endif\n#define CUSTOM_VERTEX_UPDATE_WORLDPOS\n#ifdef MULTIVIEW\nif (gl_ViewID_OVR==0u) {gl_Position=viewProjection*worldPos;} else {gl_Position=viewProjectionR*worldPos;}\n#else\ngl_Position=viewProjection*worldPos;\n#endif\nvPositionW=vec3(worldPos);\n#include<prePassVertex>\n#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)\nvDirectionW=normalize(vec3(finalWorld*vec4(positionUpdated,0.0)));\n#endif\n#ifndef UV1\nvec2 uvUpdated=vec2(0.,0.);\n#endif\n#ifdef MAINUV1\nvMainUV1=uvUpdated;\n#endif\n#include<uvVariableDeclaration>[2..7]\n#include<samplerVertexImplementation>(_DEFINENAME_,DIFFUSE,_VARYINGNAME_,Diffuse,_MATRIXNAME_,diffuse,_INFONAME_,DiffuseInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,DETAIL,_VARYINGNAME_,Detail,_MATRIXNAME_,detail,_INFONAME_,DetailInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,AMBIENT,_VARYINGNAME_,Ambient,_MATRIXNAME_,ambient,_INFONAME_,AmbientInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,OPACITY,_VARYINGNAME_,Opacity,_MATRIXNAME_,opacity,_INFONAME_,OpacityInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,EMISSIVE,_VARYINGNAME_,Emissive,_MATRIXNAME_,emissive,_INFONAME_,EmissiveInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,LIGHTMAP,_VARYINGNAME_,Lightmap,_MATRIXNAME_,lightmap,_INFONAME_,LightmapInfos.x)\n#if defined(SPECULARTERM)\n#include<samplerVertexImplementation>(_DEFINENAME_,SPECULAR,_VARYINGNAME_,Specular,_MATRIXNAME_,specular,_INFONAME_,SpecularInfos.x)\n#endif\n#include<samplerVertexImplementation>(_DEFINENAME_,BUMP,_VARYINGNAME_,Bump,_MATRIXNAME_,bump,_INFONAME_,BumpInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,DECAL,_VARYINGNAME_,Decal,_MATRIXNAME_,decal,_INFONAME_,DecalInfos.x)\n#include<bumpVertex>\n#include<clipPlaneVertex>\n#include<fogVertex>\n#include<shadowsVertex>[0..maxSimultaneousLights]\n#include<vertexColorMixing>\n#include<pointCloudVertex>\n#include<logDepthVertex>\n#define CUSTOM_VERTEX_MAIN_END\n}\n`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const defaultVertexShader = { name, shader };\n", "import type { Nullable } from \"../types\";\r\nimport type { IEffectFallbacks } from \"./iEffectFallbacks\";\r\n\r\nimport type { Effect } from \"./effect\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\n\r\n/**\r\n * EffectFallbacks can be used to add fallbacks (properties to disable) to certain properties when desired to improve performance.\r\n * (Eg. Start at high quality with reflection and fog, if fps is low, remove reflection, if still low remove fog)\r\n */\r\nexport class EffectFallbacks implements IEffectFallbacks {\r\n    private _defines: { [key: string]: Array<String> } = {};\r\n\r\n    private _currentRank = 32;\r\n    private _maxRank = -1;\r\n\r\n    private _mesh: Nullable<AbstractMesh> = null;\r\n\r\n    /**\r\n     * Removes the fallback from the bound mesh.\r\n     */\r\n    public unBindMesh() {\r\n        this._mesh = null;\r\n    }\r\n\r\n    /**\r\n     * Adds a fallback on the specified property.\r\n     * @param rank The rank of the fallback (Lower ranks will be fallbacked to first)\r\n     * @param define The name of the define in the shader\r\n     */\r\n    public addFallback(rank: number, define: string): void {\r\n        if (!this._defines[rank]) {\r\n            if (rank < this._currentRank) {\r\n                this._currentRank = rank;\r\n            }\r\n\r\n            if (rank > this._maxRank) {\r\n                this._maxRank = rank;\r\n            }\r\n\r\n            this._defines[rank] = new Array<String>();\r\n        }\r\n\r\n        this._defines[rank].push(define);\r\n    }\r\n\r\n    /**\r\n     * Sets the mesh to use CPU skinning when needing to fallback.\r\n     * @param rank The rank of the fallback (Lower ranks will be fallbacked to first)\r\n     * @param mesh The mesh to use the fallbacks.\r\n     */\r\n    public addCPUSkinningFallback(rank: number, mesh: AbstractMesh) {\r\n        this._mesh = mesh;\r\n\r\n        if (rank < this._currentRank) {\r\n            this._currentRank = rank;\r\n        }\r\n        if (rank > this._maxRank) {\r\n            this._maxRank = rank;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Checks to see if more fallbacks are still available.\r\n     */\r\n    public get hasMoreFallbacks(): boolean {\r\n        return this._currentRank <= this._maxRank;\r\n    }\r\n\r\n    /**\r\n     * Removes the defines that should be removed when falling back.\r\n     * @param currentDefines defines the current define statements for the shader.\r\n     * @param effect defines the current effect we try to compile\r\n     * @returns The resulting defines with defines of the current rank removed.\r\n     */\r\n    public reduce(currentDefines: string, effect: Effect): string {\r\n        // First we try to switch to CPU skinning\r\n        if (this._mesh && this._mesh.computeBonesUsingShaders && this._mesh.numBoneInfluencers > 0) {\r\n            this._mesh.computeBonesUsingShaders = false;\r\n            currentDefines = currentDefines.replace(\"#define NUM_BONE_INFLUENCERS \" + this._mesh.numBoneInfluencers, \"#define NUM_BONE_INFLUENCERS 0\");\r\n            effect._bonesComputationForcedToCPU = true;\r\n\r\n            const scene = this._mesh.getScene();\r\n            for (let index = 0; index < scene.meshes.length; index++) {\r\n                const otherMesh = scene.meshes[index];\r\n\r\n                if (!otherMesh.material) {\r\n                    if (!this._mesh.material && otherMesh.computeBonesUsingShaders && otherMesh.numBoneInfluencers > 0) {\r\n                        otherMesh.computeBonesUsingShaders = false;\r\n                    }\r\n                    continue;\r\n                }\r\n\r\n                if (!otherMesh.computeBonesUsingShaders || otherMesh.numBoneInfluencers === 0) {\r\n                    continue;\r\n                }\r\n\r\n                if (otherMesh.material.getEffect() === effect) {\r\n                    otherMesh.computeBonesUsingShaders = false;\r\n                } else if (otherMesh.subMeshes) {\r\n                    for (const subMesh of otherMesh.subMeshes) {\r\n                        const subMeshEffect = subMesh.effect;\r\n\r\n                        if (subMeshEffect === effect) {\r\n                            otherMesh.computeBonesUsingShaders = false;\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            const currentFallbacks = this._defines[this._currentRank];\r\n            if (currentFallbacks) {\r\n                for (let index = 0; index < currentFallbacks.length; index++) {\r\n                    currentDefines = currentDefines.replace(\"#define \" + currentFallbacks[index], \"\");\r\n                }\r\n            }\r\n\r\n            this._currentRank++;\r\n        }\r\n\r\n        return currentDefines;\r\n    }\r\n}\r\n", "/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Nullable } from \"../types\";\r\nimport { Material } from \"./material\";\r\nimport { serialize, expandToProperty, serializeAsTexture } from \"../Misc/decorators\";\r\nimport { MaterialFlags } from \"./materialFlags\";\r\nimport type { BaseTexture } from \"./Textures/baseTexture\";\r\nimport type { UniformBuffer } from \"./uniformBuffer\";\r\nimport type { IAnimatable } from \"../Animations/animatable.interface\";\r\nimport { MaterialDefines } from \"./materialDefines\";\r\nimport { MaterialPluginBase } from \"./materialPluginBase\";\r\nimport { Constants } from \"../Engines/constants\";\r\n\r\nimport type { Engine } from \"../Engines/engine\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { StandardMaterial } from \"./standardMaterial\";\r\nimport type { PBRBaseMaterial } from \"./PBR/pbrBaseMaterial\";\r\nimport { BindTextureMatrix, PrepareDefinesForMergedUV } from \"./materialHelper.functions\";\r\n\r\n/**\r\n * @internal\r\n */\r\nexport class MaterialDetailMapDefines extends MaterialDefines {\r\n    DETAIL = false;\r\n    DETAILDIRECTUV = 0;\r\n    DETAIL_NORMALBLENDMETHOD = 0;\r\n}\r\n\r\n/**\r\n * Plugin that implements the detail map component of a material\r\n *\r\n * Inspired from:\r\n *   Unity: https://docs.unity3d.com/Packages/com.unity.render-pipelines.high-definition@9.0/manual/Mask-Map-and-Detail-Map.html and https://docs.unity3d.com/Manual/StandardShaderMaterialParameterDetail.html\r\n *   Unreal: https://docs.unrealengine.com/en-US/Engine/Rendering/Materials/HowTo/DetailTexturing/index.html\r\n *   Cryengine: https://docs.cryengine.com/display/SDKDOC2/Detail+Maps\r\n */\r\nexport class DetailMapConfiguration extends MaterialPluginBase {\r\n    private _texture: Nullable<BaseTexture> = null;\r\n    /**\r\n     * The detail texture of the material.\r\n     */\r\n    @serializeAsTexture(\"detailTexture\")\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public texture: Nullable<BaseTexture>;\r\n\r\n    /**\r\n     * Defines how strongly the detail diffuse/albedo channel is blended with the regular diffuse/albedo texture\r\n     * Bigger values mean stronger blending\r\n     */\r\n    @serialize()\r\n    public diffuseBlendLevel = 1;\r\n\r\n    /**\r\n     * Defines how strongly the detail roughness channel is blended with the regular roughness value\r\n     * Bigger values mean stronger blending. Only used with PBR materials\r\n     */\r\n    @serialize()\r\n    public roughnessBlendLevel = 1;\r\n\r\n    /**\r\n     * Defines how strong the bump effect from the detail map is\r\n     * Bigger values mean stronger effect\r\n     */\r\n    @serialize()\r\n    public bumpLevel = 1;\r\n\r\n    private _normalBlendMethod = Material.MATERIAL_NORMALBLENDMETHOD_WHITEOUT;\r\n    /**\r\n     * The method used to blend the bump and detail normals together\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public normalBlendMethod: number;\r\n\r\n    private _isEnabled = false;\r\n    /**\r\n     * Enable or disable the detail map on this material\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public isEnabled = false;\r\n\r\n    /** @internal */\r\n    private _internalMarkAllSubMeshesAsTexturesDirty: () => void;\r\n\r\n    /** @internal */\r\n    public _markAllSubMeshesAsTexturesDirty(): void {\r\n        this._enable(this._isEnabled);\r\n        this._internalMarkAllSubMeshesAsTexturesDirty();\r\n    }\r\n\r\n    constructor(material: PBRBaseMaterial | StandardMaterial, addToPluginList = true) {\r\n        super(material, \"DetailMap\", 140, new MaterialDetailMapDefines(), addToPluginList);\r\n\r\n        this._internalMarkAllSubMeshesAsTexturesDirty = material._dirtyCallbacks[Constants.MATERIAL_TextureDirtyFlag];\r\n    }\r\n\r\n    public isReadyForSubMesh(defines: MaterialDetailMapDefines, scene: Scene, engine: Engine): boolean {\r\n        if (!this._isEnabled) {\r\n            return true;\r\n        }\r\n\r\n        if (defines._areTexturesDirty && scene.texturesEnabled) {\r\n            if (engine.getCaps().standardDerivatives && this._texture && MaterialFlags.DetailTextureEnabled) {\r\n                // Detail texture cannot be not blocking.\r\n                if (!this._texture.isReady()) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    public prepareDefines(defines: MaterialDetailMapDefines, scene: Scene): void {\r\n        if (this._isEnabled) {\r\n            defines.DETAIL_NORMALBLENDMETHOD = this._normalBlendMethod;\r\n\r\n            const engine = scene.getEngine();\r\n\r\n            if (defines._areTexturesDirty) {\r\n                if (engine.getCaps().standardDerivatives && this._texture && MaterialFlags.DetailTextureEnabled && this._isEnabled) {\r\n                    PrepareDefinesForMergedUV(this._texture, defines, \"DETAIL\");\r\n                    defines.DETAIL_NORMALBLENDMETHOD = this._normalBlendMethod;\r\n                } else {\r\n                    defines.DETAIL = false;\r\n                }\r\n            }\r\n        } else {\r\n            defines.DETAIL = false;\r\n        }\r\n    }\r\n\r\n    public bindForSubMesh(uniformBuffer: UniformBuffer, scene: Scene): void {\r\n        if (!this._isEnabled) {\r\n            return;\r\n        }\r\n\r\n        const isFrozen = this._material.isFrozen;\r\n\r\n        if (!uniformBuffer.useUbo || !isFrozen || !uniformBuffer.isSync) {\r\n            if (this._texture && MaterialFlags.DetailTextureEnabled) {\r\n                uniformBuffer.updateFloat4(\"vDetailInfos\", this._texture.coordinatesIndex, this.diffuseBlendLevel, this.bumpLevel, this.roughnessBlendLevel);\r\n                BindTextureMatrix(this._texture, uniformBuffer, \"detail\");\r\n            }\r\n        }\r\n\r\n        // Textures\r\n        if (scene.texturesEnabled) {\r\n            if (this._texture && MaterialFlags.DetailTextureEnabled) {\r\n                uniformBuffer.setTexture(\"detailSampler\", this._texture);\r\n            }\r\n        }\r\n    }\r\n\r\n    public hasTexture(texture: BaseTexture): boolean {\r\n        if (this._texture === texture) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    public getActiveTextures(activeTextures: BaseTexture[]): void {\r\n        if (this._texture) {\r\n            activeTextures.push(this._texture);\r\n        }\r\n    }\r\n\r\n    public getAnimatables(animatables: IAnimatable[]): void {\r\n        if (this._texture && this._texture.animations && this._texture.animations.length > 0) {\r\n            animatables.push(this._texture);\r\n        }\r\n    }\r\n\r\n    public dispose(forceDisposeTextures?: boolean): void {\r\n        if (forceDisposeTextures) {\r\n            this._texture?.dispose();\r\n        }\r\n    }\r\n\r\n    public getClassName(): string {\r\n        return \"DetailMapConfiguration\";\r\n    }\r\n\r\n    public getSamplers(samplers: string[]): void {\r\n        samplers.push(\"detailSampler\");\r\n    }\r\n\r\n    public getUniforms(): { ubo?: Array<{ name: string; size: number; type: string }>; vertex?: string; fragment?: string } {\r\n        return {\r\n            ubo: [\r\n                { name: \"vDetailInfos\", size: 4, type: \"vec4\" },\r\n                { name: \"detailMatrix\", size: 16, type: \"mat4\" },\r\n            ],\r\n        };\r\n    }\r\n}\r\n", "/* eslint-disable @typescript-eslint/naming-convention */\r\nimport { serialize, serializeAsColor3, expandToProperty, serializeAsFresnelParameters, serializeAsTexture } from \"../Misc/decorators\";\r\nimport type { Observer } from \"../Misc/observable\";\r\nimport { SmartArray } from \"../Misc/smartArray\";\r\nimport type { IAnimatable } from \"../Animations/animatable.interface\";\r\n\r\nimport type { Nullable } from \"../types\";\r\nimport { Scene } from \"../scene\";\r\nimport { Matrix } from \"../Maths/math.vector\";\r\nimport { Color3 } from \"../Maths/math.color\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport type { SubMesh } from \"../Meshes/subMesh\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { Mesh } from \"../Meshes/mesh\";\r\nimport { PrePassConfiguration } from \"./prePassConfiguration\";\r\n\r\nimport type { IImageProcessingConfigurationDefines } from \"./imageProcessingConfiguration.defines\";\r\nimport { ImageProcessingConfiguration } from \"./imageProcessingConfiguration\";\r\nimport type { ColorCurves } from \"./colorCurves\";\r\nimport type { FresnelParameters } from \"./fresnelParameters\";\r\nimport type { ICustomShaderNameResolveOptions } from \"../Materials/material\";\r\nimport { Material } from \"../Materials/material\";\r\nimport { MaterialPluginEvent } from \"./materialPluginEvent\";\r\nimport { MaterialDefines } from \"../Materials/materialDefines\";\r\nimport { PushMaterial } from \"./pushMaterial\";\r\n\r\nimport type { BaseTexture } from \"../Materials/Textures/baseTexture\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport type { CubeTexture } from \"../Materials/Textures/cubeTexture\";\r\nimport type { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\r\nimport { RegisterClass } from \"../Misc/typeStore\";\r\nimport { MaterialFlags } from \"./materialFlags\";\r\n\r\nimport \"../Shaders/default.fragment\";\r\nimport \"../Shaders/default.vertex\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { EffectFallbacks } from \"./effectFallbacks\";\r\nimport type { Effect, IEffectCreationOptions } from \"./effect\";\r\nimport { DetailMapConfiguration } from \"./material.detailMapConfiguration\";\r\nimport { addClipPlaneUniforms, bindClipPlane } from \"./clipPlaneMaterialHelper\";\r\nimport {\r\n    BindBonesParameters,\r\n    BindFogParameters,\r\n    BindLights,\r\n    BindLogDepth,\r\n    BindMorphTargetParameters,\r\n    BindTextureMatrix,\r\n    HandleFallbacksForShadows,\r\n    PrepareAttributesForBakedVertexAnimation,\r\n    PrepareAttributesForBones,\r\n    PrepareAttributesForInstances,\r\n    PrepareAttributesForMorphTargets,\r\n    PrepareDefinesForAttributes,\r\n    PrepareDefinesForFrameBoundValues,\r\n    PrepareDefinesForLights,\r\n    PrepareDefinesForMergedUV,\r\n    PrepareDefinesForMisc,\r\n    PrepareDefinesForMultiview,\r\n    PrepareDefinesForOIT,\r\n    PrepareDefinesForPrePass,\r\n    PrepareUniformsAndSamplersList,\r\n} from \"./materialHelper.functions\";\r\nimport { SerializationHelper } from \"../Misc/decorators.serialization\";\r\n\r\nconst onCreatedEffectParameters = { effect: null as unknown as Effect, subMesh: null as unknown as Nullable<SubMesh> };\r\n\r\n/** @internal */\r\nexport class StandardMaterialDefines extends MaterialDefines implements IImageProcessingConfigurationDefines {\r\n    public MAINUV1 = false;\r\n    public MAINUV2 = false;\r\n    public MAINUV3 = false;\r\n    public MAINUV4 = false;\r\n    public MAINUV5 = false;\r\n    public MAINUV6 = false;\r\n    public DIFFUSE = false;\r\n    public DIFFUSEDIRECTUV = 0;\r\n    public BAKED_VERTEX_ANIMATION_TEXTURE = false;\r\n    public AMBIENT = false;\r\n    public AMBIENTDIRECTUV = 0;\r\n    public OPACITY = false;\r\n    public OPACITYDIRECTUV = 0;\r\n    public OPACITYRGB = false;\r\n    public REFLECTION = false;\r\n    public EMISSIVE = false;\r\n    public EMISSIVEDIRECTUV = 0;\r\n    public SPECULAR = false;\r\n    public SPECULARDIRECTUV = 0;\r\n    public BUMP = false;\r\n    public BUMPDIRECTUV = 0;\r\n    public PARALLAX = false;\r\n    public PARALLAX_RHS = false;\r\n    public PARALLAXOCCLUSION = false;\r\n    public SPECULAROVERALPHA = false;\r\n    public CLIPPLANE = false;\r\n    public CLIPPLANE2 = false;\r\n    public CLIPPLANE3 = false;\r\n    public CLIPPLANE4 = false;\r\n    public CLIPPLANE5 = false;\r\n    public CLIPPLANE6 = false;\r\n    public ALPHATEST = false;\r\n    public DEPTHPREPASS = false;\r\n    public ALPHAFROMDIFFUSE = false;\r\n    public POINTSIZE = false;\r\n    public FOG = false;\r\n    public SPECULARTERM = false;\r\n    public DIFFUSEFRESNEL = false;\r\n    public OPACITYFRESNEL = false;\r\n    public REFLECTIONFRESNEL = false;\r\n    public REFRACTIONFRESNEL = false;\r\n    public EMISSIVEFRESNEL = false;\r\n    public FRESNEL = false;\r\n    public NORMAL = false;\r\n    public TANGENT = false;\r\n    public UV1 = false;\r\n    public UV2 = false;\r\n    public UV3 = false;\r\n    public UV4 = false;\r\n    public UV5 = false;\r\n    public UV6 = false;\r\n    public VERTEXCOLOR = false;\r\n    public VERTEXALPHA = false;\r\n    public NUM_BONE_INFLUENCERS = 0;\r\n    public BonesPerMesh = 0;\r\n    public BONETEXTURE = false;\r\n    public BONES_VELOCITY_ENABLED = false;\r\n    public INSTANCES = false;\r\n    public THIN_INSTANCES = false;\r\n    public INSTANCESCOLOR = false;\r\n    public GLOSSINESS = false;\r\n    public ROUGHNESS = false;\r\n    public EMISSIVEASILLUMINATION = false;\r\n    public LINKEMISSIVEWITHDIFFUSE = false;\r\n    public REFLECTIONFRESNELFROMSPECULAR = false;\r\n    public LIGHTMAP = false;\r\n    public LIGHTMAPDIRECTUV = 0;\r\n    public OBJECTSPACE_NORMALMAP = false;\r\n    public USELIGHTMAPASSHADOWMAP = false;\r\n    public REFLECTIONMAP_3D = false;\r\n    public REFLECTIONMAP_SPHERICAL = false;\r\n    public REFLECTIONMAP_PLANAR = false;\r\n    public REFLECTIONMAP_CUBIC = false;\r\n    public USE_LOCAL_REFLECTIONMAP_CUBIC = false;\r\n    public USE_LOCAL_REFRACTIONMAP_CUBIC = false;\r\n    public REFLECTIONMAP_PROJECTION = false;\r\n    public REFLECTIONMAP_SKYBOX = false;\r\n    public REFLECTIONMAP_EXPLICIT = false;\r\n    public REFLECTIONMAP_EQUIRECTANGULAR = false;\r\n    public REFLECTIONMAP_EQUIRECTANGULAR_FIXED = false;\r\n    public REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED = false;\r\n    public REFLECTIONMAP_OPPOSITEZ = false;\r\n    public INVERTCUBICMAP = false;\r\n    public LOGARITHMICDEPTH = false;\r\n    public REFRACTION = false;\r\n    public REFRACTIONMAP_3D = false;\r\n    public REFLECTIONOVERALPHA = false;\r\n    public TWOSIDEDLIGHTING = false;\r\n    public SHADOWFLOAT = false;\r\n    public MORPHTARGETS = false;\r\n    public MORPHTARGETS_NORMAL = false;\r\n    public MORPHTARGETS_TANGENT = false;\r\n    public MORPHTARGETS_UV = false;\r\n    public NUM_MORPH_INFLUENCERS = 0;\r\n    public MORPHTARGETS_TEXTURE = false;\r\n    public NONUNIFORMSCALING = false; // https://playground.babylonjs.com#V6DWIH\r\n    public PREMULTIPLYALPHA = false; // https://playground.babylonjs.com#LNVJJ7\r\n    public ALPHATEST_AFTERALLALPHACOMPUTATIONS = false;\r\n    public ALPHABLEND = true;\r\n\r\n    public PREPASS = false;\r\n    public PREPASS_IRRADIANCE = false;\r\n    public PREPASS_IRRADIANCE_INDEX = -1;\r\n    public PREPASS_ALBEDO_SQRT = false;\r\n    public PREPASS_ALBEDO_SQRT_INDEX = -1;\r\n    public PREPASS_DEPTH = false;\r\n    public PREPASS_DEPTH_INDEX = -1;\r\n    public PREPASS_NORMAL = false;\r\n    public PREPASS_NORMAL_INDEX = -1;\r\n    public PREPASS_NORMAL_WORLDSPACE = false;\r\n    public PREPASS_POSITION = false;\r\n    public PREPASS_POSITION_INDEX = -1;\r\n    public PREPASS_VELOCITY = false;\r\n    public PREPASS_VELOCITY_INDEX = -1;\r\n    public PREPASS_REFLECTIVITY = false;\r\n    public PREPASS_REFLECTIVITY_INDEX = -1;\r\n    public SCENE_MRT_COUNT = 0;\r\n\r\n    public RGBDLIGHTMAP = false;\r\n    public RGBDREFLECTION = false;\r\n    public RGBDREFRACTION = false;\r\n\r\n    public IMAGEPROCESSING = false;\r\n    public VIGNETTE = false;\r\n    public VIGNETTEBLENDMODEMULTIPLY = false;\r\n    public VIGNETTEBLENDMODEOPAQUE = false;\r\n    public TONEMAPPING = false;\r\n    public TONEMAPPING_ACES = false;\r\n    public CONTRAST = false;\r\n    public COLORCURVES = false;\r\n    public COLORGRADING = false;\r\n    public COLORGRADING3D = false;\r\n    public SAMPLER3DGREENDEPTH = false;\r\n    public SAMPLER3DBGRMAP = false;\r\n    public DITHER = false;\r\n    public IMAGEPROCESSINGPOSTPROCESS = false;\r\n    public SKIPFINALCOLORCLAMP = false;\r\n    public MULTIVIEW = false;\r\n    public ORDER_INDEPENDENT_TRANSPARENCY = false;\r\n    public ORDER_INDEPENDENT_TRANSPARENCY_16BITS = false;\r\n    public CAMERA_ORTHOGRAPHIC = false;\r\n    public CAMERA_PERSPECTIVE = false;\r\n\r\n    /**\r\n     * If the reflection texture on this material is in linear color space\r\n     * @internal\r\n     */\r\n    public IS_REFLECTION_LINEAR = false;\r\n    /**\r\n     * If the refraction texture on this material is in linear color space\r\n     * @internal\r\n     */\r\n    public IS_REFRACTION_LINEAR = false;\r\n    public EXPOSURE = false;\r\n\r\n    public DECAL_AFTER_DETAIL = false;\r\n\r\n    /**\r\n     * Initializes the Standard Material defines.\r\n     * @param externalProperties The external properties\r\n     */\r\n    constructor(externalProperties?: { [name: string]: { type: string; default: any } }) {\r\n        super(externalProperties);\r\n        this.rebuild();\r\n    }\r\n\r\n    public setReflectionMode(modeToEnable: string) {\r\n        const modes = [\r\n            \"REFLECTIONMAP_CUBIC\",\r\n            \"REFLECTIONMAP_EXPLICIT\",\r\n            \"REFLECTIONMAP_PLANAR\",\r\n            \"REFLECTIONMAP_PROJECTION\",\r\n            \"REFLECTIONMAP_PROJECTION\",\r\n            \"REFLECTIONMAP_SKYBOX\",\r\n            \"REFLECTIONMAP_SPHERICAL\",\r\n            \"REFLECTIONMAP_EQUIRECTANGULAR\",\r\n            \"REFLECTIONMAP_EQUIRECTANGULAR_FIXED\",\r\n            \"REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED\",\r\n        ];\r\n\r\n        for (const mode of modes) {\r\n            (<any>this)[mode] = mode === modeToEnable;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * This is the default material used in Babylon. It is the best trade off between quality\r\n * and performances.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/materials_introduction\r\n */\r\nexport class StandardMaterial extends PushMaterial {\r\n    @serializeAsTexture(\"diffuseTexture\")\r\n    private _diffuseTexture: Nullable<BaseTexture> = null;\r\n    /**\r\n     * The basic texture of the material as viewed under a light.\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesAndMiscDirty\")\r\n    public diffuseTexture: Nullable<BaseTexture>;\r\n\r\n    @serializeAsTexture(\"ambientTexture\")\r\n    private _ambientTexture: Nullable<BaseTexture> = null;\r\n    /**\r\n     * AKA Occlusion Texture in other nomenclature, it helps adding baked shadows into your material.\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public ambientTexture: Nullable<BaseTexture>;\r\n\r\n    @serializeAsTexture(\"opacityTexture\")\r\n    private _opacityTexture: Nullable<BaseTexture> = null;\r\n    /**\r\n     * Define the transparency of the material from a texture.\r\n     * The final alpha value can be read either from the red channel (if texture.getAlphaFromRGB is false)\r\n     * or from the luminance or the current texel (if texture.getAlphaFromRGB is true)\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesAndMiscDirty\")\r\n    public opacityTexture: Nullable<BaseTexture>;\r\n\r\n    @serializeAsTexture(\"reflectionTexture\")\r\n    private _reflectionTexture: Nullable<BaseTexture> = null;\r\n    /**\r\n     * Define the texture used to display the reflection.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/reflectionTexture#how-to-obtain-reflections-and-refractions\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public reflectionTexture: Nullable<BaseTexture>;\r\n\r\n    @serializeAsTexture(\"emissiveTexture\")\r\n    private _emissiveTexture: Nullable<BaseTexture> = null;\r\n    /**\r\n     * Define texture of the material as if self lit.\r\n     * This will be mixed in the final result even in the absence of light.\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public emissiveTexture: Nullable<BaseTexture>;\r\n\r\n    @serializeAsTexture(\"specularTexture\")\r\n    private _specularTexture: Nullable<BaseTexture> = null;\r\n    /**\r\n     * Define how the color and intensity of the highlight given by the light in the material.\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public specularTexture: Nullable<BaseTexture>;\r\n\r\n    @serializeAsTexture(\"bumpTexture\")\r\n    private _bumpTexture: Nullable<BaseTexture> = null;\r\n    /**\r\n     * Bump mapping is a technique to simulate bump and dents on a rendered surface.\r\n     * These are made by creating a normal map from an image. The means to do this can be found on the web, a search for 'normal map generator' will bring up free and paid for methods of doing this.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/moreMaterials#bump-map\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public bumpTexture: Nullable<BaseTexture>;\r\n\r\n    @serializeAsTexture(\"lightmapTexture\")\r\n    private _lightmapTexture: Nullable<BaseTexture> = null;\r\n    /**\r\n     * Complex lighting can be computationally expensive to compute at runtime.\r\n     * To save on computation, lightmaps may be used to store calculated lighting in a texture which will be applied to a given mesh.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/lights/lights_introduction#lightmaps\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public lightmapTexture: Nullable<BaseTexture>;\r\n\r\n    @serializeAsTexture(\"refractionTexture\")\r\n    private _refractionTexture: Nullable<BaseTexture> = null;\r\n    /**\r\n     * Define the texture used to display the refraction.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/reflectionTexture#how-to-obtain-reflections-and-refractions\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public refractionTexture: Nullable<BaseTexture>;\r\n\r\n    /**\r\n     * The color of the material lit by the environmental background lighting.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/materials_introduction#ambient-color-example\r\n     */\r\n    @serializeAsColor3(\"ambient\")\r\n    public ambientColor = new Color3(0, 0, 0);\r\n\r\n    /**\r\n     * The basic color of the material as viewed under a light.\r\n     */\r\n    @serializeAsColor3(\"diffuse\")\r\n    public diffuseColor = new Color3(1, 1, 1);\r\n\r\n    /**\r\n     * Define how the color and intensity of the highlight given by the light in the material.\r\n     */\r\n    @serializeAsColor3(\"specular\")\r\n    public specularColor = new Color3(1, 1, 1);\r\n\r\n    /**\r\n     * Define the color of the material as if self lit.\r\n     * This will be mixed in the final result even in the absence of light.\r\n     */\r\n    @serializeAsColor3(\"emissive\")\r\n    public emissiveColor = new Color3(0, 0, 0);\r\n\r\n    /**\r\n     * Defines how sharp are the highlights in the material.\r\n     * The bigger the value the sharper giving a more glossy feeling to the result.\r\n     * Reversely, the smaller the value the blurrier giving a more rough feeling to the result.\r\n     */\r\n    @serialize()\r\n    public specularPower = 64;\r\n\r\n    @serialize(\"useAlphaFromDiffuseTexture\")\r\n    private _useAlphaFromDiffuseTexture = false;\r\n    /**\r\n     * Does the transparency come from the diffuse texture alpha channel.\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesAndMiscDirty\")\r\n    public useAlphaFromDiffuseTexture: boolean;\r\n\r\n    @serialize(\"useEmissiveAsIllumination\")\r\n    private _useEmissiveAsIllumination = false;\r\n    /**\r\n     * If true, the emissive value is added into the end result, otherwise it is multiplied in.\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public useEmissiveAsIllumination: boolean;\r\n\r\n    @serialize(\"linkEmissiveWithDiffuse\")\r\n    private _linkEmissiveWithDiffuse = false;\r\n    /**\r\n     * If true, some kind of energy conservation will prevent the end result to be more than 1 by reducing\r\n     * the emissive level when the final color is close to one.\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public linkEmissiveWithDiffuse: boolean;\r\n\r\n    @serialize(\"useSpecularOverAlpha\")\r\n    private _useSpecularOverAlpha = false;\r\n    /**\r\n     * Specifies that the material will keep the specular highlights over a transparent surface (only the most luminous ones).\r\n     * A car glass is a good exemple of that. When sun reflects on it you can not see what is behind.\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public useSpecularOverAlpha: boolean;\r\n\r\n    @serialize(\"useReflectionOverAlpha\")\r\n    private _useReflectionOverAlpha = false;\r\n    /**\r\n     * Specifies that the material will keeps the reflection highlights over a transparent surface (only the most luminous ones).\r\n     * A car glass is a good exemple of that. When the street lights reflects on it you can not see what is behind.\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public useReflectionOverAlpha: boolean;\r\n\r\n    @serialize(\"disableLighting\")\r\n    private _disableLighting = false;\r\n    /**\r\n     * Does lights from the scene impacts this material.\r\n     * It can be a nice trick for performance to disable lighting on a fully emissive material.\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsLightsDirty\")\r\n    public disableLighting: boolean;\r\n\r\n    @serialize(\"useObjectSpaceNormalMap\")\r\n    private _useObjectSpaceNormalMap = false;\r\n    /**\r\n     * Allows using an object space normal map (instead of tangent space).\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public useObjectSpaceNormalMap: boolean;\r\n\r\n    @serialize(\"useParallax\")\r\n    private _useParallax = false;\r\n    /**\r\n     * Is parallax enabled or not.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/parallaxMapping\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public useParallax: boolean;\r\n\r\n    @serialize(\"useParallaxOcclusion\")\r\n    private _useParallaxOcclusion = false;\r\n    /**\r\n     * Is parallax occlusion enabled or not.\r\n     * If true, the outcome is way more realistic than traditional Parallax but you can expect a performance hit that worthes consideration.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/parallaxMapping\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public useParallaxOcclusion: boolean;\r\n\r\n    /**\r\n     * Apply a scaling factor that determine which \"depth\" the height map should reprensent. A value between 0.05 and 0.1 is reasonnable in Parallax, you can reach 0.2 using Parallax Occlusion.\r\n     */\r\n    @serialize()\r\n    public parallaxScaleBias = 0.05;\r\n\r\n    @serialize(\"roughness\")\r\n    private _roughness = 0;\r\n    /**\r\n     * Helps to define how blurry the reflections should appears in the material.\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public roughness: number;\r\n\r\n    /**\r\n     * In case of refraction, define the value of the index of refraction.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/reflectionTexture#how-to-obtain-reflections-and-refractions\r\n     */\r\n    @serialize()\r\n    public indexOfRefraction = 0.98;\r\n\r\n    /**\r\n     * Invert the refraction texture alongside the y axis.\r\n     * It can be useful with procedural textures or probe for instance.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/reflectionTexture#how-to-obtain-reflections-and-refractions\r\n     */\r\n    @serialize()\r\n    public invertRefractionY = true;\r\n\r\n    /**\r\n     * Defines the alpha limits in alpha test mode.\r\n     */\r\n    @serialize()\r\n    public alphaCutOff = 0.4;\r\n\r\n    @serialize(\"useLightmapAsShadowmap\")\r\n    private _useLightmapAsShadowmap = false;\r\n    /**\r\n     * In case of light mapping, define whether the map contains light or shadow informations.\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public useLightmapAsShadowmap: boolean;\r\n\r\n    // Fresnel\r\n    @serializeAsFresnelParameters(\"diffuseFresnelParameters\")\r\n    private _diffuseFresnelParameters: FresnelParameters;\r\n    /**\r\n     * Define the diffuse fresnel parameters of the material.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/fresnelParameters\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsFresnelDirty\")\r\n    public diffuseFresnelParameters: FresnelParameters;\r\n\r\n    @serializeAsFresnelParameters(\"opacityFresnelParameters\")\r\n    private _opacityFresnelParameters: FresnelParameters;\r\n    /**\r\n     * Define the opacity fresnel parameters of the material.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/fresnelParameters\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsFresnelAndMiscDirty\")\r\n    public opacityFresnelParameters: FresnelParameters;\r\n\r\n    @serializeAsFresnelParameters(\"reflectionFresnelParameters\")\r\n    private _reflectionFresnelParameters: FresnelParameters;\r\n    /**\r\n     * Define the reflection fresnel parameters of the material.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/fresnelParameters\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsFresnelDirty\")\r\n    public reflectionFresnelParameters: FresnelParameters;\r\n\r\n    @serializeAsFresnelParameters(\"refractionFresnelParameters\")\r\n    private _refractionFresnelParameters: FresnelParameters;\r\n    /**\r\n     * Define the refraction fresnel parameters of the material.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/fresnelParameters\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsFresnelDirty\")\r\n    public refractionFresnelParameters: FresnelParameters;\r\n\r\n    @serializeAsFresnelParameters(\"emissiveFresnelParameters\")\r\n    private _emissiveFresnelParameters: FresnelParameters;\r\n    /**\r\n     * Define the emissive fresnel parameters of the material.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/fresnelParameters\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsFresnelDirty\")\r\n    public emissiveFresnelParameters: FresnelParameters;\r\n\r\n    @serialize(\"useReflectionFresnelFromSpecular\")\r\n    private _useReflectionFresnelFromSpecular = false;\r\n    /**\r\n     * If true automatically deducts the fresnels values from the material specularity.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/fresnelParameters\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsFresnelDirty\")\r\n    public useReflectionFresnelFromSpecular: boolean;\r\n\r\n    @serialize(\"useGlossinessFromSpecularMapAlpha\")\r\n    private _useGlossinessFromSpecularMapAlpha = false;\r\n    /**\r\n     * Defines if the glossiness/roughness of the material should be read from the specular map alpha channel\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public useGlossinessFromSpecularMapAlpha: boolean;\r\n\r\n    @serialize(\"maxSimultaneousLights\")\r\n    private _maxSimultaneousLights = 4;\r\n    /**\r\n     * Defines the maximum number of lights that can be used in the material\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsLightsDirty\")\r\n    public maxSimultaneousLights: number;\r\n\r\n    @serialize(\"invertNormalMapX\")\r\n    private _invertNormalMapX = false;\r\n    /**\r\n     * If sets to true, x component of normal map value will invert (x = 1.0 - x).\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public invertNormalMapX: boolean;\r\n\r\n    @serialize(\"invertNormalMapY\")\r\n    private _invertNormalMapY = false;\r\n    /**\r\n     * If sets to true, y component of normal map value will invert (y = 1.0 - y).\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public invertNormalMapY: boolean;\r\n\r\n    @serialize(\"twoSidedLighting\")\r\n    private _twoSidedLighting = false;\r\n    /**\r\n     * If sets to true and backfaceCulling is false, normals will be flipped on the backside.\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public twoSidedLighting: boolean;\r\n\r\n    @serialize(\"applyDecalMapAfterDetailMap\")\r\n    private _applyDecalMapAfterDetailMap = false;\r\n    /**\r\n     * If sets to true, the decal map will be applied after the detail map. Else, it is applied before (default: false)\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsMiscDirty\")\r\n    public applyDecalMapAfterDetailMap: boolean;\r\n\r\n    /**\r\n     * Default configuration related to image processing available in the standard Material.\r\n     */\r\n    protected _imageProcessingConfiguration: ImageProcessingConfiguration;\r\n\r\n    /**\r\n     * Gets the image processing configuration used either in this material.\r\n     */\r\n    public get imageProcessingConfiguration(): ImageProcessingConfiguration {\r\n        return this._imageProcessingConfiguration;\r\n    }\r\n\r\n    /**\r\n     * Sets the Default image processing configuration used either in the this material.\r\n     *\r\n     * If sets to null, the scene one is in use.\r\n     */\r\n    public set imageProcessingConfiguration(value: ImageProcessingConfiguration) {\r\n        this._attachImageProcessingConfiguration(value);\r\n\r\n        // Ensure the effect will be rebuilt.\r\n        this._markAllSubMeshesAsTexturesDirty();\r\n    }\r\n\r\n    /**\r\n     * Keep track of the image processing observer to allow dispose and replace.\r\n     */\r\n    private _imageProcessingObserver: Nullable<Observer<ImageProcessingConfiguration>>;\r\n\r\n    /**\r\n     * Attaches a new image processing configuration to the Standard Material.\r\n     * @param configuration\r\n     */\r\n    protected _attachImageProcessingConfiguration(configuration: Nullable<ImageProcessingConfiguration>): void {\r\n        if (configuration === this._imageProcessingConfiguration) {\r\n            return;\r\n        }\r\n\r\n        // Detaches observer\r\n        if (this._imageProcessingConfiguration && this._imageProcessingObserver) {\r\n            this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver);\r\n        }\r\n\r\n        // Pick the scene configuration if needed\r\n        if (!configuration) {\r\n            this._imageProcessingConfiguration = this.getScene().imageProcessingConfiguration;\r\n        } else {\r\n            this._imageProcessingConfiguration = configuration;\r\n        }\r\n\r\n        // Attaches observer\r\n        if (this._imageProcessingConfiguration) {\r\n            this._imageProcessingObserver = this._imageProcessingConfiguration.onUpdateParameters.add(() => {\r\n                this._markAllSubMeshesAsImageProcessingDirty();\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Defines additional PrePass parameters for the material.\r\n     */\r\n    public readonly prePassConfiguration: PrePassConfiguration;\r\n\r\n    /**\r\n     * Can this material render to prepass\r\n     */\r\n    public get isPrePassCapable(): boolean {\r\n        return !this.disableDepthWrite;\r\n    }\r\n\r\n    /**\r\n     * Gets whether the color curves effect is enabled.\r\n     */\r\n    public get cameraColorCurvesEnabled(): boolean {\r\n        return this.imageProcessingConfiguration.colorCurvesEnabled;\r\n    }\r\n    /**\r\n     * Sets whether the color curves effect is enabled.\r\n     */\r\n    public set cameraColorCurvesEnabled(value: boolean) {\r\n        this.imageProcessingConfiguration.colorCurvesEnabled = value;\r\n    }\r\n\r\n    /**\r\n     * Gets whether the color grading effect is enabled.\r\n     */\r\n    public get cameraColorGradingEnabled(): boolean {\r\n        return this.imageProcessingConfiguration.colorGradingEnabled;\r\n    }\r\n    /**\r\n     * Gets whether the color grading effect is enabled.\r\n     */\r\n    public set cameraColorGradingEnabled(value: boolean) {\r\n        this.imageProcessingConfiguration.colorGradingEnabled = value;\r\n    }\r\n\r\n    /**\r\n     * Gets whether tonemapping is enabled or not.\r\n     */\r\n    public get cameraToneMappingEnabled(): boolean {\r\n        return this._imageProcessingConfiguration.toneMappingEnabled;\r\n    }\r\n    /**\r\n     * Sets whether tonemapping is enabled or not\r\n     */\r\n    public set cameraToneMappingEnabled(value: boolean) {\r\n        this._imageProcessingConfiguration.toneMappingEnabled = value;\r\n    }\r\n\r\n    /**\r\n     * The camera exposure used on this material.\r\n     * This property is here and not in the camera to allow controlling exposure without full screen post process.\r\n     * This corresponds to a photographic exposure.\r\n     */\r\n    public get cameraExposure(): number {\r\n        return this._imageProcessingConfiguration.exposure;\r\n    }\r\n    /**\r\n     * The camera exposure used on this material.\r\n     * This property is here and not in the camera to allow controlling exposure without full screen post process.\r\n     * This corresponds to a photographic exposure.\r\n     */\r\n    public set cameraExposure(value: number) {\r\n        this._imageProcessingConfiguration.exposure = value;\r\n    }\r\n\r\n    /**\r\n     * Gets The camera contrast used on this material.\r\n     */\r\n    public get cameraContrast(): number {\r\n        return this._imageProcessingConfiguration.contrast;\r\n    }\r\n\r\n    /**\r\n     * Sets The camera contrast used on this material.\r\n     */\r\n    public set cameraContrast(value: number) {\r\n        this._imageProcessingConfiguration.contrast = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the Color Grading 2D Lookup Texture.\r\n     */\r\n    public get cameraColorGradingTexture(): Nullable<BaseTexture> {\r\n        return this._imageProcessingConfiguration.colorGradingTexture;\r\n    }\r\n    /**\r\n     * Sets the Color Grading 2D Lookup Texture.\r\n     */\r\n    public set cameraColorGradingTexture(value: Nullable<BaseTexture>) {\r\n        this._imageProcessingConfiguration.colorGradingTexture = value;\r\n    }\r\n\r\n    /**\r\n     * The color grading curves provide additional color adjustmnent that is applied after any color grading transform (3D LUT).\r\n     * They allow basic adjustment of saturation and small exposure adjustments, along with color filter tinting to provide white balance adjustment or more stylistic effects.\r\n     * These are similar to controls found in many professional imaging or colorist software. The global controls are applied to the entire image. For advanced tuning, extra controls are provided to adjust the shadow, midtone and highlight areas of the image;\r\n     * corresponding to low luminance, medium luminance, and high luminance areas respectively.\r\n     */\r\n    public get cameraColorCurves(): Nullable<ColorCurves> {\r\n        return this._imageProcessingConfiguration.colorCurves;\r\n    }\r\n    /**\r\n     * The color grading curves provide additional color adjustment that is applied after any color grading transform (3D LUT).\r\n     * They allow basic adjustment of saturation and small exposure adjustments, along with color filter tinting to provide white balance adjustment or more stylistic effects.\r\n     * These are similar to controls found in many professional imaging or colorist software. The global controls are applied to the entire image. For advanced tuning, extra controls are provided to adjust the shadow, midtone and highlight areas of the image;\r\n     * corresponding to low luminance, medium luminance, and high luminance areas respectively.\r\n     */\r\n    public set cameraColorCurves(value: Nullable<ColorCurves>) {\r\n        this._imageProcessingConfiguration.colorCurves = value;\r\n    }\r\n\r\n    /**\r\n     * Can this material render to several textures at once\r\n     */\r\n    public get canRenderToMRT() {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Defines the detail map parameters for the material.\r\n     */\r\n    public readonly detailMap: DetailMapConfiguration;\r\n\r\n    protected _renderTargets = new SmartArray<RenderTargetTexture>(16);\r\n    protected _worldViewProjectionMatrix = Matrix.Zero();\r\n    protected _globalAmbientColor = new Color3(0, 0, 0);\r\n    protected _cacheHasRenderTargetTextures = false;\r\n\r\n    /**\r\n     * Instantiates a new standard material.\r\n     * This is the default material used in Babylon. It is the best trade off between quality\r\n     * and performances.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/materials_introduction\r\n     * @param name Define the name of the material in the scene\r\n     * @param scene Define the scene the material belong to\r\n     */\r\n    constructor(name: string, scene?: Scene) {\r\n        super(name, scene);\r\n\r\n        this.detailMap = new DetailMapConfiguration(this);\r\n\r\n        // Setup the default processing configuration to the scene.\r\n        this._attachImageProcessingConfiguration(null);\r\n        this.prePassConfiguration = new PrePassConfiguration();\r\n\r\n        this.getRenderTargetTextures = (): SmartArray<RenderTargetTexture> => {\r\n            this._renderTargets.reset();\r\n\r\n            if (StandardMaterial.ReflectionTextureEnabled && this._reflectionTexture && this._reflectionTexture.isRenderTarget) {\r\n                this._renderTargets.push(<RenderTargetTexture>this._reflectionTexture);\r\n            }\r\n\r\n            if (StandardMaterial.RefractionTextureEnabled && this._refractionTexture && this._refractionTexture.isRenderTarget) {\r\n                this._renderTargets.push(<RenderTargetTexture>this._refractionTexture);\r\n            }\r\n\r\n            this._eventInfo.renderTargets = this._renderTargets;\r\n            this._callbackPluginEventFillRenderTargetTextures(this._eventInfo);\r\n\r\n            return this._renderTargets;\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating that current material needs to register RTT\r\n     */\r\n    public get hasRenderTargetTextures(): boolean {\r\n        if (StandardMaterial.ReflectionTextureEnabled && this._reflectionTexture && this._reflectionTexture.isRenderTarget) {\r\n            return true;\r\n        }\r\n\r\n        if (StandardMaterial.RefractionTextureEnabled && this._refractionTexture && this._refractionTexture.isRenderTarget) {\r\n            return true;\r\n        }\r\n\r\n        return this._cacheHasRenderTargetTextures;\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name of the material e.g. \"StandardMaterial\"\r\n     * Mainly use in serialization.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"StandardMaterial\";\r\n    }\r\n\r\n    /**\r\n     * Specifies if the material will require alpha blending\r\n     * @returns a boolean specifying if alpha blending is needed\r\n     */\r\n    public needAlphaBlending(): boolean {\r\n        if (this._disableAlphaBlending) {\r\n            return false;\r\n        }\r\n\r\n        return (\r\n            this.alpha < 1.0 ||\r\n            this._opacityTexture != null ||\r\n            this._shouldUseAlphaFromDiffuseTexture() ||\r\n            (this._opacityFresnelParameters && this._opacityFresnelParameters.isEnabled)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Specifies if this material should be rendered in alpha test mode\r\n     * @returns a boolean specifying if an alpha test is needed.\r\n     */\r\n    public needAlphaTesting(): boolean {\r\n        if (this._forceAlphaTest) {\r\n            return true;\r\n        }\r\n\r\n        return this._hasAlphaChannel() && (this._transparencyMode == null || this._transparencyMode === Material.MATERIAL_ALPHATEST);\r\n    }\r\n\r\n    /**\r\n     * @returns whether or not the alpha value of the diffuse texture should be used for alpha blending.\r\n     */\r\n    protected _shouldUseAlphaFromDiffuseTexture(): boolean {\r\n        return this._diffuseTexture != null && this._diffuseTexture.hasAlpha && this._useAlphaFromDiffuseTexture && this._transparencyMode !== Material.MATERIAL_OPAQUE;\r\n    }\r\n\r\n    /**\r\n     * @returns whether or not there is a usable alpha channel for transparency.\r\n     */\r\n    protected _hasAlphaChannel(): boolean {\r\n        return (this._diffuseTexture != null && this._diffuseTexture.hasAlpha) || this._opacityTexture != null;\r\n    }\r\n\r\n    /**\r\n     * Get the texture used for alpha test purpose.\r\n     * @returns the diffuse texture in case of the standard material.\r\n     */\r\n    public getAlphaTestTexture(): Nullable<BaseTexture> {\r\n        return this._diffuseTexture;\r\n    }\r\n\r\n    /**\r\n     * Get if the submesh is ready to be used and all its information available.\r\n     * Child classes can use it to update shaders\r\n     * @param mesh defines the mesh to check\r\n     * @param subMesh defines which submesh to check\r\n     * @param useInstances specifies that instances should be used\r\n     * @returns a boolean indicating that the submesh is ready or not\r\n     */\r\n    public isReadyForSubMesh(mesh: AbstractMesh, subMesh: SubMesh, useInstances: boolean = false): boolean {\r\n        if (!this._uniformBufferLayoutBuilt) {\r\n            this.buildUniformLayout();\r\n        }\r\n\r\n        const drawWrapper = subMesh._drawWrapper;\r\n\r\n        if (drawWrapper.effect && this.isFrozen) {\r\n            if (drawWrapper._wasPreviouslyReady && drawWrapper._wasPreviouslyUsingInstances === useInstances) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        if (!subMesh.materialDefines) {\r\n            this._callbackPluginEventGeneric(MaterialPluginEvent.GetDefineNames, this._eventInfo);\r\n            subMesh.materialDefines = new StandardMaterialDefines(this._eventInfo.defineNames);\r\n        }\r\n\r\n        const scene = this.getScene();\r\n        const defines = <StandardMaterialDefines>subMesh.materialDefines;\r\n        if (this._isReadyForSubMesh(subMesh)) {\r\n            return true;\r\n        }\r\n\r\n        const engine = scene.getEngine();\r\n\r\n        // Lights\r\n        defines._needNormals = PrepareDefinesForLights(scene, mesh, defines, true, this._maxSimultaneousLights, this._disableLighting);\r\n\r\n        // Multiview\r\n        PrepareDefinesForMultiview(scene, defines);\r\n\r\n        // PrePass\r\n        const oit = this.needAlphaBlendingForMesh(mesh) && this.getScene().useOrderIndependentTransparency;\r\n        PrepareDefinesForPrePass(scene, defines, this.canRenderToMRT && !oit);\r\n\r\n        // Order independant transparency\r\n        PrepareDefinesForOIT(scene, defines, oit);\r\n\r\n        // Textures\r\n        if (defines._areTexturesDirty) {\r\n            this._eventInfo.hasRenderTargetTextures = false;\r\n            this._callbackPluginEventHasRenderTargetTextures(this._eventInfo);\r\n            this._cacheHasRenderTargetTextures = this._eventInfo.hasRenderTargetTextures;\r\n            defines._needUVs = false;\r\n            for (let i = 1; i <= Constants.MAX_SUPPORTED_UV_SETS; ++i) {\r\n                defines[\"MAINUV\" + i] = false;\r\n            }\r\n            if (scene.texturesEnabled) {\r\n                defines.DIFFUSEDIRECTUV = 0;\r\n                defines.BUMPDIRECTUV = 0;\r\n                defines.AMBIENTDIRECTUV = 0;\r\n                defines.OPACITYDIRECTUV = 0;\r\n                defines.EMISSIVEDIRECTUV = 0;\r\n                defines.SPECULARDIRECTUV = 0;\r\n                defines.LIGHTMAPDIRECTUV = 0;\r\n\r\n                if (this._diffuseTexture && StandardMaterial.DiffuseTextureEnabled) {\r\n                    if (!this._diffuseTexture.isReadyOrNotBlocking()) {\r\n                        return false;\r\n                    } else {\r\n                        PrepareDefinesForMergedUV(this._diffuseTexture, defines, \"DIFFUSE\");\r\n                    }\r\n                } else {\r\n                    defines.DIFFUSE = false;\r\n                }\r\n\r\n                if (this._ambientTexture && StandardMaterial.AmbientTextureEnabled) {\r\n                    if (!this._ambientTexture.isReadyOrNotBlocking()) {\r\n                        return false;\r\n                    } else {\r\n                        PrepareDefinesForMergedUV(this._ambientTexture, defines, \"AMBIENT\");\r\n                    }\r\n                } else {\r\n                    defines.AMBIENT = false;\r\n                }\r\n\r\n                if (this._opacityTexture && StandardMaterial.OpacityTextureEnabled) {\r\n                    if (!this._opacityTexture.isReadyOrNotBlocking()) {\r\n                        return false;\r\n                    } else {\r\n                        PrepareDefinesForMergedUV(this._opacityTexture, defines, \"OPACITY\");\r\n                        defines.OPACITYRGB = this._opacityTexture.getAlphaFromRGB;\r\n                    }\r\n                } else {\r\n                    defines.OPACITY = false;\r\n                }\r\n\r\n                if (this._reflectionTexture && StandardMaterial.ReflectionTextureEnabled) {\r\n                    if (!this._reflectionTexture.isReadyOrNotBlocking()) {\r\n                        return false;\r\n                    } else {\r\n                        defines._needNormals = true;\r\n                        defines.REFLECTION = true;\r\n\r\n                        defines.ROUGHNESS = this._roughness > 0;\r\n                        defines.REFLECTIONOVERALPHA = this._useReflectionOverAlpha;\r\n                        defines.INVERTCUBICMAP = this._reflectionTexture.coordinatesMode === Texture.INVCUBIC_MODE;\r\n                        defines.REFLECTIONMAP_3D = this._reflectionTexture.isCube;\r\n                        defines.REFLECTIONMAP_OPPOSITEZ =\r\n                            defines.REFLECTIONMAP_3D && this.getScene().useRightHandedSystem ? !this._reflectionTexture.invertZ : this._reflectionTexture.invertZ;\r\n                        defines.RGBDREFLECTION = this._reflectionTexture.isRGBD;\r\n\r\n                        switch (this._reflectionTexture.coordinatesMode) {\r\n                            case Texture.EXPLICIT_MODE:\r\n                                defines.setReflectionMode(\"REFLECTIONMAP_EXPLICIT\");\r\n                                break;\r\n                            case Texture.PLANAR_MODE:\r\n                                defines.setReflectionMode(\"REFLECTIONMAP_PLANAR\");\r\n                                break;\r\n                            case Texture.PROJECTION_MODE:\r\n                                defines.setReflectionMode(\"REFLECTIONMAP_PROJECTION\");\r\n                                break;\r\n                            case Texture.SKYBOX_MODE:\r\n                                defines.setReflectionMode(\"REFLECTIONMAP_SKYBOX\");\r\n                                break;\r\n                            case Texture.SPHERICAL_MODE:\r\n                                defines.setReflectionMode(\"REFLECTIONMAP_SPHERICAL\");\r\n                                break;\r\n                            case Texture.EQUIRECTANGULAR_MODE:\r\n                                defines.setReflectionMode(\"REFLECTIONMAP_EQUIRECTANGULAR\");\r\n                                break;\r\n                            case Texture.FIXED_EQUIRECTANGULAR_MODE:\r\n                                defines.setReflectionMode(\"REFLECTIONMAP_EQUIRECTANGULAR_FIXED\");\r\n                                break;\r\n                            case Texture.FIXED_EQUIRECTANGULAR_MIRRORED_MODE:\r\n                                defines.setReflectionMode(\"REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED\");\r\n                                break;\r\n                            case Texture.CUBIC_MODE:\r\n                            case Texture.INVCUBIC_MODE:\r\n                            default:\r\n                                defines.setReflectionMode(\"REFLECTIONMAP_CUBIC\");\r\n                                break;\r\n                        }\r\n\r\n                        defines.USE_LOCAL_REFLECTIONMAP_CUBIC = (<any>this._reflectionTexture).boundingBoxSize ? true : false;\r\n                    }\r\n                } else {\r\n                    defines.REFLECTION = false;\r\n                    defines.REFLECTIONMAP_OPPOSITEZ = false;\r\n                }\r\n\r\n                if (this._emissiveTexture && StandardMaterial.EmissiveTextureEnabled) {\r\n                    if (!this._emissiveTexture.isReadyOrNotBlocking()) {\r\n                        return false;\r\n                    } else {\r\n                        PrepareDefinesForMergedUV(this._emissiveTexture, defines, \"EMISSIVE\");\r\n                    }\r\n                } else {\r\n                    defines.EMISSIVE = false;\r\n                }\r\n\r\n                if (this._lightmapTexture && StandardMaterial.LightmapTextureEnabled) {\r\n                    if (!this._lightmapTexture.isReadyOrNotBlocking()) {\r\n                        return false;\r\n                    } else {\r\n                        PrepareDefinesForMergedUV(this._lightmapTexture, defines, \"LIGHTMAP\");\r\n                        defines.USELIGHTMAPASSHADOWMAP = this._useLightmapAsShadowmap;\r\n                        defines.RGBDLIGHTMAP = this._lightmapTexture.isRGBD;\r\n                    }\r\n                } else {\r\n                    defines.LIGHTMAP = false;\r\n                }\r\n\r\n                if (this._specularTexture && StandardMaterial.SpecularTextureEnabled) {\r\n                    if (!this._specularTexture.isReadyOrNotBlocking()) {\r\n                        return false;\r\n                    } else {\r\n                        PrepareDefinesForMergedUV(this._specularTexture, defines, \"SPECULAR\");\r\n                        defines.GLOSSINESS = this._useGlossinessFromSpecularMapAlpha;\r\n                    }\r\n                } else {\r\n                    defines.SPECULAR = false;\r\n                }\r\n\r\n                if (scene.getEngine().getCaps().standardDerivatives && this._bumpTexture && StandardMaterial.BumpTextureEnabled) {\r\n                    // Bump texture can not be not blocking.\r\n                    if (!this._bumpTexture.isReady()) {\r\n                        return false;\r\n                    } else {\r\n                        PrepareDefinesForMergedUV(this._bumpTexture, defines, \"BUMP\");\r\n\r\n                        defines.PARALLAX = this._useParallax;\r\n                        defines.PARALLAX_RHS = scene.useRightHandedSystem;\r\n                        defines.PARALLAXOCCLUSION = this._useParallaxOcclusion;\r\n                    }\r\n\r\n                    defines.OBJECTSPACE_NORMALMAP = this._useObjectSpaceNormalMap;\r\n                } else {\r\n                    defines.BUMP = false;\r\n                    defines.PARALLAX = false;\r\n                    defines.PARALLAX_RHS = false;\r\n                    defines.PARALLAXOCCLUSION = false;\r\n                }\r\n\r\n                if (this._refractionTexture && StandardMaterial.RefractionTextureEnabled) {\r\n                    if (!this._refractionTexture.isReadyOrNotBlocking()) {\r\n                        return false;\r\n                    } else {\r\n                        defines._needUVs = true;\r\n                        defines.REFRACTION = true;\r\n\r\n                        defines.REFRACTIONMAP_3D = this._refractionTexture.isCube;\r\n                        defines.RGBDREFRACTION = this._refractionTexture.isRGBD;\r\n                        defines.USE_LOCAL_REFRACTIONMAP_CUBIC = (<any>this._refractionTexture).boundingBoxSize ? true : false;\r\n                    }\r\n                } else {\r\n                    defines.REFRACTION = false;\r\n                }\r\n\r\n                defines.TWOSIDEDLIGHTING = !this._backFaceCulling && this._twoSidedLighting;\r\n            } else {\r\n                defines.DIFFUSE = false;\r\n                defines.AMBIENT = false;\r\n                defines.OPACITY = false;\r\n                defines.REFLECTION = false;\r\n                defines.EMISSIVE = false;\r\n                defines.LIGHTMAP = false;\r\n                defines.BUMP = false;\r\n                defines.REFRACTION = false;\r\n            }\r\n\r\n            defines.ALPHAFROMDIFFUSE = this._shouldUseAlphaFromDiffuseTexture();\r\n\r\n            defines.EMISSIVEASILLUMINATION = this._useEmissiveAsIllumination;\r\n\r\n            defines.LINKEMISSIVEWITHDIFFUSE = this._linkEmissiveWithDiffuse;\r\n\r\n            defines.SPECULAROVERALPHA = this._useSpecularOverAlpha;\r\n\r\n            defines.PREMULTIPLYALPHA = this.alphaMode === Constants.ALPHA_PREMULTIPLIED || this.alphaMode === Constants.ALPHA_PREMULTIPLIED_PORTERDUFF;\r\n\r\n            defines.ALPHATEST_AFTERALLALPHACOMPUTATIONS = this.transparencyMode !== null;\r\n\r\n            defines.ALPHABLEND = this.transparencyMode === null || this.needAlphaBlendingForMesh(mesh); // check on null for backward compatibility\r\n        }\r\n\r\n        this._eventInfo.isReadyForSubMesh = true;\r\n        this._eventInfo.defines = defines;\r\n        this._eventInfo.subMesh = subMesh;\r\n        this._callbackPluginEventIsReadyForSubMesh(this._eventInfo);\r\n\r\n        if (!this._eventInfo.isReadyForSubMesh) {\r\n            return false;\r\n        }\r\n\r\n        if (defines._areImageProcessingDirty && this._imageProcessingConfiguration) {\r\n            if (!this._imageProcessingConfiguration.isReady()) {\r\n                return false;\r\n            }\r\n\r\n            this._imageProcessingConfiguration.prepareDefines(defines);\r\n\r\n            defines.IS_REFLECTION_LINEAR = this.reflectionTexture != null && !this.reflectionTexture.gammaSpace;\r\n            defines.IS_REFRACTION_LINEAR = this.refractionTexture != null && !this.refractionTexture.gammaSpace;\r\n        }\r\n\r\n        if (defines._areFresnelDirty) {\r\n            if (StandardMaterial.FresnelEnabled) {\r\n                // Fresnel\r\n                if (\r\n                    this._diffuseFresnelParameters ||\r\n                    this._opacityFresnelParameters ||\r\n                    this._emissiveFresnelParameters ||\r\n                    this._refractionFresnelParameters ||\r\n                    this._reflectionFresnelParameters\r\n                ) {\r\n                    defines.DIFFUSEFRESNEL = this._diffuseFresnelParameters && this._diffuseFresnelParameters.isEnabled;\r\n\r\n                    defines.OPACITYFRESNEL = this._opacityFresnelParameters && this._opacityFresnelParameters.isEnabled;\r\n\r\n                    defines.REFLECTIONFRESNEL = this._reflectionFresnelParameters && this._reflectionFresnelParameters.isEnabled;\r\n\r\n                    defines.REFLECTIONFRESNELFROMSPECULAR = this._useReflectionFresnelFromSpecular;\r\n\r\n                    defines.REFRACTIONFRESNEL = this._refractionFresnelParameters && this._refractionFresnelParameters.isEnabled;\r\n\r\n                    defines.EMISSIVEFRESNEL = this._emissiveFresnelParameters && this._emissiveFresnelParameters.isEnabled;\r\n\r\n                    defines._needNormals = true;\r\n                    defines.FRESNEL = true;\r\n                }\r\n            } else {\r\n                defines.FRESNEL = false;\r\n            }\r\n        }\r\n\r\n        // Misc.\r\n        PrepareDefinesForMisc(\r\n            mesh,\r\n            scene,\r\n            this._useLogarithmicDepth,\r\n            this.pointsCloud,\r\n            this.fogEnabled,\r\n            this._shouldTurnAlphaTestOn(mesh) || this._forceAlphaTest,\r\n            defines,\r\n            this._applyDecalMapAfterDetailMap\r\n        );\r\n\r\n        // Values that need to be evaluated on every frame\r\n        PrepareDefinesForFrameBoundValues(scene, engine, this, defines, useInstances, null, subMesh.getRenderingMesh().hasThinInstances);\r\n\r\n        // External config\r\n        this._eventInfo.defines = defines;\r\n        this._eventInfo.mesh = mesh;\r\n        this._callbackPluginEventPrepareDefinesBeforeAttributes(this._eventInfo);\r\n\r\n        // Attribs\r\n        PrepareDefinesForAttributes(mesh, defines, true, true, true);\r\n\r\n        // External config\r\n        this._callbackPluginEventPrepareDefines(this._eventInfo);\r\n\r\n        // Get correct effect\r\n        let forceWasNotReadyPreviously = false;\r\n\r\n        if (defines.isDirty) {\r\n            const lightDisposed = defines._areLightsDisposed;\r\n            defines.markAsProcessed();\r\n\r\n            // Fallbacks\r\n            const fallbacks = new EffectFallbacks();\r\n            if (defines.REFLECTION) {\r\n                fallbacks.addFallback(0, \"REFLECTION\");\r\n            }\r\n\r\n            if (defines.SPECULAR) {\r\n                fallbacks.addFallback(0, \"SPECULAR\");\r\n            }\r\n\r\n            if (defines.BUMP) {\r\n                fallbacks.addFallback(0, \"BUMP\");\r\n            }\r\n\r\n            if (defines.PARALLAX) {\r\n                fallbacks.addFallback(1, \"PARALLAX\");\r\n            }\r\n\r\n            if (defines.PARALLAX_RHS) {\r\n                fallbacks.addFallback(1, \"PARALLAX_RHS\");\r\n            }\r\n\r\n            if (defines.PARALLAXOCCLUSION) {\r\n                fallbacks.addFallback(0, \"PARALLAXOCCLUSION\");\r\n            }\r\n\r\n            if (defines.SPECULAROVERALPHA) {\r\n                fallbacks.addFallback(0, \"SPECULAROVERALPHA\");\r\n            }\r\n\r\n            if (defines.FOG) {\r\n                fallbacks.addFallback(1, \"FOG\");\r\n            }\r\n\r\n            if (defines.POINTSIZE) {\r\n                fallbacks.addFallback(0, \"POINTSIZE\");\r\n            }\r\n\r\n            if (defines.LOGARITHMICDEPTH) {\r\n                fallbacks.addFallback(0, \"LOGARITHMICDEPTH\");\r\n            }\r\n\r\n            HandleFallbacksForShadows(defines, fallbacks, this._maxSimultaneousLights);\r\n\r\n            if (defines.SPECULARTERM) {\r\n                fallbacks.addFallback(0, \"SPECULARTERM\");\r\n            }\r\n\r\n            if (defines.DIFFUSEFRESNEL) {\r\n                fallbacks.addFallback(1, \"DIFFUSEFRESNEL\");\r\n            }\r\n\r\n            if (defines.OPACITYFRESNEL) {\r\n                fallbacks.addFallback(2, \"OPACITYFRESNEL\");\r\n            }\r\n\r\n            if (defines.REFLECTIONFRESNEL) {\r\n                fallbacks.addFallback(3, \"REFLECTIONFRESNEL\");\r\n            }\r\n\r\n            if (defines.EMISSIVEFRESNEL) {\r\n                fallbacks.addFallback(4, \"EMISSIVEFRESNEL\");\r\n            }\r\n\r\n            if (defines.FRESNEL) {\r\n                fallbacks.addFallback(4, \"FRESNEL\");\r\n            }\r\n\r\n            if (defines.MULTIVIEW) {\r\n                fallbacks.addFallback(0, \"MULTIVIEW\");\r\n            }\r\n\r\n            //Attributes\r\n            const attribs = [VertexBuffer.PositionKind];\r\n\r\n            if (defines.NORMAL) {\r\n                attribs.push(VertexBuffer.NormalKind);\r\n            }\r\n\r\n            if (defines.TANGENT) {\r\n                attribs.push(VertexBuffer.TangentKind);\r\n            }\r\n\r\n            for (let i = 1; i <= Constants.MAX_SUPPORTED_UV_SETS; ++i) {\r\n                if (defines[\"UV\" + i]) {\r\n                    attribs.push(`uv${i === 1 ? \"\" : i}`);\r\n                }\r\n            }\r\n\r\n            if (defines.VERTEXCOLOR) {\r\n                attribs.push(VertexBuffer.ColorKind);\r\n            }\r\n\r\n            PrepareAttributesForBones(attribs, mesh, defines, fallbacks);\r\n            PrepareAttributesForInstances(attribs, defines);\r\n            PrepareAttributesForMorphTargets(attribs, mesh, defines);\r\n            PrepareAttributesForBakedVertexAnimation(attribs, mesh, defines);\r\n\r\n            let shaderName = \"default\";\r\n\r\n            const uniforms = [\r\n                \"world\",\r\n                \"view\",\r\n                \"viewProjection\",\r\n                \"vEyePosition\",\r\n                \"vLightsType\",\r\n                \"vAmbientColor\",\r\n                \"vDiffuseColor\",\r\n                \"vSpecularColor\",\r\n                \"vEmissiveColor\",\r\n                \"visibility\",\r\n                \"vFogInfos\",\r\n                \"vFogColor\",\r\n                \"pointSize\",\r\n                \"vDiffuseInfos\",\r\n                \"vAmbientInfos\",\r\n                \"vOpacityInfos\",\r\n                \"vReflectionInfos\",\r\n                \"vEmissiveInfos\",\r\n                \"vSpecularInfos\",\r\n                \"vBumpInfos\",\r\n                \"vLightmapInfos\",\r\n                \"vRefractionInfos\",\r\n                \"mBones\",\r\n                \"diffuseMatrix\",\r\n                \"ambientMatrix\",\r\n                \"opacityMatrix\",\r\n                \"reflectionMatrix\",\r\n                \"emissiveMatrix\",\r\n                \"specularMatrix\",\r\n                \"bumpMatrix\",\r\n                \"normalMatrix\",\r\n                \"lightmapMatrix\",\r\n                \"refractionMatrix\",\r\n                \"diffuseLeftColor\",\r\n                \"diffuseRightColor\",\r\n                \"opacityParts\",\r\n                \"reflectionLeftColor\",\r\n                \"reflectionRightColor\",\r\n                \"emissiveLeftColor\",\r\n                \"emissiveRightColor\",\r\n                \"refractionLeftColor\",\r\n                \"refractionRightColor\",\r\n                \"vReflectionPosition\",\r\n                \"vReflectionSize\",\r\n                \"vRefractionPosition\",\r\n                \"vRefractionSize\",\r\n                \"logarithmicDepthConstant\",\r\n                \"vTangentSpaceParams\",\r\n                \"alphaCutOff\",\r\n                \"boneTextureWidth\",\r\n                \"morphTargetTextureInfo\",\r\n                \"morphTargetTextureIndices\",\r\n            ];\r\n\r\n            const samplers = [\r\n                \"diffuseSampler\",\r\n                \"ambientSampler\",\r\n                \"opacitySampler\",\r\n                \"reflectionCubeSampler\",\r\n                \"reflection2DSampler\",\r\n                \"emissiveSampler\",\r\n                \"specularSampler\",\r\n                \"bumpSampler\",\r\n                \"lightmapSampler\",\r\n                \"refractionCubeSampler\",\r\n                \"refraction2DSampler\",\r\n                \"boneSampler\",\r\n                \"morphTargets\",\r\n                \"oitDepthSampler\",\r\n                \"oitFrontColorSampler\",\r\n            ];\r\n\r\n            const uniformBuffers = [\"Material\", \"Scene\", \"Mesh\"];\r\n\r\n            const indexParameters = { maxSimultaneousLights: this._maxSimultaneousLights, maxSimultaneousMorphTargets: defines.NUM_MORPH_INFLUENCERS };\r\n\r\n            this._eventInfo.fallbacks = fallbacks;\r\n            this._eventInfo.fallbackRank = 0;\r\n            this._eventInfo.defines = defines;\r\n            this._eventInfo.uniforms = uniforms;\r\n            this._eventInfo.attributes = attribs;\r\n            this._eventInfo.samplers = samplers;\r\n            this._eventInfo.uniformBuffersNames = uniformBuffers;\r\n            this._eventInfo.customCode = undefined;\r\n            this._eventInfo.mesh = mesh;\r\n            this._eventInfo.indexParameters = indexParameters;\r\n            this._callbackPluginEventGeneric(MaterialPluginEvent.PrepareEffect, this._eventInfo);\r\n\r\n            PrePassConfiguration.AddUniforms(uniforms);\r\n            PrePassConfiguration.AddSamplers(samplers);\r\n\r\n            if (ImageProcessingConfiguration) {\r\n                ImageProcessingConfiguration.PrepareUniforms(uniforms, defines);\r\n                ImageProcessingConfiguration.PrepareSamplers(samplers, defines);\r\n            }\r\n\r\n            PrepareUniformsAndSamplersList(<IEffectCreationOptions>{\r\n                uniformsNames: uniforms,\r\n                uniformBuffersNames: uniformBuffers,\r\n                samplers: samplers,\r\n                defines: defines,\r\n                maxSimultaneousLights: this._maxSimultaneousLights,\r\n            });\r\n\r\n            addClipPlaneUniforms(uniforms);\r\n\r\n            const csnrOptions: ICustomShaderNameResolveOptions = {};\r\n\r\n            if (this.customShaderNameResolve) {\r\n                shaderName = this.customShaderNameResolve(shaderName, uniforms, uniformBuffers, samplers, defines, attribs, csnrOptions);\r\n            }\r\n\r\n            const join = defines.toString();\r\n\r\n            const previousEffect = subMesh.effect;\r\n            let effect = scene.getEngine().createEffect(\r\n                shaderName,\r\n                <IEffectCreationOptions>{\r\n                    attributes: attribs,\r\n                    uniformsNames: uniforms,\r\n                    uniformBuffersNames: uniformBuffers,\r\n                    samplers: samplers,\r\n                    defines: join,\r\n                    fallbacks: fallbacks,\r\n                    onCompiled: this.onCompiled,\r\n                    onError: this.onError,\r\n                    indexParameters,\r\n                    processFinalCode: csnrOptions.processFinalCode,\r\n                    processCodeAfterIncludes: this._eventInfo.customCode,\r\n                    multiTarget: defines.PREPASS,\r\n                },\r\n                engine\r\n            );\r\n\r\n            this._eventInfo.customCode = undefined;\r\n\r\n            if (effect) {\r\n                if (this._onEffectCreatedObservable) {\r\n                    onCreatedEffectParameters.effect = effect;\r\n                    onCreatedEffectParameters.subMesh = subMesh;\r\n                    this._onEffectCreatedObservable.notifyObservers(onCreatedEffectParameters);\r\n                }\r\n\r\n                // Use previous effect while new one is compiling\r\n                if (this.allowShaderHotSwapping && previousEffect && !effect.isReady()) {\r\n                    effect = previousEffect;\r\n                    defines.markAsUnprocessed();\r\n\r\n                    forceWasNotReadyPreviously = this.isFrozen;\r\n\r\n                    if (lightDisposed) {\r\n                        // re register in case it takes more than one frame.\r\n                        defines._areLightsDisposed = true;\r\n                        return false;\r\n                    }\r\n                } else {\r\n                    scene.resetCachedMaterial();\r\n                    subMesh.setEffect(effect, defines, this._materialContext);\r\n                }\r\n            }\r\n        }\r\n\r\n        if (!subMesh.effect || !subMesh.effect.isReady()) {\r\n            return false;\r\n        }\r\n\r\n        defines._renderId = scene.getRenderId();\r\n        drawWrapper._wasPreviouslyReady = forceWasNotReadyPreviously ? false : true;\r\n        drawWrapper._wasPreviouslyUsingInstances = useInstances;\r\n\r\n        this._checkScenePerformancePriority();\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Builds the material UBO layouts.\r\n     * Used internally during the effect preparation.\r\n     */\r\n    public buildUniformLayout(): void {\r\n        // Order is important !\r\n        const ubo = this._uniformBuffer;\r\n        ubo.addUniform(\"diffuseLeftColor\", 4);\r\n        ubo.addUniform(\"diffuseRightColor\", 4);\r\n        ubo.addUniform(\"opacityParts\", 4);\r\n        ubo.addUniform(\"reflectionLeftColor\", 4);\r\n        ubo.addUniform(\"reflectionRightColor\", 4);\r\n        ubo.addUniform(\"refractionLeftColor\", 4);\r\n        ubo.addUniform(\"refractionRightColor\", 4);\r\n        ubo.addUniform(\"emissiveLeftColor\", 4);\r\n        ubo.addUniform(\"emissiveRightColor\", 4);\r\n\r\n        ubo.addUniform(\"vDiffuseInfos\", 2);\r\n        ubo.addUniform(\"vAmbientInfos\", 2);\r\n        ubo.addUniform(\"vOpacityInfos\", 2);\r\n        ubo.addUniform(\"vReflectionInfos\", 2);\r\n        ubo.addUniform(\"vReflectionPosition\", 3);\r\n        ubo.addUniform(\"vReflectionSize\", 3);\r\n        ubo.addUniform(\"vEmissiveInfos\", 2);\r\n        ubo.addUniform(\"vLightmapInfos\", 2);\r\n        ubo.addUniform(\"vSpecularInfos\", 2);\r\n        ubo.addUniform(\"vBumpInfos\", 3);\r\n\r\n        ubo.addUniform(\"diffuseMatrix\", 16);\r\n        ubo.addUniform(\"ambientMatrix\", 16);\r\n        ubo.addUniform(\"opacityMatrix\", 16);\r\n        ubo.addUniform(\"reflectionMatrix\", 16);\r\n        ubo.addUniform(\"emissiveMatrix\", 16);\r\n        ubo.addUniform(\"lightmapMatrix\", 16);\r\n        ubo.addUniform(\"specularMatrix\", 16);\r\n        ubo.addUniform(\"bumpMatrix\", 16);\r\n        ubo.addUniform(\"vTangentSpaceParams\", 2);\r\n        ubo.addUniform(\"pointSize\", 1);\r\n        ubo.addUniform(\"alphaCutOff\", 1);\r\n        ubo.addUniform(\"refractionMatrix\", 16);\r\n        ubo.addUniform(\"vRefractionInfos\", 4);\r\n        ubo.addUniform(\"vRefractionPosition\", 3);\r\n        ubo.addUniform(\"vRefractionSize\", 3);\r\n        ubo.addUniform(\"vSpecularColor\", 4);\r\n        ubo.addUniform(\"vEmissiveColor\", 3);\r\n        ubo.addUniform(\"vDiffuseColor\", 4);\r\n        ubo.addUniform(\"vAmbientColor\", 3);\r\n\r\n        super.buildUniformLayout();\r\n    }\r\n\r\n    /**\r\n     * Binds the submesh to this material by preparing the effect and shader to draw\r\n     * @param world defines the world transformation matrix\r\n     * @param mesh defines the mesh containing the submesh\r\n     * @param subMesh defines the submesh to bind the material to\r\n     */\r\n    public bindForSubMesh(world: Matrix, mesh: Mesh, subMesh: SubMesh): void {\r\n        const scene = this.getScene();\r\n\r\n        const defines = <StandardMaterialDefines>subMesh.materialDefines;\r\n        if (!defines) {\r\n            return;\r\n        }\r\n\r\n        const effect = subMesh.effect;\r\n        if (!effect) {\r\n            return;\r\n        }\r\n        this._activeEffect = effect;\r\n\r\n        // Matrices Mesh.\r\n        mesh.getMeshUniformBuffer().bindToEffect(effect, \"Mesh\");\r\n        mesh.transferToEffect(world);\r\n\r\n        // Binding unconditionally\r\n        this._uniformBuffer.bindToEffect(effect, \"Material\");\r\n\r\n        this.prePassConfiguration.bindForSubMesh(this._activeEffect, scene, mesh, world, this.isFrozen);\r\n\r\n        this._eventInfo.subMesh = subMesh;\r\n        this._callbackPluginEventHardBindForSubMesh(this._eventInfo);\r\n\r\n        // Normal Matrix\r\n        if (defines.OBJECTSPACE_NORMALMAP) {\r\n            world.toNormalMatrix(this._normalMatrix);\r\n            this.bindOnlyNormalMatrix(this._normalMatrix);\r\n        }\r\n\r\n        const mustRebind = this._mustRebind(scene, effect, subMesh, mesh.visibility);\r\n\r\n        // Bones\r\n        BindBonesParameters(mesh, effect);\r\n        const ubo = this._uniformBuffer;\r\n        if (mustRebind) {\r\n            this.bindViewProjection(effect);\r\n            if (!ubo.useUbo || !this.isFrozen || !ubo.isSync || subMesh._drawWrapper._forceRebindOnNextCall) {\r\n                if (StandardMaterial.FresnelEnabled && defines.FRESNEL) {\r\n                    // Fresnel\r\n                    if (this.diffuseFresnelParameters && this.diffuseFresnelParameters.isEnabled) {\r\n                        ubo.updateColor4(\"diffuseLeftColor\", this.diffuseFresnelParameters.leftColor, this.diffuseFresnelParameters.power);\r\n                        ubo.updateColor4(\"diffuseRightColor\", this.diffuseFresnelParameters.rightColor, this.diffuseFresnelParameters.bias);\r\n                    }\r\n\r\n                    if (this.opacityFresnelParameters && this.opacityFresnelParameters.isEnabled) {\r\n                        ubo.updateColor4(\r\n                            \"opacityParts\",\r\n                            new Color3(\r\n                                this.opacityFresnelParameters.leftColor.toLuminance(),\r\n                                this.opacityFresnelParameters.rightColor.toLuminance(),\r\n                                this.opacityFresnelParameters.bias\r\n                            ),\r\n                            this.opacityFresnelParameters.power\r\n                        );\r\n                    }\r\n\r\n                    if (this.reflectionFresnelParameters && this.reflectionFresnelParameters.isEnabled) {\r\n                        ubo.updateColor4(\"reflectionLeftColor\", this.reflectionFresnelParameters.leftColor, this.reflectionFresnelParameters.power);\r\n                        ubo.updateColor4(\"reflectionRightColor\", this.reflectionFresnelParameters.rightColor, this.reflectionFresnelParameters.bias);\r\n                    }\r\n\r\n                    if (this.refractionFresnelParameters && this.refractionFresnelParameters.isEnabled) {\r\n                        ubo.updateColor4(\"refractionLeftColor\", this.refractionFresnelParameters.leftColor, this.refractionFresnelParameters.power);\r\n                        ubo.updateColor4(\"refractionRightColor\", this.refractionFresnelParameters.rightColor, this.refractionFresnelParameters.bias);\r\n                    }\r\n\r\n                    if (this.emissiveFresnelParameters && this.emissiveFresnelParameters.isEnabled) {\r\n                        ubo.updateColor4(\"emissiveLeftColor\", this.emissiveFresnelParameters.leftColor, this.emissiveFresnelParameters.power);\r\n                        ubo.updateColor4(\"emissiveRightColor\", this.emissiveFresnelParameters.rightColor, this.emissiveFresnelParameters.bias);\r\n                    }\r\n                }\r\n\r\n                // Textures\r\n                if (scene.texturesEnabled) {\r\n                    if (this._diffuseTexture && StandardMaterial.DiffuseTextureEnabled) {\r\n                        ubo.updateFloat2(\"vDiffuseInfos\", this._diffuseTexture.coordinatesIndex, this._diffuseTexture.level);\r\n                        BindTextureMatrix(this._diffuseTexture, ubo, \"diffuse\");\r\n                    }\r\n\r\n                    if (this._ambientTexture && StandardMaterial.AmbientTextureEnabled) {\r\n                        ubo.updateFloat2(\"vAmbientInfos\", this._ambientTexture.coordinatesIndex, this._ambientTexture.level);\r\n                        BindTextureMatrix(this._ambientTexture, ubo, \"ambient\");\r\n                    }\r\n\r\n                    if (this._opacityTexture && StandardMaterial.OpacityTextureEnabled) {\r\n                        ubo.updateFloat2(\"vOpacityInfos\", this._opacityTexture.coordinatesIndex, this._opacityTexture.level);\r\n                        BindTextureMatrix(this._opacityTexture, ubo, \"opacity\");\r\n                    }\r\n\r\n                    if (this._hasAlphaChannel()) {\r\n                        ubo.updateFloat(\"alphaCutOff\", this.alphaCutOff);\r\n                    }\r\n\r\n                    if (this._reflectionTexture && StandardMaterial.ReflectionTextureEnabled) {\r\n                        ubo.updateFloat2(\"vReflectionInfos\", this._reflectionTexture.level, this.roughness);\r\n                        ubo.updateMatrix(\"reflectionMatrix\", this._reflectionTexture.getReflectionTextureMatrix());\r\n\r\n                        if ((<any>this._reflectionTexture).boundingBoxSize) {\r\n                            const cubeTexture = <CubeTexture>this._reflectionTexture;\r\n\r\n                            ubo.updateVector3(\"vReflectionPosition\", cubeTexture.boundingBoxPosition);\r\n                            ubo.updateVector3(\"vReflectionSize\", cubeTexture.boundingBoxSize);\r\n                        }\r\n                    }\r\n\r\n                    if (this._emissiveTexture && StandardMaterial.EmissiveTextureEnabled) {\r\n                        ubo.updateFloat2(\"vEmissiveInfos\", this._emissiveTexture.coordinatesIndex, this._emissiveTexture.level);\r\n                        BindTextureMatrix(this._emissiveTexture, ubo, \"emissive\");\r\n                    }\r\n\r\n                    if (this._lightmapTexture && StandardMaterial.LightmapTextureEnabled) {\r\n                        ubo.updateFloat2(\"vLightmapInfos\", this._lightmapTexture.coordinatesIndex, this._lightmapTexture.level);\r\n                        BindTextureMatrix(this._lightmapTexture, ubo, \"lightmap\");\r\n                    }\r\n\r\n                    if (this._specularTexture && StandardMaterial.SpecularTextureEnabled) {\r\n                        ubo.updateFloat2(\"vSpecularInfos\", this._specularTexture.coordinatesIndex, this._specularTexture.level);\r\n                        BindTextureMatrix(this._specularTexture, ubo, \"specular\");\r\n                    }\r\n\r\n                    if (this._bumpTexture && scene.getEngine().getCaps().standardDerivatives && StandardMaterial.BumpTextureEnabled) {\r\n                        ubo.updateFloat3(\"vBumpInfos\", this._bumpTexture.coordinatesIndex, 1.0 / this._bumpTexture.level, this.parallaxScaleBias);\r\n                        BindTextureMatrix(this._bumpTexture, ubo, \"bump\");\r\n\r\n                        if (scene._mirroredCameraPosition) {\r\n                            ubo.updateFloat2(\"vTangentSpaceParams\", this._invertNormalMapX ? 1.0 : -1.0, this._invertNormalMapY ? 1.0 : -1.0);\r\n                        } else {\r\n                            ubo.updateFloat2(\"vTangentSpaceParams\", this._invertNormalMapX ? -1.0 : 1.0, this._invertNormalMapY ? -1.0 : 1.0);\r\n                        }\r\n                    }\r\n\r\n                    if (this._refractionTexture && StandardMaterial.RefractionTextureEnabled) {\r\n                        let depth = 1.0;\r\n                        if (!this._refractionTexture.isCube) {\r\n                            ubo.updateMatrix(\"refractionMatrix\", this._refractionTexture.getReflectionTextureMatrix());\r\n\r\n                            if ((<any>this._refractionTexture).depth) {\r\n                                depth = (<any>this._refractionTexture).depth;\r\n                            }\r\n                        }\r\n                        ubo.updateFloat4(\"vRefractionInfos\", this._refractionTexture.level, this.indexOfRefraction, depth, this.invertRefractionY ? -1 : 1);\r\n\r\n                        if ((<any>this._refractionTexture).boundingBoxSize) {\r\n                            const cubeTexture = <CubeTexture>this._refractionTexture;\r\n\r\n                            ubo.updateVector3(\"vRefractionPosition\", cubeTexture.boundingBoxPosition);\r\n                            ubo.updateVector3(\"vRefractionSize\", cubeTexture.boundingBoxSize);\r\n                        }\r\n                    }\r\n                }\r\n\r\n                // Point size\r\n                if (this.pointsCloud) {\r\n                    ubo.updateFloat(\"pointSize\", this.pointSize);\r\n                }\r\n\r\n                if (defines.SPECULARTERM) {\r\n                    ubo.updateColor4(\"vSpecularColor\", this.specularColor, this.specularPower);\r\n                }\r\n\r\n                ubo.updateColor3(\"vEmissiveColor\", StandardMaterial.EmissiveTextureEnabled ? this.emissiveColor : Color3.BlackReadOnly);\r\n                ubo.updateColor4(\"vDiffuseColor\", this.diffuseColor, this.alpha);\r\n\r\n                scene.ambientColor.multiplyToRef(this.ambientColor, this._globalAmbientColor);\r\n                ubo.updateColor3(\"vAmbientColor\", this._globalAmbientColor);\r\n            }\r\n\r\n            // Textures\r\n            if (scene.texturesEnabled) {\r\n                if (this._diffuseTexture && StandardMaterial.DiffuseTextureEnabled) {\r\n                    effect.setTexture(\"diffuseSampler\", this._diffuseTexture);\r\n                }\r\n\r\n                if (this._ambientTexture && StandardMaterial.AmbientTextureEnabled) {\r\n                    effect.setTexture(\"ambientSampler\", this._ambientTexture);\r\n                }\r\n\r\n                if (this._opacityTexture && StandardMaterial.OpacityTextureEnabled) {\r\n                    effect.setTexture(\"opacitySampler\", this._opacityTexture);\r\n                }\r\n\r\n                if (this._reflectionTexture && StandardMaterial.ReflectionTextureEnabled) {\r\n                    if (this._reflectionTexture.isCube) {\r\n                        effect.setTexture(\"reflectionCubeSampler\", this._reflectionTexture);\r\n                    } else {\r\n                        effect.setTexture(\"reflection2DSampler\", this._reflectionTexture);\r\n                    }\r\n                }\r\n\r\n                if (this._emissiveTexture && StandardMaterial.EmissiveTextureEnabled) {\r\n                    effect.setTexture(\"emissiveSampler\", this._emissiveTexture);\r\n                }\r\n\r\n                if (this._lightmapTexture && StandardMaterial.LightmapTextureEnabled) {\r\n                    effect.setTexture(\"lightmapSampler\", this._lightmapTexture);\r\n                }\r\n\r\n                if (this._specularTexture && StandardMaterial.SpecularTextureEnabled) {\r\n                    effect.setTexture(\"specularSampler\", this._specularTexture);\r\n                }\r\n\r\n                if (this._bumpTexture && scene.getEngine().getCaps().standardDerivatives && StandardMaterial.BumpTextureEnabled) {\r\n                    effect.setTexture(\"bumpSampler\", this._bumpTexture);\r\n                }\r\n\r\n                if (this._refractionTexture && StandardMaterial.RefractionTextureEnabled) {\r\n                    if (this._refractionTexture.isCube) {\r\n                        effect.setTexture(\"refractionCubeSampler\", this._refractionTexture);\r\n                    } else {\r\n                        effect.setTexture(\"refraction2DSampler\", this._refractionTexture);\r\n                    }\r\n                }\r\n            }\r\n\r\n            // OIT with depth peeling\r\n            if (this.getScene().useOrderIndependentTransparency && this.needAlphaBlendingForMesh(mesh)) {\r\n                this.getScene().depthPeelingRenderer!.bind(effect);\r\n            }\r\n\r\n            this._eventInfo.subMesh = subMesh;\r\n            this._callbackPluginEventBindForSubMesh(this._eventInfo);\r\n\r\n            // Clip plane\r\n            bindClipPlane(effect, this, scene);\r\n\r\n            // Colors\r\n            this.bindEyePosition(effect);\r\n        } else if (scene.getEngine()._features.needToAlwaysBindUniformBuffers) {\r\n            this._needToBindSceneUbo = true;\r\n        }\r\n\r\n        if (mustRebind || !this.isFrozen) {\r\n            // Lights\r\n            if (scene.lightsEnabled && !this._disableLighting) {\r\n                BindLights(scene, mesh, effect, defines, this._maxSimultaneousLights);\r\n            }\r\n\r\n            // View\r\n            if (\r\n                (scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE) ||\r\n                this._reflectionTexture ||\r\n                this._refractionTexture ||\r\n                mesh.receiveShadows ||\r\n                defines.PREPASS\r\n            ) {\r\n                this.bindView(effect);\r\n            }\r\n\r\n            // Fog\r\n            BindFogParameters(scene, mesh, effect);\r\n\r\n            // Morph targets\r\n            if (defines.NUM_MORPH_INFLUENCERS) {\r\n                BindMorphTargetParameters(mesh, effect);\r\n            }\r\n\r\n            if (defines.BAKED_VERTEX_ANIMATION_TEXTURE) {\r\n                mesh.bakedVertexAnimationManager?.bind(effect, defines.INSTANCES);\r\n            }\r\n\r\n            // Log. depth\r\n            if (this.useLogarithmicDepth) {\r\n                BindLogDepth(defines, effect, scene);\r\n            }\r\n\r\n            // image processing\r\n            if (this._imageProcessingConfiguration && !this._imageProcessingConfiguration.applyByPostProcess) {\r\n                this._imageProcessingConfiguration.bind(this._activeEffect);\r\n            }\r\n        }\r\n\r\n        this._afterBind(mesh, this._activeEffect, subMesh);\r\n        ubo.update();\r\n    }\r\n\r\n    /**\r\n     * Get the list of animatables in the material.\r\n     * @returns the list of animatables object used in the material\r\n     */\r\n    public getAnimatables(): IAnimatable[] {\r\n        const results = super.getAnimatables();\r\n\r\n        if (this._diffuseTexture && this._diffuseTexture.animations && this._diffuseTexture.animations.length > 0) {\r\n            results.push(this._diffuseTexture);\r\n        }\r\n\r\n        if (this._ambientTexture && this._ambientTexture.animations && this._ambientTexture.animations.length > 0) {\r\n            results.push(this._ambientTexture);\r\n        }\r\n\r\n        if (this._opacityTexture && this._opacityTexture.animations && this._opacityTexture.animations.length > 0) {\r\n            results.push(this._opacityTexture);\r\n        }\r\n\r\n        if (this._reflectionTexture && this._reflectionTexture.animations && this._reflectionTexture.animations.length > 0) {\r\n            results.push(this._reflectionTexture);\r\n        }\r\n\r\n        if (this._emissiveTexture && this._emissiveTexture.animations && this._emissiveTexture.animations.length > 0) {\r\n            results.push(this._emissiveTexture);\r\n        }\r\n\r\n        if (this._specularTexture && this._specularTexture.animations && this._specularTexture.animations.length > 0) {\r\n            results.push(this._specularTexture);\r\n        }\r\n\r\n        if (this._bumpTexture && this._bumpTexture.animations && this._bumpTexture.animations.length > 0) {\r\n            results.push(this._bumpTexture);\r\n        }\r\n\r\n        if (this._lightmapTexture && this._lightmapTexture.animations && this._lightmapTexture.animations.length > 0) {\r\n            results.push(this._lightmapTexture);\r\n        }\r\n\r\n        if (this._refractionTexture && this._refractionTexture.animations && this._refractionTexture.animations.length > 0) {\r\n            results.push(this._refractionTexture);\r\n        }\r\n\r\n        return results;\r\n    }\r\n\r\n    /**\r\n     * Gets the active textures from the material\r\n     * @returns an array of textures\r\n     */\r\n    public getActiveTextures(): BaseTexture[] {\r\n        const activeTextures = super.getActiveTextures();\r\n\r\n        if (this._diffuseTexture) {\r\n            activeTextures.push(this._diffuseTexture);\r\n        }\r\n\r\n        if (this._ambientTexture) {\r\n            activeTextures.push(this._ambientTexture);\r\n        }\r\n\r\n        if (this._opacityTexture) {\r\n            activeTextures.push(this._opacityTexture);\r\n        }\r\n\r\n        if (this._reflectionTexture) {\r\n            activeTextures.push(this._reflectionTexture);\r\n        }\r\n\r\n        if (this._emissiveTexture) {\r\n            activeTextures.push(this._emissiveTexture);\r\n        }\r\n\r\n        if (this._specularTexture) {\r\n            activeTextures.push(this._specularTexture);\r\n        }\r\n\r\n        if (this._bumpTexture) {\r\n            activeTextures.push(this._bumpTexture);\r\n        }\r\n\r\n        if (this._lightmapTexture) {\r\n            activeTextures.push(this._lightmapTexture);\r\n        }\r\n\r\n        if (this._refractionTexture) {\r\n            activeTextures.push(this._refractionTexture);\r\n        }\r\n\r\n        return activeTextures;\r\n    }\r\n\r\n    /**\r\n     * Specifies if the material uses a texture\r\n     * @param texture defines the texture to check against the material\r\n     * @returns a boolean specifying if the material uses the texture\r\n     */\r\n    public hasTexture(texture: BaseTexture): boolean {\r\n        if (super.hasTexture(texture)) {\r\n            return true;\r\n        }\r\n\r\n        if (this._diffuseTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._ambientTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._opacityTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._reflectionTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._emissiveTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._specularTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._bumpTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._lightmapTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        if (this._refractionTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Disposes the material\r\n     * @param forceDisposeEffect specifies if effects should be forcefully disposed\r\n     * @param forceDisposeTextures specifies if textures should be forcefully disposed\r\n     */\r\n    public dispose(forceDisposeEffect?: boolean, forceDisposeTextures?: boolean): void {\r\n        if (forceDisposeTextures) {\r\n            this._diffuseTexture?.dispose();\r\n            this._ambientTexture?.dispose();\r\n            this._opacityTexture?.dispose();\r\n            this._reflectionTexture?.dispose();\r\n            this._emissiveTexture?.dispose();\r\n            this._specularTexture?.dispose();\r\n            this._bumpTexture?.dispose();\r\n            this._lightmapTexture?.dispose();\r\n            this._refractionTexture?.dispose();\r\n        }\r\n\r\n        if (this._imageProcessingConfiguration && this._imageProcessingObserver) {\r\n            this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver);\r\n        }\r\n\r\n        super.dispose(forceDisposeEffect, forceDisposeTextures);\r\n    }\r\n\r\n    /**\r\n     * Makes a duplicate of the material, and gives it a new name\r\n     * @param name defines the new name for the duplicated material\r\n     * @param cloneTexturesOnlyOnce - if a texture is used in more than one channel (e.g diffuse and opacity), only clone it once and reuse it on the other channels. Default false.\r\n     * @param rootUrl defines the root URL to use to load textures\r\n     * @returns the cloned material\r\n     */\r\n    public clone(name: string, cloneTexturesOnlyOnce: boolean = true, rootUrl = \"\"): StandardMaterial {\r\n        const result = SerializationHelper.Clone(() => new StandardMaterial(name, this.getScene()), this, { cloneTexturesOnlyOnce });\r\n\r\n        result.name = name;\r\n        result.id = name;\r\n\r\n        this.stencil.copyTo(result.stencil);\r\n\r\n        this._clonePlugins(result, rootUrl);\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Creates a standard material from parsed material data\r\n     * @param source defines the JSON representation of the material\r\n     * @param scene defines the hosting scene\r\n     * @param rootUrl defines the root URL to use to load textures and relative dependencies\r\n     * @returns a new standard material\r\n     */\r\n    public static Parse(source: any, scene: Scene, rootUrl: string): StandardMaterial {\r\n        const material = SerializationHelper.Parse(() => new StandardMaterial(source.name, scene), source, scene, rootUrl);\r\n\r\n        if (source.stencil) {\r\n            material.stencil.parse(source.stencil, scene, rootUrl);\r\n        }\r\n\r\n        Material._ParsePlugins(source, material, scene, rootUrl);\r\n\r\n        return material;\r\n    }\r\n\r\n    // Flags used to enable or disable a type of texture for all Standard Materials\r\n    /**\r\n     * Are diffuse textures enabled in the application.\r\n     */\r\n    public static get DiffuseTextureEnabled(): boolean {\r\n        return MaterialFlags.DiffuseTextureEnabled;\r\n    }\r\n    public static set DiffuseTextureEnabled(value: boolean) {\r\n        MaterialFlags.DiffuseTextureEnabled = value;\r\n    }\r\n\r\n    /**\r\n     * Are detail textures enabled in the application.\r\n     */\r\n    public static get DetailTextureEnabled(): boolean {\r\n        return MaterialFlags.DetailTextureEnabled;\r\n    }\r\n    public static set DetailTextureEnabled(value: boolean) {\r\n        MaterialFlags.DetailTextureEnabled = value;\r\n    }\r\n\r\n    /**\r\n     * Are ambient textures enabled in the application.\r\n     */\r\n    public static get AmbientTextureEnabled(): boolean {\r\n        return MaterialFlags.AmbientTextureEnabled;\r\n    }\r\n    public static set AmbientTextureEnabled(value: boolean) {\r\n        MaterialFlags.AmbientTextureEnabled = value;\r\n    }\r\n\r\n    /**\r\n     * Are opacity textures enabled in the application.\r\n     */\r\n    public static get OpacityTextureEnabled(): boolean {\r\n        return MaterialFlags.OpacityTextureEnabled;\r\n    }\r\n    public static set OpacityTextureEnabled(value: boolean) {\r\n        MaterialFlags.OpacityTextureEnabled = value;\r\n    }\r\n\r\n    /**\r\n     * Are reflection textures enabled in the application.\r\n     */\r\n    public static get ReflectionTextureEnabled(): boolean {\r\n        return MaterialFlags.ReflectionTextureEnabled;\r\n    }\r\n    public static set ReflectionTextureEnabled(value: boolean) {\r\n        MaterialFlags.ReflectionTextureEnabled = value;\r\n    }\r\n\r\n    /**\r\n     * Are emissive textures enabled in the application.\r\n     */\r\n    public static get EmissiveTextureEnabled(): boolean {\r\n        return MaterialFlags.EmissiveTextureEnabled;\r\n    }\r\n    public static set EmissiveTextureEnabled(value: boolean) {\r\n        MaterialFlags.EmissiveTextureEnabled = value;\r\n    }\r\n\r\n    /**\r\n     * Are specular textures enabled in the application.\r\n     */\r\n    public static get SpecularTextureEnabled(): boolean {\r\n        return MaterialFlags.SpecularTextureEnabled;\r\n    }\r\n    public static set SpecularTextureEnabled(value: boolean) {\r\n        MaterialFlags.SpecularTextureEnabled = value;\r\n    }\r\n\r\n    /**\r\n     * Are bump textures enabled in the application.\r\n     */\r\n    public static get BumpTextureEnabled(): boolean {\r\n        return MaterialFlags.BumpTextureEnabled;\r\n    }\r\n    public static set BumpTextureEnabled(value: boolean) {\r\n        MaterialFlags.BumpTextureEnabled = value;\r\n    }\r\n\r\n    /**\r\n     * Are lightmap textures enabled in the application.\r\n     */\r\n    public static get LightmapTextureEnabled(): boolean {\r\n        return MaterialFlags.LightmapTextureEnabled;\r\n    }\r\n    public static set LightmapTextureEnabled(value: boolean) {\r\n        MaterialFlags.LightmapTextureEnabled = value;\r\n    }\r\n\r\n    /**\r\n     * Are refraction textures enabled in the application.\r\n     */\r\n    public static get RefractionTextureEnabled(): boolean {\r\n        return MaterialFlags.RefractionTextureEnabled;\r\n    }\r\n    public static set RefractionTextureEnabled(value: boolean) {\r\n        MaterialFlags.RefractionTextureEnabled = value;\r\n    }\r\n\r\n    /**\r\n     * Are color grading textures enabled in the application.\r\n     */\r\n    public static get ColorGradingTextureEnabled(): boolean {\r\n        return MaterialFlags.ColorGradingTextureEnabled;\r\n    }\r\n    public static set ColorGradingTextureEnabled(value: boolean) {\r\n        MaterialFlags.ColorGradingTextureEnabled = value;\r\n    }\r\n\r\n    /**\r\n     * Are fresnels enabled in the application.\r\n     */\r\n    public static get FresnelEnabled(): boolean {\r\n        return MaterialFlags.FresnelEnabled;\r\n    }\r\n    public static set FresnelEnabled(value: boolean) {\r\n        MaterialFlags.FresnelEnabled = value;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.StandardMaterial\", StandardMaterial);\r\n\r\nScene.DefaultMaterialFactory = (scene: Scene) => {\r\n    return new StandardMaterial(\"default material\", scene);\r\n};\r\n", "import { SerializationHelper } from \"../Misc/decorators.serialization\";\r\nimport type { Nullable } from \"../types\";\r\nimport { Scene } from \"../scene\";\r\nimport { Matrix, Vector3, Vector2, Vector4, Quaternion } from \"../Maths/math.vector\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { Mesh } from \"../Meshes/mesh\";\r\nimport type { SubMesh } from \"../Meshes/subMesh\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport type { BaseTexture } from \"../Materials/Textures/baseTexture\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport type { Effect, IEffectCreationOptions } from \"./effect\";\r\nimport { RegisterClass } from \"../Misc/typeStore\";\r\nimport { Color3, Color4 } from \"../Maths/math.color\";\r\nimport { EffectFallbacks } from \"./effectFallbacks\";\r\nimport { WebRequest } from \"../Misc/webRequest\";\r\nimport type { ShaderLanguage } from \"./shaderLanguage\";\r\nimport type { UniformBuffer } from \"./uniformBuffer\";\r\nimport type { TextureSampler } from \"./Textures/textureSampler\";\r\nimport type { StorageBuffer } from \"../Buffers/storageBuffer\";\r\nimport { PushMaterial } from \"./pushMaterial\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { addClipPlaneUniforms, bindClipPlane, prepareStringDefinesForClipPlanes } from \"./clipPlaneMaterialHelper\";\r\n\r\nimport type { ExternalTexture } from \"./Textures/externalTexture\";\r\nimport {\r\n    BindBonesParameters,\r\n    BindFogParameters,\r\n    BindLogDepth,\r\n    BindMorphTargetParameters,\r\n    BindSceneUniformBuffer,\r\n    PrepareAttributesForBakedVertexAnimation,\r\n    PushAttributesForInstances,\r\n} from \"./materialHelper.functions\";\r\n\r\nconst onCreatedEffectParameters = { effect: null as unknown as Effect, subMesh: null as unknown as Nullable<SubMesh> };\r\n\r\n/**\r\n * Defines the options associated with the creation of a shader material.\r\n */\r\nexport interface IShaderMaterialOptions {\r\n    /**\r\n     * Does the material work in alpha blend mode\r\n     */\r\n    needAlphaBlending: boolean;\r\n\r\n    /**\r\n     * Does the material work in alpha test mode\r\n     */\r\n    needAlphaTesting: boolean;\r\n\r\n    /**\r\n     * The list of attribute names used in the shader\r\n     */\r\n    attributes: string[];\r\n\r\n    /**\r\n     * The list of uniform names used in the shader\r\n     */\r\n    uniforms: string[];\r\n\r\n    /**\r\n     * The list of UBO names used in the shader\r\n     */\r\n    uniformBuffers: string[];\r\n\r\n    /**\r\n     * The list of sampler (texture) names used in the shader\r\n     */\r\n    samplers: string[];\r\n\r\n    /**\r\n     * The list of external texture names used in the shader\r\n     */\r\n    externalTextures: string[];\r\n\r\n    /**\r\n     * The list of sampler object names used in the shader\r\n     */\r\n    samplerObjects: string[];\r\n\r\n    /**\r\n     * The list of storage buffer names used in the shader\r\n     */\r\n    storageBuffers: string[];\r\n\r\n    /**\r\n     * The list of defines used in the shader\r\n     */\r\n    defines: string[];\r\n\r\n    /**\r\n     * Defines if clip planes have to be turned on: true to turn them on, false to turn them off and null to turn them on/off depending on the scene configuration (scene.clipPlaneX)\r\n     */\r\n    useClipPlane: Nullable<boolean>;\r\n\r\n    /**\r\n     * The language the shader is written in (default: GLSL)\r\n     */\r\n    shaderLanguage?: ShaderLanguage;\r\n}\r\n\r\n/**\r\n * The ShaderMaterial object has the necessary methods to pass data from your scene to the Vertex and Fragment Shaders and returns a material that can be applied to any mesh.\r\n *\r\n * This returned material effects how the mesh will look based on the code in the shaders.\r\n *\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/shaders/shaderMaterial\r\n */\r\nexport class ShaderMaterial extends PushMaterial {\r\n    private _shaderPath: any;\r\n    private _options: IShaderMaterialOptions;\r\n    private _textures: { [name: string]: BaseTexture } = {};\r\n    private _textureArrays: { [name: string]: BaseTexture[] } = {};\r\n    private _externalTextures: { [name: string]: ExternalTexture } = {};\r\n    private _floats: { [name: string]: number } = {};\r\n    private _ints: { [name: string]: number } = {};\r\n    private _uints: { [name: string]: number } = {};\r\n    private _floatsArrays: { [name: string]: number[] } = {};\r\n    private _colors3: { [name: string]: Color3 } = {};\r\n    private _colors3Arrays: { [name: string]: number[] } = {};\r\n    private _colors4: { [name: string]: Color4 } = {};\r\n    private _colors4Arrays: { [name: string]: number[] } = {};\r\n    private _vectors2: { [name: string]: Vector2 } = {};\r\n    private _vectors3: { [name: string]: Vector3 } = {};\r\n    private _vectors4: { [name: string]: Vector4 } = {};\r\n    private _quaternions: { [name: string]: Quaternion } = {};\r\n    private _quaternionsArrays: { [name: string]: number[] } = {};\r\n    private _matrices: { [name: string]: Matrix } = {};\r\n    private _matrixArrays: { [name: string]: Float32Array | Array<number> } = {};\r\n    private _matrices3x3: { [name: string]: Float32Array | Array<number> } = {};\r\n    private _matrices2x2: { [name: string]: Float32Array | Array<number> } = {};\r\n    private _vectors2Arrays: { [name: string]: number[] } = {};\r\n    private _vectors3Arrays: { [name: string]: number[] } = {};\r\n    private _vectors4Arrays: { [name: string]: number[] } = {};\r\n    private _uniformBuffers: { [name: string]: UniformBuffer } = {};\r\n    private _textureSamplers: { [name: string]: TextureSampler } = {};\r\n    private _storageBuffers: { [name: string]: StorageBuffer } = {};\r\n    private _cachedWorldViewMatrix = new Matrix();\r\n    private _cachedWorldViewProjectionMatrix = new Matrix();\r\n    private _multiview = false;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _materialHelperNeedsPreviousMatrices = false;\r\n\r\n    /** Define the Url to load snippets */\r\n    public static SnippetUrl = Constants.SnippetUrl;\r\n\r\n    /** Snippet ID if the material was created from the snippet server */\r\n    public snippetId: string;\r\n\r\n    /**\r\n     * Instantiate a new shader material.\r\n     * The ShaderMaterial object has the necessary methods to pass data from your scene to the Vertex and Fragment Shaders and returns a material that can be applied to any mesh.\r\n     * This returned material effects how the mesh will look based on the code in the shaders.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/shaders/shaderMaterial\r\n     * @param name Define the name of the material in the scene\r\n     * @param scene Define the scene the material belongs to\r\n     * @param shaderPath Defines  the route to the shader code in one of three ways:\r\n     *  * object: \\{ vertex: \"custom\", fragment: \"custom\" \\}, used with Effect.ShadersStore[\"customVertexShader\"] and Effect.ShadersStore[\"customFragmentShader\"]\r\n     *  * object: \\{ vertexElement: \"vertexShaderCode\", fragmentElement: \"fragmentShaderCode\" \\}, used with shader code in script tags\r\n     *  * object: \\{ vertexSource: \"vertex shader code string\", fragmentSource: \"fragment shader code string\" \\} using with strings containing the shaders code\r\n     *  * string: \"./COMMON_NAME\", used with external files COMMON_NAME.vertex.fx and COMMON_NAME.fragment.fx in index.html folder.\r\n     * @param options Define the options used to create the shader\r\n     * @param storeEffectOnSubMeshes true to store effect on submeshes, false to store the effect directly in the material class.\r\n     */\r\n    constructor(name: string, scene: Scene, shaderPath: any, options: Partial<IShaderMaterialOptions> = {}, storeEffectOnSubMeshes = true) {\r\n        super(name, scene, storeEffectOnSubMeshes);\r\n        this._shaderPath = shaderPath;\r\n\r\n        this._options = {\r\n            needAlphaBlending: false,\r\n            needAlphaTesting: false,\r\n            attributes: [\"position\", \"normal\", \"uv\"],\r\n            uniforms: [\"worldViewProjection\"],\r\n            uniformBuffers: [],\r\n            samplers: [],\r\n            externalTextures: [],\r\n            samplerObjects: [],\r\n            storageBuffers: [],\r\n            defines: [],\r\n            useClipPlane: false,\r\n            ...options,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Gets the shader path used to define the shader code\r\n     * It can be modified to trigger a new compilation\r\n     */\r\n    public get shaderPath(): any {\r\n        return this._shaderPath;\r\n    }\r\n\r\n    /**\r\n     * Sets the shader path used to define the shader code\r\n     * It can be modified to trigger a new compilation\r\n     */\r\n    public set shaderPath(shaderPath: any) {\r\n        this._shaderPath = shaderPath;\r\n    }\r\n\r\n    /**\r\n     * Gets the options used to compile the shader.\r\n     * They can be modified to trigger a new compilation\r\n     */\r\n    public get options(): IShaderMaterialOptions {\r\n        return this._options;\r\n    }\r\n\r\n    /**\r\n     * is multiview set to true?\r\n     */\r\n    public get isMultiview(): boolean {\r\n        return this._multiview;\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name of the material e.g. \"ShaderMaterial\"\r\n     * Mainly use in serialization.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"ShaderMaterial\";\r\n    }\r\n\r\n    /**\r\n     * Specifies if the material will require alpha blending\r\n     * @returns a boolean specifying if alpha blending is needed\r\n     */\r\n    public needAlphaBlending(): boolean {\r\n        return this.alpha < 1.0 || this._options.needAlphaBlending;\r\n    }\r\n\r\n    /**\r\n     * Specifies if this material should be rendered in alpha test mode\r\n     * @returns a boolean specifying if an alpha test is needed.\r\n     */\r\n    public needAlphaTesting(): boolean {\r\n        return this._options.needAlphaTesting;\r\n    }\r\n\r\n    private _checkUniform(uniformName: string): void {\r\n        if (this._options.uniforms.indexOf(uniformName) === -1) {\r\n            this._options.uniforms.push(uniformName);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set a texture in the shader.\r\n     * @param name Define the name of the uniform samplers as defined in the shader\r\n     * @param texture Define the texture to bind to this sampler\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setTexture(name: string, texture: BaseTexture): ShaderMaterial {\r\n        if (this._options.samplers.indexOf(name) === -1) {\r\n            this._options.samplers.push(name);\r\n        }\r\n        this._textures[name] = texture;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a texture array in the shader.\r\n     * @param name Define the name of the uniform sampler array as defined in the shader\r\n     * @param textures Define the list of textures to bind to this sampler\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setTextureArray(name: string, textures: BaseTexture[]): ShaderMaterial {\r\n        if (this._options.samplers.indexOf(name) === -1) {\r\n            this._options.samplers.push(name);\r\n        }\r\n\r\n        this._checkUniform(name);\r\n\r\n        this._textureArrays[name] = textures;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set an internal texture in the shader.\r\n     * @param name Define the name of the uniform samplers as defined in the shader\r\n     * @param texture Define the texture to bind to this sampler\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setExternalTexture(name: string, texture: ExternalTexture): ShaderMaterial {\r\n        if (this._options.externalTextures.indexOf(name) === -1) {\r\n            this._options.externalTextures.push(name);\r\n        }\r\n        this._externalTextures[name] = texture;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a float in the shader.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setFloat(name: string, value: number): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._floats[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a int in the shader.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setInt(name: string, value: number): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._ints[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a unsigned int in the shader.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setUInt(name: string, value: number): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._uints[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set an array of floats in the shader.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setFloats(name: string, value: number[]): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._floatsArrays[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec3 in the shader from a Color3.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setColor3(name: string, value: Color3): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._colors3[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec3 array in the shader from a Color3 array.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setColor3Array(name: string, value: Color3[]): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._colors3Arrays[name] = value.reduce((arr, color) => {\r\n            color.toArray(arr, arr.length);\r\n            return arr;\r\n        }, []);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec4 in the shader from a Color4.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setColor4(name: string, value: Color4): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._colors4[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec4 array in the shader from a Color4 array.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setColor4Array(name: string, value: Color4[]): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._colors4Arrays[name] = value.reduce((arr, color) => {\r\n            color.toArray(arr, arr.length);\r\n            return arr;\r\n        }, []);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec2 in the shader from a Vector2.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setVector2(name: string, value: Vector2): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._vectors2[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec3 in the shader from a Vector3.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setVector3(name: string, value: Vector3): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._vectors3[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec4 in the shader from a Vector4.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setVector4(name: string, value: Vector4): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._vectors4[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec4 in the shader from a Quaternion.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setQuaternion(name: string, value: Quaternion): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._quaternions[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec4 array in the shader from a Quaternion array.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setQuaternionArray(name: string, value: Quaternion[]): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._quaternionsArrays[name] = value.reduce((arr, quaternion) => {\r\n            quaternion.toArray(arr, arr.length);\r\n            return arr;\r\n        }, []);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a mat4 in the shader from a Matrix.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setMatrix(name: string, value: Matrix): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._matrices[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a float32Array in the shader from a matrix array.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setMatrices(name: string, value: Matrix[]): ShaderMaterial {\r\n        this._checkUniform(name);\r\n\r\n        const float32Array = new Float32Array(value.length * 16);\r\n\r\n        for (let index = 0; index < value.length; index++) {\r\n            const matrix = value[index];\r\n\r\n            matrix.copyToArray(float32Array, index * 16);\r\n        }\r\n\r\n        this._matrixArrays[name] = float32Array;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a mat3 in the shader from a Float32Array.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setMatrix3x3(name: string, value: Float32Array | Array<number>): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._matrices3x3[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a mat2 in the shader from a Float32Array.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setMatrix2x2(name: string, value: Float32Array | Array<number>): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._matrices2x2[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec2 array in the shader from a number array.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setArray2(name: string, value: number[]): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._vectors2Arrays[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec3 array in the shader from a number array.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setArray3(name: string, value: number[]): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._vectors3Arrays[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec4 array in the shader from a number array.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setArray4(name: string, value: number[]): ShaderMaterial {\r\n        this._checkUniform(name);\r\n        this._vectors4Arrays[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a uniform buffer in the shader\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param buffer Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setUniformBuffer(name: string, buffer: UniformBuffer): ShaderMaterial {\r\n        if (this._options.uniformBuffers.indexOf(name) === -1) {\r\n            this._options.uniformBuffers.push(name);\r\n        }\r\n        this._uniformBuffers[name] = buffer;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a texture sampler in the shader\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param sampler Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setTextureSampler(name: string, sampler: TextureSampler): ShaderMaterial {\r\n        if (this._options.samplerObjects.indexOf(name) === -1) {\r\n            this._options.samplerObjects.push(name);\r\n        }\r\n        this._textureSamplers[name] = sampler;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a storage buffer in the shader\r\n     * @param name Define the name of the storage buffer as defined in the shader\r\n     * @param buffer Define the value to give to the uniform\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setStorageBuffer(name: string, buffer: StorageBuffer): ShaderMaterial {\r\n        if (this._options.storageBuffers.indexOf(name) === -1) {\r\n            this._options.storageBuffers.push(name);\r\n        }\r\n        this._storageBuffers[name] = buffer;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Adds, removes, or replaces the specified shader define and value.\r\n     * * setDefine(\"MY_DEFINE\", true); // enables a boolean define\r\n     * * setDefine(\"MY_DEFINE\", \"0.5\"); // adds \"#define MY_DEFINE 0.5\" to the shader (or sets and replaces the value of any existing define with that name)\r\n     * * setDefine(\"MY_DEFINE\", false); // disables and removes the define\r\n     * Note if the active defines do change, the shader will be recompiled and this can be expensive.\r\n     * @param define the define name e.g., \"OUTPUT_TO_SRGB\" or \"#define OUTPUT_TO_SRGB\". If the define was passed into the constructor already, the version used should match that, and in either case, it should not include any appended value.\r\n     * @param value either the value of the define (e.g. a numerical value) or for booleans, true if the define should be enabled or false if it should be disabled\r\n     * @returns the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setDefine(define: string, value: boolean | string): ShaderMaterial {\r\n        // First remove any existing define with this name.\r\n        const defineName = define.trimEnd() + \" \";\r\n        const existingDefineIdx = this.options.defines.findIndex((x) => x === define || x.startsWith(defineName));\r\n        if (existingDefineIdx >= 0) {\r\n            this.options.defines.splice(existingDefineIdx, 1);\r\n        }\r\n\r\n        // Then add the new define value. (If it's a boolean value and false, don't add it.)\r\n        if (typeof value !== \"boolean\" || value) {\r\n            this.options.defines.push(defineName + value);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Specifies that the submesh is ready to be used\r\n     * @param mesh defines the mesh to check\r\n     * @param subMesh defines which submesh to check\r\n     * @param useInstances specifies that instances should be used\r\n     * @returns a boolean indicating that the submesh is ready or not\r\n     */\r\n    public isReadyForSubMesh(mesh: AbstractMesh, subMesh: SubMesh, useInstances?: boolean): boolean {\r\n        return this.isReady(mesh, useInstances, subMesh);\r\n    }\r\n\r\n    /**\r\n     * Checks if the material is ready to render the requested mesh\r\n     * @param mesh Define the mesh to render\r\n     * @param useInstances Define whether or not the material is used with instances\r\n     * @param subMesh defines which submesh to render\r\n     * @returns true if ready, otherwise false\r\n     */\r\n    public isReady(mesh?: AbstractMesh, useInstances?: boolean, subMesh?: SubMesh): boolean {\r\n        const storeEffectOnSubMeshes = subMesh && this._storeEffectOnSubMeshes;\r\n\r\n        if (this.isFrozen) {\r\n            const drawWrapper = storeEffectOnSubMeshes ? subMesh._drawWrapper : this._drawWrapper;\r\n            if (drawWrapper.effect && drawWrapper._wasPreviouslyReady && drawWrapper._wasPreviouslyUsingInstances === useInstances) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        const scene = this.getScene();\r\n        const engine = scene.getEngine();\r\n\r\n        // Instances\r\n        const defines = [];\r\n        const attribs = [];\r\n        const fallbacks = new EffectFallbacks();\r\n\r\n        let shaderName = this._shaderPath,\r\n            uniforms = this._options.uniforms,\r\n            uniformBuffers = this._options.uniformBuffers,\r\n            samplers = this._options.samplers;\r\n\r\n        // global multiview\r\n        if (engine.getCaps().multiview && scene.activeCamera && scene.activeCamera.outputRenderTarget && scene.activeCamera.outputRenderTarget.getViewCount() > 1) {\r\n            this._multiview = true;\r\n            defines.push(\"#define MULTIVIEW\");\r\n            if (uniforms.indexOf(\"viewProjection\") !== -1 && uniforms.indexOf(\"viewProjectionR\") === -1) {\r\n                uniforms.push(\"viewProjectionR\");\r\n            }\r\n        }\r\n\r\n        for (let index = 0; index < this._options.defines.length; index++) {\r\n            const defineToAdd = this._options.defines[index].indexOf(\"#define\") === 0 ? this._options.defines[index] : `#define ${this._options.defines[index]}`;\r\n            defines.push(defineToAdd);\r\n        }\r\n\r\n        for (let index = 0; index < this._options.attributes.length; index++) {\r\n            attribs.push(this._options.attributes[index]);\r\n        }\r\n\r\n        if (mesh && mesh.isVerticesDataPresent(VertexBuffer.ColorKind)) {\r\n            if (attribs.indexOf(VertexBuffer.ColorKind) === -1) {\r\n                attribs.push(VertexBuffer.ColorKind);\r\n            }\r\n            defines.push(\"#define VERTEXCOLOR\");\r\n        }\r\n\r\n        if (useInstances) {\r\n            defines.push(\"#define INSTANCES\");\r\n            PushAttributesForInstances(attribs, this._materialHelperNeedsPreviousMatrices);\r\n            if (mesh?.hasThinInstances) {\r\n                defines.push(\"#define THIN_INSTANCES\");\r\n                if (mesh && mesh.isVerticesDataPresent(VertexBuffer.ColorInstanceKind)) {\r\n                    attribs.push(VertexBuffer.ColorInstanceKind);\r\n                    defines.push(\"#define INSTANCESCOLOR\");\r\n                }\r\n            }\r\n        }\r\n\r\n        // Bones\r\n        if (mesh && mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton) {\r\n            attribs.push(VertexBuffer.MatricesIndicesKind);\r\n            attribs.push(VertexBuffer.MatricesWeightsKind);\r\n            if (mesh.numBoneInfluencers > 4) {\r\n                attribs.push(VertexBuffer.MatricesIndicesExtraKind);\r\n                attribs.push(VertexBuffer.MatricesWeightsExtraKind);\r\n            }\r\n\r\n            const skeleton = mesh.skeleton;\r\n\r\n            defines.push(\"#define NUM_BONE_INFLUENCERS \" + mesh.numBoneInfluencers);\r\n            fallbacks.addCPUSkinningFallback(0, mesh);\r\n\r\n            if (skeleton.isUsingTextureForMatrices) {\r\n                defines.push(\"#define BONETEXTURE\");\r\n\r\n                if (uniforms.indexOf(\"boneTextureWidth\") === -1) {\r\n                    uniforms.push(\"boneTextureWidth\");\r\n                }\r\n\r\n                if (this._options.samplers.indexOf(\"boneSampler\") === -1) {\r\n                    this._options.samplers.push(\"boneSampler\");\r\n                }\r\n            } else {\r\n                defines.push(\"#define BonesPerMesh \" + (skeleton.bones.length + 1));\r\n\r\n                if (uniforms.indexOf(\"mBones\") === -1) {\r\n                    uniforms.push(\"mBones\");\r\n                }\r\n            }\r\n        } else {\r\n            defines.push(\"#define NUM_BONE_INFLUENCERS 0\");\r\n        }\r\n\r\n        // Morph\r\n        let numInfluencers = 0;\r\n        const manager = mesh ? (<Mesh>mesh).morphTargetManager : null;\r\n        if (manager) {\r\n            const uv = manager.supportsUVs && defines.indexOf(\"#define UV1\") !== -1;\r\n            const tangent = manager.supportsTangents && defines.indexOf(\"#define TANGENT\") !== -1;\r\n            const normal = manager.supportsNormals && defines.indexOf(\"#define NORMAL\") !== -1;\r\n            numInfluencers = manager.numMaxInfluencers || manager.numInfluencers;\r\n            if (uv) {\r\n                defines.push(\"#define MORPHTARGETS_UV\");\r\n            }\r\n            if (tangent) {\r\n                defines.push(\"#define MORPHTARGETS_TANGENT\");\r\n            }\r\n            if (normal) {\r\n                defines.push(\"#define MORPHTARGETS_NORMAL\");\r\n            }\r\n            if (numInfluencers > 0) {\r\n                defines.push(\"#define MORPHTARGETS\");\r\n            }\r\n            if (manager.isUsingTextureForTargets) {\r\n                defines.push(\"#define MORPHTARGETS_TEXTURE\");\r\n\r\n                if (uniforms.indexOf(\"morphTargetTextureIndices\") === -1) {\r\n                    uniforms.push(\"morphTargetTextureIndices\");\r\n                }\r\n\r\n                if (this._options.samplers.indexOf(\"morphTargets\") === -1) {\r\n                    this._options.samplers.push(\"morphTargets\");\r\n                }\r\n            }\r\n            defines.push(\"#define NUM_MORPH_INFLUENCERS \" + numInfluencers);\r\n            for (let index = 0; index < numInfluencers; index++) {\r\n                attribs.push(VertexBuffer.PositionKind + index);\r\n\r\n                if (normal) {\r\n                    attribs.push(VertexBuffer.NormalKind + index);\r\n                }\r\n\r\n                if (tangent) {\r\n                    attribs.push(VertexBuffer.TangentKind + index);\r\n                }\r\n\r\n                if (uv) {\r\n                    attribs.push(VertexBuffer.UVKind + \"_\" + index);\r\n                }\r\n            }\r\n            if (numInfluencers > 0) {\r\n                uniforms = uniforms.slice();\r\n                uniforms.push(\"morphTargetInfluences\");\r\n                uniforms.push(\"morphTargetCount\");\r\n                uniforms.push(\"morphTargetTextureInfo\");\r\n                uniforms.push(\"morphTargetTextureIndices\");\r\n            }\r\n        } else {\r\n            defines.push(\"#define NUM_MORPH_INFLUENCERS 0\");\r\n        }\r\n\r\n        // Baked Vertex Animation\r\n        if (mesh) {\r\n            const bvaManager = (<Mesh>mesh).bakedVertexAnimationManager;\r\n\r\n            if (bvaManager && bvaManager.isEnabled) {\r\n                defines.push(\"#define BAKED_VERTEX_ANIMATION_TEXTURE\");\r\n                if (uniforms.indexOf(\"bakedVertexAnimationSettings\") === -1) {\r\n                    uniforms.push(\"bakedVertexAnimationSettings\");\r\n                }\r\n                if (uniforms.indexOf(\"bakedVertexAnimationTextureSizeInverted\") === -1) {\r\n                    uniforms.push(\"bakedVertexAnimationTextureSizeInverted\");\r\n                }\r\n                if (uniforms.indexOf(\"bakedVertexAnimationTime\") === -1) {\r\n                    uniforms.push(\"bakedVertexAnimationTime\");\r\n                }\r\n\r\n                if (this._options.samplers.indexOf(\"bakedVertexAnimationTexture\") === -1) {\r\n                    this._options.samplers.push(\"bakedVertexAnimationTexture\");\r\n                }\r\n            }\r\n\r\n            PrepareAttributesForBakedVertexAnimation(attribs, mesh, defines);\r\n        }\r\n\r\n        // Textures\r\n        for (const name in this._textures) {\r\n            if (!this._textures[name].isReady()) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        // Alpha test\r\n        if (mesh && this._shouldTurnAlphaTestOn(mesh)) {\r\n            defines.push(\"#define ALPHATEST\");\r\n        }\r\n\r\n        // Clip planes\r\n        if (this._options.useClipPlane !== false) {\r\n            addClipPlaneUniforms(uniforms);\r\n\r\n            prepareStringDefinesForClipPlanes(this, scene, defines);\r\n        }\r\n\r\n        // Fog\r\n        if (scene.fogEnabled && mesh?.applyFog && scene.fogMode !== Scene.FOGMODE_NONE) {\r\n            defines.push(\"#define FOG\");\r\n            if (uniforms.indexOf(\"view\") === -1) {\r\n                uniforms.push(\"view\");\r\n            }\r\n            if (uniforms.indexOf(\"vFogInfos\") === -1) {\r\n                uniforms.push(\"vFogInfos\");\r\n            }\r\n            if (uniforms.indexOf(\"vFogColor\") === -1) {\r\n                uniforms.push(\"vFogColor\");\r\n            }\r\n        }\r\n\r\n        // Misc\r\n        if (this._useLogarithmicDepth) {\r\n            defines.push(\"#define LOGARITHMICDEPTH\");\r\n            if (uniforms.indexOf(\"logarithmicDepthConstant\") === -1) {\r\n                uniforms.push(\"logarithmicDepthConstant\");\r\n            }\r\n        }\r\n\r\n        if (this.customShaderNameResolve) {\r\n            uniforms = uniforms.slice();\r\n            uniformBuffers = uniformBuffers.slice();\r\n            samplers = samplers.slice();\r\n            shaderName = this.customShaderNameResolve(shaderName, uniforms, uniformBuffers, samplers, defines, attribs);\r\n        }\r\n\r\n        const drawWrapper = storeEffectOnSubMeshes ? subMesh._getDrawWrapper(undefined, true) : this._drawWrapper;\r\n        const previousEffect = drawWrapper?.effect ?? null;\r\n        const previousDefines = drawWrapper?.defines ?? null;\r\n        const join = defines.join(\"\\n\");\r\n\r\n        let effect = previousEffect;\r\n        if (previousDefines !== join) {\r\n            effect = engine.createEffect(\r\n                shaderName,\r\n                <IEffectCreationOptions>{\r\n                    attributes: attribs,\r\n                    uniformsNames: uniforms,\r\n                    uniformBuffersNames: uniformBuffers,\r\n                    samplers: samplers,\r\n                    defines: join,\r\n                    fallbacks: fallbacks,\r\n                    onCompiled: this.onCompiled,\r\n                    onError: this.onError,\r\n                    indexParameters: { maxSimultaneousMorphTargets: numInfluencers },\r\n                    shaderLanguage: this._options.shaderLanguage,\r\n                },\r\n                engine\r\n            );\r\n\r\n            if (storeEffectOnSubMeshes) {\r\n                subMesh.setEffect(effect, join, this._materialContext);\r\n            } else if (drawWrapper) {\r\n                drawWrapper.setEffect(effect, join);\r\n            }\r\n\r\n            if (this._onEffectCreatedObservable) {\r\n                onCreatedEffectParameters.effect = effect;\r\n                onCreatedEffectParameters.subMesh = subMesh ?? mesh?.subMeshes[0] ?? null;\r\n                this._onEffectCreatedObservable.notifyObservers(onCreatedEffectParameters);\r\n            }\r\n        }\r\n\r\n        drawWrapper!._wasPreviouslyUsingInstances = !!useInstances;\r\n\r\n        if (!effect?.isReady() ?? true) {\r\n            return false;\r\n        }\r\n\r\n        if (previousEffect !== effect) {\r\n            scene.resetCachedMaterial();\r\n        }\r\n\r\n        drawWrapper!._wasPreviouslyReady = true;\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Binds the world matrix to the material\r\n     * @param world defines the world transformation matrix\r\n     * @param effectOverride - If provided, use this effect instead of internal effect\r\n     */\r\n    public bindOnlyWorldMatrix(world: Matrix, effectOverride?: Nullable<Effect>): void {\r\n        const scene = this.getScene();\r\n\r\n        const effect = effectOverride ?? this.getEffect();\r\n\r\n        if (!effect) {\r\n            return;\r\n        }\r\n\r\n        if (this._options.uniforms.indexOf(\"world\") !== -1) {\r\n            effect.setMatrix(\"world\", world);\r\n        }\r\n\r\n        if (this._options.uniforms.indexOf(\"worldView\") !== -1) {\r\n            world.multiplyToRef(scene.getViewMatrix(), this._cachedWorldViewMatrix);\r\n            effect.setMatrix(\"worldView\", this._cachedWorldViewMatrix);\r\n        }\r\n\r\n        if (this._options.uniforms.indexOf(\"worldViewProjection\") !== -1) {\r\n            world.multiplyToRef(scene.getTransformMatrix(), this._cachedWorldViewProjectionMatrix);\r\n            effect.setMatrix(\"worldViewProjection\", this._cachedWorldViewProjectionMatrix);\r\n        }\r\n\r\n        if (this._options.uniforms.indexOf(\"view\") !== -1) {\r\n            effect.setMatrix(\"view\", scene.getViewMatrix());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Binds the submesh to this material by preparing the effect and shader to draw\r\n     * @param world defines the world transformation matrix\r\n     * @param mesh defines the mesh containing the submesh\r\n     * @param subMesh defines the submesh to bind the material to\r\n     */\r\n    public bindForSubMesh(world: Matrix, mesh: Mesh, subMesh: SubMesh): void {\r\n        this.bind(world, mesh, subMesh._drawWrapperOverride?.effect, subMesh);\r\n    }\r\n\r\n    /**\r\n     * Binds the material to the mesh\r\n     * @param world defines the world transformation matrix\r\n     * @param mesh defines the mesh to bind the material to\r\n     * @param effectOverride - If provided, use this effect instead of internal effect\r\n     * @param subMesh defines the submesh to bind the material to\r\n     */\r\n    public bind(world: Matrix, mesh?: Mesh, effectOverride?: Nullable<Effect>, subMesh?: SubMesh): void {\r\n        // Std values\r\n        const storeEffectOnSubMeshes = subMesh && this._storeEffectOnSubMeshes;\r\n        const effect = effectOverride ?? (storeEffectOnSubMeshes ? subMesh.effect : this.getEffect());\r\n\r\n        if (!effect) {\r\n            return;\r\n        }\r\n\r\n        const scene = this.getScene();\r\n\r\n        this._activeEffect = effect;\r\n\r\n        this.bindOnlyWorldMatrix(world, effectOverride);\r\n\r\n        const uniformBuffers = this._options.uniformBuffers;\r\n\r\n        let useSceneUBO = false;\r\n\r\n        if (effect && uniformBuffers && uniformBuffers.length > 0 && scene.getEngine().supportsUniformBuffers) {\r\n            for (let i = 0; i < uniformBuffers.length; ++i) {\r\n                const bufferName = uniformBuffers[i];\r\n                switch (bufferName) {\r\n                    case \"Mesh\":\r\n                        if (mesh) {\r\n                            mesh.getMeshUniformBuffer().bindToEffect(effect, \"Mesh\");\r\n                            mesh.transferToEffect(world);\r\n                        }\r\n                        break;\r\n                    case \"Scene\":\r\n                        BindSceneUniformBuffer(effect, scene.getSceneUniformBuffer());\r\n                        scene.finalizeSceneUbo();\r\n                        useSceneUBO = true;\r\n                        break;\r\n                }\r\n            }\r\n        }\r\n\r\n        const mustRebind = mesh && storeEffectOnSubMeshes ? this._mustRebind(scene, effect, subMesh, mesh.visibility) : scene.getCachedMaterial() !== this;\r\n\r\n        if (effect && mustRebind) {\r\n            if (!useSceneUBO && this._options.uniforms.indexOf(\"view\") !== -1) {\r\n                effect.setMatrix(\"view\", scene.getViewMatrix());\r\n            }\r\n\r\n            if (!useSceneUBO && this._options.uniforms.indexOf(\"projection\") !== -1) {\r\n                effect.setMatrix(\"projection\", scene.getProjectionMatrix());\r\n            }\r\n\r\n            if (!useSceneUBO && this._options.uniforms.indexOf(\"viewProjection\") !== -1) {\r\n                effect.setMatrix(\"viewProjection\", scene.getTransformMatrix());\r\n                if (this._multiview) {\r\n                    effect.setMatrix(\"viewProjectionR\", scene._transformMatrixR);\r\n                }\r\n            }\r\n\r\n            if (scene.activeCamera && this._options.uniforms.indexOf(\"cameraPosition\") !== -1) {\r\n                effect.setVector3(\"cameraPosition\", scene.activeCamera!.globalPosition);\r\n            }\r\n\r\n            // Bones\r\n            BindBonesParameters(mesh, effect);\r\n\r\n            // Clip plane\r\n            bindClipPlane(effect, this, scene);\r\n\r\n            // Misc\r\n            if (this._useLogarithmicDepth) {\r\n                BindLogDepth(storeEffectOnSubMeshes ? subMesh.materialDefines : effect.defines, effect, scene);\r\n            }\r\n\r\n            // Fog\r\n            if (mesh) {\r\n                BindFogParameters(scene, mesh, effect);\r\n            }\r\n\r\n            let name: string;\r\n            // Texture\r\n            for (name in this._textures) {\r\n                effect.setTexture(name, this._textures[name]);\r\n            }\r\n\r\n            // Texture arrays\r\n            for (name in this._textureArrays) {\r\n                effect.setTextureArray(name, this._textureArrays[name]);\r\n            }\r\n\r\n            // External texture\r\n            for (name in this._externalTextures) {\r\n                effect.setExternalTexture(name, this._externalTextures[name]);\r\n            }\r\n\r\n            // Int\r\n            for (name in this._ints) {\r\n                effect.setInt(name, this._ints[name]);\r\n            }\r\n\r\n            // UInt\r\n            for (name in this._uints) {\r\n                effect.setUInt(name, this._uints[name]);\r\n            }\r\n\r\n            // Float\r\n            for (name in this._floats) {\r\n                effect.setFloat(name, this._floats[name]);\r\n            }\r\n\r\n            // Floats\r\n            for (name in this._floatsArrays) {\r\n                effect.setArray(name, this._floatsArrays[name]);\r\n            }\r\n\r\n            // Color3\r\n            for (name in this._colors3) {\r\n                effect.setColor3(name, this._colors3[name]);\r\n            }\r\n\r\n            // Color3Array\r\n            for (name in this._colors3Arrays) {\r\n                effect.setArray3(name, this._colors3Arrays[name]);\r\n            }\r\n\r\n            // Color4\r\n            for (name in this._colors4) {\r\n                const color = this._colors4[name];\r\n                effect.setFloat4(name, color.r, color.g, color.b, color.a);\r\n            }\r\n\r\n            // Color4Array\r\n            for (name in this._colors4Arrays) {\r\n                effect.setArray4(name, this._colors4Arrays[name]);\r\n            }\r\n\r\n            // Vector2\r\n            for (name in this._vectors2) {\r\n                effect.setVector2(name, this._vectors2[name]);\r\n            }\r\n\r\n            // Vector3\r\n            for (name in this._vectors3) {\r\n                effect.setVector3(name, this._vectors3[name]);\r\n            }\r\n\r\n            // Vector4\r\n            for (name in this._vectors4) {\r\n                effect.setVector4(name, this._vectors4[name]);\r\n            }\r\n\r\n            // Quaternion\r\n            for (name in this._quaternions) {\r\n                effect.setQuaternion(name, this._quaternions[name]);\r\n            }\r\n\r\n            // Matrix\r\n            for (name in this._matrices) {\r\n                effect.setMatrix(name, this._matrices[name]);\r\n            }\r\n\r\n            // MatrixArray\r\n            for (name in this._matrixArrays) {\r\n                effect.setMatrices(name, this._matrixArrays[name]);\r\n            }\r\n\r\n            // Matrix 3x3\r\n            for (name in this._matrices3x3) {\r\n                effect.setMatrix3x3(name, this._matrices3x3[name]);\r\n            }\r\n\r\n            // Matrix 2x2\r\n            for (name in this._matrices2x2) {\r\n                effect.setMatrix2x2(name, this._matrices2x2[name]);\r\n            }\r\n\r\n            // Vector2Array\r\n            for (name in this._vectors2Arrays) {\r\n                effect.setArray2(name, this._vectors2Arrays[name]);\r\n            }\r\n\r\n            // Vector3Array\r\n            for (name in this._vectors3Arrays) {\r\n                effect.setArray3(name, this._vectors3Arrays[name]);\r\n            }\r\n\r\n            // Vector4Array\r\n            for (name in this._vectors4Arrays) {\r\n                effect.setArray4(name, this._vectors4Arrays[name]);\r\n            }\r\n\r\n            // QuaternionArray\r\n            for (name in this._quaternionsArrays) {\r\n                effect.setArray4(name, this._quaternionsArrays[name]);\r\n            }\r\n\r\n            // Uniform buffers\r\n            for (name in this._uniformBuffers) {\r\n                const buffer = this._uniformBuffers[name].getBuffer();\r\n                if (buffer) {\r\n                    effect.bindUniformBuffer(buffer, name);\r\n                }\r\n            }\r\n\r\n            // Samplers\r\n            for (name in this._textureSamplers) {\r\n                effect.setTextureSampler(name, this._textureSamplers[name]);\r\n            }\r\n\r\n            // Storage buffers\r\n            for (name in this._storageBuffers) {\r\n                effect.setStorageBuffer(name, this._storageBuffers[name]);\r\n            }\r\n        }\r\n\r\n        if (effect && mesh && (mustRebind || !this.isFrozen)) {\r\n            // Morph targets\r\n            const manager = (<Mesh>mesh).morphTargetManager;\r\n            if (manager && manager.numInfluencers > 0) {\r\n                BindMorphTargetParameters(<Mesh>mesh, effect);\r\n            }\r\n\r\n            const bvaManager = (<Mesh>mesh).bakedVertexAnimationManager;\r\n\r\n            if (bvaManager && bvaManager.isEnabled) {\r\n                const drawWrapper = storeEffectOnSubMeshes ? subMesh._drawWrapper : this._drawWrapper;\r\n                mesh.bakedVertexAnimationManager?.bind(effect, !!drawWrapper._wasPreviouslyUsingInstances);\r\n            }\r\n        }\r\n\r\n        this._afterBind(mesh, effect, subMesh);\r\n    }\r\n\r\n    /**\r\n     * Gets the active textures from the material\r\n     * @returns an array of textures\r\n     */\r\n    public getActiveTextures(): BaseTexture[] {\r\n        const activeTextures = super.getActiveTextures();\r\n\r\n        for (const name in this._textures) {\r\n            activeTextures.push(this._textures[name]);\r\n        }\r\n\r\n        for (const name in this._textureArrays) {\r\n            const array = this._textureArrays[name];\r\n            for (let index = 0; index < array.length; index++) {\r\n                activeTextures.push(array[index]);\r\n            }\r\n        }\r\n\r\n        return activeTextures;\r\n    }\r\n\r\n    /**\r\n     * Specifies if the material uses a texture\r\n     * @param texture defines the texture to check against the material\r\n     * @returns a boolean specifying if the material uses the texture\r\n     */\r\n    public hasTexture(texture: BaseTexture): boolean {\r\n        if (super.hasTexture(texture)) {\r\n            return true;\r\n        }\r\n\r\n        for (const name in this._textures) {\r\n            if (this._textures[name] === texture) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        for (const name in this._textureArrays) {\r\n            const array = this._textureArrays[name];\r\n            for (let index = 0; index < array.length; index++) {\r\n                if (array[index] === texture) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Makes a duplicate of the material, and gives it a new name\r\n     * @param name defines the new name for the duplicated material\r\n     * @returns the cloned material\r\n     */\r\n    public clone(name: string): ShaderMaterial {\r\n        const result = SerializationHelper.Clone(() => new ShaderMaterial(name, this.getScene(), this._shaderPath, this._options, this._storeEffectOnSubMeshes), this);\r\n\r\n        result.name = name;\r\n        result.id = name;\r\n\r\n        // Shader code path\r\n        if (typeof result._shaderPath === \"object\") {\r\n            result._shaderPath = { ...result._shaderPath };\r\n        }\r\n\r\n        // Options\r\n        this._options = { ...this._options };\r\n\r\n        (Object.keys(this._options) as Array<keyof IShaderMaterialOptions>).forEach((propName) => {\r\n            const propValue = this._options[propName];\r\n            if (Array.isArray(propValue)) {\r\n                (<string[]>this._options[propName]) = propValue.slice(0);\r\n            }\r\n        });\r\n\r\n        // Stencil\r\n        this.stencil.copyTo(result.stencil);\r\n\r\n        // Texture\r\n        for (const key in this._textures) {\r\n            result.setTexture(key, this._textures[key]);\r\n        }\r\n\r\n        // TextureArray\r\n        for (const key in this._textureArrays) {\r\n            result.setTextureArray(key, this._textureArrays[key]);\r\n        }\r\n\r\n        // External texture\r\n        for (const key in this._externalTextures) {\r\n            result.setExternalTexture(key, this._externalTextures[key]);\r\n        }\r\n\r\n        // Int\r\n        for (const key in this._ints) {\r\n            result.setInt(key, this._ints[key]);\r\n        }\r\n\r\n        // UInt\r\n        for (const key in this._uints) {\r\n            result.setUInt(key, this._uints[key]);\r\n        }\r\n\r\n        // Float\r\n        for (const key in this._floats) {\r\n            result.setFloat(key, this._floats[key]);\r\n        }\r\n\r\n        // Floats\r\n        for (const key in this._floatsArrays) {\r\n            result.setFloats(key, this._floatsArrays[key]);\r\n        }\r\n\r\n        // Color3\r\n        for (const key in this._colors3) {\r\n            result.setColor3(key, this._colors3[key]);\r\n        }\r\n\r\n        // Color3Array\r\n        for (const key in this._colors3Arrays) {\r\n            result._colors3Arrays[key] = this._colors3Arrays[key];\r\n        }\r\n\r\n        // Color4\r\n        for (const key in this._colors4) {\r\n            result.setColor4(key, this._colors4[key]);\r\n        }\r\n\r\n        // Color4Array\r\n        for (const key in this._colors4Arrays) {\r\n            result._colors4Arrays[key] = this._colors4Arrays[key];\r\n        }\r\n\r\n        // Vector2\r\n        for (const key in this._vectors2) {\r\n            result.setVector2(key, this._vectors2[key]);\r\n        }\r\n\r\n        // Vector3\r\n        for (const key in this._vectors3) {\r\n            result.setVector3(key, this._vectors3[key]);\r\n        }\r\n\r\n        // Vector4\r\n        for (const key in this._vectors4) {\r\n            result.setVector4(key, this._vectors4[key]);\r\n        }\r\n\r\n        // Quaternion\r\n        for (const key in this._quaternions) {\r\n            result.setQuaternion(key, this._quaternions[key]);\r\n        }\r\n\r\n        // QuaternionArray\r\n        for (const key in this._quaternionsArrays) {\r\n            result._quaternionsArrays[key] = this._quaternionsArrays[key];\r\n        }\r\n\r\n        // Matrix\r\n        for (const key in this._matrices) {\r\n            result.setMatrix(key, this._matrices[key]);\r\n        }\r\n\r\n        // MatrixArray\r\n        for (const key in this._matrixArrays) {\r\n            result._matrixArrays[key] = this._matrixArrays[key].slice();\r\n        }\r\n\r\n        // Matrix 3x3\r\n        for (const key in this._matrices3x3) {\r\n            result.setMatrix3x3(key, this._matrices3x3[key]);\r\n        }\r\n\r\n        // Matrix 2x2\r\n        for (const key in this._matrices2x2) {\r\n            result.setMatrix2x2(key, this._matrices2x2[key]);\r\n        }\r\n\r\n        // Vector2Array\r\n        for (const key in this._vectors2Arrays) {\r\n            result.setArray2(key, this._vectors2Arrays[key]);\r\n        }\r\n\r\n        // Vector3Array\r\n        for (const key in this._vectors3Arrays) {\r\n            result.setArray3(key, this._vectors3Arrays[key]);\r\n        }\r\n\r\n        // Vector4Array\r\n        for (const key in this._vectors4Arrays) {\r\n            result.setArray4(key, this._vectors4Arrays[key]);\r\n        }\r\n\r\n        // Uniform buffers\r\n        for (const key in this._uniformBuffers) {\r\n            result.setUniformBuffer(key, this._uniformBuffers[key]);\r\n        }\r\n\r\n        // Samplers\r\n        for (const key in this._textureSamplers) {\r\n            result.setTextureSampler(key, this._textureSamplers[key]);\r\n        }\r\n\r\n        // Storag buffers\r\n        for (const key in this._storageBuffers) {\r\n            result.setStorageBuffer(key, this._storageBuffers[key]);\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Disposes the material\r\n     * @param forceDisposeEffect specifies if effects should be forcefully disposed\r\n     * @param forceDisposeTextures specifies if textures should be forcefully disposed\r\n     * @param notBoundToMesh specifies if the material that is being disposed is known to be not bound to any mesh\r\n     */\r\n    public dispose(forceDisposeEffect?: boolean, forceDisposeTextures?: boolean, notBoundToMesh?: boolean): void {\r\n        if (forceDisposeTextures) {\r\n            let name: string;\r\n            for (name in this._textures) {\r\n                this._textures[name].dispose();\r\n            }\r\n\r\n            for (name in this._textureArrays) {\r\n                const array = this._textureArrays[name];\r\n                for (let index = 0; index < array.length; index++) {\r\n                    array[index].dispose();\r\n                }\r\n            }\r\n        }\r\n\r\n        this._textures = {};\r\n\r\n        super.dispose(forceDisposeEffect, forceDisposeTextures, notBoundToMesh);\r\n    }\r\n\r\n    /**\r\n     * Serializes this material in a JSON representation\r\n     * @returns the serialized material object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject = SerializationHelper.Serialize(this);\r\n        serializationObject.customType = \"BABYLON.ShaderMaterial\";\r\n        serializationObject.uniqueId = this.uniqueId;\r\n\r\n        serializationObject.options = this._options;\r\n        serializationObject.shaderPath = this._shaderPath;\r\n        serializationObject.storeEffectOnSubMeshes = this._storeEffectOnSubMeshes;\r\n\r\n        let name: string;\r\n\r\n        // Stencil\r\n        serializationObject.stencil = this.stencil.serialize();\r\n\r\n        // Texture\r\n        serializationObject.textures = {};\r\n        for (name in this._textures) {\r\n            serializationObject.textures[name] = this._textures[name].serialize();\r\n        }\r\n\r\n        // Texture arrays\r\n        serializationObject.textureArrays = {};\r\n        for (name in this._textureArrays) {\r\n            serializationObject.textureArrays[name] = [];\r\n            const array = this._textureArrays[name];\r\n            for (let index = 0; index < array.length; index++) {\r\n                serializationObject.textureArrays[name].push(array[index].serialize());\r\n            }\r\n        }\r\n\r\n        // Int\r\n        serializationObject.ints = {};\r\n        for (name in this._ints) {\r\n            serializationObject.ints[name] = this._ints[name];\r\n        }\r\n\r\n        // UInt\r\n        serializationObject.uints = {};\r\n        for (name in this._uints) {\r\n            serializationObject.uints[name] = this._uints[name];\r\n        }\r\n\r\n        // Float\r\n        serializationObject.floats = {};\r\n        for (name in this._floats) {\r\n            serializationObject.floats[name] = this._floats[name];\r\n        }\r\n\r\n        // Floats\r\n        serializationObject.floatsArrays = {};\r\n        for (name in this._floatsArrays) {\r\n            serializationObject.floatsArrays[name] = this._floatsArrays[name];\r\n        }\r\n\r\n        // Color3\r\n        serializationObject.colors3 = {};\r\n        for (name in this._colors3) {\r\n            serializationObject.colors3[name] = this._colors3[name].asArray();\r\n        }\r\n\r\n        // Color3 array\r\n        serializationObject.colors3Arrays = {};\r\n        for (name in this._colors3Arrays) {\r\n            serializationObject.colors3Arrays[name] = this._colors3Arrays[name];\r\n        }\r\n\r\n        // Color4\r\n        serializationObject.colors4 = {};\r\n        for (name in this._colors4) {\r\n            serializationObject.colors4[name] = this._colors4[name].asArray();\r\n        }\r\n\r\n        // Color4 array\r\n        serializationObject.colors4Arrays = {};\r\n        for (name in this._colors4Arrays) {\r\n            serializationObject.colors4Arrays[name] = this._colors4Arrays[name];\r\n        }\r\n\r\n        // Vector2\r\n        serializationObject.vectors2 = {};\r\n        for (name in this._vectors2) {\r\n            serializationObject.vectors2[name] = this._vectors2[name].asArray();\r\n        }\r\n\r\n        // Vector3\r\n        serializationObject.vectors3 = {};\r\n        for (name in this._vectors3) {\r\n            serializationObject.vectors3[name] = this._vectors3[name].asArray();\r\n        }\r\n\r\n        // Vector4\r\n        serializationObject.vectors4 = {};\r\n        for (name in this._vectors4) {\r\n            serializationObject.vectors4[name] = this._vectors4[name].asArray();\r\n        }\r\n\r\n        // Quaternion\r\n        serializationObject.quaternions = {};\r\n        for (name in this._quaternions) {\r\n            serializationObject.quaternions[name] = this._quaternions[name].asArray();\r\n        }\r\n\r\n        // Matrix\r\n        serializationObject.matrices = {};\r\n        for (name in this._matrices) {\r\n            serializationObject.matrices[name] = this._matrices[name].asArray();\r\n        }\r\n\r\n        // MatrixArray\r\n        serializationObject.matrixArray = {};\r\n        for (name in this._matrixArrays) {\r\n            serializationObject.matrixArray[name] = this._matrixArrays[name];\r\n        }\r\n\r\n        // Matrix 3x3\r\n        serializationObject.matrices3x3 = {};\r\n        for (name in this._matrices3x3) {\r\n            serializationObject.matrices3x3[name] = this._matrices3x3[name];\r\n        }\r\n\r\n        // Matrix 2x2\r\n        serializationObject.matrices2x2 = {};\r\n        for (name in this._matrices2x2) {\r\n            serializationObject.matrices2x2[name] = this._matrices2x2[name];\r\n        }\r\n\r\n        // Vector2Array\r\n        serializationObject.vectors2Arrays = {};\r\n        for (name in this._vectors2Arrays) {\r\n            serializationObject.vectors2Arrays[name] = this._vectors2Arrays[name];\r\n        }\r\n\r\n        // Vector3Array\r\n        serializationObject.vectors3Arrays = {};\r\n        for (name in this._vectors3Arrays) {\r\n            serializationObject.vectors3Arrays[name] = this._vectors3Arrays[name];\r\n        }\r\n\r\n        // Vector4Array\r\n        serializationObject.vectors4Arrays = {};\r\n        for (name in this._vectors4Arrays) {\r\n            serializationObject.vectors4Arrays[name] = this._vectors4Arrays[name];\r\n        }\r\n\r\n        // QuaternionArray\r\n        serializationObject.quaternionsArrays = {};\r\n        for (name in this._quaternionsArrays) {\r\n            serializationObject.quaternionsArrays[name] = this._quaternionsArrays[name];\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Creates a shader material from parsed shader material data\r\n     * @param source defines the JSON representation of the material\r\n     * @param scene defines the hosting scene\r\n     * @param rootUrl defines the root URL to use to load textures and relative dependencies\r\n     * @returns a new material\r\n     */\r\n    public static Parse(source: any, scene: Scene, rootUrl: string): ShaderMaterial {\r\n        const material = SerializationHelper.Parse(\r\n            () => new ShaderMaterial(source.name, scene, source.shaderPath, source.options, source.storeEffectOnSubMeshes),\r\n            source,\r\n            scene,\r\n            rootUrl\r\n        );\r\n\r\n        let name: string;\r\n\r\n        // Stencil\r\n        if (source.stencil) {\r\n            material.stencil.parse(source.stencil, scene, rootUrl);\r\n        }\r\n\r\n        // Texture\r\n        for (name in source.textures) {\r\n            material.setTexture(name, <Texture>Texture.Parse(source.textures[name], scene, rootUrl));\r\n        }\r\n\r\n        // Texture arrays\r\n        for (name in source.textureArrays) {\r\n            const array = source.textureArrays[name];\r\n            const textureArray: Texture[] = [];\r\n\r\n            for (let index = 0; index < array.length; index++) {\r\n                textureArray.push(<Texture>Texture.Parse(array[index], scene, rootUrl));\r\n            }\r\n            material.setTextureArray(name, textureArray);\r\n        }\r\n\r\n        // Int\r\n        for (name in source.ints) {\r\n            material.setInt(name, source.ints[name]);\r\n        }\r\n\r\n        // UInt\r\n        for (name in source.uints) {\r\n            material.setUInt(name, source.uints[name]);\r\n        }\r\n\r\n        // Float\r\n        for (name in source.floats) {\r\n            material.setFloat(name, source.floats[name]);\r\n        }\r\n\r\n        // Floats\r\n        for (name in source.floatsArrays) {\r\n            material.setFloats(name, source.floatsArrays[name]);\r\n        }\r\n\r\n        // Color3\r\n        for (name in source.colors3) {\r\n            material.setColor3(name, Color3.FromArray(source.colors3[name]));\r\n        }\r\n\r\n        // Color3 arrays\r\n        for (name in source.colors3Arrays) {\r\n            const colors: Color3[] = source.colors3Arrays[name]\r\n                .reduce((arr: Array<Array<number>>, num: number, i: number) => {\r\n                    if (i % 3 === 0) {\r\n                        arr.push([num]);\r\n                    } else {\r\n                        arr[arr.length - 1].push(num);\r\n                    }\r\n                    return arr;\r\n                }, [])\r\n                .map((color: ArrayLike<number>) => Color3.FromArray(color));\r\n            material.setColor3Array(name, colors);\r\n        }\r\n\r\n        // Color4\r\n        for (name in source.colors4) {\r\n            material.setColor4(name, Color4.FromArray(source.colors4[name]));\r\n        }\r\n\r\n        // Color4 arrays\r\n        for (name in source.colors4Arrays) {\r\n            const colors: Color4[] = source.colors4Arrays[name]\r\n                .reduce((arr: Array<Array<number>>, num: number, i: number) => {\r\n                    if (i % 4 === 0) {\r\n                        arr.push([num]);\r\n                    } else {\r\n                        arr[arr.length - 1].push(num);\r\n                    }\r\n                    return arr;\r\n                }, [])\r\n                .map((color: ArrayLike<number>) => Color4.FromArray(color));\r\n            material.setColor4Array(name, colors);\r\n        }\r\n\r\n        // Vector2\r\n        for (name in source.vectors2) {\r\n            material.setVector2(name, Vector2.FromArray(source.vectors2[name]));\r\n        }\r\n\r\n        // Vector3\r\n        for (name in source.vectors3) {\r\n            material.setVector3(name, Vector3.FromArray(source.vectors3[name]));\r\n        }\r\n\r\n        // Vector4\r\n        for (name in source.vectors4) {\r\n            material.setVector4(name, Vector4.FromArray(source.vectors4[name]));\r\n        }\r\n\r\n        // Quaternion\r\n        for (name in source.quaternions) {\r\n            material.setQuaternion(name, Quaternion.FromArray(source.quaternions[name]));\r\n        }\r\n\r\n        // Matrix\r\n        for (name in source.matrices) {\r\n            material.setMatrix(name, Matrix.FromArray(source.matrices[name]));\r\n        }\r\n\r\n        // MatrixArray\r\n        for (name in source.matrixArray) {\r\n            material._matrixArrays[name] = new Float32Array(source.matrixArray[name]);\r\n        }\r\n\r\n        // Matrix 3x3\r\n        for (name in source.matrices3x3) {\r\n            material.setMatrix3x3(name, source.matrices3x3[name]);\r\n        }\r\n\r\n        // Matrix 2x2\r\n        for (name in source.matrices2x2) {\r\n            material.setMatrix2x2(name, source.matrices2x2[name]);\r\n        }\r\n\r\n        // Vector2Array\r\n        for (name in source.vectors2Arrays) {\r\n            material.setArray2(name, source.vectors2Arrays[name]);\r\n        }\r\n\r\n        // Vector3Array\r\n        for (name in source.vectors3Arrays) {\r\n            material.setArray3(name, source.vectors3Arrays[name]);\r\n        }\r\n\r\n        // Vector4Array\r\n        for (name in source.vectors4Arrays) {\r\n            material.setArray4(name, source.vectors4Arrays[name]);\r\n        }\r\n\r\n        // QuaternionArray\r\n        for (name in source.quaternionsArrays) {\r\n            material.setArray4(name, source.quaternionsArrays[name]);\r\n        }\r\n\r\n        return material;\r\n    }\r\n\r\n    /**\r\n     * Creates a new ShaderMaterial from a snippet saved in a remote file\r\n     * @param name defines the name of the ShaderMaterial to create (can be null or empty to use the one from the json data)\r\n     * @param url defines the url to load from\r\n     * @param scene defines the hosting scene\r\n     * @param rootUrl defines the root URL to use to load textures and relative dependencies\r\n     * @returns a promise that will resolve to the new ShaderMaterial\r\n     */\r\n    public static ParseFromFileAsync(name: Nullable<string>, url: string, scene: Scene, rootUrl = \"\"): Promise<ShaderMaterial> {\r\n        return new Promise((resolve, reject) => {\r\n            const request = new WebRequest();\r\n            request.addEventListener(\"readystatechange\", () => {\r\n                if (request.readyState == 4) {\r\n                    if (request.status == 200) {\r\n                        const serializationObject = JSON.parse(request.responseText);\r\n                        const output = this.Parse(serializationObject, scene || EngineStore.LastCreatedScene, rootUrl);\r\n\r\n                        if (name) {\r\n                            output.name = name;\r\n                        }\r\n\r\n                        resolve(output);\r\n                    } else {\r\n                        reject(\"Unable to load the ShaderMaterial\");\r\n                    }\r\n                }\r\n            });\r\n\r\n            request.open(\"GET\", url);\r\n            request.send();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates a ShaderMaterial from a snippet saved by the Inspector\r\n     * @param snippetId defines the snippet to load\r\n     * @param scene defines the hosting scene\r\n     * @param rootUrl defines the root URL to use to load textures and relative dependencies\r\n     * @returns a promise that will resolve to the new ShaderMaterial\r\n     */\r\n    public static ParseFromSnippetAsync(snippetId: string, scene: Scene, rootUrl = \"\"): Promise<ShaderMaterial> {\r\n        return new Promise((resolve, reject) => {\r\n            const request = new WebRequest();\r\n            request.addEventListener(\"readystatechange\", () => {\r\n                if (request.readyState == 4) {\r\n                    if (request.status == 200) {\r\n                        const snippet = JSON.parse(JSON.parse(request.responseText).jsonPayload);\r\n                        const serializationObject = JSON.parse(snippet.shaderMaterial);\r\n                        const output = this.Parse(serializationObject, scene || EngineStore.LastCreatedScene, rootUrl);\r\n\r\n                        output.snippetId = snippetId;\r\n\r\n                        resolve(output);\r\n                    } else {\r\n                        reject(\"Unable to load the snippet \" + snippetId);\r\n                    }\r\n                }\r\n            });\r\n\r\n            request.open(\"GET\", this.SnippetUrl + \"/\" + snippetId.replace(/#/g, \"/\"));\r\n            request.send();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates a ShaderMaterial from a snippet saved by the Inspector\r\n     * @deprecated Please use ParseFromSnippetAsync instead\r\n     * @param snippetId defines the snippet to load\r\n     * @param scene defines the hosting scene\r\n     * @param rootUrl defines the root URL to use to load textures and relative dependencies\r\n     * @returns a promise that will resolve to the new ShaderMaterial\r\n     */\r\n    public static CreateFromSnippetAsync = ShaderMaterial.ParseFromSnippetAsync;\r\n}\r\n\r\nRegisterClass(\"BABYLON.ShaderMaterial\", ShaderMaterial);\r\n", "// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/clipPlaneFragmentDeclaration\";\nimport \"./ShadersInclude/fogFragmentDeclaration\";\nimport \"./ShadersInclude/clipPlaneFragment\";\nimport \"./ShadersInclude/fogFragment\";\n\nconst name = \"colorPixelShader\";\nconst shader = `#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)\n#define VERTEXCOLOR\nvarying vec4 vColor;\n#else\nuniform vec4 color;\n#endif\n#include<clipPlaneFragmentDeclaration>\n#include<fogFragmentDeclaration>\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_FRAGMENT_MAIN_BEGIN\n#include<clipPlaneFragment>\n#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)\ngl_FragColor=vColor;\n#else\ngl_FragColor=color;\n#endif\n#include<fogFragment>(color,gl_FragColor)\n#define CUSTOM_FRAGMENT_MAIN_END\n}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const colorPixelShader = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/bonesDeclaration\";\nimport \"./ShadersInclude/bakedVertexAnimationDeclaration\";\nimport \"./ShadersInclude/clipPlaneVertexDeclaration\";\nimport \"./ShadersInclude/fogVertexDeclaration\";\nimport \"./ShadersInclude/instancesDeclaration\";\nimport \"./ShadersInclude/instancesVertex\";\nimport \"./ShadersInclude/bonesVertex\";\nimport \"./ShadersInclude/bakedVertexAnimation\";\nimport \"./ShadersInclude/clipPlaneVertex\";\nimport \"./ShadersInclude/fogVertex\";\nimport \"./ShadersInclude/vertexColorMixing\";\n\nconst name = \"colorVertexShader\";\nconst shader = `attribute vec3 position;\n#ifdef VERTEXCOLOR\nattribute vec4 color;\n#endif\n#include<bonesDeclaration>\n#include<bakedVertexAnimationDeclaration>\n#include<clipPlaneVertexDeclaration>\n#include<fogVertexDeclaration>\n#ifdef FOG\nuniform mat4 view;\n#endif\n#include<instancesDeclaration>\nuniform mat4 viewProjection;\n#ifdef MULTIVIEW\nuniform mat4 viewProjectionR;\n#endif\n#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nvarying vec4 vColor;\n#endif\n#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_VERTEX_MAIN_BEGIN\n#include<instancesVertex>\n#include<bonesVertex>\n#include<bakedVertexAnimation>\nvec4 worldPos=finalWorld*vec4(position,1.0);\n#ifdef MULTIVIEW\nif (gl_ViewID_OVR==0u) {gl_Position=viewProjection*worldPos;} else {gl_Position=viewProjectionR*worldPos;}\n#else\ngl_Position=viewProjection*worldPos;\n#endif\n#include<clipPlaneVertex>\n#include<fogVertex>\n#include<vertexColorMixing>\n#define CUSTOM_VERTEX_MAIN_END\n}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const colorVertexShader = { name, shader };\n", "import type { Nullable } from \"../types\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Color3, Color4 } from \"../Maths/math.color\";\r\nimport type { Node } from \"../node\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport type { SubMesh } from \"../Meshes/subMesh\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport { InstancedMesh } from \"../Meshes/instancedMesh\";\r\nimport { Material } from \"../Materials/material\";\r\nimport { ShaderMaterial } from \"../Materials/shaderMaterial\";\r\nimport type { Effect } from \"../Materials/effect\";\r\n\r\nimport \"../Shaders/color.fragment\";\r\nimport \"../Shaders/color.vertex\";\r\n\r\nMesh._LinesMeshParser = (parsedMesh: any, scene: Scene): Mesh => {\r\n    return LinesMesh.Parse(parsedMesh, scene);\r\n};\r\n\r\n/**\r\n * Line mesh\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/param\r\n */\r\nexport class LinesMesh extends Mesh {\r\n    /**\r\n     * Color of the line (Default: White)\r\n     */\r\n    public color = new Color3(1, 1, 1);\r\n\r\n    /**\r\n     * Alpha of the line (Default: 1)\r\n     */\r\n    public alpha = 1;\r\n\r\n    /**\r\n     * The intersection Threshold is the margin applied when intersection a segment of the LinesMesh with a Ray.\r\n     * This margin is expressed in world space coordinates, so its value may vary.\r\n     * Default value is 0.1\r\n     */\r\n    public intersectionThreshold: number;\r\n\r\n    private _lineMaterial: Material;\r\n\r\n    private _isShaderMaterial(shader: Material): shader is ShaderMaterial {\r\n        return shader.getClassName() === \"ShaderMaterial\";\r\n    }\r\n\r\n    private _color4: Color4;\r\n\r\n    /**\r\n     * Creates a new LinesMesh\r\n     * @param name defines the name\r\n     * @param scene defines the hosting scene\r\n     * @param parent defines the parent mesh if any\r\n     * @param source defines the optional source LinesMesh used to clone data from\r\n     * @param doNotCloneChildren When cloning, skip cloning child meshes of source, default False.\r\n     * When false, achieved by calling a clone(), also passing False.\r\n     * This will make creation of children, recursive.\r\n     * @param useVertexColor defines if this LinesMesh supports vertex color\r\n     * @param useVertexAlpha defines if this LinesMesh supports vertex alpha\r\n     * @param material material to use to draw the line. If not provided, will create a new one\r\n     */\r\n    constructor(\r\n        name: string,\r\n        scene: Nullable<Scene> = null,\r\n        parent: Nullable<Node> = null,\r\n        source: Nullable<LinesMesh> = null,\r\n        doNotCloneChildren?: boolean,\r\n        /**\r\n         * If vertex color should be applied to the mesh\r\n         */\r\n        public readonly useVertexColor?: boolean,\r\n        /**\r\n         * If vertex alpha should be applied to the mesh\r\n         */\r\n        public readonly useVertexAlpha?: boolean,\r\n        material?: Material\r\n    ) {\r\n        super(name, scene, parent, source, doNotCloneChildren);\r\n\r\n        if (source) {\r\n            this.color = source.color.clone();\r\n            this.alpha = source.alpha;\r\n            this.useVertexColor = source.useVertexColor;\r\n            this.useVertexAlpha = source.useVertexAlpha;\r\n        }\r\n\r\n        this.intersectionThreshold = 0.1;\r\n\r\n        const defines: string[] = [];\r\n        const options = {\r\n            attributes: [VertexBuffer.PositionKind],\r\n            uniforms: [\"world\", \"viewProjection\"],\r\n            needAlphaBlending: true,\r\n            defines: defines,\r\n            useClipPlane: null,\r\n        };\r\n\r\n        if (useVertexAlpha === false) {\r\n            options.needAlphaBlending = false;\r\n        } else {\r\n            options.defines.push(\"#define VERTEXALPHA\");\r\n        }\r\n\r\n        if (!useVertexColor) {\r\n            options.uniforms.push(\"color\");\r\n            this._color4 = new Color4();\r\n        } else {\r\n            options.defines.push(\"#define VERTEXCOLOR\");\r\n            options.attributes.push(VertexBuffer.ColorKind);\r\n        }\r\n\r\n        if (material) {\r\n            this.material = material;\r\n        } else {\r\n            this.material = new ShaderMaterial(\"colorShader\", this.getScene(), \"color\", options, false);\r\n            this.material.doNotSerialize = true;\r\n        }\r\n    }\r\n\r\n    public isReady() {\r\n        if (!this._lineMaterial.isReady(this, !!this._userInstancedBuffersStorage || this.hasThinInstances)) {\r\n            return false;\r\n        }\r\n\r\n        return super.isReady();\r\n    }\r\n\r\n    /**\r\n     * @returns the string \"LineMesh\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"LinesMesh\";\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public get material(): Material {\r\n        return this._lineMaterial;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public set material(value: Material) {\r\n        this._lineMaterial = value;\r\n        this._lineMaterial.fillMode = Material.LineListDrawMode;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public get checkCollisions(): boolean {\r\n        return false;\r\n    }\r\n\r\n    public set checkCollisions(value: boolean) {\r\n        // Just ignore it\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _bind(_subMesh: SubMesh, colorEffect: Effect): Mesh {\r\n        if (!this._geometry) {\r\n            return this;\r\n        }\r\n\r\n        // VBOs\r\n        const indexToBind = this.isUnIndexed ? null : this._geometry.getIndexBuffer();\r\n        if (!this._userInstancedBuffersStorage || this.hasThinInstances) {\r\n            this._geometry._bind(colorEffect, indexToBind);\r\n        } else {\r\n            this._geometry._bind(colorEffect, indexToBind, this._userInstancedBuffersStorage.vertexBuffers, this._userInstancedBuffersStorage.vertexArrayObjects);\r\n        }\r\n\r\n        // Color\r\n        if (!this.useVertexColor && this._isShaderMaterial(this._lineMaterial)) {\r\n            const { r, g, b } = this.color;\r\n            this._color4.set(r, g, b, this.alpha);\r\n            this._lineMaterial.setColor4(\"color\", this._color4);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _draw(subMesh: SubMesh, fillMode: number, instancesCount?: number): Mesh {\r\n        if (!this._geometry || !this._geometry.getVertexBuffers() || (!this._unIndexed && !this._geometry.getIndexBuffer())) {\r\n            return this;\r\n        }\r\n\r\n        const engine = this.getScene().getEngine();\r\n\r\n        // Draw order\r\n\r\n        if (this._unIndexed) {\r\n            engine.drawArraysType(Material.LineListDrawMode, subMesh.verticesStart, subMesh.verticesCount, instancesCount);\r\n        } else {\r\n            engine.drawElementsType(Material.LineListDrawMode, subMesh.indexStart, subMesh.indexCount, instancesCount);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Disposes of the line mesh\r\n     * @param doNotRecurse If children should be disposed\r\n     * @param disposeMaterialAndTextures This parameter is not used by the LineMesh class\r\n     * @param doNotDisposeMaterial If the material should not be disposed (default: false, meaning the material is disposed)\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public dispose(doNotRecurse?: boolean, disposeMaterialAndTextures = false, doNotDisposeMaterial?: boolean): void {\r\n        if (!doNotDisposeMaterial) {\r\n            this._lineMaterial.dispose(false, false, true);\r\n        }\r\n        super.dispose(doNotRecurse);\r\n    }\r\n\r\n    /**\r\n     * Returns a new LineMesh object cloned from the current one.\r\n     * @param name defines the cloned mesh name\r\n     * @param newParent defines the new mesh parent\r\n     * @param doNotCloneChildren if set to true, none of the mesh children are cloned (false by default)\r\n     * @returns the new mesh\r\n     */\r\n    public clone(name: string, newParent: Nullable<Node> = null, doNotCloneChildren?: boolean): LinesMesh {\r\n        return new LinesMesh(name, this.getScene(), newParent, this, doNotCloneChildren);\r\n    }\r\n\r\n    /**\r\n     * Creates a new InstancedLinesMesh object from the mesh model.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/copies/instances\r\n     * @param name defines the name of the new instance\r\n     * @returns a new InstancedLinesMesh\r\n     */\r\n    public createInstance(name: string): InstancedLinesMesh {\r\n        const instance = new InstancedLinesMesh(name, this);\r\n\r\n        if (this.instancedBuffers) {\r\n            instance.instancedBuffers = {};\r\n\r\n            for (const key in this.instancedBuffers) {\r\n                instance.instancedBuffers[key] = this.instancedBuffers[key];\r\n            }\r\n        }\r\n\r\n        return instance;\r\n    }\r\n\r\n    /**\r\n     * Serializes this ground mesh\r\n     * @param serializationObject object to write serialization to\r\n     */\r\n    public serialize(serializationObject: any): void {\r\n        super.serialize(serializationObject);\r\n        serializationObject.color = this.color.asArray();\r\n        serializationObject.alpha = this.alpha;\r\n    }\r\n\r\n    /**\r\n     * Parses a serialized ground mesh\r\n     * @param parsedMesh the serialized mesh\r\n     * @param scene the scene to create the ground mesh in\r\n     * @returns the created ground mesh\r\n     */\r\n    public static Parse(parsedMesh: any, scene: Scene): LinesMesh {\r\n        const result = new LinesMesh(parsedMesh.name, scene);\r\n\r\n        result.color = Color3.FromArray(parsedMesh.color);\r\n        result.alpha = parsedMesh.alpha;\r\n\r\n        return result;\r\n    }\r\n}\r\n\r\n/**\r\n * Creates an instance based on a source LinesMesh\r\n */\r\nexport class InstancedLinesMesh extends InstancedMesh {\r\n    /**\r\n     * The intersection Threshold is the margin applied when intersection a segment of the LinesMesh with a Ray.\r\n     * This margin is expressed in world space coordinates, so its value may vary.\r\n     * Initialized with the intersectionThreshold value of the source LinesMesh\r\n     */\r\n    public intersectionThreshold: number;\r\n\r\n    constructor(name: string, source: LinesMesh) {\r\n        super(name, source);\r\n        this.intersectionThreshold = source.intersectionThreshold;\r\n    }\r\n\r\n    /**\r\n     * @returns the string \"InstancedLinesMesh\".\r\n     */\r\n    public getClassName(): string {\r\n        return \"InstancedLinesMesh\";\r\n    }\r\n}\r\n", "/* eslint-disable @typescript-eslint/naming-convention */\r\nimport { Vector3 } from \"../../Maths/math.vector\";\r\nimport type { Color4 } from \"../../Maths/math.color\";\r\nimport { _CreationDataStorage, Mesh } from \"../mesh\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\nimport type { FloatArray, Nullable } from \"../../types\";\r\nimport { LinesMesh } from \"../../Meshes/linesMesh\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { VertexBuffer } from \"../../Buffers/buffer\";\r\nimport { Logger } from \"../../Misc/logger\";\r\n\r\nimport type { Material } from \"../../Materials/material\";\r\n\r\n/**\r\n * Creates the VertexData of the LineSystem\r\n * @param options an object used to set the following optional parameters for the LineSystem, required but can be empty\r\n *  - lines an array of lines, each line being an array of successive Vector3\r\n *  - colors an array of line colors, each of the line colors being an array of successive Color4, one per line point\r\n * @returns the VertexData of the LineSystem\r\n */\r\nexport function CreateLineSystemVertexData(options: { lines: Vector3[][]; colors?: Nullable<Color4[][]> }): VertexData {\r\n    const indices = [];\r\n    const positions = [];\r\n    const lines = options.lines;\r\n    const colors = options.colors;\r\n    const vertexColors = [];\r\n    let idx = 0;\r\n\r\n    for (let l = 0; l < lines.length; l++) {\r\n        const points = lines[l];\r\n        for (let index = 0; index < points.length; index++) {\r\n            const { x, y, z } = points[index];\r\n            positions.push(x, y, z);\r\n            if (colors) {\r\n                const color = colors[l];\r\n                const { r, g, b, a } = color[index];\r\n                vertexColors.push(r, g, b, a);\r\n            }\r\n            if (index > 0) {\r\n                indices.push(idx - 1);\r\n                indices.push(idx);\r\n            }\r\n            idx++;\r\n        }\r\n    }\r\n    const vertexData = new VertexData();\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    if (colors) {\r\n        vertexData.colors = vertexColors;\r\n    }\r\n    return vertexData;\r\n}\r\n\r\n/**\r\n * Create the VertexData for a DashedLines\r\n * @param options an object used to set the following optional parameters for the DashedLines, required but can be empty\r\n *  - points an array successive Vector3\r\n *  - dashSize the size of the dashes relative to the dash number, optional, default 3\r\n *  - gapSize the size of the gap between two successive dashes relative to the dash number, optional, default 1\r\n *  - dashNb the intended total number of dashes, optional, default 200\r\n * @returns the VertexData for the DashedLines\r\n */\r\nexport function CreateDashedLinesVertexData(options: { points: Vector3[]; dashSize?: number; gapSize?: number; dashNb?: number }): VertexData {\r\n    const dashSize = options.dashSize || 3;\r\n    const gapSize = options.gapSize || 1;\r\n    const dashNb = options.dashNb || 200;\r\n    const points = options.points;\r\n\r\n    const positions: number[] = [];\r\n    const indices: number[] = [];\r\n\r\n    const curvect = Vector3.Zero();\r\n    let lg = 0;\r\n    let nb = 0;\r\n    let shft = 0;\r\n    let dashshft = 0;\r\n    let curshft = 0;\r\n    let idx = 0;\r\n    let i = 0;\r\n    for (i = 0; i < points.length - 1; i++) {\r\n        points[i + 1].subtractToRef(points[i], curvect);\r\n        lg += curvect.length();\r\n    }\r\n    shft = lg / dashNb;\r\n    dashshft = (dashSize * shft) / (dashSize + gapSize);\r\n    for (i = 0; i < points.length - 1; i++) {\r\n        points[i + 1].subtractToRef(points[i], curvect);\r\n        nb = Math.floor(curvect.length() / shft);\r\n        curvect.normalize();\r\n        for (let j = 0; j < nb; j++) {\r\n            curshft = shft * j;\r\n            positions.push(points[i].x + curshft * curvect.x, points[i].y + curshft * curvect.y, points[i].z + curshft * curvect.z);\r\n            positions.push(points[i].x + (curshft + dashshft) * curvect.x, points[i].y + (curshft + dashshft) * curvect.y, points[i].z + (curshft + dashshft) * curvect.z);\r\n            indices.push(idx, idx + 1);\r\n            idx += 2;\r\n        }\r\n    }\r\n\r\n    // Result\r\n    const vertexData = new VertexData();\r\n    vertexData.positions = positions;\r\n    vertexData.indices = indices;\r\n\r\n    return vertexData;\r\n}\r\n\r\n/**\r\n * Creates a line system mesh. A line system is a pool of many lines gathered in a single mesh\r\n * * A line system mesh is considered as a parametric shape since it has no predefined original shape. Its shape is determined by the passed array of lines as an input parameter\r\n * * Like every other parametric shape, it is dynamically updatable by passing an existing instance of LineSystem to this static function\r\n * * The parameter `lines` is an array of lines, each line being an array of successive Vector3\r\n * * The optional parameter `instance` is an instance of an existing LineSystem object to be updated with the passed `lines` parameter\r\n * * The optional parameter `colors` is an array of line colors, each line colors being an array of successive Color4, one per line point\r\n * * The optional parameter `useVertexAlpha` is to be set to `false` (default `true`) when you don't need the alpha blending (faster)\r\n * * The optional parameter `material` is the material to use to draw the lines if provided. If not, a default material will be created\r\n * * Updating a simple Line mesh, you just need to update every line in the `lines` array : https://doc.babylonjs.com/features/featuresDeepDive/mesh/dynamicMeshMorph#lines-and-dashedlines\r\n * * When updating an instance, remember that only line point positions can change, not the number of points, neither the number of lines\r\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/param#line-system\r\n * @param name defines the name of the new line system\r\n * @param options defines the options used to create the line system\r\n * @param scene defines the hosting scene\r\n * @returns a new line system mesh\r\n */\r\nexport function CreateLineSystem(\r\n    name: string,\r\n    options: { lines: Vector3[][]; updatable?: boolean; instance?: Nullable<LinesMesh>; colors?: Nullable<Color4[][]>; useVertexAlpha?: boolean; material?: Material },\r\n    scene: Nullable<Scene> = null\r\n): LinesMesh {\r\n    const instance = options.instance;\r\n    const lines = options.lines;\r\n    const colors = options.colors;\r\n\r\n    if (instance) {\r\n        // lines update\r\n        const positions = instance.getVerticesData(VertexBuffer.PositionKind)!;\r\n        let vertexColor;\r\n        let lineColors;\r\n        if (colors) {\r\n            vertexColor = instance.getVerticesData(VertexBuffer.ColorKind)!;\r\n        }\r\n        let i = 0;\r\n        let c = 0;\r\n        for (let l = 0; l < lines.length; l++) {\r\n            const points = lines[l];\r\n            for (let p = 0; p < points.length; p++) {\r\n                positions[i] = points[p].x;\r\n                positions[i + 1] = points[p].y;\r\n                positions[i + 2] = points[p].z;\r\n                if (colors && vertexColor) {\r\n                    lineColors = colors[l];\r\n                    vertexColor[c] = lineColors[p].r;\r\n                    vertexColor[c + 1] = lineColors[p].g;\r\n                    vertexColor[c + 2] = lineColors[p].b;\r\n                    vertexColor[c + 3] = lineColors[p].a;\r\n                    c += 4;\r\n                }\r\n                i += 3;\r\n            }\r\n        }\r\n        instance.updateVerticesData(VertexBuffer.PositionKind, positions, false, false);\r\n        if (colors && vertexColor) {\r\n            instance.updateVerticesData(VertexBuffer.ColorKind, vertexColor, false, false);\r\n        }\r\n        return instance;\r\n    }\r\n\r\n    // line system creation\r\n    const useVertexColor = colors ? true : false;\r\n    const lineSystem = new LinesMesh(name, scene, null, undefined, undefined, useVertexColor, options.useVertexAlpha, options.material);\r\n    const vertexData = CreateLineSystemVertexData(options);\r\n    vertexData.applyToMesh(lineSystem, options.updatable);\r\n    return lineSystem;\r\n}\r\n\r\n/**\r\n * Creates a line mesh\r\n * A line mesh is considered as a parametric shape since it has no predefined original shape. Its shape is determined by the passed array of points as an input parameter\r\n * * Like every other parametric shape, it is dynamically updatable by passing an existing instance of LineMesh to this static function\r\n * * The parameter `points` is an array successive Vector3\r\n * * The optional parameter `instance` is an instance of an existing LineMesh object to be updated with the passed `points` parameter : https://doc.babylonjs.com/features/featuresDeepDive/mesh/dynamicMeshMorph#lines-and-dashedlines\r\n * * The optional parameter `colors` is an array of successive Color4, one per line point\r\n * * The optional parameter `useVertexAlpha` is to be set to `false` (default `true`) when you don't need alpha blending (faster)\r\n * * The optional parameter `material` is the material to use to draw the lines if provided. If not, a default material will be created\r\n * * When updating an instance, remember that only point positions can change, not the number of points\r\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/param#lines\r\n * @param name defines the name of the new line system\r\n * @param options defines the options used to create the line system\r\n * @param scene defines the hosting scene\r\n * @returns a new line mesh\r\n */\r\nexport function CreateLines(\r\n    name: string,\r\n    options: { points: Vector3[]; updatable?: boolean; instance?: Nullable<LinesMesh>; colors?: Color4[]; useVertexAlpha?: boolean; material?: Material },\r\n    scene: Nullable<Scene> = null\r\n): LinesMesh {\r\n    const colors = options.colors ? [options.colors] : null;\r\n    const lines = CreateLineSystem(\r\n        name,\r\n        { lines: [options.points], updatable: options.updatable, instance: options.instance, colors: colors, useVertexAlpha: options.useVertexAlpha, material: options.material },\r\n        scene\r\n    );\r\n    return lines;\r\n}\r\n\r\n/**\r\n * Creates a dashed line mesh\r\n * * A dashed line mesh is considered as a parametric shape since it has no predefined original shape. Its shape is determined by the passed array of points as an input parameter\r\n * * Like every other parametric shape, it is dynamically updatable by passing an existing instance of LineMesh to this static function\r\n * * The parameter `points` is an array successive Vector3\r\n * * The parameter `dashNb` is the intended total number of dashes (positive integer, default 200)\r\n * * The parameter `dashSize` is the size of the dashes relatively the dash number (positive float, default 3)\r\n * * The parameter `gapSize` is the size of the gap between two successive dashes relatively the dash number (positive float, default 1)\r\n * * The optional parameter `instance` is an instance of an existing LineMesh object to be updated with the passed `points` parameter : https://doc.babylonjs.com/features/featuresDeepDive/mesh/dynamicMeshMorph#lines-and-dashedlines\r\n * * The optional parameter `useVertexAlpha` is to be set to `false` (default `true`) when you don't need the alpha blending (faster)\r\n * * The optional parameter `material` is the material to use to draw the lines if provided. If not, a default material will be created\r\n * * When updating an instance, remember that only point positions can change, not the number of points\r\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n * @param name defines the name of the mesh\r\n * @param options defines the options used to create the mesh\r\n * @param scene defines the hosting scene\r\n * @returns the dashed line mesh\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/param#dashed-lines\r\n */\r\nexport function CreateDashedLines(\r\n    name: string,\r\n    options: { points: Vector3[]; dashSize?: number; gapSize?: number; dashNb?: number; updatable?: boolean; instance?: LinesMesh; useVertexAlpha?: boolean; material?: Material },\r\n    scene: Nullable<Scene> = null\r\n): LinesMesh {\r\n    const points = options.points;\r\n    const instance = options.instance;\r\n    const gapSize = options.gapSize || 1;\r\n    const dashSize = options.dashSize || 3;\r\n\r\n    if (instance) {\r\n        //  dashed lines update\r\n        const positionFunction = (positions: FloatArray): void => {\r\n            const curvect = Vector3.Zero();\r\n            const nbSeg = positions.length / 6;\r\n            let lg = 0;\r\n            let nb = 0;\r\n            let shft = 0;\r\n            let dashshft = 0;\r\n            let curshft = 0;\r\n            let p = 0;\r\n            let i = 0;\r\n            let j = 0;\r\n            for (i = 0; i < points.length - 1; i++) {\r\n                points[i + 1].subtractToRef(points[i], curvect);\r\n                lg += curvect.length();\r\n            }\r\n            shft = lg / nbSeg;\r\n            const dashSize = instance!._creationDataStorage!.dashSize;\r\n            const gapSize = instance!._creationDataStorage!.gapSize;\r\n            dashshft = (dashSize * shft) / (dashSize + gapSize);\r\n            for (i = 0; i < points.length - 1; i++) {\r\n                points[i + 1].subtractToRef(points[i], curvect);\r\n                nb = Math.floor(curvect.length() / shft);\r\n                curvect.normalize();\r\n                j = 0;\r\n                while (j < nb && p < positions.length) {\r\n                    curshft = shft * j;\r\n                    positions[p] = points[i].x + curshft * curvect.x;\r\n                    positions[p + 1] = points[i].y + curshft * curvect.y;\r\n                    positions[p + 2] = points[i].z + curshft * curvect.z;\r\n                    positions[p + 3] = points[i].x + (curshft + dashshft) * curvect.x;\r\n                    positions[p + 4] = points[i].y + (curshft + dashshft) * curvect.y;\r\n                    positions[p + 5] = points[i].z + (curshft + dashshft) * curvect.z;\r\n                    p += 6;\r\n                    j++;\r\n                }\r\n            }\r\n            while (p < positions.length) {\r\n                positions[p] = points[i].x;\r\n                positions[p + 1] = points[i].y;\r\n                positions[p + 2] = points[i].z;\r\n                p += 3;\r\n            }\r\n        };\r\n        if (options.dashNb || options.dashSize || options.gapSize || options.useVertexAlpha || options.material) {\r\n            Logger.Warn(\"You have used an option other than points with the instance option. Please be aware that these other options will be ignored.\");\r\n        }\r\n        instance.updateMeshPositions(positionFunction, false);\r\n        return instance;\r\n    }\r\n    // dashed lines creation\r\n    const dashedLines = new LinesMesh(name, scene, null, undefined, undefined, undefined, options.useVertexAlpha, options.material);\r\n    const vertexData = CreateDashedLinesVertexData(options);\r\n    vertexData.applyToMesh(dashedLines, options.updatable);\r\n\r\n    dashedLines._creationDataStorage = new _CreationDataStorage();\r\n    dashedLines._creationDataStorage.dashSize = dashSize;\r\n    dashedLines._creationDataStorage.gapSize = gapSize;\r\n    return dashedLines;\r\n}\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n * @deprecated use the functions directly from the module\r\n */\r\nexport const LinesBuilder = {\r\n    CreateDashedLines,\r\n    CreateLineSystem,\r\n    CreateLines,\r\n};\r\n\r\nVertexData.CreateLineSystem = CreateLineSystemVertexData;\r\nVertexData.CreateDashedLines = CreateDashedLinesVertexData;\r\n\r\nMesh.CreateLines = (name: string, points: Vector3[], scene: Nullable<Scene> = null, updatable: boolean = false, instance: Nullable<LinesMesh> = null): LinesMesh => {\r\n    const options = {\r\n        points,\r\n        updatable,\r\n        instance,\r\n    };\r\n    return CreateLines(name, options, scene);\r\n};\r\n\r\nMesh.CreateDashedLines = (\r\n    name: string,\r\n    points: Vector3[],\r\n    dashSize: number,\r\n    gapSize: number,\r\n    dashNb: number,\r\n    scene: Nullable<Scene> = null,\r\n    updatable?: boolean,\r\n    instance?: LinesMesh\r\n): LinesMesh => {\r\n    const options = {\r\n        points,\r\n        dashSize,\r\n        gapSize,\r\n        dashNb,\r\n        updatable,\r\n        instance,\r\n    };\r\n    return CreateDashedLines(name, options, scene);\r\n};\r\n", "import type { Scene } from \"../../scene\";\r\nimport type { Vector4 } from \"../../Maths/math.vector\";\r\nimport { Mesh } from \"../mesh\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { Plane } from \"../../Maths/math.plane\";\r\nimport { CompatibilityOptions } from \"../../Compat/compatibilityOptions\";\r\n\r\n/**\r\n * Creates the VertexData for a Plane\r\n * @param options an object used to set the following optional parameters for the plane, required but can be empty\r\n * * size sets the width and height of the plane to the value of size, optional default 1\r\n * * width sets the width (x direction) of the plane, overwrites the width set by size, optional, default size\r\n * * height sets the height (y direction) of the plane, overwrites the height set by size, optional, default size\r\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n * @returns the VertexData of the box\r\n */\r\nexport function CreatePlaneVertexData(options: { size?: number; width?: number; height?: number; sideOrientation?: number; frontUVs?: Vector4; backUVs?: Vector4 }): VertexData {\r\n    const indices = [];\r\n    const positions = [];\r\n    const normals = [];\r\n    const uvs = [];\r\n\r\n    const width: number = options.width || options.size || 1;\r\n    const height: number = options.height || options.size || 1;\r\n    const sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;\r\n\r\n    // Vertices\r\n    const halfWidth = width / 2.0;\r\n    const halfHeight = height / 2.0;\r\n\r\n    positions.push(-halfWidth, -halfHeight, 0);\r\n    normals.push(0, 0, -1.0);\r\n    uvs.push(0.0, CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 : 0.0);\r\n\r\n    positions.push(halfWidth, -halfHeight, 0);\r\n    normals.push(0, 0, -1.0);\r\n    uvs.push(1.0, CompatibilityOptions.UseOpenGLOrientationForUV ? 1.0 : 0.0);\r\n\r\n    positions.push(halfWidth, halfHeight, 0);\r\n    normals.push(0, 0, -1.0);\r\n    uvs.push(1.0, CompatibilityOptions.UseOpenGLOrientationForUV ? 0.0 : 1.0);\r\n\r\n    positions.push(-halfWidth, halfHeight, 0);\r\n    normals.push(0, 0, -1.0);\r\n    uvs.push(0.0, CompatibilityOptions.UseOpenGLOrientationForUV ? 0.0 : 1.0);\r\n\r\n    // Indices\r\n    indices.push(0);\r\n    indices.push(1);\r\n    indices.push(2);\r\n\r\n    indices.push(0);\r\n    indices.push(2);\r\n    indices.push(3);\r\n\r\n    // Sides\r\n    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\r\n\r\n    // Result\r\n    const vertexData = new VertexData();\r\n\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    vertexData.normals = normals;\r\n    vertexData.uvs = uvs;\r\n\r\n    return vertexData;\r\n}\r\n\r\n/**\r\n * Creates a plane mesh\r\n * * The parameter `size` sets the size (float) of both sides of the plane at once (default 1)\r\n * * You can set some different plane dimensions by using the parameters `width` and `height` (both by default have the same value of `size`)\r\n * * The parameter `sourcePlane` is a Plane instance. It builds a mesh plane from a Math plane\r\n * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#side-orientation\r\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n * @param name defines the name of the mesh\r\n * @param options defines the options used to create the mesh\r\n * @param scene defines the hosting scene\r\n * @returns the plane mesh\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#plane\r\n */\r\nexport function CreatePlane(\r\n    name: string,\r\n    options: { size?: number; width?: number; height?: number; sideOrientation?: number; frontUVs?: Vector4; backUVs?: Vector4; updatable?: boolean; sourcePlane?: Plane } = {},\r\n    scene: Nullable<Scene> = null\r\n): Mesh {\r\n    const plane = new Mesh(name, scene);\r\n\r\n    options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\r\n    plane._originalBuilderSideOrientation = options.sideOrientation;\r\n\r\n    const vertexData = CreatePlaneVertexData(options);\r\n\r\n    vertexData.applyToMesh(plane, options.updatable);\r\n\r\n    if (options.sourcePlane) {\r\n        plane.translate(options.sourcePlane.normal, -options.sourcePlane.d);\r\n        plane.setDirection(options.sourcePlane.normal.scale(-1));\r\n    }\r\n\r\n    return plane;\r\n}\r\n\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n * @deprecated use the function directly from the module\r\n */\r\nexport const PlaneBuilder = {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    CreatePlane,\r\n};\r\n\r\nVertexData.CreatePlane = CreatePlaneVertexData;\r\nMesh.CreatePlane = (name: string, size: number, scene: Scene, updatable?: boolean, sideOrientation?: number): Mesh => {\r\n    const options = {\r\n        size,\r\n        width: size,\r\n        height: size,\r\n        sideOrientation,\r\n        updatable,\r\n    };\r\n\r\n    return CreatePlane(name, options, scene);\r\n};\r\n", "\nimport aabb from 'aabb-3d'\nimport vec3 from 'gl-vec3'\nimport sweep from 'voxel-aabb-sweep'\n\nimport { RigidBody } from './rigidBody'\nexport { RigidBody }\n\n\nvar DEBUG = 0\n\n\nexport function DefaultOptions() {\n    this.airDrag = 0.1\n    this.fluidDrag = 0.4\n    this.fluidDensity = 2.0\n    this.gravity = [0, -10, 0]\n    this.minBounceImpulse = .5 // lowest collision impulse that bounces\n}\n\n\n\n\n/**\n *          Voxel Physics Engine\n * \n * Models a world of rigid bodies, to be integrated against\n * solid or liquid voxel terrain.\n * \n * Takes `testSolid(x,y,z)` function to query block solidity\n * Takes `testFluid(x,y,z)` function to query if a block is a fluid\n *  \n * The `options` argument can take the following params:\n * \n * ```js\n * {\n *     airDrag: 0.1,\n *     fluidDrag: 0.4,\n *     fluidDensity: 2.0,\n *     gravity: [0, -10, 0],\n *     minBounceImpulse: .5, // lowest collision impulse that bounces\n * }\n * ```\n * \n * @param {(x:number, y:number, z:number) => boolean} testSolid\n * @param {(x:number, y:number, z:number) => boolean} testFluid\n * \n*/\nexport function Physics(opts, testSolid, testFluid) {\n    opts = Object.assign(new DefaultOptions(), opts)\n\n    this.gravity = opts.gravity || [0, -10, 0]\n    this.airDrag = opts.airDrag || 0.1\n    this.fluidDensity = opts.fluidDensity || 2.0\n    this.fluidDrag = opts.fluidDrag || 0.4\n    this.minBounceImpulse = opts.minBounceImpulse\n    this.bodies = []\n\n    // collision function - TODO: abstract this into a setter?\n    this.testSolid = testSolid\n    this.testFluid = testFluid\n}\n\n\n/** \n * Adds a physics body to the simulation\n * @returns {RigidBody}\n*/\nPhysics.prototype.addBody = function (_aabb, mass, friction,\n    restitution, gravMult, onCollide) {\n    _aabb = _aabb || new aabb([0, 0, 0], [1, 1, 1])\n    if (typeof mass == 'undefined') mass = 1\n    if (typeof friction == 'undefined') friction = 1\n    if (typeof restitution == 'undefined') restitution = 0\n    if (typeof gravMult == 'undefined') gravMult = 1\n    var b = new RigidBody(_aabb, mass, friction, restitution, gravMult, onCollide)\n    this.bodies.push(b)\n    return b\n}\n\n/** Removes a body, by direct reference */\nPhysics.prototype.removeBody = function (b) {\n    var i = this.bodies.indexOf(b)\n    if (i < 0) return undefined\n    this.bodies.splice(i, 1)\n    b.aabb = b.onCollide = null\n}\n\n\n\n\n/*\n *    PHYSICS AND COLLISIONS\n*/\n\nvar a = vec3.create()\nvar dv = vec3.create()\nvar dx = vec3.create()\nvar impacts = vec3.create()\nvar oldResting = vec3.create()\n\n\n/* Ticks the simulation forwards in time. */\nPhysics.prototype.tick = function (dt) {\n    // convert dt to seconds\n    dt = dt / 1000\n    var noGravity = equals(0, vec3.squaredLength(this.gravity))\n    this.bodies.forEach(b => iterateBody(this, b, dt, noGravity))\n}\n\n\n\n/*\n *    PER-BODY MAIN PHYSICS ROUTINE\n*/\n\nfunction iterateBody(self, b, dt, noGravity) {\n    vec3.copy(oldResting, b.resting)\n\n    // treat bodies with <= mass as static\n    if (b.mass <= 0) {\n        vec3.set(b.velocity, 0, 0, 0)\n        vec3.set(b._forces, 0, 0, 0)\n        vec3.set(b._impulses, 0, 0, 0)\n        return\n    }\n\n    // skip bodies if static or no velocity/forces/impulses\n    var localNoGrav = noGravity || (b.gravityMultiplier === 0)\n    if (bodyAsleep(self, b, dt, localNoGrav)) return\n    b._sleepFrameCount--\n\n    // check if under water, if so apply buoyancy and drag forces\n    applyFluidForces(self, b)\n\n    // debug hooks\n    sanityCheck(b._forces)\n    sanityCheck(b._impulses)\n    sanityCheck(b.velocity)\n    sanityCheck(b.resting)\n\n    // semi-implicit Euler integration\n\n    // a = f/m + gravity*gravityMultiplier\n    vec3.scale(a, b._forces, 1 / b.mass)\n    vec3.scaleAndAdd(a, a, self.gravity, b.gravityMultiplier)\n\n    // dv = i/m + a*dt\n    // v1 = v0 + dv\n    vec3.scale(dv, b._impulses, 1 / b.mass)\n    vec3.scaleAndAdd(dv, dv, a, dt)\n    vec3.add(b.velocity, b.velocity, dv)\n\n    // apply friction based on change in velocity this frame\n    if (b.friction) {\n        applyFrictionByAxis(0, b, dv)\n        applyFrictionByAxis(1, b, dv)\n        applyFrictionByAxis(2, b, dv)\n    }\n\n    // linear air or fluid friction - effectively v *= drag\n    // body settings override global settings\n    var drag = (b.airDrag >= 0) ? b.airDrag : self.airDrag\n    if (b.inFluid) {\n        drag = (b.fluidDrag >= 0) ? b.fluidDrag : self.fluidDrag\n        drag *= 1 - (1 - b.ratioInFluid) ** 2\n    }\n    var mult = Math.max(1 - drag * dt / b.mass, 0)\n    vec3.scale(b.velocity, b.velocity, mult)\n\n    // x1-x0 = v1*dt\n    vec3.scale(dx, b.velocity, dt)\n\n    // clear forces and impulses for next timestep\n    vec3.set(b._forces, 0, 0, 0)\n    vec3.set(b._impulses, 0, 0, 0)\n\n    // cache old position for use in autostepping\n    if (b.autoStep) {\n        cloneAABB(tmpBox, b.aabb)\n    }\n\n    // sweeps aabb along dx and accounts for collisions\n    processCollisions(self, b.aabb, dx, b.resting)\n\n    // if autostep, and on ground, run collisions again with stepped up aabb\n    if (b.autoStep) {\n        tryAutoStepping(self, b, tmpBox, dx)\n    }\n\n    // Collision impacts. b.resting shows which axes had collisions:\n    for (var i = 0; i < 3; ++i) {\n        impacts[i] = 0\n        if (b.resting[i]) {\n            // count impact only if wasn't collided last frame\n            if (!oldResting[i]) impacts[i] = -b.velocity[i]\n            b.velocity[i] = 0\n        }\n    }\n    var mag = vec3.length(impacts)\n    if (mag > .001) { // epsilon\n        // send collision event - allows client to optionally change\n        // body's restitution depending on what terrain it hit\n        // event argument is impulse J = m * dv\n        vec3.scale(impacts, impacts, b.mass)\n        if (b.onCollide) b.onCollide(impacts)\n\n        // bounce depending on restitution and minBounceImpulse\n        if (b.restitution > 0 && mag > self.minBounceImpulse) {\n            vec3.scale(impacts, impacts, b.restitution)\n            b.applyImpulse(impacts)\n        }\n    }\n\n\n    // sleep check\n    var vsq = vec3.squaredLength(b.velocity)\n    if (vsq > 1e-5) b._markActive()\n}\n\n\n\n\n\n\n\n\n/*\n *    FLUIDS\n*/\n\nfunction applyFluidForces(self, body) {\n    // First pass at handling fluids. Assumes fluids are settled\n    //   thus, only check at corner of body, and only from bottom up\n    var box = body.aabb\n    var cx = Math.floor(box.base[0])\n    var cz = Math.floor(box.base[2])\n    var y0 = Math.floor(box.base[1])\n    var y1 = Math.floor(box.max[1])\n\n    if (!self.testFluid(cx, y0, cz)) {\n        body.inFluid = false\n        body.ratioInFluid = 0\n        return\n    }\n\n    // body is in a fluid - find out how much of body is submerged\n    var submerged = 1\n    var cy = y0 + 1\n    while (cy <= y1 && self.testFluid(cx, cy, cz)) {\n        submerged++\n        cy++\n    }\n    var fluidLevel = y0 + submerged\n    var heightInFluid = fluidLevel - box.base[1]\n    var ratioInFluid = heightInFluid / box.vec[1]\n    if (ratioInFluid > 1) ratioInFluid = 1\n    var vol = box.vec[0] * box.vec[1] * box.vec[2]\n    var displaced = vol * ratioInFluid\n    // bouyant force = -gravity * fluidDensity * volumeDisplaced\n    var f = _fluidVec\n    vec3.scale(f, self.gravity, -self.fluidDensity * displaced)\n    body.applyForce(f)\n\n    body.inFluid = true\n    body.ratioInFluid = ratioInFluid\n}\n\nvar _fluidVec = vec3.create()\n\n\n\n\n\n/*\n *    FRICTION\n*/\n\n\nfunction applyFrictionByAxis(axis, body, dvel) {\n    // friction applies only if moving into a touched surface\n    var restDir = body.resting[axis]\n    var vNormal = dvel[axis]\n    if (restDir === 0) return\n    if (restDir * vNormal <= 0) return\n\n    // current vel lateral to friction axis\n    vec3.copy(lateralVel, body.velocity)\n    lateralVel[axis] = 0\n    var vCurr = vec3.length(lateralVel)\n    if (equals(vCurr, 0)) return\n\n    // treat current change in velocity as the result of a pseudoforce\n    //        Fpseudo = m*dv/dt\n    // Base friction force on normal component of the pseudoforce\n    //        Ff = u * Fnormal\n    //        Ff = u * m * dvnormal / dt\n    // change in velocity due to friction force\n    //        dvF = dt * Ff / m\n    //            = dt * (u * m * dvnormal / dt) / m\n    //            = u * dvnormal\n    var dvMax = Math.abs(body.friction * vNormal)\n\n    // decrease lateral vel by dvMax (or clamp to zero)\n    var scaler = (vCurr > dvMax) ? (vCurr - dvMax) / vCurr : 0\n    body.velocity[(axis + 1) % 3] *= scaler\n    body.velocity[(axis + 2) % 3] *= scaler\n}\nvar lateralVel = vec3.create()\n\n\n\n\n\n\n/*\n *    COLLISION HANDLER\n*/\n\n// sweep aabb along velocity vector and set resting vector\nfunction processCollisions(self, box, velocity, resting) {\n    vec3.set(resting, 0, 0, 0)\n    return sweep(self.testSolid, box, velocity, function (dist, axis, dir, vec) {\n        resting[axis] = dir\n        vec[axis] = 0\n    })\n}\n\n\n\n\n\n/*\n *    AUTO-STEPPING\n*/\n\nvar tmpBox = new aabb([], [])\nvar tmpResting = vec3.create()\nvar targetPos = vec3.create()\nvar upvec = vec3.create()\nvar leftover = vec3.create()\n\nfunction tryAutoStepping(self, b, oldBox, dx) {\n    if (b.resting[1] >= 0 && !b.inFluid) return\n\n    // // direction movement was blocked before trying a step\n    var xBlocked = (b.resting[0] !== 0)\n    var zBlocked = (b.resting[2] !== 0)\n    if (!(xBlocked || zBlocked)) return\n\n    // continue autostepping only if headed sufficiently into obstruction\n    var ratio = Math.abs(dx[0] / dx[2])\n    var cutoff = 4\n    if (!xBlocked && ratio > cutoff) return\n    if (!zBlocked && ratio < 1 / cutoff) return\n\n    // original target position before being obstructed\n    vec3.add(targetPos, oldBox.base, dx)\n\n    // move towards the target until the first X/Z collision\n    var getVoxels = self.testSolid\n    sweep(getVoxels, oldBox, dx, function (dist, axis, dir, vec) {\n        if (axis === 1) vec[axis] = 0\n        else return true\n    })\n\n    var y = b.aabb.base[1]\n    var ydist = Math.floor(y + 1.001) - y\n    vec3.set(upvec, 0, ydist, 0)\n    var collided = false\n    // sweep up, bailing on any obstruction\n    sweep(getVoxels, oldBox, upvec, function (dist, axis, dir, vec) {\n        collided = true\n        return true\n    })\n    if (collided) return // could't move upwards\n\n    // now move in X/Z however far was left over before hitting the obstruction\n    vec3.subtract(leftover, targetPos, oldBox.base)\n    leftover[1] = 0\n    processCollisions(self, oldBox, leftover, tmpResting)\n\n    // bail if no movement happened in the originally blocked direction\n    if (xBlocked && !equals(oldBox.base[0], targetPos[0])) return\n    if (zBlocked && !equals(oldBox.base[2], targetPos[2])) return\n\n    // done - oldBox is now at the target autostepped position\n    cloneAABB(b.aabb, oldBox)\n    b.resting[0] = tmpResting[0]\n    b.resting[2] = tmpResting[2]\n    if (b.onStep) b.onStep()\n}\n\n\n\n\n\n/*\n *    SLEEP CHECK\n*/\n\nfunction bodyAsleep(self, body, dt, noGravity) {\n    if (body._sleepFrameCount > 0) return false\n    // without gravity bodies stay asleep until a force/impulse wakes them up\n    if (noGravity) return true\n    // otherwise check body is resting against something\n    // i.e. sweep along by distance d = 1/2 g*t^2\n    // and check there's still a collision\n    var isResting = false\n    var gmult = 0.5 * dt * dt * body.gravityMultiplier\n    vec3.scale(sleepVec, self.gravity, gmult)\n    sweep(self.testSolid, body.aabb, sleepVec, function () {\n        isResting = true\n        return true\n    }, true)\n    return isResting\n}\nvar sleepVec = vec3.create()\n\n\n\n\n\nfunction equals(a, b) { return Math.abs(a - b) < 1e-5 }\n\nfunction cloneAABB(tgt, src) {\n    for (var i = 0; i < 3; i++) {\n        tgt.base[i] = src.base[i]\n        tgt.max[i] = src.max[i]\n        tgt.vec[i] = src.vec[i]\n    }\n}\n\n\n\nvar sanityCheck = function (v) { }\nif (DEBUG) sanityCheck = function (v) {\n    if (isNaN(vec3.length(v))) throw 'Vector with NAN: ' + v\n}\n", "\nimport aabb from 'aabb-3d'\nimport vec3 from 'gl-vec3'\n\nvar DEBUG = 0\n\n\n\n/*\n *    RIGID BODY - internal data structure\n *  Only AABB bodies right now. Someday will likely need spheres?\n*/\n\nexport class RigidBody {\n    constructor(_aabb, mass, friction, restitution, gravMult, onCollide, autoStep) {\n        this.aabb = new aabb(_aabb.base, _aabb.vec) // clone\n        this.mass = mass\n        this.friction = friction\n        this.restitution = restitution\n        this.gravityMultiplier = gravMult\n        this.onCollide = onCollide\n        this.autoStep = !!autoStep\n        this.airDrag = -1   // overrides global airDrag when >= 0\n        this.fluidDrag = -1 // overrides global fluidDrag when >= 0\n        this.onStep = null\n\n        // internal state\n        this.velocity = vec3.create()\n        this.resting = [0, 0, 0]\n        this.inFluid = false\n\n        // internals\n        /** @internal */\n        this._ratioInFluid = 0\n        /** @internal */\n        this._forces = vec3.create()\n        /** @internal */\n        this._impulses = vec3.create()\n        /** @internal */\n        this._sleepFrameCount = 10 | 0\n    }\n\n    setPosition(p) {\n        sanityCheck(p)\n        vec3.subtract(p, p, this.aabb.base)\n        this.aabb.translate(p)\n        this._markActive()\n    }\n    getPosition() {\n        return vec3.clone(this.aabb.base)\n    }\n    applyForce(f) {\n        sanityCheck(f)\n        vec3.add(this._forces, this._forces, f)\n        this._markActive()\n    }\n    applyImpulse(i) {\n        sanityCheck(i)\n        vec3.add(this._impulses, this._impulses, i)\n        this._markActive()\n    }\n\n    /** @internal */\n    _markActive() {\n        this._sleepFrameCount = 10 | 0\n    }\n\n\n\n    // temp\n    atRestX() { return this.resting[0] }\n    atRestY() { return this.resting[1] }\n    atRestZ() { return this.resting[2] }\n}\n\n\n\n\nvar sanityCheck = (v) => { }\nif (DEBUG) sanityCheck = (v) => {\n    if (isNaN(vec3.length(v))) throw 'Vector with NAN: ' + v\n}\n", "\nimport { Physics as VoxelPhysics } from 'voxel-physics-engine'\n\n\n\n\nvar defaultOptions = {\n    gravity: [0, -10, 0],\n    airDrag: 0.1,\n}\n\n/**\n * `noa.physics` - Wrapper module for the physics engine.\n * \n * This module extends \n * [voxel-physics-engine](https://github.com/fenomas/voxel-physics-engine),\n * so turn on \"Inherited\" to see its APIs here, or view the base module \n * for full docs.\n * \n * This module uses the following default options (from the options\n * object passed to the {@link Engine}):\n * \n * ```js\n * {\n *     gravity: [0, -10, 0],\n *     airDrag: 0.1,\n *     fluidDrag: 0.4,\n *     fluidDensity: 2.0,\n *     minBounceImpulse: .5,      // cutoff for a bounce to occur\n * }\n * ```\n*/\n\nexport class Physics extends VoxelPhysics {\n\n    /** \n     * @internal \n     * @param {import('../index').Engine} noa\n    */\n    constructor(noa, opts) {\n        opts = Object.assign({}, defaultOptions, opts)\n        var world = noa.world\n        var solidLookup = noa.registry._solidityLookup\n        var fluidLookup = noa.registry._fluidityLookup\n\n        // physics engine runs in offset coords, so voxel getters need to match\n        var offset = noa.worldOriginOffset\n\n        var blockGetter = (x, y, z) => {\n            var id = world.getBlockID(x + offset[0], y + offset[1], z + offset[2])\n            return solidLookup[id]\n        }\n        var isFluidGetter = (x, y, z) => {\n            var id = world.getBlockID(x + offset[0], y + offset[1], z + offset[2])\n            return fluidLookup[id]\n        }\n\n        super(opts, blockGetter, isFluidGetter)\n    }\n\n}\n\n\n\n", "\nimport EventEmitter from 'events'\nimport { Chunk } from './chunk'\nimport { LocationQueue, ChunkStorage, locationHasher } from './util'\n\nvar PROFILE_EVERY = 0               // ticks\nvar PROFILE_QUEUES_EVERY = 0        // ticks\n\n\n\n\n\n\nvar defaultOptions = {\n    chunkSize: 24,\n    chunkAddDistance: [2, 2],           // [horizontal, vertical]\n    chunkRemoveDistance: [3, 3],        // [horizontal, vertical]\n    worldGenWhilePaused: false,\n    manuallyControlChunkLoading: false,\n}\n\n/**\n * `noa.world` - manages world data, chunks, voxels.\n * \n * This module uses the following default options (from the options\n * object passed to the {@link Engine}):\n * ```js\n * var defaultOptions = {\n *   chunkSize: 24,\n *   chunkAddDistance: [2, 2],           // [horizontal, vertical]\n *   chunkRemoveDistance: [3, 3],        // [horizontal, vertical]\n *   worldGenWhilePaused: false,\n *   manuallyControlChunkLoading: false,\n * }\n * ```\n * \n * **Events:**\n *  + `worldDataNeeded = (requestID, dataArr, x, y, z, worldName)`  \n *    Alerts client that a new chunk of world data is needed.\n *  + `playerEnteredChunk => (i, j, k)`    \n *    Fires when player enters a new chunk\n *  + `chunkAdded => (chunk)`  \n *    Fires after a new chunk object is added to the world\n *  + `chunkBeingRemoved = (requestID, dataArr, userData)`  \n *    Fires before a chunk is removed from world\n*/\nexport class World extends EventEmitter {\n\n    /** @internal */\n    constructor(noa, opts) {\n        super()\n        opts = Object.assign({}, defaultOptions, opts)\n        /** @internal */\n        this.noa = noa\n\n        /** @internal */\n        this.playerChunkLoaded = false\n\n        /** @internal */\n        this.Chunk = Chunk // expose this class for ...reasons\n\n        /**\n         * Game clients should set this if they need to manually control \n         * which chunks to load and unload. When set, client should call \n         * `noa.world.manuallyLoadChunk` / `manuallyUnloadChunk` as needed.\n         */\n        this.manuallyControlChunkLoading = !!opts.manuallyControlChunkLoading\n\n        /**\n         * Defining this function sets a custom order in which to create chunks.\n         * The function should look like:\n         * ```js\n         *   (i, j, k) => 1 // return a smaller number for chunks to process first\n         * ```\n         */\n        this.chunkSortingDistFn = defaultSortDistance\n\n        /**\n         * Set this higher to cause chunks not to mesh until they have some neighbors.\n         * Max legal value is 26 (each chunk will mesh only when all neighbors are present)\n         */\n        this.minNeighborsToMesh = 6\n\n        /** When true, worldgen queues will keep running if engine is paused. */\n        this.worldGenWhilePaused = !!opts.worldGenWhilePaused\n\n        /** Limit the size of internal chunk processing queues \n         * @type {number} \n        */\n        this.maxChunksPendingCreation = 50\n\n        /** Limit the size of internal chunk processing queues \n         * @type {number} \n        */\n        this.maxChunksPendingMeshing = 50\n\n        /** Cutoff (in ms) of time spent each **tick** \n         * @type {number}\n        */\n        this.maxProcessingPerTick = 5\n\n        /** Cutoff (in ms) of time spent each **render** \n         * @type {number}\n        */\n        this.maxProcessingPerRender = 3\n\n\n        // set up internal state\n\n\n        /** @internal */\n        this._chunkSize = opts.chunkSize\n        /** @internal */\n        this._chunkAddDistance = [2, 2]\n        /** @internal */\n        this._chunkRemoveDistance = [3, 3]\n        /** @internal */\n        this._addDistanceFn = null\n        /** @internal */\n        this._remDistanceFn = null\n        /** @internal */\n        this._prevWorldName = ''\n        /** @internal */\n        this._prevPlayerChunkHash = 0\n        /** @internal */\n        this._chunkAddSearchFrom = 0\n        /** @internal */\n        this._prevSortingFn = null\n        /** @internal */\n        this._sortMeshQueueEvery = 0\n\n\n        // Init internal chunk queues:\n\n        /** @internal All chunks existing in any queue */\n        this._chunksKnown = new LocationQueue()\n\n        /** @internal in range but not yet requested from client */\n        this._chunksToRequest = new LocationQueue()\n        /** @internal known to have invalid data (wrong world, eg) */\n        this._chunksInvalidated = new LocationQueue()\n        /** @internal out of range, and waiting to be removed */\n        this._chunksToRemove = new LocationQueue()\n\n        /** @internal requested, awaiting data event from client */\n        this._chunksPending = new LocationQueue()\n        /** @internal has data, waiting to be (re-)meshed */\n        this._chunksToMesh = new LocationQueue()\n        /** @internal priority queue for chunks to re-mesh */\n        this._chunksToMeshFirst = new LocationQueue()\n\n        /** \n         * @internal A queue of chunk locations, rather than chunk references.\n         * Has only the positive 1/16 quadrant, sorted (reverse order!) */\n        this._chunksSortedLocs = new LocationQueue()\n\n        // validate add/remove sizes through a setter that clients can use later\n        this.setAddRemoveDistance(opts.chunkAddDistance, opts.chunkRemoveDistance)\n\n        // chunks stored in a data structure for quick lookup\n        // note that the hash wraps around every 1024 chunk indexes!!\n        // i.e. two chunks that far apart can't be loaded at the same time\n        /** @internal */\n        this._storage = new ChunkStorage()\n\n        // coordinate converter functions - default versions first:\n        var cs = this._chunkSize\n        /** @internal */\n        this._coordsToChunkIndexes = chunkCoordsToIndexesGeneral\n        /** @internal */\n        this._coordsToChunkLocals = chunkCoordsToLocalsGeneral\n\n        // when chunk size is a power of two, override with bit-twiddling:\n        var powerOfTwo = ((cs & cs - 1) === 0)\n        if (powerOfTwo) {\n            /** @internal */\n            this._coordShiftBits = Math.log2(cs) | 0\n            /** @internal */\n            this._coordMask = (cs - 1) | 0\n            this._coordsToChunkIndexes = chunkCoordsToIndexesPowerOfTwo\n            this._coordsToChunkLocals = chunkCoordsToLocalsPowerOfTwo\n        }\n    }\n}\n\n\n\n\n\n/*\n *\n *\n *\n *\n *                  PUBLIC API \n *\n *\n *\n *\n*/\n\nWorld.prototype.getBlockID = function (x = 0, y = 0, z = 0) {\n    var [ci, cj, ck] = this._coordsToChunkIndexes(x, y, z)\n    var chunk = this._storage.getChunkByIndexes(ci, cj, ck)\n    if (!chunk) return 0\n    var [i, j, k] = this._coordsToChunkLocals(x, y, z)\n    return chunk.voxels.get(i, j, k)\n}\n\nWorld.prototype.getBlockSolidity = function (x = 0, y = 0, z = 0) {\n    var [ci, cj, ck] = this._coordsToChunkIndexes(x, y, z)\n    var chunk = this._storage.getChunkByIndexes(ci, cj, ck)\n    if (!chunk) return false\n    var [i, j, k] = this._coordsToChunkLocals(x, y, z)\n    return !!chunk.getSolidityAt(i, j, k)\n}\n\nWorld.prototype.getBlockOpacity = function (x = 0, y = 0, z = 0) {\n    var id = this.getBlockID(x, y, z)\n    return this.noa.registry.getBlockOpacity(id)\n}\n\nWorld.prototype.getBlockFluidity = function (x = 0, y = 0, z = 0) {\n    var id = this.getBlockID(x, y, z)\n    return this.noa.registry.getBlockFluidity(id)\n}\n\nWorld.prototype.getBlockProperties = function (x = 0, y = 0, z = 0) {\n    var id = this.getBlockID(x, y, z)\n    return this.noa.registry.getBlockProps(id)\n}\n\n\nWorld.prototype.setBlockID = function (id = 0, x = 0, y = 0, z = 0) {\n    var [ci, cj, ck] = this._coordsToChunkIndexes(x, y, z)\n    var chunk = this._storage.getChunkByIndexes(ci, cj, ck)\n    if (!chunk) return\n    var [i, j, k] = this._coordsToChunkLocals(x, y, z)\n    return chunk.set(i, j, k, id)\n}\n\n\n/** @param box */\nWorld.prototype.isBoxUnobstructed = function (box) {\n    var base = box.base\n    var max = box.max\n    for (var i = Math.floor(base[0]); i < max[0] + 1; i++) {\n        for (var j = Math.floor(base[1]); j < max[1] + 1; j++) {\n            for (var k = Math.floor(base[2]); k < max[2] + 1; k++) {\n                if (this.getBlockSolidity(i, j, k)) return false\n            }\n        }\n    }\n    return true\n}\n\n\n/** \n * Clients should call this after creating a chunk's worth of data (as an ndarray)  \n * If userData is passed in it will be attached to the chunk\n * @param {string} id - the string specified when the chunk was requested \n * @param {*} array - an ndarray of voxel data\n * @param {*} userData - an arbitrary value for game client use\n * @param {number} fillVoxelID - specify a voxel ID here if you want to signify that \n * the entire chunk should be solidly filled with that voxel (e.g. `0` for air). \n * If you do this, the voxel array data will be overwritten and the engine will \n * take a fast path through some initialization steps.\n */\nWorld.prototype.setChunkData = function (id, array, userData = null, fillVoxelID = -1) {\n    setChunkData(this, id, array, userData, fillVoxelID)\n}\n\n\n\n/** \n * Sets the distances within which to load new chunks, and beyond which \n * to unload them. Generally you want the remove distance to be somewhat\n * farther, so that moving back and forth across the same chunk border doesn't\n * keep loading/unloading the same distant chunks.\n * \n * Both arguments can be numbers (number of voxels), or arrays like:\n * `[horiz, vert]` specifying different horizontal and vertical distances.\n * @param {number | number[]} addDist\n * @param {number | number[]} remDist\n */\nWorld.prototype.setAddRemoveDistance = function (addDist = 2, remDist = 3) {\n    var addArr = Array.isArray(addDist) ? addDist : [addDist, addDist]\n    var remArr = Array.isArray(remDist) ? remDist : [remDist, remDist]\n    var minGap = 1\n    if (remArr[0] < addArr[0] + minGap) remArr[0] = addArr[0] + minGap\n    if (remArr[1] < addArr[1] + minGap) remArr[1] = addArr[1] + minGap\n    this._chunkAddDistance = addArr\n    this._chunkRemoveDistance = remArr\n    // rebuild chunk distance functions and add search locations\n    this._addDistanceFn = makeDistanceTestFunction(addArr[0], addArr[1])\n    this._remDistanceFn = makeDistanceTestFunction(remArr[0], remArr[1])\n    this._chunksSortedLocs.empty()\n    // this queue holds only 1/16th the search space: i=0..max, j=0..i, k=0..max\n    for (var i = 0; i <= addArr[0]; i++) {\n        for (var k = 0; k <= i; k++) {\n            for (var j = 0; j <= addArr[1]; j++) {\n                if (!this._addDistanceFn(i, j, k)) continue\n                this._chunksSortedLocs.add(i, j, k)\n            }\n        }\n    }\n    // resets state of nearby chunk search\n    this._prevSortingFn = null\n    this._chunkAddSearchFrom = 0\n}\n\n\n\n\n\n\n/** \n * Tells noa to discard voxel data within a given `AABB` (e.g. because \n * the game client received updated data from a server). \n * The engine will mark all affected chunks for removal, and will later emit \n * new `worldDataNeeded` events (if the chunk is still in draw range).\n */\nWorld.prototype.invalidateVoxelsInAABB = function (box) {\n    invalidateChunksInBox(this, box)\n}\n\n\n/** When manually controlling chunk loading, tells the engine that the \n * chunk containing the specified (x,y,z) needs to be created and loaded.\n * > Note: throws unless `noa.world.manuallyControlChunkLoading` is set.\n * @param x, y, z\n */\nWorld.prototype.manuallyLoadChunk = function (x = 0, y = 0, z = 0) {\n    if (!this.manuallyControlChunkLoading) throw manualErr\n    var [i, j, k] = this._coordsToChunkIndexes(x, y, z)\n    this._chunksKnown.add(i, j, k)\n    this._chunksToRequest.add(i, j, k)\n}\n\n/** When manually controlling chunk loading, tells the engine that the \n * chunk containing the specified (x,y,z) needs to be unloaded and disposed.\n * > Note: throws unless `noa.world.manuallyControlChunkLoading` is set.\n * @param x, y, z\n */\nWorld.prototype.manuallyUnloadChunk = function (x = 0, y = 0, z = 0) {\n    if (!this.manuallyControlChunkLoading) throw manualErr\n    var [i, j, k] = this._coordsToChunkIndexes(x, y, z)\n    this._chunksToRemove.add(i, j, k)\n    this._chunksToMesh.remove(i, j, k)\n    this._chunksToRequest.remove(i, j, k)\n    this._chunksToMeshFirst.remove(i, j, k)\n}\nvar manualErr = 'Set `noa.world.manuallyControlChunkLoading` if you need this API'\n\n\n\n\n/*\n * \n * \n * \n *                  internals:\n * \n *          tick functions that process queues and trigger events\n * \n * \n * \n*/\n\n/** @internal */\nWorld.prototype.tick = function () {\n    var tickStartTime = performance.now()\n\n    // get indexes of player's current chunk, and has it changed since last tick?\n    var [ci, cj, ck] = getPlayerChunkIndexes(this)\n    var chunkLocHash = locationHasher(ci, cj, ck)\n    var changedChunks = (chunkLocHash !== this._prevPlayerChunkHash)\n    if (changedChunks) {\n        this.emit('playerEnteredChunk', ci, cj, ck)\n        this._prevPlayerChunkHash = chunkLocHash\n        this._chunkAddSearchFrom = 0\n    }\n\n    // if world has changed, invalidate everything and ping\n    // removals queue so that player's chunk gets loaded back quickly\n    if (this._prevWorldName !== this.noa.worldName) {\n        if (!this.manuallyControlChunkLoading) {\n            markAllChunksInvalid(this)\n            this._chunkAddSearchFrom = 0\n            processRemoveQueue(this)\n        }\n        this._prevWorldName = this.noa.worldName\n    }\n\n    profile_hook('start')\n    profile_queues_hook('start')\n\n    // scan for chunks to add/remove (unless client handles manually)\n    if (!this.manuallyControlChunkLoading) {\n        findDistantChunksToRemove(this, ci, cj, ck)\n        profile_hook('remQueue')\n        findChunksToRequest(this, ci, cj, ck)\n        profile_hook('addQueue')\n    }\n\n    // possibly scan for additions to meshing queue if it's empty\n    findChunksToMesh(this)\n\n    // process (create or mesh) some chunks, up to max iteration time\n    var t = performance.now()\n    var t1 = tickStartTime + (this.maxProcessingPerTick || 0)\n    if (t < t1) t1 = t + 1\n    var done1 = false\n    var done2 = false\n    var done3 = false\n    while (t < t1) {\n        if (!done1) {\n            done1 = processRemoveQueue(this)\n                || processRemoveQueue(this)\n            profile_hook('removes')\n        }\n        if (!done2) {\n            done2 = processRequestQueue(this)\n            profile_hook('requests')\n        }\n        if (!done3) {\n            done3 = processMeshingQueue(this, false)\n            profile_hook('meshes')\n        }\n        if (done1 && done2 && done3) break\n        t = performance.now()\n    }\n\n    // track whether the player's local chunk is loaded and ready or not\n    var pChunk = this._storage.getChunkByIndexes(ci, cj, ck)\n    this.playerChunkLoaded = !!pChunk\n\n    profile_queues_hook('end', this)\n    profile_hook('end')\n}\n\n\n/** @internal */\nWorld.prototype.render = function () {\n    // on render, quickly process the high-priority meshing queue\n    // to help avoid flashes of background while neighboring chunks update\n    var t = performance.now()\n    var t1 = t + this.maxProcessingPerRender\n    while (t < t1) {\n        var done = processMeshingQueue(this, true)\n        if (done) break\n        t = performance.now()\n    }\n}\n\n\n/** @internal */\nWorld.prototype._getChunkByCoords = function (x = 0, y = 0, z = 0) {\n    // let internal modules request a chunk object\n    var [i, j, k] = this._coordsToChunkIndexes(x, y, z)\n    return this._storage.getChunkByIndexes(i, j, k)\n}\n\n\n\n\n\n\n\n\n\n\n/*\n * \n * \n * \n *              chunk queues and queue processing\n * \n * \n * \n*/\n\n// internal accessor for chunks to queue themeselves for remeshing \n// after their data changes\nWorld.prototype._queueChunkForRemesh = function (chunk) {\n    possiblyQueueChunkForMeshing(this, chunk)\n}\n\n\n\n/** \n * helper - chunk indexes of where the player is\n * @param {World} world \n*/\nfunction getPlayerChunkIndexes(world) {\n    var [x, y, z] = world.noa.entities.getPosition(world.noa.playerEntity)\n    return world._coordsToChunkIndexes(x, y, z)\n}\n\n\n\n\n/** \n * Gradually scan neighborhood chunk locs; add missing ones to \"toRequest\".\n * @param {World} world \n*/\nfunction findChunksToRequest(world, ci, cj, ck) {\n    var toRequest = world._chunksToRequest\n    var numQueued = toRequest.count()\n    var maxQueued = 50\n    if (numQueued >= maxQueued) return\n\n    // handle changes to chunk sorting function\n    var sortDistFn = world.chunkSortingDistFn || defaultSortDistance\n    if (sortDistFn !== world._prevSortingFn) {\n        sortQueueByDistanceFrom(world, world._chunksSortedLocs, 0, 0, 0, true)\n        world._prevSortingFn = sortDistFn\n    }\n\n    // consume the pre-sorted positions array, checking each loc and \n    // its reflections for locations that need to be added to request queue\n    var locsArr = world._chunksSortedLocs.arr\n    var ix = world._chunkAddSearchFrom\n    var maxIter = Math.min(20, locsArr.length / 10)\n    for (var ct = 0; ct < maxIter; ct++) {\n        var [di, dj, dk] = locsArr[ix++ % locsArr.length]\n        checkReflectedLocations(world, ci, cj, ck, di, dj, dk)\n        if (toRequest.count() >= maxQueued) break\n    }\n\n    // only advance start point if nothing is invalidated, \n    // so that nearyby chunks stay at high priority in that case\n    if (world._chunksInvalidated.isEmpty()) {\n        world._chunkAddSearchFrom = ix % locsArr.length\n    }\n\n    // queue should be mostly sorted, but may not have been empty\n    sortQueueByDistanceFrom(world, toRequest, ci, cj, ck, false)\n}\n\n// Helpers for checking whether to add a location, and reflections of it\nvar checkReflectedLocations = (world, ci, cj, ck, i, j, k) => {\n    checkOneLocation(world, ci + i, cj + j, ck + k)\n    if (i !== k) checkOneLocation(world, ci + k, cj + j, ck + i)\n    if (i > 0) checkReflectedLocations(world, ci, cj, ck, -i, j, k)\n    if (j > 0) checkReflectedLocations(world, ci, cj, ck, i, -j, k)\n    if (k > 0) checkReflectedLocations(world, ci, cj, ck, i, j, -k)\n}\n// finally, the logic for each reflected location checked\nvar checkOneLocation = (world, i, j, k) => {\n    if (world._chunksKnown.includes(i, j, k)) return\n    world._chunksKnown.add(i, j, k)\n    world._chunksToRequest.add(i, j, k, true)\n}\n\n\n\n\n\n/** \n * Incrementally scan known chunks for any that are no longer in range.\n * Assume that the order they're removed in isn't very important.\n * @param {World} world \n*/\nfunction findDistantChunksToRemove(world, ci, cj, ck) {\n    var distCheck = world._remDistanceFn\n    var toRemove = world._chunksToRemove\n    var numQueued = toRemove.count() + world._chunksInvalidated.count()\n    var maxQueued = 50\n    if (numQueued >= maxQueued) return\n\n    var knownArr = world._chunksKnown.arr\n    if (knownArr.length === 0) return\n    var maxIter = Math.min(100, knownArr.length / 10)\n    var found = false\n    for (var ct = 0; ct < maxIter; ct++) {\n        var [i, j, k] = knownArr[removeCheckIndex++ % knownArr.length]\n        if (toRemove.includes(i, j, k)) continue\n        if (distCheck(i - ci, j - cj, k - ck)) continue\n        // flag chunk for removal and remove it from work queues\n        world._chunksToRemove.add(i, j, k)\n        world._chunksToRequest.remove(i, j, k)\n        world._chunksToMesh.remove(i, j, k)\n        world._chunksToMeshFirst.remove(i, j, k)\n        found = true\n        numQueued++\n        if (numQueued > maxQueued) break\n    }\n    removeCheckIndex = removeCheckIndex % knownArr.length\n    if (found) sortQueueByDistanceFrom(world, toRemove, ci, cj, ck)\n}\nvar removeCheckIndex = 0\n\n\n/** \n * Incrementally look for chunks that could be re-meshed\n * @param {World} world \n*/\nfunction findChunksToMesh(world) {\n    var maxQueued = 10\n    var numQueued = world._chunksToMesh.count() + world._chunksToMeshFirst.count()\n    if (numQueued > maxQueued) return\n    var knownArr = world._chunksKnown.arr\n    var maxIter = Math.min(50, knownArr.length / 10)\n    for (var ct = 0; ct < maxIter; ct++) {\n        var [i, j, k] = knownArr[meshCheckIndex++ % knownArr.length]\n        var chunk = world._storage.getChunkByIndexes(i, j, k)\n        if (!chunk) continue\n        var res = possiblyQueueChunkForMeshing(world, chunk)\n        if (res) numQueued++\n        if (numQueued > maxQueued) break\n    }\n    meshCheckIndex %= knownArr.length\n}\nvar meshCheckIndex = 0\n\n\n\n\n\n\n/** \n * invalidate chunks overlapping the given AABB\n * @param {World} world \n*/\nfunction invalidateChunksInBox(world, box) {\n    var min = world._coordsToChunkIndexes(box.base[0], box.base[1], box.base[2])\n    var max = world._coordsToChunkIndexes(box.max[0], box.max[1], box.max[2])\n    for (var i = 0; i < 3; i++) {\n        if (!Number.isFinite(box.base[i])) min[i] = box.base[i]\n        if (!Number.isFinite(box.max[i])) max[i] = box.max[i]\n    }\n    world._chunksKnown.forEach(loc => {\n        var [i, j, k] = loc\n        if (i < min[0] || i >= max[0]) return\n        if (j < min[1] || j >= max[1]) return\n        if (k < min[2] || k >= max[2]) return\n        world._chunksInvalidated.add(i, j, k)\n        world._chunksToRemove.remove(i, j, k)\n        world._chunksToRequest.remove(i, j, k)\n        world._chunksToMesh.remove(i, j, k)\n        world._chunksToMeshFirst.remove(i, j, k)\n    })\n}\n\n\n\n/** \n * when current world changes - empty work queues and mark all for removal\n * @param {World} world \n*/\nfunction markAllChunksInvalid(world) {\n    world._chunksInvalidated.copyFrom(world._chunksKnown)\n    world._chunksToRemove.empty()\n    world._chunksToRequest.empty()\n    world._chunksToMesh.empty()\n    world._chunksToMeshFirst.empty()\n    sortQueueByDistanceFrom(world, world._chunksInvalidated)\n}\n\n\n\n\n\n\n\n\n/** \n * Run through chunk tracking queues looking for work to do next\n * @param {World} world \n*/\nfunction processRequestQueue(world) {\n    var toRequest = world._chunksToRequest\n    if (toRequest.isEmpty()) return true\n    // skip if too many outstanding requests, or if meshing queue is full\n    var pending = world._chunksPending.count()\n    var toMesh = world._chunksToMesh.count()\n    if (pending >= world.maxChunksPendingCreation) return true\n    if (toMesh >= world.maxChunksPendingMeshing) return true\n    var [i, j, k] = toRequest.pop()\n    requestNewChunk(world, i, j, k)\n    return toRequest.isEmpty()\n}\n\n\n/** @param {World} world */\nfunction processRemoveQueue(world) {\n    var queue = world._chunksInvalidated\n    if (queue.isEmpty()) queue = world._chunksToRemove\n    if (queue.isEmpty()) return true\n    var [i, j, k] = queue.pop()\n    removeChunk(world, i, j, k)\n    return (queue.isEmpty())\n}\n\n\n/** \n * similar to above but for chunks waiting to be meshed\n * @param {World} world \n*/\nfunction processMeshingQueue(world, firstOnly) {\n    var queue = world._chunksToMeshFirst\n    if (queue.isEmpty() && !firstOnly) queue = world._chunksToMesh\n    if (queue.isEmpty()) return true\n    var [i, j, k] = queue.pop()\n    if (world._chunksToRemove.includes(i, j, k)) return\n    var chunk = world._storage.getChunkByIndexes(i, j, k)\n    if (chunk) doChunkRemesh(world, chunk)\n}\n\n\n/** @param {World} world */\nfunction possiblyQueueChunkForMeshing(world, chunk) {\n    if (!(chunk._terrainDirty || chunk._objectsDirty)) return false\n    if (chunk._neighborCount < chunk.minNeighborsToMesh) return false\n    if (world._chunksToMesh.includes(chunk.i, chunk.j, chunk.k)) return false\n    if (world._chunksToMeshFirst.includes(chunk.i, chunk.j, chunk.k)) return false\n    var queue = (chunk._neighborCount === 26) ?\n        world._chunksToMeshFirst : world._chunksToMesh\n    queue.add(chunk.i, chunk.j, chunk.k)\n    world._sortMeshQueueEvery++\n    if (world._sortMeshQueueEvery > 20) {\n        sortQueueByDistanceFrom(world, queue)\n        world._sortMeshQueueEvery = 0\n    }\n    return true\n}\n\n\n\n\n\n\n/*\n * \n * \n * \n *              chunk lifecycle - create / set / remove / modify\n * \n * \n * \n*/\n\n\n/** \n * create chunk object and request voxel data from client\n * @param {World} world \n*/\nfunction requestNewChunk(world, i, j, k) {\n    var size = world._chunkSize\n    var dataArr = Chunk._createVoxelArray(world._chunkSize)\n    var worldName = world.noa.worldName\n    var requestID = [i, j, k, worldName].join('|')\n    var x = i * size\n    var y = j * size\n    var z = k * size\n    world._chunksPending.add(i, j, k)\n    world.emit('worldDataNeeded', requestID, dataArr, x, y, z, worldName)\n    profile_queues_hook('request')\n}\n\n/** \n * called when client sets a chunk's voxel data\n * If userData is passed in it will be attached to the chunk\n * @param {World} world \n*/\nfunction setChunkData(world, reqID, array, userData, fillVoxelID) {\n    var arr = reqID.split('|')\n    var i = parseInt(arr.shift())\n    var j = parseInt(arr.shift())\n    var k = parseInt(arr.shift())\n    var worldName = arr.join('|')\n    world._chunksPending.remove(i, j, k)\n    // discard data if it's for a world that's no longer current\n    if (worldName !== world.noa.worldName) return\n    // discard if chunk is no longer needed\n    if (!world._chunksKnown.includes(i, j, k)) return\n    if (world._chunksToRemove.includes(i, j, k)) return\n\n    var chunk = world._storage.getChunkByIndexes(i, j, k)\n    if (!chunk) {\n        // if chunk doesn't exist, create and init\n        var size = world._chunkSize\n        chunk = new Chunk(world.noa, reqID, i, j, k, size, array, fillVoxelID)\n        world._storage.storeChunkByIndexes(i, j, k, chunk)\n        chunk.userData = userData\n        world.noa.rendering.prepareChunkForRendering(chunk)\n        world.emit('chunkAdded', chunk)\n    } else {\n        // else we're updating data for an existing chunk\n        chunk._updateVoxelArray(array, fillVoxelID)\n    }\n    // chunk can now be meshed, and ping neighbors\n    possiblyQueueChunkForMeshing(world, chunk)\n    updateNeighborsOfChunk(world, i, j, k, chunk)\n\n    profile_queues_hook('receive')\n}\n\n\n\n/** \n * remove a chunk that wound up in the remove queue\n * @param {World} world \n*/\nfunction removeChunk(world, i, j, k) {\n    var chunk = world._storage.getChunkByIndexes(i, j, k)\n\n    if (chunk) {\n        world.emit('chunkBeingRemoved', chunk.requestID, chunk.voxels, chunk.userData)\n        world.noa.rendering.disposeChunkForRendering(chunk)\n        chunk.dispose()\n        profile_queues_hook('dispose')\n        updateNeighborsOfChunk(world, i, j, k, null)\n    }\n\n    world._storage.removeChunkByIndexes(i, j, k)\n    world._chunksKnown.remove(i, j, k)\n    world._chunksToMesh.remove(i, j, k)\n    world._chunksToRemove.remove(i, j, k)\n    world._chunksToMeshFirst.remove(i, j, k)\n}\n\n\n/** @param {World} world */\nfunction doChunkRemesh(world, chunk) {\n    world._chunksToMesh.remove(chunk.i, chunk.j, chunk.k)\n    world._chunksToMeshFirst.remove(chunk.i, chunk.j, chunk.k)\n    chunk.updateMeshes()\n    profile_queues_hook('mesh')\n}\n\n\n\n\n\n\n\n\n\n\n/*\n * \n * \n *          two different versions of logic to convert\n *          chunk coords to chunk indexes or local scope\n * \n * \n*/\n\nfunction chunkCoordsToIndexesGeneral(x, y, z) {\n    var cs = this._chunkSize\n    return [Math.floor(x / cs) | 0, Math.floor(y / cs) | 0, Math.floor(z / cs) | 0]\n}\nfunction chunkCoordsToLocalsGeneral(x, y, z) {\n    var cs = this._chunkSize\n    var i = (x % cs) | 0; if (i < 0) i += cs\n    var j = (y % cs) | 0; if (j < 0) j += cs\n    var k = (z % cs) | 0; if (k < 0) k += cs\n    return [i, j, k]\n}\nfunction chunkCoordsToIndexesPowerOfTwo(x, y, z) {\n    var shift = this._coordShiftBits\n    return [(x >> shift) | 0, (y >> shift) | 0, (z >> shift) | 0]\n}\nfunction chunkCoordsToLocalsPowerOfTwo(x, y, z) {\n    var mask = this._coordMask\n    return [(x & mask) | 0, (y & mask) | 0, (z & mask) | 0]\n}\n\n\n\n\n\n\n\n/*\n * \n * \n * \n *          misc helpers and implementation functions\n * \n * \n * \n*/\n\n/** \n * sorts DESCENDING, unless reversed\n * @param {World} world \n*/\nfunction sortQueueByDistanceFrom(world, queue, pi, pj, pk, reverse = false) {\n    var distFn = world.chunkSortingDistFn || defaultSortDistance\n    var localDist = (i, j, k) => distFn(pi - i, pj - j, pk - k)\n    if (pi === undefined) {\n        [pi, pj, pk] = getPlayerChunkIndexes(world)\n    }\n    queue.sortByDistance(localDist, reverse)\n}\nvar defaultSortDistance = (i, j, k) => (i * i) + (j * j) + (k * k)\n\n\n\n\n/** \n * keep neighbor data updated when chunk is added or removed\n * @param {World} world \n*/\nfunction updateNeighborsOfChunk(world, ci, cj, ck, chunk) {\n    var terrainChanged = (!chunk) || (chunk && !chunk.isEmpty)\n    for (var i = -1; i <= 1; i++) {\n        for (var j = -1; j <= 1; j++) {\n            for (var k = -1; k <= 1; k++) {\n                if ((i | j | k) === 0) continue\n                var neighbor = world._storage.getChunkByIndexes(ci + i, cj + j, ck + k)\n                if (!neighbor) continue\n                // flag neighbor, assume terrain needs remeshing\n                if (terrainChanged) neighbor._terrainDirty = true\n                // update neighbor counts and references, both ways\n                if (chunk && !chunk._neighbors.get(i, j, k)) {\n                    chunk._neighborCount++\n                    chunk._neighbors.set(i, j, k, neighbor)\n                }\n                var nabRef = neighbor._neighbors.get(-i, -j, -k)\n                if (chunk && !nabRef) {\n                    neighbor._neighborCount++\n                    neighbor._neighbors.set(-i, -j, -k, chunk)\n                    // immediately queue neighbor if it's surrounded\n                    if (neighbor._neighborCount === 26) {\n                        possiblyQueueChunkForMeshing(world, neighbor)\n                    }\n                }\n                if (!chunk && nabRef) {\n                    neighbor._neighborCount--\n                    neighbor._neighbors.set(-i, -j, -k, null)\n                }\n            }\n        }\n    }\n}\n\n\n// make a function to check if an (i,j,k) is within a sphere/ellipse of given size\nfunction makeDistanceTestFunction(xsize, ysize) {\n    var asq = xsize * xsize\n    var bsq = ysize * ysize\n    // spherical case\n    if (xsize === ysize) return (i, j, k) => (i * i + j * j + k * k <= asq)\n    // otherwise do clipped spheres for now\n    if (xsize > ysize) return (i, j, k) => {\n        if (Math.abs(j) > ysize) return false\n        return (i * i + j * j + k * k <= asq)\n    }\n    return (i, j, k) => {\n        var dxsq = i * i + k * k\n        if (dxsq > asq) return false\n        return (dxsq + j * j <= bsq)\n    }\n}\n\n\n\n\n\n\n\n\n\n\n/*\n * \n * \n * \n * \n *                  debugging\n * \n * \n * \n * \n*/\n\n/** @internal */\nWorld.prototype.report = function () {\n    console.log('World report - playerChunkLoaded: ', this.playerChunkLoaded)\n    _report(this, '  known:     ', this._chunksKnown.arr, true)\n    _report(this, '  to request:', this._chunksToRequest.arr, 0)\n    _report(this, '  to remove: ', this._chunksToRemove.arr, 0)\n    _report(this, '  invalid:   ', this._chunksInvalidated.arr, 0)\n    _report(this, '  creating:  ', this._chunksPending.arr, 0)\n    _report(this, '  to mesh:   ', this._chunksToMesh.arr, 0)\n    _report(this, '  mesh 1st:  ', this._chunksToMeshFirst.arr, 0)\n}\n\nfunction _report(world, name, arr, ext) {\n    var full = 0,\n        empty = 0,\n        exist = 0,\n        surrounded = 0,\n        remeshes = []\n    arr.forEach(loc => {\n        var chunk = world._storage.getChunkByIndexes(loc[0], loc[1], loc[2])\n        if (!chunk) return\n        exist++\n        remeshes.push(chunk._timesMeshed)\n        if (chunk._isFull) full++\n        if (chunk._isEmpty) empty++\n        if (chunk._neighborCount === 26) surrounded++\n    })\n    var out = arr.length.toString().padEnd(8)\n    out += ('exist: ' + exist).padEnd(12)\n    out += ('full: ' + full).padEnd(12)\n    out += ('empty: ' + empty).padEnd(12)\n    out += ('surr: ' + surrounded).padEnd(12)\n    if (ext) {\n        var sum = remeshes.reduce((acc, val) => acc + val, 0)\n        var max = remeshes.reduce((acc, val) => Math.max(acc, val), 0)\n        var min = remeshes.reduce((acc, val) => Math.min(acc, val), 0)\n        out += 'times meshed: avg ' + (sum / exist).toFixed(2)\n        out += '  max ' + max\n        out += '  min ' + min\n    }\n    console.log(name, out)\n}\n\n\nimport { makeProfileHook } from './util'\nvar profile_hook = makeProfileHook(PROFILE_EVERY, 'world ticks:', 1)\nvar profile_queues_hook = ((every) => {\n    if (!(every > 0)) return () => { }\n    var iter = 0\n    var counts = {}\n    var queues = {}\n    var started = performance.now()\n    return function profile_queues_hook(state, world) {\n        if (state === 'start') return\n        if (state !== 'end') return counts[state] = (counts[state] || 0) + 1\n        queues.toreq = (queues.toreq || 0) + world._chunksToRequest.count()\n        queues.toget = (queues.toget || 0) + world._chunksPending.count()\n        queues.tomesh = (queues.tomesh || 0) + world._chunksToMesh.count() + world._chunksToMeshFirst.count()\n        queues.tomesh1 = (queues.tomesh1 || 0) + world._chunksToMeshFirst.count()\n        queues.torem = (queues.torem || 0) + world._chunksToRemove.count()\n        if (++iter < every) return\n        var t = performance.now(), dt = t - started\n        var res = {}\n        Object.keys(queues).forEach(k => {\n            var num = Math.round((queues[k] || 0) / iter)\n            res[k] = `[${num}]`.padStart(5)\n        })\n        Object.keys(counts).forEach(k => {\n            var num = Math.round((counts[k] || 0) * 1000 / dt)\n            res[k] = ('' + num).padStart(3)\n        })\n        console.log('chunk flow: ',\n            `${res.toreq}-> ${res.request || 0} req/s  `,\n            `${res.toget}-> ${res.receive || 0} got/s  `,\n            `${(res.tomesh)}-> ${res.mesh || 0} mesh/s  `,\n            `${res.torem}-> ${res.dispose || 0} rem/s  `,\n            `(meshFirst: ${res.tomesh1.trim()})`,\n        )\n        iter = 0\n        counts = {}\n        queues = {}\n        started = performance.now()\n    }\n})(PROFILE_QUEUES_EVERY)\n", "\nimport { LocationQueue } from './util'\nimport ndarray from 'ndarray'\n\n\n\n\n/* \n * \n *   Chunk\n * \n *  Stores and manages voxel ids and flags for each voxel within chunk\n * \n */\n\n\n\n\n\n/*\n *\n *    Chunk constructor\n *\n */\n\n/** @param {import('../index').Engine} noa */\nexport function Chunk(noa, requestID, ci, cj, ck, size, dataArray, fillVoxelID = -1) {\n    this.noa = noa\n    this.isDisposed = false\n\n    // arbitrary data passed in by client when generating world\n    this.userData = null\n\n    // voxel data and properties\n    this.requestID = requestID     // id sent to game client\n    this.voxels = dataArray\n    this.i = ci\n    this.j = cj\n    this.k = ck\n    this.size = size\n    this.x = ci * size\n    this.y = cj * size\n    this.z = ck * size\n    this.pos = [this.x, this.y, this.z]\n\n    // flags to track if things need re-meshing\n    this._terrainDirty = false\n    this._objectsDirty = false\n\n    // inits state of terrain / object meshing\n    this._terrainMeshes = []\n    noa._terrainMesher.initChunk(this)\n    noa._objectMesher.initChunk(this)\n\n    this._isFull = false\n    this._isEmpty = false\n\n    this._wholeLayerVoxel = Array(size).fill(-1)\n    if (fillVoxelID >= 0) {\n        this.voxels.data.fill(fillVoxelID, 0, this.voxels.size)\n        this._wholeLayerVoxel.fill(fillVoxelID)\n    }\n\n    // references to neighboring chunks, if they exist (filled in by `world`)\n    var narr = Array.from(Array(27), () => null)\n    this._neighbors = ndarray(narr, [3, 3, 3]).lo(1, 1, 1)\n    this._neighbors.set(0, 0, 0, this)\n    this._neighborCount = 0\n    this._timesMeshed = 0\n\n    // location queue of voxels in this chunk with block handlers (assume it's rare)\n    /** @internal */\n    this._blockHandlerLocs = new LocationQueue()\n\n    // passes through voxel contents, calling block handlers etc.\n    scanVoxelData(this)\n}\n\n\n// expose logic internally to create and update the voxel data array\nChunk._createVoxelArray = function (size) {\n    var arr = new Uint16Array(size * size * size)\n    return ndarray(arr, [size, size, size])\n}\n\nChunk.prototype._updateVoxelArray = function (dataArray, fillVoxelID = -1) {\n    // dispose current object blocks\n    callAllBlockHandlers(this, 'onUnload')\n    this.noa._objectMesher.disposeChunk(this)\n    this.noa._terrainMesher.disposeChunk(this)\n    this.voxels = dataArray\n    this._terrainDirty = false\n    this._objectsDirty = false\n    this._blockHandlerLocs.empty()\n    this.noa._objectMesher.initChunk(this)\n    this.noa._terrainMesher.initChunk(this)\n\n    if (fillVoxelID >= 0) {\n        this._wholeLayerVoxel.fill(fillVoxelID)\n    } else {\n        this._wholeLayerVoxel.fill(-1)\n    }\n\n    scanVoxelData(this)\n}\n\n\n\n\n\n\n\n\n/*\n *\n *    Chunk API\n *\n */\n\n// get/set deal with block IDs, so that this class acts like an ndarray\n\nChunk.prototype.get = function (i, j, k) {\n    return this.voxels.get(i, j, k)\n}\n\nChunk.prototype.getSolidityAt = function (i, j, k) {\n    var solidLookup = this.noa.registry._solidityLookup\n    return solidLookup[this.voxels.get(i, j, k)]\n}\n\nChunk.prototype.set = function (i, j, k, newID) {\n    var oldID = this.voxels.get(i, j, k)\n    if (newID === oldID) return\n\n    // update voxel data\n    this.voxels.set(i, j, k, newID)\n\n    // lookup tables from registry, etc\n    var solidLookup = this.noa.registry._solidityLookup\n    var objectLookup = this.noa.registry._objectLookup\n    var opaqueLookup = this.noa.registry._opacityLookup\n    var handlerLookup = this.noa.registry._blockHandlerLookup\n\n    // track invariants about chunk data\n    if (!opaqueLookup[newID]) this._isFull = false\n    if (newID !== 0) this._isEmpty = false\n    if (this._wholeLayerVoxel[j] !== newID) this._wholeLayerVoxel[j] = -1\n\n    // voxel lifecycle handling\n    var hold = handlerLookup[oldID]\n    var hnew = handlerLookup[newID]\n    if (hold) callBlockHandler(this, hold, 'onUnset', i, j, k)\n    if (hnew) {\n        callBlockHandler(this, hnew, 'onSet', i, j, k)\n        this._blockHandlerLocs.add(i, j, k)\n    } else {\n        this._blockHandlerLocs.remove(i, j, k)\n    }\n\n    // track object block states\n    var objMesher = this.noa._objectMesher\n    var objOld = objectLookup[oldID]\n    var objNew = objectLookup[newID]\n    if (objOld) objMesher.setObjectBlock(this, 0, i, j, k)\n    if (objNew) objMesher.setObjectBlock(this, newID, i, j, k)\n\n    // decide dirtiness states\n    var solidityChanged = (solidLookup[oldID] !== solidLookup[newID])\n    var opacityChanged = (opaqueLookup[oldID] !== opaqueLookup[newID])\n    var wasTerrain = !objOld && (oldID !== 0)\n    var nowTerrain = !objNew && (newID !== 0)\n\n    if (objOld || objNew) this._objectsDirty = true\n    if (solidityChanged || opacityChanged || wasTerrain || nowTerrain) {\n        this._terrainDirty = true\n    }\n\n    if (this._terrainDirty || this._objectsDirty) {\n        this.noa.world._queueChunkForRemesh(this)\n    }\n\n    // neighbors only affected if solidity or opacity changed on an edge\n    if (solidityChanged || opacityChanged) {\n        var edge = this.size - 1\n        var imin = (i === 0) ? -1 : 0\n        var jmin = (j === 0) ? -1 : 0\n        var kmin = (k === 0) ? -1 : 0\n        var imax = (i === edge) ? 1 : 0\n        var jmax = (j === edge) ? 1 : 0\n        var kmax = (k === edge) ? 1 : 0\n        for (var ni = imin; ni <= imax; ni++) {\n            for (var nj = jmin; nj <= jmax; nj++) {\n                for (var nk = kmin; nk <= kmax; nk++) {\n                    if ((ni | nj | nk) === 0) continue\n                    var nab = this._neighbors.get(ni, nj, nk)\n                    if (!nab) continue\n                    nab._terrainDirty = true\n                    this.noa.world._queueChunkForRemesh(nab)\n                }\n            }\n        }\n    }\n}\n\n\n\n// helper to call handler of a given type at a particular xyz\nfunction callBlockHandler(chunk, handlers, type, i, j, k) {\n    var handler = handlers[type]\n    if (!handler) return\n    handler(chunk.x + i, chunk.y + j, chunk.z + k)\n}\n\n\n// gets called by World when this chunk has been queued for remeshing\nChunk.prototype.updateMeshes = function () {\n    if (this._terrainDirty) {\n        this.noa._terrainMesher.meshChunk(this)\n        this._timesMeshed++\n        this._terrainDirty = false\n    }\n    if (this._objectsDirty) {\n        this.noa._objectMesher.buildObjectMeshes()\n        this._objectsDirty = false\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n/*\n * \n *      Init\n * \n *  Scans voxel data, processing object blocks and setting chunk flags\n * \n*/\n\nfunction scanVoxelData(chunk) {\n    var voxels = chunk.voxels\n    var data = voxels.data\n    var len = voxels.shape[0]\n    var opaqueLookup = chunk.noa.registry._opacityLookup\n    var handlerLookup = chunk.noa.registry._blockHandlerLookup\n    var objectLookup = chunk.noa.registry._objectLookup\n    var plainLookup = chunk.noa.registry._blockIsPlainLookup\n    var objMesher = chunk.noa._objectMesher\n\n    // flags for tracking if chunk is entirely opaque or transparent\n    var fullyOpaque = true\n    var fullyAir = true\n\n    // scan vertically..\n    for (var j = 0; j < len; ++j) {\n\n        // fastest case where whole layer is air/dirt/etc\n        var layerID = chunk._wholeLayerVoxel[j]\n        if (layerID >= 0 && !objMesher[layerID] && !handlerLookup[layerID]) {\n            if (!opaqueLookup[layerID]) fullyOpaque = false\n            if (layerID !== 0) fullyAir = false\n            continue\n        }\n\n        var constantID = voxels.get(0, j, 0)\n\n        for (var i = 0; i < len; ++i) {\n            var index = voxels.index(i, j, 0)\n            for (var k = 0; k < len; ++k, ++index) {\n                var id = data[index]\n\n                // detect constant layer ID if there is one\n                if (constantID >= 0 && id !== constantID) constantID = -1\n\n                // most common cases: air block...\n                if (id === 0) {\n                    fullyOpaque = false\n                    continue\n                }\n                // ...or plain boring block (no mesh, handlers, etc)\n                if (plainLookup[id]) {\n                    fullyAir = false\n                    continue\n                }\n                // otherwise check opacity, object mesh, and handlers\n                fullyOpaque = fullyOpaque && opaqueLookup[id]\n                fullyAir = false\n                if (objectLookup[id]) {\n                    objMesher.setObjectBlock(chunk, id, i, j, k)\n                    chunk._objectsDirty = true\n                }\n                var handlers = handlerLookup[id]\n                if (handlers) {\n                    chunk._blockHandlerLocs.add(i, j, k)\n                    callBlockHandler(chunk, handlers, 'onLoad', i, j, k)\n                }\n            }\n        }\n\n        if (constantID >= 0) chunk._wholeLayerVoxel[j] = constantID\n    }\n\n    chunk._isFull = fullyOpaque\n    chunk._isEmpty = fullyAir\n    chunk._terrainDirty = !chunk._isEmpty\n}\n\n\n\n\n\n\n\n\n\n\n// dispose function - just clears properties and references\n\nChunk.prototype.dispose = function () {\n    // look through the data for onUnload handlers\n    callAllBlockHandlers(this, 'onUnload')\n    this._blockHandlerLocs.empty()\n\n    // let meshers dispose their stuff\n    this.noa._objectMesher.disposeChunk(this)\n    this.noa._terrainMesher.disposeChunk(this)\n\n    // apparently there's no way to dispose typed arrays, so just null everything\n    this.voxels.data = null\n    this.voxels = null\n    this._neighbors.data = null\n    this._neighbors = null\n\n    this.isDisposed = true\n}\n\n\n\n// helper to call a given handler for all blocks in the chunk\nfunction callAllBlockHandlers(chunk, type) {\n    var voxels = chunk.voxels\n    var handlerLookup = chunk.noa.registry._blockHandlerLookup\n    chunk._blockHandlerLocs.arr.forEach(([i, j, k]) => {\n        var id = voxels.get(i, j, k)\n        callBlockHandler(chunk, handlerLookup[id], type, i, j, k)\n    })\n}\n", "{\n    \"name\": \"noa-engine\",\n    \"version\": \"0.33.0\",\n    \"description\": \"Experimental voxel game engine\",\n    \"main\": \"src/index.js\",\n    \"typings\": \"dist/src/index.d.ts\",\n    \"files\": [\n        \"/src\",\n        \"/dist\"\n    ],\n    \"scripts\": {\n        \"build\": \"npm run types; npm run docs\",\n        \"types\": \"tsc\",\n        \"docs\": \"typedoc\"\n    },\n    \"author\": \"Andy Hall (https://fenomas.com)\",\n    \"license\": \"MIT\",\n    \"repository\": {\n        \"type\": \"git\",\n        \"url\": \"https://github.com/fenomas/noa.git\"\n    },\n    \"bugs\": {\n        \"url\": \"https://github.com/fenomas/noa/issues\"\n    },\n    \"dependencies\": {\n        \"aabb-3d\": \"fenomas/aabb-3d\",\n        \"box-intersect\": \"fenomas/box-intersect\",\n        \"ent-comp\": \"^0.11.0\",\n        \"events\": \"^3.3.0\",\n        \"fast-voxel-raycast\": \"^0.1.1\",\n        \"game-inputs\": \"^0.8.0\",\n        \"gl-vec3\": \"^1.1.3\",\n        \"micro-game-shell\": \"^0.9.0\",\n        \"ndarray\": \"^1.0.19\",\n        \"voxel-aabb-sweep\": \"^0.5.0\",\n        \"voxel-physics-engine\": \"^0.13.0\"\n    },\n    \"peerDependencies\": {\n        \"@babylonjs/core\": \"^6.1.0\"\n    },\n    \"devDependencies\": {\n        \"eslint\": \"^8.3.0\",\n        \"js-beautify\": \"^1.14.0\",\n        \"typedoc\": \"^0.24.6\",\n        \"typedoc-plugin-missing-exports\": \"^2.0.0\",\n        \"typescript\": \"^5.0.4\"\n    },\n    \"keywords\": [\n        \"voxel\",\n        \"voxels\",\n        \"game\",\n        \"engine\",\n        \"game-engine\"\n    ]\n}\n"],
  "mappings": "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",
  "names": ["ReflectApply", "ReflectOwnKeys", "NumberIsNaN", "EventEmitter", "len", "once", "copy", "name", "create", "clone", "a", "fromValues", "normalize", "a", "len", "dot", "a", "angle", "fromValues", "normalize", "dot", "a", "copy", "a", "set", "equals", "EPSILON", "a", "a2", "exactEquals", "a", "add", "a", "subtract", "a", "multiply", "a", "divide", "a", "min", "a", "max", "a", "floor", "a", "ceil", "a", "round", "a", "scale", "a", "scaleAndAdd", "a", "scale", "distance", "a", "squaredDistance", "a", "length", "a", "squaredLength", "a", "negate", "a", "inverse", "a", "cross", "a", "lerp", "a", "random", "scale", "transformMat4", "a", "transformMat3", "a", "transformQuat", "a", "rotateX", "a", "rotateY", "a", "rotateZ", "a", "forEach", "a", "a", "i", "dx", "floor", "max", "floor", "i", "dist", "done", "dv", "axis", "step", "sweep", "ECS", "name", "a", "state", "require_is_buffer", "a", "sweep", "sweep", "boxIntersect", "import_events", "import_gl_vec3", "import_ndarray", "dx", "scale", "a", "down", "name", "import_events", "observer", "a", "create", "round", "create", "a", "round", "scale", "len", "angle", "a2", "create", "normalize", "a", "len", "forEach", "create", "a", "create", "slerp", "a", "normalize", "create", "a", "dot", "normalize", "slerp", "create", "forEach", "create", "a", "max", "min", "vec3", "Camera", "dx", "dist", "sweep", "import_gl_vec3", "import_gl_vec3", "vec3", "import_gl_vec3", "vec3", "boxIntersect", "a", "noa", "dx", "import_gl_vec3", "vec3", "import_gl_vec3", "vec3", "import_gl_vec3", "vec3", "import_gl_vec3", "a", "name", "name", "name", "clone", "distance", "dist", "vec3", "scale", "defaultOptions", "ECS", "vec3", "name", "min", "max", "a", "add", "name", "boundingInfo", "len", "scale", "index", "len", "name", "texture", "a", "plugin", "name", "code", "name", "profile_hook", "ndarray", "len", "name", "dv", "defaults", "opts", "name", "import_gl_vec3", "length", "min", "max", "dot", "distance", "a", "len", "result", "min", "max", "name", "distance", "len", "_CameraProperty", "name", "name", "name", "name", "name", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "shader", "name", "onCreatedEffectParameters", "name", "drawWrapper", "name", "shader", "name", "shader", "shader", "name", "a", "name", "dashSize", "gapSize", "name", "name", "name", "PROFILE", "defaults", "profile_hook", "dist", "glvec3", "name", "mat", "mats", "div", "min", "import_gl_vec3", "import_voxel_aabb_sweep", "import_gl_vec3", "vec3", "DEBUG", "DefaultOptions", "vec3", "equals", "sanityCheck", "sweep", "dist", "dx", "a", "defaultOptions", "Physics", "import_events", "import_ndarray", "ndarray", "len", "PROFILE_EVERY", "defaultOptions", "EventEmitter", "max", "profile_hook", "min", "i", "name", "profile_queues_hook", "package_default", "version", "package_default", "PROFILE", "defaultOptions", "Engine", "Physics", "Camera", "vec3", "ndarray", "profile_hook", "global", "local", "dist", "raycast", "name"]
}
