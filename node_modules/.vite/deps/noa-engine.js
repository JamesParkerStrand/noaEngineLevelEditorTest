import {
  AbstractMesh,
  ArrayTools,
  Axis,
  BindBonesParameters,
  BindFogParameters,
  BindLights,
  BindLogDepth,
  BindMorphTargetParameters,
  BindSceneUniformBuffer,
  BindTextureMatrix,
  BoundingBox,
  BoundingInfo,
  Buffer,
  Camera,
  Color3,
  Color4,
  CompatibilityOptions,
  Coordinate,
  DeepCopier,
  EncodeArrayBufferToBase64,
  Engine,
  EngineStore,
  Epsilon,
  EventConstants,
  GetClass,
  HandleFallbacksForShadows,
  ImageProcessingConfiguration,
  InstantiationTools,
  InternalTexture,
  InternalTextureSource,
  IntersectionInfo,
  IsExponentOfTwo,
  KeyboardEventTypes,
  LightConstants,
  Logger,
  Material,
  MaterialPluginEvent,
  Matrix,
  Mesh,
  Node,
  Observable,
  PickingInfo,
  Plane,
  PointerEventTypes,
  PrepareAttributesForBakedVertexAnimation,
  PrepareAttributesForBones,
  PrepareAttributesForInstances,
  PrepareAttributesForMorphTargets,
  PrepareDefinesForAttributes,
  PrepareDefinesForFrameBoundValues,
  PrepareDefinesForLights,
  PrepareDefinesForMergedUV,
  PrepareDefinesForMisc,
  PrepareDefinesForMultiview,
  PrepareDefinesForOIT,
  PrepareDefinesForPrePass,
  PrepareUniformsAndSamplersList,
  PushAttributesForInstances,
  Quaternion,
  RandomGUID,
  RegisterClass,
  Scene,
  SceneComponentConstants,
  ScenePerformancePriority,
  SerializationHelper,
  ShaderLanguage,
  ShaderProcessor,
  ShaderStore,
  SmartArray,
  SmartArrayNoDuplicate,
  ThinEngine,
  TimingTools,
  TmpColors,
  TmpVectors,
  Tools,
  TransformNode,
  UniformBuffer,
  Vector2,
  Vector3,
  Vector4,
  VertexBuffer,
  VertexData,
  WebRequest,
  _CreationDataStorage,
  _WarnImport,
  __commonJS,
  __decorate,
  __export,
  __toESM,
  addClipPlaneUniforms,
  bindClipPlane,
  expandToProperty,
  prepareStringDefinesForClipPlanes,
  serialize,
  serializeAsColor3,
  serializeAsFresnelParameters,
  serializeAsMeshReference,
  serializeAsTexture,
  serializeAsVector3
} from "./chunk-2GBVOOZS.js";

// ../../node_modules/events/events.js
var require_events = __commonJS({
  "../../node_modules/events/events.js"(exports, module) {
    "use strict";
    var R = typeof Reflect === "object" ? Reflect : null;
    var ReflectApply = R && typeof R.apply === "function" ? R.apply : function ReflectApply2(target, receiver, args) {
      return Function.prototype.apply.call(target, receiver, args);
    };
    var ReflectOwnKeys;
    if (R && typeof R.ownKeys === "function") {
      ReflectOwnKeys = R.ownKeys;
    } else if (Object.getOwnPropertySymbols) {
      ReflectOwnKeys = function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
      };
    } else {
      ReflectOwnKeys = function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target);
      };
    }
    function ProcessEmitWarning(warning) {
      if (console && console.warn) console.warn(warning);
    }
    var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value) {
      return value !== value;
    };
    function EventEmitter5() {
      EventEmitter5.init.call(this);
    }
    module.exports = EventEmitter5;
    module.exports.once = once;
    EventEmitter5.EventEmitter = EventEmitter5;
    EventEmitter5.prototype._events = void 0;
    EventEmitter5.prototype._eventsCount = 0;
    EventEmitter5.prototype._maxListeners = void 0;
    var defaultMaxListeners = 10;
    function checkListener(listener) {
      if (typeof listener !== "function") {
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
      }
    }
    Object.defineProperty(EventEmitter5, "defaultMaxListeners", {
      enumerable: true,
      get: function() {
        return defaultMaxListeners;
      },
      set: function(arg) {
        if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
          throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
        }
        defaultMaxListeners = arg;
      }
    });
    EventEmitter5.init = function() {
      if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
      }
      this._maxListeners = this._maxListeners || void 0;
    };
    EventEmitter5.prototype.setMaxListeners = function setMaxListeners(n) {
      if (typeof n !== "number" || n < 0 || NumberIsNaN(n)) {
        throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + ".");
      }
      this._maxListeners = n;
      return this;
    };
    function _getMaxListeners(that) {
      if (that._maxListeners === void 0)
        return EventEmitter5.defaultMaxListeners;
      return that._maxListeners;
    }
    EventEmitter5.prototype.getMaxListeners = function getMaxListeners() {
      return _getMaxListeners(this);
    };
    EventEmitter5.prototype.emit = function emit(type) {
      var args = [];
      for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
      var doError = type === "error";
      var events = this._events;
      if (events !== void 0)
        doError = doError && events.error === void 0;
      else if (!doError)
        return false;
      if (doError) {
        var er;
        if (args.length > 0)
          er = args[0];
        if (er instanceof Error) {
          throw er;
        }
        var err = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
        err.context = er;
        throw err;
      }
      var handler = events[type];
      if (handler === void 0)
        return false;
      if (typeof handler === "function") {
        ReflectApply(handler, this, args);
      } else {
        var len2 = handler.length;
        var listeners = arrayClone(handler, len2);
        for (var i = 0; i < len2; ++i)
          ReflectApply(listeners[i], this, args);
      }
      return true;
    };
    function _addListener(target, type, listener, prepend) {
      var m;
      var events;
      var existing;
      checkListener(listener);
      events = target._events;
      if (events === void 0) {
        events = target._events = /* @__PURE__ */ Object.create(null);
        target._eventsCount = 0;
      } else {
        if (events.newListener !== void 0) {
          target.emit(
            "newListener",
            type,
            listener.listener ? listener.listener : listener
          );
          events = target._events;
        }
        existing = events[type];
      }
      if (existing === void 0) {
        existing = events[type] = listener;
        ++target._eventsCount;
      } else {
        if (typeof existing === "function") {
          existing = events[type] = prepend ? [listener, existing] : [existing, listener];
        } else if (prepend) {
          existing.unshift(listener);
        } else {
          existing.push(listener);
        }
        m = _getMaxListeners(target);
        if (m > 0 && existing.length > m && !existing.warned) {
          existing.warned = true;
          var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
          w.name = "MaxListenersExceededWarning";
          w.emitter = target;
          w.type = type;
          w.count = existing.length;
          ProcessEmitWarning(w);
        }
      }
      return target;
    }
    EventEmitter5.prototype.addListener = function addListener(type, listener) {
      return _addListener(this, type, listener, false);
    };
    EventEmitter5.prototype.on = EventEmitter5.prototype.addListener;
    EventEmitter5.prototype.prependListener = function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };
    function onceWrapper() {
      if (!this.fired) {
        this.target.removeListener(this.type, this.wrapFn);
        this.fired = true;
        if (arguments.length === 0)
          return this.listener.call(this.target);
        return this.listener.apply(this.target, arguments);
      }
    }
    function _onceWrap(target, type, listener) {
      var state = { fired: false, wrapFn: void 0, target, type, listener };
      var wrapped = onceWrapper.bind(state);
      wrapped.listener = listener;
      state.wrapFn = wrapped;
      return wrapped;
    }
    EventEmitter5.prototype.once = function once2(type, listener) {
      checkListener(listener);
      this.on(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter5.prototype.prependOnceListener = function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter5.prototype.removeListener = function removeListener(type, listener) {
      var list, events, position, i, originalListener;
      checkListener(listener);
      events = this._events;
      if (events === void 0)
        return this;
      list = events[type];
      if (list === void 0)
        return this;
      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = /* @__PURE__ */ Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit("removeListener", type, list.listener || listener);
        }
      } else if (typeof list !== "function") {
        position = -1;
        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }
        if (position < 0)
          return this;
        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }
        if (list.length === 1)
          events[type] = list[0];
        if (events.removeListener !== void 0)
          this.emit("removeListener", type, originalListener || listener);
      }
      return this;
    };
    EventEmitter5.prototype.off = EventEmitter5.prototype.removeListener;
    EventEmitter5.prototype.removeAllListeners = function removeAllListeners(type) {
      var listeners, events, i;
      events = this._events;
      if (events === void 0)
        return this;
      if (events.removeListener === void 0) {
        if (arguments.length === 0) {
          this._events = /* @__PURE__ */ Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== void 0) {
          if (--this._eventsCount === 0)
            this._events = /* @__PURE__ */ Object.create(null);
          else
            delete events[type];
        }
        return this;
      }
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === "removeListener") continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners("removeListener");
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
        return this;
      }
      listeners = events[type];
      if (typeof listeners === "function") {
        this.removeListener(type, listeners);
      } else if (listeners !== void 0) {
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }
      return this;
    };
    function _listeners(target, type, unwrap) {
      var events = target._events;
      if (events === void 0)
        return [];
      var evlistener = events[type];
      if (evlistener === void 0)
        return [];
      if (typeof evlistener === "function")
        return unwrap ? [evlistener.listener || evlistener] : [evlistener];
      return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
    }
    EventEmitter5.prototype.listeners = function listeners(type) {
      return _listeners(this, type, true);
    };
    EventEmitter5.prototype.rawListeners = function rawListeners(type) {
      return _listeners(this, type, false);
    };
    EventEmitter5.listenerCount = function(emitter, type) {
      if (typeof emitter.listenerCount === "function") {
        return emitter.listenerCount(type);
      } else {
        return listenerCount.call(emitter, type);
      }
    };
    EventEmitter5.prototype.listenerCount = listenerCount;
    function listenerCount(type) {
      var events = this._events;
      if (events !== void 0) {
        var evlistener = events[type];
        if (typeof evlistener === "function") {
          return 1;
        } else if (evlistener !== void 0) {
          return evlistener.length;
        }
      }
      return 0;
    }
    EventEmitter5.prototype.eventNames = function eventNames() {
      return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
    };
    function arrayClone(arr, n) {
      var copy4 = new Array(n);
      for (var i = 0; i < n; ++i)
        copy4[i] = arr[i];
      return copy4;
    }
    function spliceOne(list, index) {
      for (; index + 1 < list.length; index++)
        list[index] = list[index + 1];
      list.pop();
    }
    function unwrapListeners(arr) {
      var ret = new Array(arr.length);
      for (var i = 0; i < ret.length; ++i) {
        ret[i] = arr[i].listener || arr[i];
      }
      return ret;
    }
    function once(emitter, name66) {
      return new Promise(function(resolve, reject) {
        function errorListener(err) {
          emitter.removeListener(name66, resolver);
          reject(err);
        }
        function resolver() {
          if (typeof emitter.removeListener === "function") {
            emitter.removeListener("error", errorListener);
          }
          resolve([].slice.call(arguments));
        }
        ;
        eventTargetAgnosticAddListener(emitter, name66, resolver, { once: true });
        if (name66 !== "error") {
          addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
        }
      });
    }
    function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
      if (typeof emitter.on === "function") {
        eventTargetAgnosticAddListener(emitter, "error", handler, flags);
      }
    }
    function eventTargetAgnosticAddListener(emitter, name66, listener, flags) {
      if (typeof emitter.on === "function") {
        if (flags.once) {
          emitter.once(name66, listener);
        } else {
          emitter.on(name66, listener);
        }
      } else if (typeof emitter.addEventListener === "function") {
        emitter.addEventListener(name66, function wrapListener(arg) {
          if (flags.once) {
            emitter.removeEventListener(name66, wrapListener);
          }
          listener(arg);
        });
      } else {
        throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
      }
    }
  }
});

// ../../node_modules/gl-vec3/epsilon.js
var require_epsilon = __commonJS({
  "../../node_modules/gl-vec3/epsilon.js"(exports, module) {
    module.exports = 1e-6;
  }
});

// ../../node_modules/gl-vec3/create.js
var require_create = __commonJS({
  "../../node_modules/gl-vec3/create.js"(exports, module) {
    module.exports = create6;
    function create6() {
      var out = new Float32Array(3);
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
      return out;
    }
  }
});

// ../../node_modules/gl-vec3/clone.js
var require_clone = __commonJS({
  "../../node_modules/gl-vec3/clone.js"(exports, module) {
    module.exports = clone3;
    function clone3(a2) {
      var out = new Float32Array(3);
      out[0] = a2[0];
      out[1] = a2[1];
      out[2] = a2[2];
      return out;
    }
  }
});

// ../../node_modules/gl-vec3/fromValues.js
var require_fromValues = __commonJS({
  "../../node_modules/gl-vec3/fromValues.js"(exports, module) {
    module.exports = fromValues3;
    function fromValues3(x, y, z) {
      var out = new Float32Array(3);
      out[0] = x;
      out[1] = y;
      out[2] = z;
      return out;
    }
  }
});

// ../../node_modules/gl-vec3/normalize.js
var require_normalize = __commonJS({
  "../../node_modules/gl-vec3/normalize.js"(exports, module) {
    module.exports = normalize4;
    function normalize4(out, a2) {
      var x = a2[0], y = a2[1], z = a2[2];
      var len2 = x * x + y * y + z * z;
      if (len2 > 0) {
        len2 = 1 / Math.sqrt(len2);
        out[0] = a2[0] * len2;
        out[1] = a2[1] * len2;
        out[2] = a2[2] * len2;
      }
      return out;
    }
  }
});

// ../../node_modules/gl-vec3/dot.js
var require_dot = __commonJS({
  "../../node_modules/gl-vec3/dot.js"(exports, module) {
    module.exports = dot4;
    function dot4(a2, b) {
      return a2[0] * b[0] + a2[1] * b[1] + a2[2] * b[2];
    }
  }
});

// ../../node_modules/gl-vec3/angle.js
var require_angle = __commonJS({
  "../../node_modules/gl-vec3/angle.js"(exports, module) {
    module.exports = angle2;
    var fromValues3 = require_fromValues();
    var normalize4 = require_normalize();
    var dot4 = require_dot();
    function angle2(a2, b) {
      var tempA = fromValues3(a2[0], a2[1], a2[2]);
      var tempB = fromValues3(b[0], b[1], b[2]);
      normalize4(tempA, tempA);
      normalize4(tempB, tempB);
      var cosine = dot4(tempA, tempB);
      if (cosine > 1) {
        return 0;
      } else {
        return Math.acos(cosine);
      }
    }
  }
});

// ../../node_modules/gl-vec3/copy.js
var require_copy = __commonJS({
  "../../node_modules/gl-vec3/copy.js"(exports, module) {
    module.exports = copy4;
    function copy4(out, a2) {
      out[0] = a2[0];
      out[1] = a2[1];
      out[2] = a2[2];
      return out;
    }
  }
});

// ../../node_modules/gl-vec3/set.js
var require_set = __commonJS({
  "../../node_modules/gl-vec3/set.js"(exports, module) {
    module.exports = set3;
    function set3(out, x, y, z) {
      out[0] = x;
      out[1] = y;
      out[2] = z;
      return out;
    }
  }
});

// ../../node_modules/gl-vec3/equals.js
var require_equals = __commonJS({
  "../../node_modules/gl-vec3/equals.js"(exports, module) {
    module.exports = equals3;
    var EPSILON2 = require_epsilon();
    function equals3(a2, b) {
      var a0 = a2[0];
      var a1 = a2[1];
      var a22 = a2[2];
      var b0 = b[0];
      var b1 = b[1];
      var b2 = b[2];
      return Math.abs(a0 - b0) <= EPSILON2 * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON2 * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a22 - b2) <= EPSILON2 * Math.max(1, Math.abs(a22), Math.abs(b2));
    }
  }
});

// ../../node_modules/gl-vec3/exactEquals.js
var require_exactEquals = __commonJS({
  "../../node_modules/gl-vec3/exactEquals.js"(exports, module) {
    module.exports = exactEquals3;
    function exactEquals3(a2, b) {
      return a2[0] === b[0] && a2[1] === b[1] && a2[2] === b[2];
    }
  }
});

// ../../node_modules/gl-vec3/add.js
var require_add = __commonJS({
  "../../node_modules/gl-vec3/add.js"(exports, module) {
    module.exports = add3;
    function add3(out, a2, b) {
      out[0] = a2[0] + b[0];
      out[1] = a2[1] + b[1];
      out[2] = a2[2] + b[2];
      return out;
    }
  }
});

// ../../node_modules/gl-vec3/subtract.js
var require_subtract = __commonJS({
  "../../node_modules/gl-vec3/subtract.js"(exports, module) {
    module.exports = subtract2;
    function subtract2(out, a2, b) {
      out[0] = a2[0] - b[0];
      out[1] = a2[1] - b[1];
      out[2] = a2[2] - b[2];
      return out;
    }
  }
});

// ../../node_modules/gl-vec3/sub.js
var require_sub = __commonJS({
  "../../node_modules/gl-vec3/sub.js"(exports, module) {
    module.exports = require_subtract();
  }
});

// ../../node_modules/gl-vec3/multiply.js
var require_multiply = __commonJS({
  "../../node_modules/gl-vec3/multiply.js"(exports, module) {
    module.exports = multiply2;
    function multiply2(out, a2, b) {
      out[0] = a2[0] * b[0];
      out[1] = a2[1] * b[1];
      out[2] = a2[2] * b[2];
      return out;
    }
  }
});

// ../../node_modules/gl-vec3/mul.js
var require_mul = __commonJS({
  "../../node_modules/gl-vec3/mul.js"(exports, module) {
    module.exports = require_multiply();
  }
});

// ../../node_modules/gl-vec3/divide.js
var require_divide = __commonJS({
  "../../node_modules/gl-vec3/divide.js"(exports, module) {
    module.exports = divide2;
    function divide2(out, a2, b) {
      out[0] = a2[0] / b[0];
      out[1] = a2[1] / b[1];
      out[2] = a2[2] / b[2];
      return out;
    }
  }
});

// ../../node_modules/gl-vec3/div.js
var require_div = __commonJS({
  "../../node_modules/gl-vec3/div.js"(exports, module) {
    module.exports = require_divide();
  }
});

// ../../node_modules/gl-vec3/min.js
var require_min = __commonJS({
  "../../node_modules/gl-vec3/min.js"(exports, module) {
    module.exports = min2;
    function min2(out, a2, b) {
      out[0] = Math.min(a2[0], b[0]);
      out[1] = Math.min(a2[1], b[1]);
      out[2] = Math.min(a2[2], b[2]);
      return out;
    }
  }
});

// ../../node_modules/gl-vec3/max.js
var require_max = __commonJS({
  "../../node_modules/gl-vec3/max.js"(exports, module) {
    module.exports = max2;
    function max2(out, a2, b) {
      out[0] = Math.max(a2[0], b[0]);
      out[1] = Math.max(a2[1], b[1]);
      out[2] = Math.max(a2[2], b[2]);
      return out;
    }
  }
});

// ../../node_modules/gl-vec3/floor.js
var require_floor = __commonJS({
  "../../node_modules/gl-vec3/floor.js"(exports, module) {
    module.exports = floor2;
    function floor2(out, a2) {
      out[0] = Math.floor(a2[0]);
      out[1] = Math.floor(a2[1]);
      out[2] = Math.floor(a2[2]);
      return out;
    }
  }
});

// ../../node_modules/gl-vec3/ceil.js
var require_ceil = __commonJS({
  "../../node_modules/gl-vec3/ceil.js"(exports, module) {
    module.exports = ceil2;
    function ceil2(out, a2) {
      out[0] = Math.ceil(a2[0]);
      out[1] = Math.ceil(a2[1]);
      out[2] = Math.ceil(a2[2]);
      return out;
    }
  }
});

// ../../node_modules/gl-vec3/round.js
var require_round = __commonJS({
  "../../node_modules/gl-vec3/round.js"(exports, module) {
    module.exports = round3;
    function round3(out, a2) {
      out[0] = Math.round(a2[0]);
      out[1] = Math.round(a2[1]);
      out[2] = Math.round(a2[2]);
      return out;
    }
  }
});

// ../../node_modules/gl-vec3/scale.js
var require_scale = __commonJS({
  "../../node_modules/gl-vec3/scale.js"(exports, module) {
    module.exports = scale3;
    function scale3(out, a2, b) {
      out[0] = a2[0] * b;
      out[1] = a2[1] * b;
      out[2] = a2[2] * b;
      return out;
    }
  }
});

// ../../node_modules/gl-vec3/scaleAndAdd.js
var require_scaleAndAdd = __commonJS({
  "../../node_modules/gl-vec3/scaleAndAdd.js"(exports, module) {
    module.exports = scaleAndAdd2;
    function scaleAndAdd2(out, a2, b, scale3) {
      out[0] = a2[0] + b[0] * scale3;
      out[1] = a2[1] + b[1] * scale3;
      out[2] = a2[2] + b[2] * scale3;
      return out;
    }
  }
});

// ../../node_modules/gl-vec3/distance.js
var require_distance = __commonJS({
  "../../node_modules/gl-vec3/distance.js"(exports, module) {
    module.exports = distance2;
    function distance2(a2, b) {
      var x = b[0] - a2[0], y = b[1] - a2[1], z = b[2] - a2[2];
      return Math.sqrt(x * x + y * y + z * z);
    }
  }
});

// ../../node_modules/gl-vec3/dist.js
var require_dist = __commonJS({
  "../../node_modules/gl-vec3/dist.js"(exports, module) {
    module.exports = require_distance();
  }
});

// ../../node_modules/gl-vec3/squaredDistance.js
var require_squaredDistance = __commonJS({
  "../../node_modules/gl-vec3/squaredDistance.js"(exports, module) {
    module.exports = squaredDistance2;
    function squaredDistance2(a2, b) {
      var x = b[0] - a2[0], y = b[1] - a2[1], z = b[2] - a2[2];
      return x * x + y * y + z * z;
    }
  }
});

// ../../node_modules/gl-vec3/sqrDist.js
var require_sqrDist = __commonJS({
  "../../node_modules/gl-vec3/sqrDist.js"(exports, module) {
    module.exports = require_squaredDistance();
  }
});

// ../../node_modules/gl-vec3/length.js
var require_length = __commonJS({
  "../../node_modules/gl-vec3/length.js"(exports, module) {
    module.exports = length4;
    function length4(a2) {
      var x = a2[0], y = a2[1], z = a2[2];
      return Math.sqrt(x * x + y * y + z * z);
    }
  }
});

// ../../node_modules/gl-vec3/len.js
var require_len = __commonJS({
  "../../node_modules/gl-vec3/len.js"(exports, module) {
    module.exports = require_length();
  }
});

// ../../node_modules/gl-vec3/squaredLength.js
var require_squaredLength = __commonJS({
  "../../node_modules/gl-vec3/squaredLength.js"(exports, module) {
    module.exports = squaredLength4;
    function squaredLength4(a2) {
      var x = a2[0], y = a2[1], z = a2[2];
      return x * x + y * y + z * z;
    }
  }
});

// ../../node_modules/gl-vec3/sqrLen.js
var require_sqrLen = __commonJS({
  "../../node_modules/gl-vec3/sqrLen.js"(exports, module) {
    module.exports = require_squaredLength();
  }
});

// ../../node_modules/gl-vec3/negate.js
var require_negate = __commonJS({
  "../../node_modules/gl-vec3/negate.js"(exports, module) {
    module.exports = negate2;
    function negate2(out, a2) {
      out[0] = -a2[0];
      out[1] = -a2[1];
      out[2] = -a2[2];
      return out;
    }
  }
});

// ../../node_modules/gl-vec3/inverse.js
var require_inverse = __commonJS({
  "../../node_modules/gl-vec3/inverse.js"(exports, module) {
    module.exports = inverse2;
    function inverse2(out, a2) {
      out[0] = 1 / a2[0];
      out[1] = 1 / a2[1];
      out[2] = 1 / a2[2];
      return out;
    }
  }
});

// ../../node_modules/gl-vec3/cross.js
var require_cross = __commonJS({
  "../../node_modules/gl-vec3/cross.js"(exports, module) {
    module.exports = cross2;
    function cross2(out, a2, b) {
      var ax = a2[0], ay = a2[1], az = a2[2], bx = b[0], by = b[1], bz = b[2];
      out[0] = ay * bz - az * by;
      out[1] = az * bx - ax * bz;
      out[2] = ax * by - ay * bx;
      return out;
    }
  }
});

// ../../node_modules/gl-vec3/lerp.js
var require_lerp = __commonJS({
  "../../node_modules/gl-vec3/lerp.js"(exports, module) {
    module.exports = lerp3;
    function lerp3(out, a2, b, t) {
      var ax = a2[0], ay = a2[1], az = a2[2];
      out[0] = ax + t * (b[0] - ax);
      out[1] = ay + t * (b[1] - ay);
      out[2] = az + t * (b[2] - az);
      return out;
    }
  }
});

// ../../node_modules/gl-vec3/random.js
var require_random = __commonJS({
  "../../node_modules/gl-vec3/random.js"(exports, module) {
    module.exports = random2;
    function random2(out, scale3) {
      scale3 = scale3 || 1;
      var r = Math.random() * 2 * Math.PI;
      var z = Math.random() * 2 - 1;
      var zScale = Math.sqrt(1 - z * z) * scale3;
      out[0] = Math.cos(r) * zScale;
      out[1] = Math.sin(r) * zScale;
      out[2] = z * scale3;
      return out;
    }
  }
});

// ../../node_modules/gl-vec3/transformMat4.js
var require_transformMat4 = __commonJS({
  "../../node_modules/gl-vec3/transformMat4.js"(exports, module) {
    module.exports = transformMat42;
    function transformMat42(out, a2, m) {
      var x = a2[0], y = a2[1], z = a2[2], w = m[3] * x + m[7] * y + m[11] * z + m[15];
      w = w || 1;
      out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
      out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
      out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
      return out;
    }
  }
});

// ../../node_modules/gl-vec3/transformMat3.js
var require_transformMat3 = __commonJS({
  "../../node_modules/gl-vec3/transformMat3.js"(exports, module) {
    module.exports = transformMat32;
    function transformMat32(out, a2, m) {
      var x = a2[0], y = a2[1], z = a2[2];
      out[0] = x * m[0] + y * m[3] + z * m[6];
      out[1] = x * m[1] + y * m[4] + z * m[7];
      out[2] = x * m[2] + y * m[5] + z * m[8];
      return out;
    }
  }
});

// ../../node_modules/gl-vec3/transformQuat.js
var require_transformQuat = __commonJS({
  "../../node_modules/gl-vec3/transformQuat.js"(exports, module) {
    module.exports = transformQuat2;
    function transformQuat2(out, a2, q) {
      var x = a2[0], y = a2[1], z = a2[2], qx = q[0], qy = q[1], qz = q[2], qw = q[3];
      var tx = qy * z - qz * y;
      var ty = qz * x - qx * z;
      var tz = qx * y - qy * x;
      tx *= 2;
      ty *= 2;
      tz *= 2;
      out[0] = x + qw * tx + qy * tz - qz * ty;
      out[1] = y + qw * ty + qz * tx - qx * tz;
      out[2] = z + qw * tz + qx * ty - qy * tx;
      return out;
    }
  }
});

// ../../node_modules/gl-vec3/rotateX.js
var require_rotateX = __commonJS({
  "../../node_modules/gl-vec3/rotateX.js"(exports, module) {
    module.exports = rotateX3;
    function rotateX3(out, a2, b, c) {
      var by = b[1];
      var bz = b[2];
      var py = a2[1] - by;
      var pz = a2[2] - bz;
      var sc = Math.sin(c);
      var cc = Math.cos(c);
      out[0] = a2[0];
      out[1] = by + py * cc - pz * sc;
      out[2] = bz + py * sc + pz * cc;
      return out;
    }
  }
});

// ../../node_modules/gl-vec3/rotateY.js
var require_rotateY = __commonJS({
  "../../node_modules/gl-vec3/rotateY.js"(exports, module) {
    module.exports = rotateY3;
    function rotateY3(out, a2, b, c) {
      var bx = b[0];
      var bz = b[2];
      var px = a2[0] - bx;
      var pz = a2[2] - bz;
      var sc = Math.sin(c);
      var cc = Math.cos(c);
      out[0] = bx + pz * sc + px * cc;
      out[1] = a2[1];
      out[2] = bz + pz * cc - px * sc;
      return out;
    }
  }
});

// ../../node_modules/gl-vec3/rotateZ.js
var require_rotateZ = __commonJS({
  "../../node_modules/gl-vec3/rotateZ.js"(exports, module) {
    module.exports = rotateZ3;
    function rotateZ3(out, a2, b, c) {
      var bx = b[0];
      var by = b[1];
      var px = a2[0] - bx;
      var py = a2[1] - by;
      var sc = Math.sin(c);
      var cc = Math.cos(c);
      out[0] = bx + px * cc - py * sc;
      out[1] = by + px * sc + py * cc;
      out[2] = a2[2];
      return out;
    }
  }
});

// ../../node_modules/gl-vec3/forEach.js
var require_forEach = __commonJS({
  "../../node_modules/gl-vec3/forEach.js"(exports, module) {
    module.exports = forEach4;
    var vec = require_create()();
    function forEach4(a2, stride, offset, count, fn, arg) {
      var i, l;
      if (!stride) {
        stride = 3;
      }
      if (!offset) {
        offset = 0;
      }
      if (count) {
        l = Math.min(count * stride + offset, a2.length);
      } else {
        l = a2.length;
      }
      for (i = offset; i < l; i += stride) {
        vec[0] = a2[i];
        vec[1] = a2[i + 1];
        vec[2] = a2[i + 2];
        fn(vec, vec, arg);
        a2[i] = vec[0];
        a2[i + 1] = vec[1];
        a2[i + 2] = vec[2];
      }
      return a2;
    }
  }
});

// ../../node_modules/gl-vec3/index.js
var require_gl_vec3 = __commonJS({
  "../../node_modules/gl-vec3/index.js"(exports, module) {
    module.exports = {
      EPSILON: require_epsilon(),
      create: require_create(),
      clone: require_clone(),
      angle: require_angle(),
      fromValues: require_fromValues(),
      copy: require_copy(),
      set: require_set(),
      equals: require_equals(),
      exactEquals: require_exactEquals(),
      add: require_add(),
      subtract: require_subtract(),
      sub: require_sub(),
      multiply: require_multiply(),
      mul: require_mul(),
      divide: require_divide(),
      div: require_div(),
      min: require_min(),
      max: require_max(),
      floor: require_floor(),
      ceil: require_ceil(),
      round: require_round(),
      scale: require_scale(),
      scaleAndAdd: require_scaleAndAdd(),
      distance: require_distance(),
      dist: require_dist(),
      squaredDistance: require_squaredDistance(),
      sqrDist: require_sqrDist(),
      length: require_length(),
      len: require_len(),
      squaredLength: require_squaredLength(),
      sqrLen: require_sqrLen(),
      negate: require_negate(),
      inverse: require_inverse(),
      normalize: require_normalize(),
      dot: require_dot(),
      cross: require_cross(),
      lerp: require_lerp(),
      random: require_random(),
      transformMat4: require_transformMat4(),
      transformMat3: require_transformMat3(),
      transformQuat: require_transformQuat(),
      rotateX: require_rotateX(),
      rotateY: require_rotateY(),
      rotateZ: require_rotateZ(),
      forEach: require_forEach()
    };
  }
});

// ../../node_modules/iota-array/iota.js
var require_iota = __commonJS({
  "../../node_modules/iota-array/iota.js"(exports, module) {
    "use strict";
    function iota(n) {
      var result = new Array(n);
      for (var i = 0; i < n; ++i) {
        result[i] = i;
      }
      return result;
    }
    module.exports = iota;
  }
});

// ../../node_modules/ndarray/node_modules/is-buffer/index.js
var require_is_buffer = __commonJS({
  "../../node_modules/ndarray/node_modules/is-buffer/index.js"(exports, module) {
    module.exports = function(obj) {
      return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer);
    };
    function isBuffer(obj) {
      return !!obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
    }
    function isSlowBuffer(obj) {
      return typeof obj.readFloatLE === "function" && typeof obj.slice === "function" && isBuffer(obj.slice(0, 0));
    }
  }
});

// ../../node_modules/ndarray/ndarray.js
var require_ndarray = __commonJS({
  "../../node_modules/ndarray/ndarray.js"(exports, module) {
    var iota = require_iota();
    var isBuffer = require_is_buffer();
    var hasTypedArrays = typeof Float64Array !== "undefined";
    function compare1st(a2, b) {
      return a2[0] - b[0];
    }
    function order() {
      var stride = this.stride;
      var terms = new Array(stride.length);
      var i;
      for (i = 0; i < terms.length; ++i) {
        terms[i] = [Math.abs(stride[i]), i];
      }
      terms.sort(compare1st);
      var result = new Array(terms.length);
      for (i = 0; i < result.length; ++i) {
        result[i] = terms[i][1];
      }
      return result;
    }
    function compileConstructor(dtype, dimension) {
      var className = ["View", dimension, "d", dtype].join("");
      if (dimension < 0) {
        className = "View_Nil" + dtype;
      }
      var useGetters = dtype === "generic";
      if (dimension === -1) {
        var code = "function " + className + "(a){this.data=a;};var proto=" + className + ".prototype;proto.dtype='" + dtype + "';proto.index=function(){return -1};proto.size=0;proto.dimension=-1;proto.shape=proto.stride=proto.order=[];proto.lo=proto.hi=proto.transpose=proto.step=function(){return new " + className + "(this.data);};proto.get=proto.set=function(){};proto.pick=function(){return null};return function construct_" + className + "(a){return new " + className + "(a);}";
        var procedure = new Function(code);
        return procedure();
      } else if (dimension === 0) {
        var code = "function " + className + "(a,d) {this.data = a;this.offset = d};var proto=" + className + ".prototype;proto.dtype='" + dtype + "';proto.index=function(){return this.offset};proto.dimension=0;proto.size=1;proto.shape=proto.stride=proto.order=[];proto.lo=proto.hi=proto.transpose=proto.step=function " + className + "_copy() {return new " + className + "(this.data,this.offset)};proto.pick=function " + className + "_pick(){return TrivialArray(this.data);};proto.valueOf=proto.get=function " + className + "_get(){return " + (useGetters ? "this.data.get(this.offset)" : "this.data[this.offset]") + "};proto.set=function " + className + "_set(v){return " + (useGetters ? "this.data.set(this.offset,v)" : "this.data[this.offset]=v") + "};return function construct_" + className + "(a,b,c,d){return new " + className + "(a,d)}";
        var procedure = new Function("TrivialArray", code);
        return procedure(CACHED_CONSTRUCTORS[dtype][0]);
      }
      var code = ["'use strict'"];
      var indices = iota(dimension);
      var args = indices.map(function(i2) {
        return "i" + i2;
      });
      var index_str = "this.offset+" + indices.map(function(i2) {
        return "this.stride[" + i2 + "]*i" + i2;
      }).join("+");
      var shapeArg = indices.map(function(i2) {
        return "b" + i2;
      }).join(",");
      var strideArg = indices.map(function(i2) {
        return "c" + i2;
      }).join(",");
      code.push(
        "function " + className + "(a," + shapeArg + "," + strideArg + ",d){this.data=a",
        "this.shape=[" + shapeArg + "]",
        "this.stride=[" + strideArg + "]",
        "this.offset=d|0}",
        "var proto=" + className + ".prototype",
        "proto.dtype='" + dtype + "'",
        "proto.dimension=" + dimension
      );
      code.push(
        "Object.defineProperty(proto,'size',{get:function " + className + "_size(){return " + indices.map(function(i2) {
          return "this.shape[" + i2 + "]";
        }).join("*"),
        "}})"
      );
      if (dimension === 1) {
        code.push("proto.order=[0]");
      } else {
        code.push("Object.defineProperty(proto,'order',{get:");
        if (dimension < 4) {
          code.push("function " + className + "_order(){");
          if (dimension === 2) {
            code.push("return (Math.abs(this.stride[0])>Math.abs(this.stride[1]))?[1,0]:[0,1]}})");
          } else if (dimension === 3) {
            code.push(
              "var s0=Math.abs(this.stride[0]),s1=Math.abs(this.stride[1]),s2=Math.abs(this.stride[2]);if(s0>s1){if(s1>s2){return [2,1,0];}else if(s0>s2){return [1,2,0];}else{return [1,0,2];}}else if(s0>s2){return [2,0,1];}else if(s2>s1){return [0,1,2];}else{return [0,2,1];}}})"
            );
          }
        } else {
          code.push("ORDER})");
        }
      }
      code.push(
        "proto.set=function " + className + "_set(" + args.join(",") + ",v){"
      );
      if (useGetters) {
        code.push("return this.data.set(" + index_str + ",v)}");
      } else {
        code.push("return this.data[" + index_str + "]=v}");
      }
      code.push("proto.get=function " + className + "_get(" + args.join(",") + "){");
      if (useGetters) {
        code.push("return this.data.get(" + index_str + ")}");
      } else {
        code.push("return this.data[" + index_str + "]}");
      }
      code.push(
        "proto.index=function " + className + "_index(",
        args.join(),
        "){return " + index_str + "}"
      );
      code.push("proto.hi=function " + className + "_hi(" + args.join(",") + "){return new " + className + "(this.data," + indices.map(function(i2) {
        return ["(typeof i", i2, "!=='number'||i", i2, "<0)?this.shape[", i2, "]:i", i2, "|0"].join("");
      }).join(",") + "," + indices.map(function(i2) {
        return "this.stride[" + i2 + "]";
      }).join(",") + ",this.offset)}");
      var a_vars = indices.map(function(i2) {
        return "a" + i2 + "=this.shape[" + i2 + "]";
      });
      var c_vars = indices.map(function(i2) {
        return "c" + i2 + "=this.stride[" + i2 + "]";
      });
      code.push("proto.lo=function " + className + "_lo(" + args.join(",") + "){var b=this.offset,d=0," + a_vars.join(",") + "," + c_vars.join(","));
      for (var i = 0; i < dimension; ++i) {
        code.push(
          "if(typeof i" + i + "==='number'&&i" + i + ">=0){d=i" + i + "|0;b+=c" + i + "*d;a" + i + "-=d}"
        );
      }
      code.push("return new " + className + "(this.data," + indices.map(function(i2) {
        return "a" + i2;
      }).join(",") + "," + indices.map(function(i2) {
        return "c" + i2;
      }).join(",") + ",b)}");
      code.push("proto.step=function " + className + "_step(" + args.join(",") + "){var " + indices.map(function(i2) {
        return "a" + i2 + "=this.shape[" + i2 + "]";
      }).join(",") + "," + indices.map(function(i2) {
        return "b" + i2 + "=this.stride[" + i2 + "]";
      }).join(",") + ",c=this.offset,d=0,ceil=Math.ceil");
      for (var i = 0; i < dimension; ++i) {
        code.push(
          "if(typeof i" + i + "==='number'){d=i" + i + "|0;if(d<0){c+=b" + i + "*(a" + i + "-1);a" + i + "=ceil(-a" + i + "/d)}else{a" + i + "=ceil(a" + i + "/d)}b" + i + "*=d}"
        );
      }
      code.push("return new " + className + "(this.data," + indices.map(function(i2) {
        return "a" + i2;
      }).join(",") + "," + indices.map(function(i2) {
        return "b" + i2;
      }).join(",") + ",c)}");
      var tShape = new Array(dimension);
      var tStride = new Array(dimension);
      for (var i = 0; i < dimension; ++i) {
        tShape[i] = "a[i" + i + "]";
        tStride[i] = "b[i" + i + "]";
      }
      code.push(
        "proto.transpose=function " + className + "_transpose(" + args + "){" + args.map(function(n, idx) {
          return n + "=(" + n + "===undefined?" + idx + ":" + n + "|0)";
        }).join(";"),
        "var a=this.shape,b=this.stride;return new " + className + "(this.data," + tShape.join(",") + "," + tStride.join(",") + ",this.offset)}"
      );
      code.push("proto.pick=function " + className + "_pick(" + args + "){var a=[],b=[],c=this.offset");
      for (var i = 0; i < dimension; ++i) {
        code.push("if(typeof i" + i + "==='number'&&i" + i + ">=0){c=(c+this.stride[" + i + "]*i" + i + ")|0}else{a.push(this.shape[" + i + "]);b.push(this.stride[" + i + "])}");
      }
      code.push("var ctor=CTOR_LIST[a.length+1];return ctor(this.data,a,b,c)}");
      code.push("return function construct_" + className + "(data,shape,stride,offset){return new " + className + "(data," + indices.map(function(i2) {
        return "shape[" + i2 + "]";
      }).join(",") + "," + indices.map(function(i2) {
        return "stride[" + i2 + "]";
      }).join(",") + ",offset)}");
      var procedure = new Function("CTOR_LIST", "ORDER", code.join("\n"));
      return procedure(CACHED_CONSTRUCTORS[dtype], order);
    }
    function arrayDType(data) {
      if (isBuffer(data)) {
        return "buffer";
      }
      if (hasTypedArrays) {
        switch (Object.prototype.toString.call(data)) {
          case "[object Float64Array]":
            return "float64";
          case "[object Float32Array]":
            return "float32";
          case "[object Int8Array]":
            return "int8";
          case "[object Int16Array]":
            return "int16";
          case "[object Int32Array]":
            return "int32";
          case "[object Uint8Array]":
            return "uint8";
          case "[object Uint16Array]":
            return "uint16";
          case "[object Uint32Array]":
            return "uint32";
          case "[object Uint8ClampedArray]":
            return "uint8_clamped";
          case "[object BigInt64Array]":
            return "bigint64";
          case "[object BigUint64Array]":
            return "biguint64";
        }
      }
      if (Array.isArray(data)) {
        return "array";
      }
      return "generic";
    }
    var CACHED_CONSTRUCTORS = {
      "float32": [],
      "float64": [],
      "int8": [],
      "int16": [],
      "int32": [],
      "uint8": [],
      "uint16": [],
      "uint32": [],
      "array": [],
      "uint8_clamped": [],
      "bigint64": [],
      "biguint64": [],
      "buffer": [],
      "generic": []
    };
    function wrappedNDArrayCtor(data, shape, stride, offset) {
      if (data === void 0) {
        var ctor = CACHED_CONSTRUCTORS.array[0];
        return ctor([]);
      } else if (typeof data === "number") {
        data = [data];
      }
      if (shape === void 0) {
        shape = [data.length];
      }
      var d = shape.length;
      if (stride === void 0) {
        stride = new Array(d);
        for (var i = d - 1, sz = 1; i >= 0; --i) {
          stride[i] = sz;
          sz *= shape[i];
        }
      }
      if (offset === void 0) {
        offset = 0;
        for (var i = 0; i < d; ++i) {
          if (stride[i] < 0) {
            offset -= (shape[i] - 1) * stride[i];
          }
        }
      }
      var dtype = arrayDType(data);
      var ctor_list = CACHED_CONSTRUCTORS[dtype];
      while (ctor_list.length <= d + 1) {
        ctor_list.push(compileConstructor(dtype, ctor_list.length - 1));
      }
      var ctor = ctor_list[d + 1];
      return ctor(data, shape, stride, offset);
    }
    module.exports = wrappedNDArrayCtor;
  }
});

// ../../node_modules/fast-voxel-raycast/index.js
var require_fast_voxel_raycast = __commonJS({
  "../../node_modules/fast-voxel-raycast/index.js"(exports, module) {
    "use strict";
    function traceRay_impl(getVoxel, px, py, pz, dx2, dy, dz, max_d, hit_pos, hit_norm) {
      var t = 0, floor2 = Math.floor, ix = floor2(px) | 0, iy = floor2(py) | 0, iz = floor2(pz) | 0, stepx = dx2 > 0 ? 1 : -1, stepy = dy > 0 ? 1 : -1, stepz = dz > 0 ? 1 : -1, txDelta = Math.abs(1 / dx2), tyDelta = Math.abs(1 / dy), tzDelta = Math.abs(1 / dz), xdist = stepx > 0 ? ix + 1 - px : px - ix, ydist = stepy > 0 ? iy + 1 - py : py - iy, zdist = stepz > 0 ? iz + 1 - pz : pz - iz, txMax = txDelta < Infinity ? txDelta * xdist : Infinity, tyMax = tyDelta < Infinity ? tyDelta * ydist : Infinity, tzMax = tzDelta < Infinity ? tzDelta * zdist : Infinity, steppedIndex = -1;
      while (t <= max_d) {
        var b = getVoxel(ix, iy, iz);
        if (b) {
          if (hit_pos) {
            hit_pos[0] = px + t * dx2;
            hit_pos[1] = py + t * dy;
            hit_pos[2] = pz + t * dz;
          }
          if (hit_norm) {
            hit_norm[0] = hit_norm[1] = hit_norm[2] = 0;
            if (steppedIndex === 0) hit_norm[0] = -stepx;
            if (steppedIndex === 1) hit_norm[1] = -stepy;
            if (steppedIndex === 2) hit_norm[2] = -stepz;
          }
          return b;
        }
        if (txMax < tyMax) {
          if (txMax < tzMax) {
            ix += stepx;
            t = txMax;
            txMax += txDelta;
            steppedIndex = 0;
          } else {
            iz += stepz;
            t = tzMax;
            tzMax += tzDelta;
            steppedIndex = 2;
          }
        } else {
          if (tyMax < tzMax) {
            iy += stepy;
            t = tyMax;
            tyMax += tyDelta;
            steppedIndex = 1;
          } else {
            iz += stepz;
            t = tzMax;
            tzMax += tzDelta;
            steppedIndex = 2;
          }
        }
      }
      if (hit_pos) {
        hit_pos[0] = px + t * dx2;
        hit_pos[1] = py + t * dy;
        hit_pos[2] = pz + t * dz;
      }
      if (hit_norm) {
        hit_norm[0] = hit_norm[1] = hit_norm[2] = 0;
      }
      return 0;
    }
    function traceRay(getVoxel, origin, direction, max_d, hit_pos, hit_norm) {
      var px = +origin[0], py = +origin[1], pz = +origin[2], dx2 = +direction[0], dy = +direction[1], dz = +direction[2], ds = Math.sqrt(dx2 * dx2 + dy * dy + dz * dz);
      if (ds === 0) {
        throw new Error("Can't raycast along a zero vector");
      }
      dx2 /= ds;
      dy /= ds;
      dz /= ds;
      if (typeof max_d === "undefined") {
        max_d = 64;
      } else {
        max_d = +max_d;
      }
      return traceRay_impl(getVoxel, px, py, pz, dx2, dy, dz, max_d, hit_pos, hit_norm);
    }
    module.exports = traceRay;
  }
});

// ../../node_modules/voxel-aabb-sweep/index.js
var require_voxel_aabb_sweep = __commonJS({
  "../../node_modules/voxel-aabb-sweep/index.js"(exports, module) {
    "use strict";
    var tr_arr = [];
    var ldi_arr = [];
    var tri_arr = [];
    var step_arr = [];
    var tDelta_arr = [];
    var tNext_arr = [];
    var vec_arr = [];
    var normed_arr = [];
    var base_arr = [];
    var max_arr = [];
    var left_arr = [];
    var result_arr = [];
    function sweep_impl(getVoxel, callback, vec, base, max2, epsilon) {
      var tr = tr_arr;
      var ldi = ldi_arr;
      var tri = tri_arr;
      var step = step_arr;
      var tDelta = tDelta_arr;
      var tNext = tNext_arr;
      var normed = normed_arr;
      var floor2 = Math.floor;
      var cumulative_t = 0;
      var t = 0;
      var max_t = 0;
      var axis = 0;
      var i = 0;
      initSweep();
      if (max_t === 0) return 0;
      axis = stepForward();
      while (t <= max_t) {
        if (checkCollision(axis)) {
          var done = handleCollision();
          if (done) return cumulative_t;
        }
        axis = stepForward();
      }
      cumulative_t += max_t;
      for (i = 0; i < 3; i++) {
        base[i] += vec[i];
        max2[i] += vec[i];
      }
      return cumulative_t;
      function initSweep() {
        t = 0;
        max_t = Math.sqrt(vec[0] * vec[0] + vec[1] * vec[1] + vec[2] * vec[2]);
        if (max_t === 0) return;
        for (var i2 = 0; i2 < 3; i2++) {
          var dir = vec[i2] >= 0;
          step[i2] = dir ? 1 : -1;
          var lead = dir ? max2[i2] : base[i2];
          tr[i2] = dir ? base[i2] : max2[i2];
          ldi[i2] = leadEdgeToInt(lead, step[i2]);
          tri[i2] = trailEdgeToInt(tr[i2], step[i2]);
          normed[i2] = vec[i2] / max_t;
          tDelta[i2] = Math.abs(1 / normed[i2]);
          var dist2 = dir ? ldi[i2] + 1 - lead : lead - ldi[i2];
          tNext[i2] = tDelta[i2] < Infinity ? tDelta[i2] * dist2 : Infinity;
        }
      }
      function checkCollision(i_axis) {
        var stepx = step[0];
        var x0 = i_axis === 0 ? ldi[0] : tri[0];
        var x1 = ldi[0] + stepx;
        var stepy = step[1];
        var y0 = i_axis === 1 ? ldi[1] : tri[1];
        var y1 = ldi[1] + stepy;
        var stepz = step[2];
        var z0 = i_axis === 2 ? ldi[2] : tri[2];
        var z1 = ldi[2] + stepz;
        for (var x = x0; x != x1; x += stepx) {
          for (var y = y0; y != y1; y += stepy) {
            for (var z = z0; z != z1; z += stepz) {
              if (getVoxel(x, y, z)) return true;
            }
          }
        }
        return false;
      }
      function handleCollision() {
        cumulative_t += t;
        var dir = step[axis];
        var done2 = t / max_t;
        var left = left_arr;
        for (i = 0; i < 3; i++) {
          var dv2 = vec[i] * done2;
          base[i] += dv2;
          max2[i] += dv2;
          left[i] = vec[i] - dv2;
        }
        if (dir > 0) {
          max2[axis] = Math.round(max2[axis]);
        } else {
          base[axis] = Math.round(base[axis]);
        }
        var res = callback(cumulative_t, axis, dir, left);
        if (res) return true;
        for (i = 0; i < 3; i++) vec[i] = left[i];
        initSweep();
        if (max_t === 0) return true;
        return false;
      }
      function stepForward() {
        var axis2 = tNext[0] < tNext[1] ? tNext[0] < tNext[2] ? 0 : 2 : tNext[1] < tNext[2] ? 1 : 2;
        var dt = tNext[axis2] - t;
        t = tNext[axis2];
        ldi[axis2] += step[axis2];
        tNext[axis2] += tDelta[axis2];
        for (i = 0; i < 3; i++) {
          tr[i] += dt * normed[i];
          tri[i] = trailEdgeToInt(tr[i], step[i]);
        }
        return axis2;
      }
      function leadEdgeToInt(coord, step2) {
        return floor2(coord - step2 * epsilon);
      }
      function trailEdgeToInt(coord, step2) {
        return floor2(coord + step2 * epsilon);
      }
    }
    function sweep3(getVoxel, box, dir, callback, noTranslate, epsilon) {
      var vec = vec_arr;
      var base = base_arr;
      var max2 = max_arr;
      var result = result_arr;
      for (var i = 0; i < 3; i++) {
        vec[i] = +dir[i];
        max2[i] = +box.max[i];
        base[i] = +box.base[i];
      }
      if (!epsilon) epsilon = 1e-10;
      var dist2 = sweep_impl(getVoxel, callback, vec, base, max2, epsilon);
      if (!noTranslate) {
        for (i = 0; i < 3; i++) {
          result[i] = dir[i] > 0 ? max2[i] - box.max[i] : base[i] - box.base[i];
        }
        box.translate(result);
      }
      return dist2;
    }
    module.exports = sweep3;
  }
});

// ../../node_modules/ent-comp/src/dataStore.js
var require_dataStore = __commonJS({
  "../../node_modules/ent-comp/src/dataStore.js"(exports, module) {
    module.exports = class DataStore {
      constructor() {
        this.list = [];
        this.hash = {};
        this._map = {};
        this._pendingRemovals = [];
      }
      // add a new state object
      add(id, stateObject) {
        if (typeof this._map[id] === "number") {
          var index = this._map[id];
          this.hash[id] = stateObject;
          this.list[index] = stateObject;
        } else {
          this._map[id] = this.list.length;
          this.hash[id] = stateObject;
          this.list.push(stateObject);
        }
      }
      // remove - nulls the state object, actual removal comes later
      remove(id) {
        var index = this._map[id];
        this.hash[id] = null;
        this.list[index] = null;
        this._pendingRemovals.push(id);
      }
      // just sever references
      dispose() {
        this.list = null;
        this.hash = null;
        this._map = null;
        this._pendingRemovals.length = 0;
      }
      // deletes removed objects from data structures
      flush() {
        for (var i = 0; i < this._pendingRemovals.length; i++) {
          var id = this._pendingRemovals[i];
          if (this.hash[id] !== null) continue;
          removeElement(this, id);
        }
        this._pendingRemovals.length = 0;
      }
    };
    function removeElement(data, id) {
      var index = data._map[id];
      delete data.hash[id];
      delete data._map[id];
      if (index === data.list.length - 1) {
        data.list.pop();
      } else {
        var swapped = data.list.pop();
        data.list[index] = swapped;
        if (swapped === null || swapped[0] === null) {
          var prevIndex = data.list.length;
          for (var swapID in data._map) {
            if (data._map[swapID] === prevIndex) {
              data._map[swapID] = index;
              return;
            }
          }
        } else {
          var swappedID = swapped.__id || swapped[0].__id;
          data._map[swappedID] = index;
        }
      }
    }
  }
});

// ../../node_modules/ent-comp/src/ECS.js
var require_ECS = __commonJS({
  "../../node_modules/ent-comp/src/ECS.js"(exports, module) {
    module.exports = ECS2;
    var DataStore = require_dataStore();
    function ECS2() {
      var self = this;
      this.components = {};
      this.comps = this.components;
      var components = this.components;
      var UID = 1;
      var storage = {};
      var systems = [];
      var renderSystems = [];
      var deferrals = {
        timeout: false,
        removals: [],
        multiComps: []
      };
      this._storage = storage;
      this._systems = systems;
      this._renderSystems = renderSystems;
      this.createEntity = function(compList) {
        var id = UID++;
        if (Array.isArray(compList)) {
          compList.forEach((compName) => self.addComponent(id, compName));
        }
        return id;
      };
      this.deleteEntity = function(entID) {
        Object.keys(storage).forEach((compName) => {
          var data = storage[compName];
          if (data.hash[entID]) {
            removeComponent(entID, compName);
          }
        });
        return self;
      };
      this.createComponent = function(compDefn) {
        if (!compDefn) throw new Error("Missing component definition");
        var name66 = compDefn.name;
        if (!name66) throw new Error("Component definition must have a name property.");
        if (typeof name66 !== "string") throw new Error("Component name must be a string.");
        if (name66 === "") throw new Error("Component name must be a non-empty string.");
        if (storage[name66]) throw new Error(`Component ${name66} already exists.`);
        var internalDef = {};
        internalDef.name = name66;
        internalDef.multi = !!compDefn.multi;
        internalDef.order = isNaN(compDefn.order) ? 99 : compDefn.order;
        internalDef.state = compDefn.state || {};
        internalDef.onAdd = compDefn.onAdd || null;
        internalDef.onRemove = compDefn.onRemove || null;
        internalDef.system = compDefn.system || null;
        internalDef.renderSystem = compDefn.renderSystem || null;
        components[name66] = internalDef;
        storage[name66] = new DataStore();
        storage[name66]._pendingMultiCleanup = false;
        storage[name66]._multiCleanupIDs = internalDef.multi ? [] : null;
        if (internalDef.system) {
          systems.push(name66);
          systems.sort((a2, b) => components[a2].order - components[b].order);
        }
        if (internalDef.renderSystem) {
          renderSystems.push(name66);
          renderSystems.sort((a2, b) => components[a2].order - components[b].order);
        }
        return name66;
      };
      this.overwriteComponent = function(compName, compDefn) {
        var def = components[compName];
        if (!def) throw new Error(`Unknown component: ${compName}`);
        if (!compDefn) throw new Error("Missing component definition");
        if (def.name !== compDefn.name) throw new Error("Overwriting component must use the same name property.");
        var internalDef = {};
        internalDef.name = compName;
        internalDef.multi = !!compDefn.multi;
        internalDef.order = isNaN(compDefn.order) ? 99 : compDefn.order;
        internalDef.state = compDefn.state || {};
        internalDef.onAdd = compDefn.onAdd || null;
        internalDef.onRemove = compDefn.onRemove || null;
        internalDef.system = compDefn.system || null;
        internalDef.renderSystem = compDefn.renderSystem || null;
        components[compName] = internalDef;
        storage[compName]._pendingMultiCleanup = false;
        storage[compName]._multiCleanupIDs = internalDef.multi ? [] : null;
        var si = systems.indexOf(compName);
        if (internalDef.system && si < 0) systems.push(compName);
        if (!internalDef.system && si >= 0) systems.splice(si, 1);
        systems.sort((a2, b) => components[a2].order - components[b].order);
        var ri = renderSystems.indexOf(compName);
        if (internalDef.renderSystem && ri < 0) renderSystems.push(compName);
        if (!internalDef.renderSystem && ri >= 0) renderSystems.splice(ri, 1);
        renderSystems.sort((a2, b) => components[a2].order - components[b].order);
        var baseState = internalDef.state;
        this.getStatesList(compName).forEach((state) => {
          for (var key in baseState) {
            if (!(key in state)) state[key] = baseState[key];
          }
          if (internalDef.onAdd) internalDef.onAdd(state.__id, state);
        });
        return compName;
      };
      this.deleteComponent = function(compName) {
        var data = storage[compName];
        if (!data) throw new Error(`Unknown component: ${compName}`);
        data.flush();
        data.list.forEach((obj) => {
          if (!obj) return;
          var id = obj.__id || obj[0].__id;
          removeComponent(id, compName);
        });
        var i = systems.indexOf(compName);
        var j = renderSystems.indexOf(compName);
        if (i > -1) systems.splice(i, 1);
        if (j > -1) renderSystems.splice(j, 1);
        storage[compName].dispose();
        delete storage[compName];
        delete components[compName];
        return self;
      };
      this.addComponent = function(entID, compName, state) {
        var def = components[compName];
        var data = storage[compName];
        if (!data) throw new Error(`Unknown component: ${compName}.`);
        if (data.hash[entID] && !def.multi) {
          throw new Error(`Entity ${entID} already has component: ${compName}.`);
        }
        var newState = Object.assign({}, { __id: entID }, def.state, state);
        newState.__id = entID;
        if (def.multi) {
          var statesArr = data.hash[entID];
          if (!statesArr) {
            statesArr = [];
            data.add(entID, statesArr);
          }
          statesArr.push(newState);
        } else {
          data.add(entID, newState);
        }
        if (def.onAdd) def.onAdd(entID, newState);
        return this;
      };
      this.hasComponent = function(entID, compName) {
        var data = storage[compName];
        if (!data) throw new Error(`Unknown component: ${compName}.`);
        return !!data.hash[entID];
      };
      this.removeComponent = function(entID, compName) {
        var data = storage[compName];
        if (!data) throw new Error(`Unknown component: ${compName}.`);
        removeComponent(entID, compName);
        return self;
      };
      this.getState = function(entID, compName) {
        var data = storage[compName];
        if (!data) throw new Error(`Unknown component: ${compName}.`);
        return data.hash[entID];
      };
      this.getStatesList = function(compName) {
        var data = storage[compName];
        if (!data) throw new Error(`Unknown component: ${compName}.`);
        doDeferredCleanup(data);
        return data.list;
      };
      this.getStateAccessor = function(compName) {
        if (!storage[compName]) throw new Error(`Unknown component: ${compName}.`);
        var hash = storage[compName].hash;
        return (id) => hash[id];
      };
      this.getComponentAccessor = function(compName) {
        if (!storage[compName]) throw new Error(`Unknown component: ${compName}.`);
        var hash = storage[compName].hash;
        return (id) => !!hash[id];
      };
      this.tick = function(dt) {
        doDeferredCleanup();
        for (var i = 0; i < systems.length; i++) {
          var compName = systems[i];
          var comp = components[compName];
          var data = storage[compName];
          comp.system(dt, data.list);
          doDeferredCleanup();
        }
        return self;
      };
      this.render = function(dt) {
        doDeferredCleanup();
        for (var i = 0; i < renderSystems.length; i++) {
          var compName = renderSystems[i];
          var comp = components[compName];
          var data = storage[compName];
          comp.renderSystem(dt, data.list);
          doDeferredCleanup();
        }
        return self;
      };
      this.removeMultiComponent = function(entID, compName, index) {
        var def = components[compName];
        var data = storage[compName];
        if (!data) throw new Error(`Unknown component: ${compName}.`);
        if (!def.multi) throw new Error("removeMultiComponent called on non-multi component");
        removeMultiCompElement(entID, def, data, index);
        return self;
      };
      function removeComponent(entID, compName) {
        var def = components[compName];
        var data = storage[compName];
        var state = data.hash[entID];
        if (!state) return;
        data.remove(entID);
        if (def.onRemove) {
          if (def.multi) {
            state.forEach((state2) => {
              if (state2) def.onRemove(entID, state2);
            });
            state.length = 0;
          } else {
            def.onRemove(entID, state);
          }
        }
        deferrals.removals.push(data);
        pingDeferrals();
      }
      function removeMultiCompElement(entID, def, data, index) {
        var statesArr = data.hash[entID];
        if (!statesArr) return;
        var state = statesArr[index];
        if (!state) return;
        statesArr[index] = null;
        if (def.onRemove) def.onRemove(entID, state);
        deferrals.multiComps.push({ entID, data });
        pingDeferrals();
      }
      function pingDeferrals() {
        if (deferrals.timeout) return;
        deferrals.timeout = true;
        setTimeout(deferralHandler, 1);
      }
      function deferralHandler() {
        deferrals.timeout = false;
        doDeferredCleanup();
      }
      function doDeferredCleanup() {
        if (deferrals.multiComps.length) {
          deferredMultiCompCleanup(deferrals.multiComps);
        }
        if (deferrals.removals.length) {
          deferredComponentCleanup(deferrals.removals);
        }
      }
      function deferredMultiCompCleanup(list) {
        for (var i = 0; i < list.length; i++) {
          var { entID, data } = list[i];
          var statesArr = data.hash[entID];
          if (!statesArr) continue;
          for (var j = 0; j < statesArr.length; j++) {
            if (statesArr[j]) continue;
            statesArr.splice(j, 1);
            j--;
          }
          if (statesArr.length === 0) {
            data.remove(entID);
            deferrals.removals.push(data);
          }
        }
        list.length = 0;
      }
      function deferredComponentCleanup(list) {
        for (var i = 0; i < list.length; i++) {
          var data = list[i];
          data.flush();
        }
        list.length = 0;
      }
    }
  }
});

// ../../node_modules/bit-twiddle/twiddle.js
var require_twiddle = __commonJS({
  "../../node_modules/bit-twiddle/twiddle.js"(exports) {
    "use strict";
    "use restrict";
    var INT_BITS = 32;
    exports.INT_BITS = INT_BITS;
    exports.INT_MAX = 2147483647;
    exports.INT_MIN = -1 << INT_BITS - 1;
    exports.sign = function(v) {
      return (v > 0) - (v < 0);
    };
    exports.abs = function(v) {
      var mask = v >> INT_BITS - 1;
      return (v ^ mask) - mask;
    };
    exports.min = function(x, y) {
      return y ^ (x ^ y) & -(x < y);
    };
    exports.max = function(x, y) {
      return x ^ (x ^ y) & -(x < y);
    };
    exports.isPow2 = function(v) {
      return !(v & v - 1) && !!v;
    };
    exports.log2 = function(v) {
      var r, shift;
      r = (v > 65535) << 4;
      v >>>= r;
      shift = (v > 255) << 3;
      v >>>= shift;
      r |= shift;
      shift = (v > 15) << 2;
      v >>>= shift;
      r |= shift;
      shift = (v > 3) << 1;
      v >>>= shift;
      r |= shift;
      return r | v >> 1;
    };
    exports.log10 = function(v) {
      return v >= 1e9 ? 9 : v >= 1e8 ? 8 : v >= 1e7 ? 7 : v >= 1e6 ? 6 : v >= 1e5 ? 5 : v >= 1e4 ? 4 : v >= 1e3 ? 3 : v >= 100 ? 2 : v >= 10 ? 1 : 0;
    };
    exports.popCount = function(v) {
      v = v - (v >>> 1 & 1431655765);
      v = (v & 858993459) + (v >>> 2 & 858993459);
      return (v + (v >>> 4) & 252645135) * 16843009 >>> 24;
    };
    function countTrailingZeros(v) {
      var c = 32;
      v &= -v;
      if (v) c--;
      if (v & 65535) c -= 16;
      if (v & 16711935) c -= 8;
      if (v & 252645135) c -= 4;
      if (v & 858993459) c -= 2;
      if (v & 1431655765) c -= 1;
      return c;
    }
    exports.countTrailingZeros = countTrailingZeros;
    exports.nextPow2 = function(v) {
      v += v === 0;
      --v;
      v |= v >>> 1;
      v |= v >>> 2;
      v |= v >>> 4;
      v |= v >>> 8;
      v |= v >>> 16;
      return v + 1;
    };
    exports.prevPow2 = function(v) {
      v |= v >>> 1;
      v |= v >>> 2;
      v |= v >>> 4;
      v |= v >>> 8;
      v |= v >>> 16;
      return v - (v >>> 1);
    };
    exports.parity = function(v) {
      v ^= v >>> 16;
      v ^= v >>> 8;
      v ^= v >>> 4;
      v &= 15;
      return 27030 >>> v & 1;
    };
    var REVERSE_TABLE = new Array(256);
    (function(tab) {
      for (var i = 0; i < 256; ++i) {
        var v = i, r = i, s = 7;
        for (v >>>= 1; v; v >>>= 1) {
          r <<= 1;
          r |= v & 1;
          --s;
        }
        tab[i] = r << s & 255;
      }
    })(REVERSE_TABLE);
    exports.reverse = function(v) {
      return REVERSE_TABLE[v & 255] << 24 | REVERSE_TABLE[v >>> 8 & 255] << 16 | REVERSE_TABLE[v >>> 16 & 255] << 8 | REVERSE_TABLE[v >>> 24 & 255];
    };
    exports.interleave2 = function(x, y) {
      x &= 65535;
      x = (x | x << 8) & 16711935;
      x = (x | x << 4) & 252645135;
      x = (x | x << 2) & 858993459;
      x = (x | x << 1) & 1431655765;
      y &= 65535;
      y = (y | y << 8) & 16711935;
      y = (y | y << 4) & 252645135;
      y = (y | y << 2) & 858993459;
      y = (y | y << 1) & 1431655765;
      return x | y << 1;
    };
    exports.deinterleave2 = function(v, n) {
      v = v >>> n & 1431655765;
      v = (v | v >>> 1) & 858993459;
      v = (v | v >>> 2) & 252645135;
      v = (v | v >>> 4) & 16711935;
      v = (v | v >>> 16) & 65535;
      return v << 16 >> 16;
    };
    exports.interleave3 = function(x, y, z) {
      x &= 1023;
      x = (x | x << 16) & 4278190335;
      x = (x | x << 8) & 251719695;
      x = (x | x << 4) & 3272356035;
      x = (x | x << 2) & 1227133513;
      y &= 1023;
      y = (y | y << 16) & 4278190335;
      y = (y | y << 8) & 251719695;
      y = (y | y << 4) & 3272356035;
      y = (y | y << 2) & 1227133513;
      x |= y << 1;
      z &= 1023;
      z = (z | z << 16) & 4278190335;
      z = (z | z << 8) & 251719695;
      z = (z | z << 4) & 3272356035;
      z = (z | z << 2) & 1227133513;
      return x | z << 2;
    };
    exports.deinterleave3 = function(v, n) {
      v = v >>> n & 1227133513;
      v = (v | v >>> 2) & 3272356035;
      v = (v | v >>> 4) & 251719695;
      v = (v | v >>> 8) & 4278190335;
      v = (v | v >>> 16) & 1023;
      return v << 22 >> 22;
    };
    exports.nextCombination = function(v) {
      var t = v | v - 1;
      return t + 1 | (~t & -~t) - 1 >>> countTrailingZeros(v) + 1;
    };
  }
});

// ../../node_modules/dup/dup.js
var require_dup = __commonJS({
  "../../node_modules/dup/dup.js"(exports, module) {
    "use strict";
    function dupe_array(count, value, i) {
      var c = count[i] | 0;
      if (c <= 0) {
        return [];
      }
      var result = new Array(c), j;
      if (i === count.length - 1) {
        for (j = 0; j < c; ++j) {
          result[j] = value;
        }
      } else {
        for (j = 0; j < c; ++j) {
          result[j] = dupe_array(count, value, i + 1);
        }
      }
      return result;
    }
    function dupe_number(count, value) {
      var result, i;
      result = new Array(count);
      for (i = 0; i < count; ++i) {
        result[i] = value;
      }
      return result;
    }
    function dupe(count, value) {
      if (typeof value === "undefined") {
        value = 0;
      }
      switch (typeof count) {
        case "number":
          if (count > 0) {
            return dupe_number(count | 0, value);
          }
          break;
        case "object":
          if (typeof count.length === "number") {
            return dupe_array(count, value, 0);
          }
          break;
      }
      return [];
    }
    module.exports = dupe;
  }
});

// ../../node_modules/is-buffer/index.js
var require_is_buffer2 = __commonJS({
  "../../node_modules/is-buffer/index.js"(exports, module) {
    module.exports = function isBuffer(obj) {
      return obj != null && obj.constructor != null && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
    };
  }
});

// ../../node_modules/@jpweeks/typedarray-pool/pool.js
var require_pool = __commonJS({
  "../../node_modules/@jpweeks/typedarray-pool/pool.js"(exports) {
    "use strict";
    var bits = require_twiddle();
    var dup = require_dup();
    var isBuffer = require_is_buffer2();
    if (!global.__TYPEDARRAY_POOL) {
      global.__TYPEDARRAY_POOL = {
        UINT8: dup([32, 0]),
        UINT16: dup([32, 0]),
        UINT32: dup([32, 0]),
        INT8: dup([32, 0]),
        INT16: dup([32, 0]),
        INT32: dup([32, 0]),
        FLOAT: dup([32, 0]),
        DOUBLE: dup([32, 0]),
        DATA: dup([32, 0]),
        UINT8C: dup([32, 0]),
        BUFFER: dup([32, 0])
      };
    }
    var hasUint8C = typeof Uint8ClampedArray !== "undefined";
    var POOL = global.__TYPEDARRAY_POOL;
    if (!POOL.UINT8C) {
      POOL.UINT8C = dup([32, 0]);
    }
    if (!POOL.BUFFER) {
      POOL.BUFFER = dup([32, 0]);
    }
    var DATA = POOL.DATA;
    var BUFFER = POOL.BUFFER;
    exports.free = function free(array) {
      if (isBuffer(array)) {
        BUFFER[bits.log2(array.length)].push(array);
      } else {
        if (Object.prototype.toString.call(array) !== "[object ArrayBuffer]") {
          array = array.buffer;
        }
        if (!array) {
          return;
        }
        var n = array.length || array.byteLength;
        var log_n = bits.log2(n) | 0;
        DATA[log_n].push(array);
      }
    };
    function freeArrayBuffer(buffer) {
      if (!buffer) {
        return;
      }
      var n = buffer.length || buffer.byteLength;
      var log_n = bits.log2(n);
      DATA[log_n].push(buffer);
    }
    function freeTypedArray(array) {
      freeArrayBuffer(array.buffer);
    }
    exports.freeUint8 = exports.freeUint16 = exports.freeUint32 = exports.freeInt8 = exports.freeInt16 = exports.freeInt32 = exports.freeFloat32 = exports.freeFloat = exports.freeFloat64 = exports.freeDouble = exports.freeUint8Clamped = exports.freeDataView = freeTypedArray;
    exports.freeArrayBuffer = freeArrayBuffer;
    exports.freeBuffer = function freeBuffer(array) {
      BUFFER[bits.log2(array.length)].push(array);
    };
    exports.malloc = function malloc(n, dtype) {
      if (dtype === void 0 || dtype === "arraybuffer") {
        return mallocArrayBuffer(n);
      } else {
        switch (dtype) {
          case "uint8":
            return mallocUint8(n);
          case "uint16":
            return mallocUint16(n);
          case "uint32":
            return mallocUint32(n);
          case "int8":
            return mallocInt8(n);
          case "int16":
            return mallocInt16(n);
          case "int32":
            return mallocInt32(n);
          case "float":
          case "float32":
            return mallocFloat(n);
          case "double":
          case "float64":
            return mallocDouble(n);
          case "uint8_clamped":
            return mallocUint8Clamped(n);
          case "buffer":
            throw "Buffer not supported";
          case "data":
          case "dataview":
            return mallocDataView(n);
          default:
            return null;
        }
      }
      return null;
    };
    function mallocArrayBuffer(n) {
      var n = bits.nextPow2(n);
      var log_n = bits.log2(n);
      var d = DATA[log_n];
      if (d.length > 0) {
        return d.pop();
      }
      return new ArrayBuffer(n);
    }
    exports.mallocArrayBuffer = mallocArrayBuffer;
    function mallocUint8(n) {
      return new Uint8Array(mallocArrayBuffer(n), 0, n);
    }
    exports.mallocUint8 = mallocUint8;
    function mallocUint16(n) {
      return new Uint16Array(mallocArrayBuffer(2 * n), 0, n);
    }
    exports.mallocUint16 = mallocUint16;
    function mallocUint32(n) {
      return new Uint32Array(mallocArrayBuffer(4 * n), 0, n);
    }
    exports.mallocUint32 = mallocUint32;
    function mallocInt8(n) {
      return new Int8Array(mallocArrayBuffer(n), 0, n);
    }
    exports.mallocInt8 = mallocInt8;
    function mallocInt16(n) {
      return new Int16Array(mallocArrayBuffer(2 * n), 0, n);
    }
    exports.mallocInt16 = mallocInt16;
    function mallocInt32(n) {
      return new Int32Array(mallocArrayBuffer(4 * n), 0, n);
    }
    exports.mallocInt32 = mallocInt32;
    function mallocFloat(n) {
      return new Float32Array(mallocArrayBuffer(4 * n), 0, n);
    }
    exports.mallocFloat32 = exports.mallocFloat = mallocFloat;
    function mallocDouble(n) {
      return new Float64Array(mallocArrayBuffer(8 * n), 0, n);
    }
    exports.mallocFloat64 = exports.mallocDouble = mallocDouble;
    function mallocUint8Clamped(n) {
      if (hasUint8C) {
        return new Uint8ClampedArray(mallocArrayBuffer(n), 0, n);
      } else {
        return mallocUint8(n);
      }
    }
    exports.mallocUint8Clamped = mallocUint8Clamped;
    function mallocDataView(n) {
      return new DataView(mallocArrayBuffer(n), 0, n);
    }
    exports.mallocDataView = mallocDataView;
    exports.clearCache = function clearCache() {
      for (var i = 0; i < 32; ++i) {
        POOL.UINT8[i].length = 0;
        POOL.UINT16[i].length = 0;
        POOL.UINT32[i].length = 0;
        POOL.INT8[i].length = 0;
        POOL.INT16[i].length = 0;
        POOL.INT32[i].length = 0;
        POOL.FLOAT[i].length = 0;
        POOL.DOUBLE[i].length = 0;
        POOL.UINT8C[i].length = 0;
        DATA[i].length = 0;
        BUFFER[i].length = 0;
      }
    };
  }
});

// ../../node_modules/box-intersect/lib/sort.js
var require_sort = __commonJS({
  "../../node_modules/box-intersect/lib/sort.js"(exports, module) {
    "use strict";
    module.exports = wrapper;
    var INSERT_SORT_CUTOFF = 32;
    function wrapper(data, n0) {
      if (n0 <= 4 * INSERT_SORT_CUTOFF) {
        insertionSort(0, n0 - 1, data);
      } else {
        quickSort(0, n0 - 1, data);
      }
    }
    function insertionSort(left, right, data) {
      var ptr = 2 * (left + 1);
      for (var i = left + 1; i <= right; ++i) {
        var a2 = data[ptr++];
        var b = data[ptr++];
        var j = i;
        var jptr = ptr - 2;
        while (j-- > left) {
          var x = data[jptr - 2];
          var y = data[jptr - 1];
          if (x < a2) {
            break;
          } else if (x === a2 && y < b) {
            break;
          }
          data[jptr] = x;
          data[jptr + 1] = y;
          jptr -= 2;
        }
        data[jptr] = a2;
        data[jptr + 1] = b;
      }
    }
    function swap(i, j, data) {
      i *= 2;
      j *= 2;
      var x = data[i];
      var y = data[i + 1];
      data[i] = data[j];
      data[i + 1] = data[j + 1];
      data[j] = x;
      data[j + 1] = y;
    }
    function move(i, j, data) {
      i *= 2;
      j *= 2;
      data[i] = data[j];
      data[i + 1] = data[j + 1];
    }
    function rotate(i, j, k, data) {
      i *= 2;
      j *= 2;
      k *= 2;
      var x = data[i];
      var y = data[i + 1];
      data[i] = data[j];
      data[i + 1] = data[j + 1];
      data[j] = data[k];
      data[j + 1] = data[k + 1];
      data[k] = x;
      data[k + 1] = y;
    }
    function shufflePivot(i, j, px, py, data) {
      i *= 2;
      j *= 2;
      data[i] = data[j];
      data[j] = px;
      data[i + 1] = data[j + 1];
      data[j + 1] = py;
    }
    function compare(i, j, data) {
      i *= 2;
      j *= 2;
      var x = data[i], y = data[j];
      if (x < y) {
        return false;
      } else if (x === y) {
        return data[i + 1] > data[j + 1];
      }
      return true;
    }
    function comparePivot(i, y, b, data) {
      i *= 2;
      var x = data[i];
      if (x < y) {
        return true;
      } else if (x === y) {
        return data[i + 1] < b;
      }
      return false;
    }
    function quickSort(left, right, data) {
      var sixth = (right - left + 1) / 6 | 0, index1 = left + sixth, index5 = right - sixth, index3 = left + right >> 1, index2 = index3 - sixth, index4 = index3 + sixth, el1 = index1, el2 = index2, el3 = index3, el4 = index4, el5 = index5, less = left + 1, great = right - 1, tmp = 0;
      if (compare(el1, el2, data)) {
        tmp = el1;
        el1 = el2;
        el2 = tmp;
      }
      if (compare(el4, el5, data)) {
        tmp = el4;
        el4 = el5;
        el5 = tmp;
      }
      if (compare(el1, el3, data)) {
        tmp = el1;
        el1 = el3;
        el3 = tmp;
      }
      if (compare(el2, el3, data)) {
        tmp = el2;
        el2 = el3;
        el3 = tmp;
      }
      if (compare(el1, el4, data)) {
        tmp = el1;
        el1 = el4;
        el4 = tmp;
      }
      if (compare(el3, el4, data)) {
        tmp = el3;
        el3 = el4;
        el4 = tmp;
      }
      if (compare(el2, el5, data)) {
        tmp = el2;
        el2 = el5;
        el5 = tmp;
      }
      if (compare(el2, el3, data)) {
        tmp = el2;
        el2 = el3;
        el3 = tmp;
      }
      if (compare(el4, el5, data)) {
        tmp = el4;
        el4 = el5;
        el5 = tmp;
      }
      var pivot1X = data[2 * el2];
      var pivot1Y = data[2 * el2 + 1];
      var pivot2X = data[2 * el4];
      var pivot2Y = data[2 * el4 + 1];
      var ptr0 = 2 * el1;
      var ptr2 = 2 * el3;
      var ptr4 = 2 * el5;
      var ptr5 = 2 * index1;
      var ptr6 = 2 * index3;
      var ptr7 = 2 * index5;
      for (var i1 = 0; i1 < 2; ++i1) {
        var x = data[ptr0 + i1];
        var y = data[ptr2 + i1];
        var z = data[ptr4 + i1];
        data[ptr5 + i1] = x;
        data[ptr6 + i1] = y;
        data[ptr7 + i1] = z;
      }
      move(index2, left, data);
      move(index4, right, data);
      for (var k = less; k <= great; ++k) {
        if (comparePivot(k, pivot1X, pivot1Y, data)) {
          if (k !== less) {
            swap(k, less, data);
          }
          ++less;
        } else {
          if (!comparePivot(k, pivot2X, pivot2Y, data)) {
            while (true) {
              if (!comparePivot(great, pivot2X, pivot2Y, data)) {
                if (--great < k) {
                  break;
                }
                continue;
              } else {
                if (comparePivot(great, pivot1X, pivot1Y, data)) {
                  rotate(k, less, great, data);
                  ++less;
                  --great;
                } else {
                  swap(k, great, data);
                  --great;
                }
                break;
              }
            }
          }
        }
      }
      shufflePivot(left, less - 1, pivot1X, pivot1Y, data);
      shufflePivot(right, great + 1, pivot2X, pivot2Y, data);
      if (less - 2 - left <= INSERT_SORT_CUTOFF) {
        insertionSort(left, less - 2, data);
      } else {
        quickSort(left, less - 2, data);
      }
      if (right - (great + 2) <= INSERT_SORT_CUTOFF) {
        insertionSort(great + 2, right, data);
      } else {
        quickSort(great + 2, right, data);
      }
      if (great - less <= INSERT_SORT_CUTOFF) {
        insertionSort(less, great, data);
      } else {
        quickSort(less, great, data);
      }
    }
  }
});

// ../../node_modules/box-intersect/lib/sweep.js
var require_sweep = __commonJS({
  "../../node_modules/box-intersect/lib/sweep.js"(exports, module) {
    "use strict";
    module.exports = {
      init: sqInit,
      sweepBipartite,
      sweepComplete,
      scanBipartite,
      scanComplete
    };
    var pool = require_pool();
    var bits = require_twiddle();
    var isort = require_sort();
    var BLUE_FLAG = 1 << 28;
    var INIT_CAPACITY = 1024;
    var RED_SWEEP_QUEUE = pool.mallocInt32(INIT_CAPACITY);
    var RED_SWEEP_INDEX = pool.mallocInt32(INIT_CAPACITY);
    var BLUE_SWEEP_QUEUE = pool.mallocInt32(INIT_CAPACITY);
    var BLUE_SWEEP_INDEX = pool.mallocInt32(INIT_CAPACITY);
    var COMMON_SWEEP_QUEUE = pool.mallocInt32(INIT_CAPACITY);
    var COMMON_SWEEP_INDEX = pool.mallocInt32(INIT_CAPACITY);
    var SWEEP_EVENTS = pool.mallocDouble(INIT_CAPACITY * 8);
    function sqInit(count) {
      var rcount = bits.nextPow2(count);
      if (RED_SWEEP_QUEUE.length < rcount) {
        pool.free(RED_SWEEP_QUEUE);
        RED_SWEEP_QUEUE = pool.mallocInt32(rcount);
      }
      if (RED_SWEEP_INDEX.length < rcount) {
        pool.free(RED_SWEEP_INDEX);
        RED_SWEEP_INDEX = pool.mallocInt32(rcount);
      }
      if (BLUE_SWEEP_QUEUE.length < rcount) {
        pool.free(BLUE_SWEEP_QUEUE);
        BLUE_SWEEP_QUEUE = pool.mallocInt32(rcount);
      }
      if (BLUE_SWEEP_INDEX.length < rcount) {
        pool.free(BLUE_SWEEP_INDEX);
        BLUE_SWEEP_INDEX = pool.mallocInt32(rcount);
      }
      if (COMMON_SWEEP_QUEUE.length < rcount) {
        pool.free(COMMON_SWEEP_QUEUE);
        COMMON_SWEEP_QUEUE = pool.mallocInt32(rcount);
      }
      if (COMMON_SWEEP_INDEX.length < rcount) {
        pool.free(COMMON_SWEEP_INDEX);
        COMMON_SWEEP_INDEX = pool.mallocInt32(rcount);
      }
      var eventLength = 8 * rcount;
      if (SWEEP_EVENTS.length < eventLength) {
        pool.free(SWEEP_EVENTS);
        SWEEP_EVENTS = pool.mallocDouble(eventLength);
      }
    }
    function sqPop(queue, index, count, item) {
      var idx = index[item];
      var top = queue[count - 1];
      queue[idx] = top;
      index[top] = idx;
    }
    function sqPush(queue, index, count, item) {
      queue[count] = item;
      index[item] = count;
    }
    function sweepBipartite(d, visit, redStart, redEnd, red, redIndex, blueStart, blueEnd, blue, blueIndex) {
      var ptr = 0;
      var elemSize = 2 * d;
      var istart = d - 1;
      var iend = elemSize - 1;
      for (var i = redStart; i < redEnd; ++i) {
        var idx = redIndex[i];
        var redOffset = elemSize * i;
        SWEEP_EVENTS[ptr++] = red[redOffset + istart];
        SWEEP_EVENTS[ptr++] = -(idx + 1);
        SWEEP_EVENTS[ptr++] = red[redOffset + iend];
        SWEEP_EVENTS[ptr++] = idx;
      }
      for (var i = blueStart; i < blueEnd; ++i) {
        var idx = blueIndex[i] + BLUE_FLAG;
        var blueOffset = elemSize * i;
        SWEEP_EVENTS[ptr++] = blue[blueOffset + istart];
        SWEEP_EVENTS[ptr++] = -idx;
        SWEEP_EVENTS[ptr++] = blue[blueOffset + iend];
        SWEEP_EVENTS[ptr++] = idx;
      }
      var n = ptr >>> 1;
      isort(SWEEP_EVENTS, n);
      var redActive = 0;
      var blueActive = 0;
      for (var i = 0; i < n; ++i) {
        var e = SWEEP_EVENTS[2 * i + 1] | 0;
        if (e >= BLUE_FLAG) {
          e = e - BLUE_FLAG | 0;
          sqPop(BLUE_SWEEP_QUEUE, BLUE_SWEEP_INDEX, blueActive--, e);
        } else if (e >= 0) {
          sqPop(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive--, e);
        } else if (e <= -BLUE_FLAG) {
          e = -e - BLUE_FLAG | 0;
          for (var j = 0; j < redActive; ++j) {
            var retval = visit(RED_SWEEP_QUEUE[j], e);
            if (retval !== void 0) {
              return retval;
            }
          }
          sqPush(BLUE_SWEEP_QUEUE, BLUE_SWEEP_INDEX, blueActive++, e);
        } else {
          e = -e - 1 | 0;
          for (var j = 0; j < blueActive; ++j) {
            var retval = visit(e, BLUE_SWEEP_QUEUE[j]);
            if (retval !== void 0) {
              return retval;
            }
          }
          sqPush(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive++, e);
        }
      }
    }
    function sweepComplete(d, visit, redStart, redEnd, red, redIndex, blueStart, blueEnd, blue, blueIndex) {
      var ptr = 0;
      var elemSize = 2 * d;
      var istart = d - 1;
      var iend = elemSize - 1;
      for (var i = redStart; i < redEnd; ++i) {
        var idx = redIndex[i] + 1 << 1;
        var redOffset = elemSize * i;
        SWEEP_EVENTS[ptr++] = red[redOffset + istart];
        SWEEP_EVENTS[ptr++] = -idx;
        SWEEP_EVENTS[ptr++] = red[redOffset + iend];
        SWEEP_EVENTS[ptr++] = idx;
      }
      for (var i = blueStart; i < blueEnd; ++i) {
        var idx = blueIndex[i] + 1 << 1;
        var blueOffset = elemSize * i;
        SWEEP_EVENTS[ptr++] = blue[blueOffset + istart];
        SWEEP_EVENTS[ptr++] = -idx | 1;
        SWEEP_EVENTS[ptr++] = blue[blueOffset + iend];
        SWEEP_EVENTS[ptr++] = idx | 1;
      }
      var n = ptr >>> 1;
      isort(SWEEP_EVENTS, n);
      var redActive = 0;
      var blueActive = 0;
      var commonActive = 0;
      for (var i = 0; i < n; ++i) {
        var e = SWEEP_EVENTS[2 * i + 1] | 0;
        var color = e & 1;
        if (i < n - 1 && e >> 1 === SWEEP_EVENTS[2 * i + 3] >> 1) {
          color = 2;
          i += 1;
        }
        if (e < 0) {
          var id = -(e >> 1) - 1;
          for (var j = 0; j < commonActive; ++j) {
            var retval = visit(COMMON_SWEEP_QUEUE[j], id);
            if (retval !== void 0) {
              return retval;
            }
          }
          if (color !== 0) {
            for (var j = 0; j < redActive; ++j) {
              var retval = visit(RED_SWEEP_QUEUE[j], id);
              if (retval !== void 0) {
                return retval;
              }
            }
          }
          if (color !== 1) {
            for (var j = 0; j < blueActive; ++j) {
              var retval = visit(BLUE_SWEEP_QUEUE[j], id);
              if (retval !== void 0) {
                return retval;
              }
            }
          }
          if (color === 0) {
            sqPush(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive++, id);
          } else if (color === 1) {
            sqPush(BLUE_SWEEP_QUEUE, BLUE_SWEEP_INDEX, blueActive++, id);
          } else if (color === 2) {
            sqPush(COMMON_SWEEP_QUEUE, COMMON_SWEEP_INDEX, commonActive++, id);
          }
        } else {
          var id = (e >> 1) - 1;
          if (color === 0) {
            sqPop(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive--, id);
          } else if (color === 1) {
            sqPop(BLUE_SWEEP_QUEUE, BLUE_SWEEP_INDEX, blueActive--, id);
          } else if (color === 2) {
            sqPop(COMMON_SWEEP_QUEUE, COMMON_SWEEP_INDEX, commonActive--, id);
          }
        }
      }
    }
    function scanBipartite(d, axis, visit, flip, redStart, redEnd, red, redIndex, blueStart, blueEnd, blue, blueIndex) {
      var ptr = 0;
      var elemSize = 2 * d;
      var istart = axis;
      var iend = axis + d;
      var redShift = 1;
      var blueShift = 1;
      if (flip) {
        blueShift = BLUE_FLAG;
      } else {
        redShift = BLUE_FLAG;
      }
      for (var i = redStart; i < redEnd; ++i) {
        var idx = i + redShift;
        var redOffset = elemSize * i;
        SWEEP_EVENTS[ptr++] = red[redOffset + istart];
        SWEEP_EVENTS[ptr++] = -idx;
        SWEEP_EVENTS[ptr++] = red[redOffset + iend];
        SWEEP_EVENTS[ptr++] = idx;
      }
      for (var i = blueStart; i < blueEnd; ++i) {
        var idx = i + blueShift;
        var blueOffset = elemSize * i;
        SWEEP_EVENTS[ptr++] = blue[blueOffset + istart];
        SWEEP_EVENTS[ptr++] = -idx;
      }
      var n = ptr >>> 1;
      isort(SWEEP_EVENTS, n);
      var redActive = 0;
      for (var i = 0; i < n; ++i) {
        var e = SWEEP_EVENTS[2 * i + 1] | 0;
        if (e < 0) {
          var idx = -e;
          var isRed = false;
          if (idx >= BLUE_FLAG) {
            isRed = !flip;
            idx -= BLUE_FLAG;
          } else {
            isRed = !!flip;
            idx -= 1;
          }
          if (isRed) {
            sqPush(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive++, idx);
          } else {
            var blueId = blueIndex[idx];
            var bluePtr = elemSize * idx;
            var b0 = blue[bluePtr + axis + 1];
            var b1 = blue[bluePtr + axis + 1 + d];
            red_loop:
              for (var j = 0; j < redActive; ++j) {
                var oidx = RED_SWEEP_QUEUE[j];
                var redPtr = elemSize * oidx;
                if (b1 < red[redPtr + axis + 1] || red[redPtr + axis + 1 + d] < b0) {
                  continue;
                }
                for (var k = axis + 2; k < d; ++k) {
                  if (blue[bluePtr + k + d] < red[redPtr + k] || red[redPtr + k + d] < blue[bluePtr + k]) {
                    continue red_loop;
                  }
                }
                var redId = redIndex[oidx];
                var retval;
                if (flip) {
                  retval = visit(blueId, redId);
                } else {
                  retval = visit(redId, blueId);
                }
                if (retval !== void 0) {
                  return retval;
                }
              }
          }
        } else {
          sqPop(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive--, e - redShift);
        }
      }
    }
    function scanComplete(d, axis, visit, redStart, redEnd, red, redIndex, blueStart, blueEnd, blue, blueIndex) {
      var ptr = 0;
      var elemSize = 2 * d;
      var istart = axis;
      var iend = axis + d;
      for (var i = redStart; i < redEnd; ++i) {
        var idx = i + BLUE_FLAG;
        var redOffset = elemSize * i;
        SWEEP_EVENTS[ptr++] = red[redOffset + istart];
        SWEEP_EVENTS[ptr++] = -idx;
        SWEEP_EVENTS[ptr++] = red[redOffset + iend];
        SWEEP_EVENTS[ptr++] = idx;
      }
      for (var i = blueStart; i < blueEnd; ++i) {
        var idx = i + 1;
        var blueOffset = elemSize * i;
        SWEEP_EVENTS[ptr++] = blue[blueOffset + istart];
        SWEEP_EVENTS[ptr++] = -idx;
      }
      var n = ptr >>> 1;
      isort(SWEEP_EVENTS, n);
      var redActive = 0;
      for (var i = 0; i < n; ++i) {
        var e = SWEEP_EVENTS[2 * i + 1] | 0;
        if (e < 0) {
          var idx = -e;
          if (idx >= BLUE_FLAG) {
            RED_SWEEP_QUEUE[redActive++] = idx - BLUE_FLAG;
          } else {
            idx -= 1;
            var blueId = blueIndex[idx];
            var bluePtr = elemSize * idx;
            var b0 = blue[bluePtr + axis + 1];
            var b1 = blue[bluePtr + axis + 1 + d];
            red_loop:
              for (var j = 0; j < redActive; ++j) {
                var oidx = RED_SWEEP_QUEUE[j];
                var redId = redIndex[oidx];
                if (redId === blueId) {
                  break;
                }
                var redPtr = elemSize * oidx;
                if (b1 < red[redPtr + axis + 1] || red[redPtr + axis + 1 + d] < b0) {
                  continue;
                }
                for (var k = axis + 2; k < d; ++k) {
                  if (blue[bluePtr + k + d] < red[redPtr + k] || red[redPtr + k + d] < blue[bluePtr + k]) {
                    continue red_loop;
                  }
                }
                var retval = visit(redId, blueId);
                if (retval !== void 0) {
                  return retval;
                }
              }
          }
        } else {
          var idx = e - BLUE_FLAG;
          for (var j = redActive - 1; j >= 0; --j) {
            if (RED_SWEEP_QUEUE[j] === idx) {
              for (var k = j + 1; k < redActive; ++k) {
                RED_SWEEP_QUEUE[k - 1] = RED_SWEEP_QUEUE[k];
              }
              break;
            }
          }
          --redActive;
        }
      }
    }
  }
});

// ../../node_modules/box-intersect/lib/brute.js
var require_brute = __commonJS({
  "../../node_modules/box-intersect/lib/brute.js"(exports) {
    "use strict";
    var DIMENSION = "d";
    var AXIS = "ax";
    var VISIT = "vv";
    var FLIP = "fp";
    var ELEM_SIZE = "es";
    var RED_START = "rs";
    var RED_END = "re";
    var RED_BOXES = "rb";
    var RED_INDEX = "ri";
    var RED_PTR = "rp";
    var BLUE_START = "bs";
    var BLUE_END = "be";
    var BLUE_BOXES = "bb";
    var BLUE_INDEX = "bi";
    var BLUE_PTR = "bp";
    var RETVAL = "rv";
    var INNER_LABEL = "Q";
    var ARGS = [
      DIMENSION,
      AXIS,
      VISIT,
      RED_START,
      RED_END,
      RED_BOXES,
      RED_INDEX,
      BLUE_START,
      BLUE_END,
      BLUE_BOXES,
      BLUE_INDEX
    ];
    function generateBruteForce(redMajor, flip, full) {
      var funcName = "bruteForce" + (redMajor ? "Red" : "Blue") + (flip ? "Flip" : "") + (full ? "Full" : "");
      var code = [
        "function ",
        funcName,
        "(",
        ARGS.join(),
        "){",
        "var ",
        ELEM_SIZE,
        "=2*",
        DIMENSION,
        ";"
      ];
      var redLoop = "for(var i=" + RED_START + "," + RED_PTR + "=" + ELEM_SIZE + "*" + RED_START + ";i<" + RED_END + ";++i," + RED_PTR + "+=" + ELEM_SIZE + "){var x0=" + RED_BOXES + "[" + AXIS + "+" + RED_PTR + "],x1=" + RED_BOXES + "[" + AXIS + "+" + RED_PTR + "+" + DIMENSION + "],xi=" + RED_INDEX + "[i];";
      var blueLoop = "for(var j=" + BLUE_START + "," + BLUE_PTR + "=" + ELEM_SIZE + "*" + BLUE_START + ";j<" + BLUE_END + ";++j," + BLUE_PTR + "+=" + ELEM_SIZE + "){var y0=" + BLUE_BOXES + "[" + AXIS + "+" + BLUE_PTR + "]," + (full ? "y1=" + BLUE_BOXES + "[" + AXIS + "+" + BLUE_PTR + "+" + DIMENSION + "]," : "") + "yi=" + BLUE_INDEX + "[j];";
      if (redMajor) {
        code.push(redLoop, INNER_LABEL, ":", blueLoop);
      } else {
        code.push(blueLoop, INNER_LABEL, ":", redLoop);
      }
      if (full) {
        code.push("if(y1<x0||x1<y0)continue;");
      } else if (flip) {
        code.push("if(y0<=x0||x1<y0)continue;");
      } else {
        code.push("if(y0<x0||x1<y0)continue;");
      }
      code.push("for(var k=" + AXIS + "+1;k<" + DIMENSION + ";++k){var r0=" + RED_BOXES + "[k+" + RED_PTR + "],r1=" + RED_BOXES + "[k+" + DIMENSION + "+" + RED_PTR + "],b0=" + BLUE_BOXES + "[k+" + BLUE_PTR + "],b1=" + BLUE_BOXES + "[k+" + DIMENSION + "+" + BLUE_PTR + "];if(r1<b0||b1<r0)continue " + INNER_LABEL + ";}var " + RETVAL + "=" + VISIT + "(");
      if (flip) {
        code.push("yi,xi");
      } else {
        code.push("xi,yi");
      }
      code.push(");if(" + RETVAL + "!==void 0)return " + RETVAL + ";}}}");
      return {
        name: funcName,
        code: code.join("")
      };
    }
    function bruteForcePlanner(full) {
      var funcName = "bruteForce" + (full ? "Full" : "Partial");
      var prefix = [];
      var fargs = ARGS.slice();
      if (!full) {
        fargs.splice(3, 0, FLIP);
      }
      var code = ["function " + funcName + "(" + fargs.join() + "){"];
      function invoke(redMajor, flip) {
        var res = generateBruteForce(redMajor, flip, full);
        prefix.push(res.code);
        code.push("return " + res.name + "(" + ARGS.join() + ");");
      }
      code.push("if(" + RED_END + "-" + RED_START + ">" + BLUE_END + "-" + BLUE_START + "){");
      if (full) {
        invoke(true, false);
        code.push("}else{");
        invoke(false, false);
      } else {
        code.push("if(" + FLIP + "){");
        invoke(true, true);
        code.push("}else{");
        invoke(true, false);
        code.push("}}else{if(" + FLIP + "){");
        invoke(false, true);
        code.push("}else{");
        invoke(false, false);
        code.push("}");
      }
      code.push("}}return " + funcName);
      var codeStr = prefix.join("") + code.join("");
      var proc = new Function(codeStr);
      return proc();
    }
    exports.partial = bruteForcePlanner(false);
    exports.full = bruteForcePlanner(true);
  }
});

// ../../node_modules/box-intersect/lib/partition.js
var require_partition = __commonJS({
  "../../node_modules/box-intersect/lib/partition.js"(exports, module) {
    "use strict";
    module.exports = genPartition;
    var code = "for(var j=2*a,k=j*c,l=k,m=c,n=b,o=a+b,p=c;d>p;++p,k+=j){var _;if($)if(m===p)m+=1,l+=j;else{for(var s=0;j>s;++s){var t=e[k+s];e[k+s]=e[l],e[l++]=t}var u=f[p];f[p]=f[m],f[m++]=u}}return m";
    function genPartition(predicate, args) {
      var fargs = "abcdef".split("").concat(args);
      var reads = [];
      if (predicate.indexOf("lo") >= 0) {
        reads.push("lo=e[k+n]");
      }
      if (predicate.indexOf("hi") >= 0) {
        reads.push("hi=e[k+o]");
      }
      fargs.push(
        code.replace("_", reads.join()).replace("$", predicate)
      );
      return Function.apply(void 0, fargs);
    }
  }
});

// ../../node_modules/box-intersect/lib/median.js
var require_median = __commonJS({
  "../../node_modules/box-intersect/lib/median.js"(exports, module) {
    "use strict";
    module.exports = findMedian;
    var genPartition = require_partition();
    var partitionStartLessThan = genPartition("lo<p0", ["p0"]);
    var PARTITION_THRESHOLD = 8;
    function insertionSort(d, axis, start, end, boxes, ids) {
      var elemSize = 2 * d;
      var boxPtr = elemSize * (start + 1) + axis;
      for (var i = start + 1; i < end; ++i, boxPtr += elemSize) {
        var x = boxes[boxPtr];
        for (var j = i, ptr = elemSize * (i - 1); j > start && boxes[ptr + axis] > x; --j, ptr -= elemSize) {
          var aPtr = ptr;
          var bPtr = ptr + elemSize;
          for (var k = 0; k < elemSize; ++k, ++aPtr, ++bPtr) {
            var y = boxes[aPtr];
            boxes[aPtr] = boxes[bPtr];
            boxes[bPtr] = y;
          }
          var tmp = ids[j];
          ids[j] = ids[j - 1];
          ids[j - 1] = tmp;
        }
      }
    }
    function findMedian(d, axis, start, end, boxes, ids) {
      if (end <= start + 1) {
        return start;
      }
      var lo = start;
      var hi = end;
      var mid = end + start >>> 1;
      var elemSize = 2 * d;
      var pivot = mid;
      var value = boxes[elemSize * mid + axis];
      while (lo < hi) {
        if (hi - lo < PARTITION_THRESHOLD) {
          insertionSort(d, axis, lo, hi, boxes, ids);
          value = boxes[elemSize * mid + axis];
          break;
        }
        var count = hi - lo;
        var pivot0 = Math.random() * count + lo | 0;
        var value0 = boxes[elemSize * pivot0 + axis];
        var pivot1 = Math.random() * count + lo | 0;
        var value1 = boxes[elemSize * pivot1 + axis];
        var pivot2 = Math.random() * count + lo | 0;
        var value2 = boxes[elemSize * pivot2 + axis];
        if (value0 <= value1) {
          if (value2 >= value1) {
            pivot = pivot1;
            value = value1;
          } else if (value0 >= value2) {
            pivot = pivot0;
            value = value0;
          } else {
            pivot = pivot2;
            value = value2;
          }
        } else {
          if (value1 >= value2) {
            pivot = pivot1;
            value = value1;
          } else if (value2 >= value0) {
            pivot = pivot0;
            value = value0;
          } else {
            pivot = pivot2;
            value = value2;
          }
        }
        var aPtr = elemSize * (hi - 1);
        var bPtr = elemSize * pivot;
        for (var i = 0; i < elemSize; ++i, ++aPtr, ++bPtr) {
          var x = boxes[aPtr];
          boxes[aPtr] = boxes[bPtr];
          boxes[bPtr] = x;
        }
        var y = ids[hi - 1];
        ids[hi - 1] = ids[pivot];
        ids[pivot] = y;
        pivot = partitionStartLessThan(
          d,
          axis,
          lo,
          hi - 1,
          boxes,
          ids,
          value
        );
        var aPtr = elemSize * (hi - 1);
        var bPtr = elemSize * pivot;
        for (var i = 0; i < elemSize; ++i, ++aPtr, ++bPtr) {
          var x = boxes[aPtr];
          boxes[aPtr] = boxes[bPtr];
          boxes[bPtr] = x;
        }
        var y = ids[hi - 1];
        ids[hi - 1] = ids[pivot];
        ids[pivot] = y;
        if (mid < pivot) {
          hi = pivot - 1;
          while (lo < hi && boxes[elemSize * (hi - 1) + axis] === value) {
            hi -= 1;
          }
          hi += 1;
        } else if (pivot < mid) {
          lo = pivot + 1;
          while (lo < hi && boxes[elemSize * lo + axis] === value) {
            lo += 1;
          }
        } else {
          break;
        }
      }
      return partitionStartLessThan(
        d,
        axis,
        start,
        mid,
        boxes,
        ids,
        boxes[elemSize * mid + axis]
      );
    }
  }
});

// ../../node_modules/box-intersect/lib/intersect.js
var require_intersect = __commonJS({
  "../../node_modules/box-intersect/lib/intersect.js"(exports, module) {
    "use strict";
    module.exports = boxIntersectIter;
    var pool = require_pool();
    var bits = require_twiddle();
    var bruteForce = require_brute();
    var bruteForcePartial = bruteForce.partial;
    var bruteForceFull = bruteForce.full;
    var sweep3 = require_sweep();
    var findMedian = require_median();
    var genPartition = require_partition();
    var BRUTE_FORCE_CUTOFF = 128;
    var SCAN_CUTOFF = 1 << 22;
    var SCAN_COMPLETE_CUTOFF = 1 << 22;
    var partitionInteriorContainsInterval = genPartition(
      "!(lo>=p0)&&!(p1>=hi)",
      ["p0", "p1"]
    );
    var partitionStartEqual = genPartition(
      "lo===p0",
      ["p0"]
    );
    var partitionStartLessThan = genPartition(
      "lo<p0",
      ["p0"]
    );
    var partitionEndLessThanEqual = genPartition(
      "hi<=p0",
      ["p0"]
    );
    var partitionContainsPoint = genPartition(
      "lo<=p0&&p0<=hi",
      ["p0"]
    );
    var partitionContainsPointProper = genPartition(
      "lo<p0&&p0<=hi",
      ["p0"]
    );
    var IFRAME_SIZE = 6;
    var DFRAME_SIZE = 2;
    var INIT_CAPACITY = 1024;
    var BOX_ISTACK = pool.mallocInt32(INIT_CAPACITY);
    var BOX_DSTACK = pool.mallocDouble(INIT_CAPACITY);
    function iterInit(d, count) {
      var levels = 8 * bits.log2(count + 1) * (d + 1) | 0;
      var maxInts = bits.nextPow2(IFRAME_SIZE * levels);
      if (BOX_ISTACK.length < maxInts) {
        pool.free(BOX_ISTACK);
        BOX_ISTACK = pool.mallocInt32(maxInts);
      }
      var maxDoubles = bits.nextPow2(DFRAME_SIZE * levels);
      if (BOX_DSTACK.length < maxDoubles) {
        pool.free(BOX_DSTACK);
        BOX_DSTACK = pool.mallocDouble(maxDoubles);
      }
    }
    function iterPush(ptr, axis, redStart, redEnd, blueStart, blueEnd, state, lo, hi) {
      var iptr = IFRAME_SIZE * ptr;
      BOX_ISTACK[iptr] = axis;
      BOX_ISTACK[iptr + 1] = redStart;
      BOX_ISTACK[iptr + 2] = redEnd;
      BOX_ISTACK[iptr + 3] = blueStart;
      BOX_ISTACK[iptr + 4] = blueEnd;
      BOX_ISTACK[iptr + 5] = state;
      var dptr = DFRAME_SIZE * ptr;
      BOX_DSTACK[dptr] = lo;
      BOX_DSTACK[dptr + 1] = hi;
    }
    function onePointPartial(d, axis, visit, flip, redStart, redEnd, red, redIndex, blueOffset, blue, blueId) {
      var elemSize = 2 * d;
      var bluePtr = blueOffset * elemSize;
      var blueX = blue[bluePtr + axis];
      red_loop:
        for (var i = redStart, redPtr = redStart * elemSize; i < redEnd; ++i, redPtr += elemSize) {
          var r0 = red[redPtr + axis];
          var r1 = red[redPtr + axis + d];
          if (blueX < r0 || r1 < blueX) {
            continue;
          }
          if (flip && blueX === r0) {
            continue;
          }
          var redId = redIndex[i];
          for (var j = axis + 1; j < d; ++j) {
            var r0 = red[redPtr + j];
            var r1 = red[redPtr + j + d];
            var b0 = blue[bluePtr + j];
            var b1 = blue[bluePtr + j + d];
            if (r1 < b0 || b1 < r0) {
              continue red_loop;
            }
          }
          var retval;
          if (flip) {
            retval = visit(blueId, redId);
          } else {
            retval = visit(redId, blueId);
          }
          if (retval !== void 0) {
            return retval;
          }
        }
    }
    function onePointFull(d, axis, visit, redStart, redEnd, red, redIndex, blueOffset, blue, blueId) {
      var elemSize = 2 * d;
      var bluePtr = blueOffset * elemSize;
      var blueX = blue[bluePtr + axis];
      red_loop:
        for (var i = redStart, redPtr = redStart * elemSize; i < redEnd; ++i, redPtr += elemSize) {
          var redId = redIndex[i];
          if (redId === blueId) {
            continue;
          }
          var r0 = red[redPtr + axis];
          var r1 = red[redPtr + axis + d];
          if (blueX < r0 || r1 < blueX) {
            continue;
          }
          for (var j = axis + 1; j < d; ++j) {
            var r0 = red[redPtr + j];
            var r1 = red[redPtr + j + d];
            var b0 = blue[bluePtr + j];
            var b1 = blue[bluePtr + j + d];
            if (r1 < b0 || b1 < r0) {
              continue red_loop;
            }
          }
          var retval = visit(redId, blueId);
          if (retval !== void 0) {
            return retval;
          }
        }
    }
    function boxIntersectIter(d, visit, initFull, xSize, xBoxes, xIndex, ySize, yBoxes, yIndex) {
      iterInit(d, xSize + ySize);
      var top = 0;
      var elemSize = 2 * d;
      var retval;
      iterPush(
        top++,
        0,
        0,
        xSize,
        0,
        ySize,
        initFull ? 16 : 0,
        -Infinity,
        Infinity
      );
      if (!initFull) {
        iterPush(
          top++,
          0,
          0,
          ySize,
          0,
          xSize,
          1,
          -Infinity,
          Infinity
        );
      }
      while (top > 0) {
        top -= 1;
        var iptr = top * IFRAME_SIZE;
        var axis = BOX_ISTACK[iptr];
        var redStart = BOX_ISTACK[iptr + 1];
        var redEnd = BOX_ISTACK[iptr + 2];
        var blueStart = BOX_ISTACK[iptr + 3];
        var blueEnd = BOX_ISTACK[iptr + 4];
        var state = BOX_ISTACK[iptr + 5];
        var dptr = top * DFRAME_SIZE;
        var lo = BOX_DSTACK[dptr];
        var hi = BOX_DSTACK[dptr + 1];
        var flip = state & 1;
        var full = !!(state & 16);
        var red = xBoxes;
        var redIndex = xIndex;
        var blue = yBoxes;
        var blueIndex = yIndex;
        if (flip) {
          red = yBoxes;
          redIndex = yIndex;
          blue = xBoxes;
          blueIndex = xIndex;
        }
        if (state & 2) {
          redEnd = partitionStartLessThan(
            d,
            axis,
            redStart,
            redEnd,
            red,
            redIndex,
            hi
          );
          if (redStart >= redEnd) {
            continue;
          }
        }
        if (state & 4) {
          redStart = partitionEndLessThanEqual(
            d,
            axis,
            redStart,
            redEnd,
            red,
            redIndex,
            lo
          );
          if (redStart >= redEnd) {
            continue;
          }
        }
        var redCount = redEnd - redStart;
        var blueCount = blueEnd - blueStart;
        if (full) {
          if (d * redCount * (redCount + blueCount) < SCAN_COMPLETE_CUTOFF) {
            retval = sweep3.scanComplete(
              d,
              axis,
              visit,
              redStart,
              redEnd,
              red,
              redIndex,
              blueStart,
              blueEnd,
              blue,
              blueIndex
            );
            if (retval !== void 0) {
              return retval;
            }
            continue;
          }
        } else {
          if (d * Math.min(redCount, blueCount) < BRUTE_FORCE_CUTOFF) {
            retval = bruteForcePartial(
              d,
              axis,
              visit,
              flip,
              redStart,
              redEnd,
              red,
              redIndex,
              blueStart,
              blueEnd,
              blue,
              blueIndex
            );
            if (retval !== void 0) {
              return retval;
            }
            continue;
          } else if (d * redCount * blueCount < SCAN_CUTOFF) {
            retval = sweep3.scanBipartite(
              d,
              axis,
              visit,
              flip,
              redStart,
              redEnd,
              red,
              redIndex,
              blueStart,
              blueEnd,
              blue,
              blueIndex
            );
            if (retval !== void 0) {
              return retval;
            }
            continue;
          }
        }
        var red0 = partitionInteriorContainsInterval(
          d,
          axis,
          redStart,
          redEnd,
          red,
          redIndex,
          lo,
          hi
        );
        if (redStart < red0) {
          if (d * (red0 - redStart) < BRUTE_FORCE_CUTOFF) {
            retval = bruteForceFull(
              d,
              axis + 1,
              visit,
              redStart,
              red0,
              red,
              redIndex,
              blueStart,
              blueEnd,
              blue,
              blueIndex
            );
            if (retval !== void 0) {
              return retval;
            }
          } else if (axis === d - 2) {
            if (flip) {
              retval = sweep3.sweepBipartite(
                d,
                visit,
                blueStart,
                blueEnd,
                blue,
                blueIndex,
                redStart,
                red0,
                red,
                redIndex
              );
            } else {
              retval = sweep3.sweepBipartite(
                d,
                visit,
                redStart,
                red0,
                red,
                redIndex,
                blueStart,
                blueEnd,
                blue,
                blueIndex
              );
            }
            if (retval !== void 0) {
              return retval;
            }
          } else {
            iterPush(
              top++,
              axis + 1,
              redStart,
              red0,
              blueStart,
              blueEnd,
              flip,
              -Infinity,
              Infinity
            );
            iterPush(
              top++,
              axis + 1,
              blueStart,
              blueEnd,
              redStart,
              red0,
              flip ^ 1,
              -Infinity,
              Infinity
            );
          }
        }
        if (red0 < redEnd) {
          var blue0 = findMedian(
            d,
            axis,
            blueStart,
            blueEnd,
            blue,
            blueIndex
          );
          var mid = blue[elemSize * blue0 + axis];
          var blue1 = partitionStartEqual(
            d,
            axis,
            blue0,
            blueEnd,
            blue,
            blueIndex,
            mid
          );
          if (blue1 < blueEnd) {
            iterPush(
              top++,
              axis,
              red0,
              redEnd,
              blue1,
              blueEnd,
              (flip | 4) + (full ? 16 : 0),
              mid,
              hi
            );
          }
          if (blueStart < blue0) {
            iterPush(
              top++,
              axis,
              red0,
              redEnd,
              blueStart,
              blue0,
              (flip | 2) + (full ? 16 : 0),
              lo,
              mid
            );
          }
          if (blue0 + 1 === blue1) {
            if (full) {
              retval = onePointFull(
                d,
                axis,
                visit,
                red0,
                redEnd,
                red,
                redIndex,
                blue0,
                blue,
                blueIndex[blue0]
              );
            } else {
              retval = onePointPartial(
                d,
                axis,
                visit,
                flip,
                red0,
                redEnd,
                red,
                redIndex,
                blue0,
                blue,
                blueIndex[blue0]
              );
            }
            if (retval !== void 0) {
              return retval;
            }
          } else if (blue0 < blue1) {
            var red1;
            if (full) {
              red1 = partitionContainsPoint(
                d,
                axis,
                red0,
                redEnd,
                red,
                redIndex,
                mid
              );
              if (red0 < red1) {
                var redX = partitionStartEqual(
                  d,
                  axis,
                  red0,
                  red1,
                  red,
                  redIndex,
                  mid
                );
                if (axis === d - 2) {
                  if (red0 < redX) {
                    retval = sweep3.sweepComplete(
                      d,
                      visit,
                      red0,
                      redX,
                      red,
                      redIndex,
                      blue0,
                      blue1,
                      blue,
                      blueIndex
                    );
                    if (retval !== void 0) {
                      return retval;
                    }
                  }
                  if (redX < red1) {
                    retval = sweep3.sweepBipartite(
                      d,
                      visit,
                      redX,
                      red1,
                      red,
                      redIndex,
                      blue0,
                      blue1,
                      blue,
                      blueIndex
                    );
                    if (retval !== void 0) {
                      return retval;
                    }
                  }
                } else {
                  if (red0 < redX) {
                    iterPush(
                      top++,
                      axis + 1,
                      red0,
                      redX,
                      blue0,
                      blue1,
                      16,
                      -Infinity,
                      Infinity
                    );
                  }
                  if (redX < red1) {
                    iterPush(
                      top++,
                      axis + 1,
                      redX,
                      red1,
                      blue0,
                      blue1,
                      0,
                      -Infinity,
                      Infinity
                    );
                    iterPush(
                      top++,
                      axis + 1,
                      blue0,
                      blue1,
                      redX,
                      red1,
                      1,
                      -Infinity,
                      Infinity
                    );
                  }
                }
              }
            } else {
              if (flip) {
                red1 = partitionContainsPointProper(
                  d,
                  axis,
                  red0,
                  redEnd,
                  red,
                  redIndex,
                  mid
                );
              } else {
                red1 = partitionContainsPoint(
                  d,
                  axis,
                  red0,
                  redEnd,
                  red,
                  redIndex,
                  mid
                );
              }
              if (red0 < red1) {
                if (axis === d - 2) {
                  if (flip) {
                    retval = sweep3.sweepBipartite(
                      d,
                      visit,
                      blue0,
                      blue1,
                      blue,
                      blueIndex,
                      red0,
                      red1,
                      red,
                      redIndex
                    );
                  } else {
                    retval = sweep3.sweepBipartite(
                      d,
                      visit,
                      red0,
                      red1,
                      red,
                      redIndex,
                      blue0,
                      blue1,
                      blue,
                      blueIndex
                    );
                  }
                } else {
                  iterPush(
                    top++,
                    axis + 1,
                    red0,
                    red1,
                    blue0,
                    blue1,
                    flip,
                    -Infinity,
                    Infinity
                  );
                  iterPush(
                    top++,
                    axis + 1,
                    blue0,
                    blue1,
                    red0,
                    red1,
                    flip ^ 1,
                    -Infinity,
                    Infinity
                  );
                }
              }
            }
          }
        }
      }
    }
  }
});

// ../../node_modules/box-intersect/index.js
var require_box_intersect = __commonJS({
  "../../node_modules/box-intersect/index.js"(exports, module) {
    "use strict";
    module.exports = boxIntersectWrapper;
    var pool = require_pool();
    var sweep3 = require_sweep();
    var boxIntersectIter = require_intersect();
    function boxEmpty(d, box) {
      for (var j = 0; j < d; ++j) {
        if (!(box[j] <= box[j + d])) {
          return true;
        }
      }
      return false;
    }
    function convertBoxes(boxes, d, data, ids) {
      var ptr = 0;
      var count = 0;
      for (var i = 0, n = boxes.length; i < n; ++i) {
        var b = boxes[i];
        if (boxEmpty(d, b)) {
          continue;
        }
        for (var j = 0; j < 2 * d; ++j) {
          data[ptr++] = b[j];
        }
        ids[count++] = i;
      }
      return count;
    }
    function boxIntersect2(red, blue, visit, full) {
      var n = red.length;
      var m = blue.length;
      if (n <= 0 || m <= 0) {
        return;
      }
      var d = red[0].length >>> 1;
      if (d <= 0) {
        return;
      }
      var retval;
      var redList = pool.mallocDouble(2 * d * n);
      var redIds = pool.mallocInt32(n);
      n = convertBoxes(red, d, redList, redIds);
      if (n > 0) {
        if (d === 1 && full) {
          sweep3.init(n);
          retval = sweep3.sweepComplete(
            d,
            visit,
            0,
            n,
            redList,
            redIds,
            0,
            n,
            redList,
            redIds
          );
        } else {
          var blueList = pool.mallocDouble(2 * d * m);
          var blueIds = pool.mallocInt32(m);
          m = convertBoxes(blue, d, blueList, blueIds);
          if (m > 0) {
            sweep3.init(n + m);
            if (d === 1) {
              retval = sweep3.sweepBipartite(
                d,
                visit,
                0,
                n,
                redList,
                redIds,
                0,
                m,
                blueList,
                blueIds
              );
            } else {
              retval = boxIntersectIter(
                d,
                visit,
                full,
                n,
                redList,
                redIds,
                m,
                blueList,
                blueIds
              );
            }
            pool.free(blueList);
            pool.free(blueIds);
          }
        }
        pool.free(redList);
        pool.free(redIds);
      }
      return retval;
    }
    var RESULT;
    function appendItem(i, j) {
      RESULT.push([i, j]);
    }
    function intersectFullArray(x) {
      RESULT = [];
      boxIntersect2(x, x, appendItem, true);
      return RESULT;
    }
    function intersectBipartiteArray(x, y) {
      RESULT = [];
      boxIntersect2(x, y, appendItem, false);
      return RESULT;
    }
    function boxIntersectWrapper(arg0, arg1, arg2) {
      var result;
      switch (arguments.length) {
        case 1:
          return intersectFullArray(arg0);
        case 2:
          if (typeof arg1 === "function") {
            return boxIntersect2(arg0, arg0, arg1, true);
          } else {
            return intersectBipartiteArray(arg0, arg1);
          }
        case 3:
          return boxIntersect2(arg0, arg1, arg2, false);
        default:
          throw new Error("box-intersect: Invalid arguments");
      }
    }
  }
});

// ../../node_modules/noa-engine/src/lib/shims.js
if (window && !window["global"]) {
  window["global"] = window.globalThis || {};
}

// ../../node_modules/noa-engine/src/index.js
var import_events4 = __toESM(require_events());
var import_gl_vec312 = __toESM(require_gl_vec3());
var import_ndarray3 = __toESM(require_ndarray());
var import_fast_voxel_raycast = __toESM(require_fast_voxel_raycast());

// ../../node_modules/game-inputs/src/inputs.js
var import_events = __toESM(require_events());

// ../../node_modules/game-inputs/package.json
var package_default = {
  name: "game-inputs",
  version: "0.8.0",
  description: "Simple library to abstract key/mouse events for games.",
  main: "src/inputs.js",
  typings: "dist/src/inputs.d.ts",
  files: [
    "/src",
    "/dist"
  ],
  scripts: {
    start: "cd docs/ && webpack serve",
    build: "tsc; cd docs/ && webpack"
  },
  author: "Andy Hall",
  license: "ISC",
  keywords: [
    "game",
    "inputs",
    "key",
    "mouse",
    "events"
  ],
  dependencies: {
    events: "^3.3.0"
  },
  repository: {
    type: "git",
    url: "https://github.com/fenomas/game-inputs"
  },
  bugs: {
    url: "https://github.com/fenomas/game-inputs/issues"
  }
};

// ../../node_modules/game-inputs/src/inputs.js
var version = package_default.version;
function DefaultOptions() {
  this.preventDefaults = false;
  this.stopPropagation = false;
  this.allowContextMenu = false;
  this.disabled = false;
}
var GameInputs = class {
  /**
   *   Simple inputs manager to abstract key/mouse inputs.
   * 
   * @param {HTMLElement} domElement
   * @param {DefaultOptions} options
  */
  constructor(domElement, options) {
    this.version = version;
    var opts = Object.assign({}, new DefaultOptions(), options || {});
    this.element = domElement || document;
    this.preventDefaults = !!opts.preventDefaults;
    this.stopPropagation = !!opts.stopPropagation;
    this.allowContextMenu = !!opts.allowContextMenu;
    this.disabled = !!opts.disabled;
    this.filterEvents = (ev, bindingName) => true;
    this.down = new import_events.EventEmitter();
    this.up = new import_events.EventEmitter();
    this.state = {};
    this.pointerState = {
      dx: 0,
      dy: 0,
      scrollx: 0,
      scrolly: 0,
      scrollz: 0
    };
    this.pressCount = {};
    this.releaseCount = {};
    this._keyBindmap = {};
    this._keyStates = {};
    this._bindPressCount = {};
    this._touches = { lastX: 0, lastY: 0, currID: null };
    this._pressedDuringMeta = {};
    if (document.readyState !== "loading") {
      initEvents(this);
    } else {
      document.addEventListener("DOMContentLoaded", (ev) => {
        initEvents(this);
      }, { once: true });
    }
  }
  /**
   * Binds one or more physical keys to an arbitrary binding name.
   * Key strings should align to `KeyboardEvent.code` strings - 
   * e.g. `KeyA`, `ArrowDown`, etc.
   * 
   * `inputs.bind('move-player-left', 'KeyW', 'ArrowLeft')
   * 
   * @param {string} bindingName 
   * @param {...string} keys 
   */
  bind(bindingName, ...keys) {
    keys.forEach((code) => {
      var bindings = this._keyBindmap[code] || [];
      if (bindings.includes(bindingName)) return;
      bindings.push(bindingName);
      this._keyBindmap[code] = bindings;
    });
    this.state[bindingName] = !!this.state[bindingName];
    this.pressCount[bindingName] = this.pressCount[bindingName] || 0;
    this.releaseCount[bindingName] = this.releaseCount[bindingName] || 0;
  }
  /**
   * Removes all key bindings for a given binding name.
   * 
   * `inputs.unbind('move-player-left')
   */
  unbind(bindingName) {
    for (var code in this._keyBindmap) {
      var bindings = this._keyBindmap[code];
      var i = bindings.indexOf(bindingName);
      if (i > -1) {
        bindings.splice(i, 1);
      }
    }
  }
  /**
   * Returns a copy of all existing bindings, in the format:
   * ```js
   *   {
   *      bindingName: [ keyCode1, keyCode2, ... ]
   *      ...
   *   }
   * ```
   */
  getBindings() {
    var res = {};
    for (var code in this._keyBindmap) {
      var bindings = this._keyBindmap[code];
      bindings.forEach((bindingName) => {
        res[bindingName] = res[bindingName] || [];
        res[bindingName].push(code);
      });
    }
    return res;
  }
  /**
   * Tick function - clears out all cumulative counters
  */
  tick() {
    zeroAllProperties(this.pointerState);
    zeroAllProperties(this.pressCount);
    zeroAllProperties(this.releaseCount);
  }
};
function zeroAllProperties(obj) {
  for (var key in obj) obj[key] = 0;
}
function initEvents(inputs) {
  window.addEventListener("keydown", onKeyEvent.bind(null, inputs, true), false);
  window.addEventListener("keyup", onKeyEvent.bind(null, inputs, false), false);
  var pointerOpts = { passive: true };
  if (window.PointerEvent) {
    inputs.element.addEventListener("pointerdown", onPointerEvent.bind(null, inputs, true), pointerOpts);
    window.document.addEventListener("pointerup", onPointerEvent.bind(null, inputs, false), pointerOpts);
    inputs.element.addEventListener("pointermove", onPointerMove.bind(null, inputs), pointerOpts);
  } else {
    inputs.element.addEventListener("mousedown", onPointerEvent.bind(null, inputs, true), pointerOpts);
    window.document.addEventListener("mouseup", onPointerEvent.bind(null, inputs, false), pointerOpts);
    inputs.element.addEventListener("mousemove", onPointerMove.bind(null, inputs), pointerOpts);
  }
  inputs.element.addEventListener("wheel", onWheelEvent.bind(null, inputs), pointerOpts);
  inputs.element.addEventListener("contextmenu", onContextMenu.bind(null, inputs), false);
  window.addEventListener("blur", onWindowBlur.bind(null, inputs), false);
}
function onKeyEvent(inputs, nowDown, ev) {
  handleKeyEvent(ev.code, nowDown, inputs, ev);
  workaroundMacBug(nowDown, inputs, ev);
}
function onPointerEvent(inputs, nowDown, ev) {
  if ("pointerId" in ev) {
    if (nowDown) {
      if (inputs._touches.currID !== null) return;
      inputs._touches.currID = ev.pointerId;
    } else {
      if (inputs._touches.currID !== ev.pointerId) return;
      inputs._touches.currID = null;
    }
  }
  var button = "button" in ev ? ev.button + 1 : 1;
  handleKeyEvent("Mouse" + button, nowDown, inputs, ev);
  return false;
}
function onPointerMove(inputs, ev) {
  if ("pointerId" in ev && inputs._touches.currID !== null) {
    if (inputs._touches.currID !== ev.pointerId) return;
  }
  var dx2 = ev.movementX || ev.mozMovementX || 0, dy = ev.movementY || ev.mozMovementY || 0;
  inputs.pointerState.dx += dx2;
  inputs.pointerState.dy += dy;
}
function onWheelEvent(inputs, ev) {
  var scale3 = 1;
  switch (ev.deltaMode) {
    case 0:
      scale3 = 1;
      break;
    // Pixel
    case 1:
      scale3 = 12;
      break;
    // Line
    case 2:
      scale3 = inputs.element.clientHeight || window.innerHeight;
      break;
  }
  inputs.pointerState.scrollx += (ev.deltaX || 0) * scale3;
  inputs.pointerState.scrolly += (ev.deltaY || 0) * scale3;
  inputs.pointerState.scrollz += (ev.deltaZ || 0) * scale3;
}
function onContextMenu(inputs, ev) {
  if (!inputs.allowContextMenu) {
    ev.preventDefault();
    return false;
  }
}
function onWindowBlur(inputs) {
  for (var code in inputs._keyStates) {
    if (!inputs._keyStates[code]) continue;
    if (/^Mouse\d/.test(code)) continue;
    handleKeyEvent(code, false, inputs, {
      code,
      note: `This is a mocked KeyboardEvent made by the 'game-inputs' module`,
      preventDefault: () => {
      },
      stopPropagation: () => {
      }
    });
  }
}
function handleKeyEvent(code, nowDown, inputs, ev) {
  var bindings = inputs._keyBindmap[code];
  if (!bindings) return;
  var prevState = inputs._keyStates[code];
  if (XOR(prevState, nowDown)) {
    inputs._keyStates[code] = nowDown;
    bindings.forEach((bindingName) => {
      var allow = inputs.filterEvents ? inputs.filterEvents(ev, bindingName) : true;
      if (!allow) return;
      handleBindingEvent(bindingName, nowDown, inputs, ev);
    });
  }
  if (!("button" in ev)) {
    if (inputs.preventDefaults && !ev.defaultPrevented) {
      ev.preventDefault();
    }
    if (inputs.stopPropagation) ev.stopPropagation();
  }
}
function handleBindingEvent(bindingName, pressed, inputs, ev) {
  var counter = pressed ? inputs.pressCount : inputs.releaseCount;
  counter[bindingName] = (counter[bindingName] || 0) + 1;
  var ct = inputs._bindPressCount[bindingName] || 0;
  ct += pressed ? 1 : -1;
  if (ct < 0) {
    ct = 0;
  }
  inputs._bindPressCount[bindingName] = ct;
  var currstate = inputs.state[bindingName];
  if (XOR(currstate, ct)) {
    inputs.state[bindingName] = ct > 0;
    var emitter = pressed ? inputs.down : inputs.up;
    if (!inputs.disabled) emitter.emit(bindingName, ev);
  }
}
function XOR(a2, b) {
  return a2 ? !b : b;
}
function workaroundMacBug(down2, inputs, ev) {
  var isMeta = /^Meta/.test(ev.code);
  if (ev.metaKey && !isMeta && down2) {
    inputs._pressedDuringMeta[ev.code] = true;
  } else if (isMeta && !down2) {
    for (var code in inputs._pressedDuringMeta) {
      if (!inputs._keyStates[code]) continue;
      if (/^Mouse\d/.test(code)) continue;
      handleKeyEvent(code, false, inputs, {
        code,
        note: `This is a mocked KeyboardEvent made by the 'game-inputs' module`,
        preventDefault: () => {
        },
        stopPropagation: () => {
        }
      });
    }
    inputs._pressedDuringMeta = {};
  }
}

// ../../node_modules/noa-engine/src/lib/inputs.js
var defaultOptions = {
  preventDefaults: false,
  stopPropagation: false,
  allowContextMenu: false
};
var defaultBindings = {
  "forward": ["KeyW", "ArrowUp"],
  "backward": ["KeyS", "ArrowDown"],
  "left": ["KeyA", "ArrowLeft"],
  "right": ["KeyD", "ArrowRight"],
  "fire": "Mouse1",
  "mid-fire": ["Mouse2", "KeyQ"],
  "alt-fire": ["Mouse3", "KeyE"],
  "jump": "Space"
};
var Inputs = class extends GameInputs {
  /** @internal */
  constructor(noa, opts, element) {
    opts = Object.assign({}, defaultOptions, opts);
    super(element, opts);
    var b = opts.bindings || defaultBindings;
    for (var name66 in b) {
      var keys = Array.isArray(b[name66]) ? b[name66] : [b[name66]];
      this.bind(name66, ...keys);
    }
  }
};

// ../../node_modules/noa-engine/src/lib/container.js
var import_events2 = __toESM(require_events());

// ../../node_modules/micro-game-shell/src/micro-game-shell.js
var MicroGameShell = class {
  constructor(domElement = null, pollTime = 10) {
    this.stickyPointerLock = false;
    this.stickyFullscreen = false;
    this.tickRate = 30;
    this.maxRenderRate = 0;
    this.maxTickTime = 100;
    this.pointerLock = false;
    this.fullscreen = false;
    this.onTick = function(dt) {
    };
    this.onRender = function(dt, framePart, tickDur) {
    };
    this.onInit = function() {
    };
    this.onResize = function() {
    };
    this.onPointerLockChanged = function(hasPL = false) {
    };
    this.onFullscreenChanged = function(hasFS = false) {
    };
    this.onPointerLockError = function(err) {
    };
    this._data = new Data(pollTime);
    domReady(() => {
      setupTimers(this);
      setupDomElement(this, domElement);
      this.onInit();
    });
  }
};
function Data(pollTime = 10) {
  this.nowObject = performance || Date;
  this.pollTime = pollTime;
  this.renderAccum = 0;
  this.lastTickStarted = 0;
  this.lastFrameStarted = 0;
  this.lastRenderStarted = 0;
  this.avgTickTime = 2;
  this.frameCB = null;
  this.intervalCB = null;
  this.intervalID = -1;
}
function setupTimers(shell) {
  var dat = shell._data;
  var now = dat.nowObject.now();
  dat.lastTickStarted = now;
  dat.lastFrameStarted = now;
  dat.lastRenderStarted = now;
  dat.frameCB = () => frameHandler(shell);
  dat.intervalCB = () => intervalHandler(shell);
  requestAnimationFrame(dat.frameCB);
  if (dat.pollTime > 0) {
    dat.intervalID = setInterval(dat.intervalCB, dat.pollTime);
  }
}
function frameHandler(shell) {
  var dat = shell._data;
  requestAnimationFrame(dat.frameCB);
  intervalHandler(shell);
  var now = dat.nowObject.now();
  var dt = now - dat.lastFrameStarted;
  dat.lastFrameStarted = now;
  if (shell.maxRenderRate > 0) {
    dat.renderAccum += dt;
    var frameDur = 1e3 / shell.maxRenderRate;
    if (dat.renderAccum < frameDur) return;
    dat.renderAccum -= frameDur;
    if (dat.renderAccum > frameDur) dat.renderAccum = frameDur;
  }
  var renderDt = now - dat.lastRenderStarted;
  dat.lastRenderStarted = now;
  var tickDur = 1e3 / shell.tickRate;
  var framePart = (now - dat.lastTickStarted) / tickDur;
  if (framePart < 0) framePart = 0;
  shell.onRender(renderDt, framePart, tickDur);
  setTimeout(intervalHandler, 0, shell, true);
}
function intervalHandler(shell, lookAhead = false) {
  var dat = shell._data;
  var now = dat.nowObject.now();
  var tickUntil = now;
  if (lookAhead) tickUntil += dat.avgTickTime;
  var cutoffTime = now + shell.maxTickTime;
  if (!(cutoffTime > now)) cutoffTime = now + 1;
  var tickDur = 1e3 / shell.tickRate;
  while (dat.lastTickStarted + tickDur < tickUntil) {
    shell.onTick(tickDur);
    dat.lastTickStarted += tickDur;
    var after = dat.nowObject.now();
    dat.avgTickTime = runningAverage(dat.avgTickTime, after - now);
    now = after;
    if (now > cutoffTime) {
      dat.lastTickStarted = now;
      return;
    }
  }
}
function setupDomElement(shell, el) {
  if (!el) return;
  var hasPL = false;
  var hasFS = false;
  var setPL = (want) => {
    hasPL = el === document.pointerLockElement;
    if (!!want === hasPL) return;
    if (want) {
      var res = el.requestPointerLock();
      if (res && res.catch) res.catch((err) => {
      });
    } else {
      document.exitPointerLock();
    }
  };
  var setFS = (want) => {
    hasFS = el === document.fullscreenElement;
    if (!!want === hasFS) return;
    if (want) {
      if (el.requestFullscreen) {
        el.requestFullscreen();
      } else if (el.webkitRequestFullscreen) {
        el.webkitRequestFullscreen();
      }
    } else {
      if (document.exitFullscreen) {
        document.exitFullscreen();
      } else if (document["webkitExitFullscreen"]) {
        document["webkitExitFullscreen"]();
      }
    }
  };
  document.addEventListener("pointerlockchange", (ev) => {
    hasPL = el === document.pointerLockElement;
    shell.onPointerLockChanged(hasPL);
  });
  document.addEventListener("fullscreenchange", (ev) => {
    hasFS = el === document.fullscreenElement;
    shell.onFullscreenChanged(hasFS);
  });
  document.addEventListener("pointerlockerror", (err) => {
    hasPL = el === document.pointerLockElement;
    shell.onPointerLockError(err);
  });
  Object.defineProperty(shell, "pointerLock", {
    get: () => hasPL,
    set: setPL
  });
  Object.defineProperty(shell, "fullscreen", {
    get: () => hasFS,
    set: setFS
  });
  el.addEventListener("click", (ev) => {
    if (shell.stickyPointerLock) setPL(true);
    if (shell.stickyFullscreen) setFS(true);
  });
  var resizeHandler = () => shell.onResize();
  if (window.ResizeObserver) {
    var observer2 = new ResizeObserver(resizeHandler);
    observer2.observe(el);
  } else {
    window.addEventListener("resize", resizeHandler);
  }
}
function runningAverage(avg, newVal) {
  if (newVal > avg * 4) newVal = avg * 4;
  if (newVal < avg * 0.25) newVal = avg * 0.25;
  return 0.9 * avg + 0.1 * newVal;
}
function domReady(fn) {
  if (document.readyState === "loading") {
    var handler = () => {
      document.removeEventListener("readystatechange", handler);
      fn();
    };
    document.addEventListener("readystatechange", handler);
  } else {
    setTimeout(fn, 0);
  }
}

// ../../node_modules/noa-engine/src/lib/container.js
var Container = class extends import_events2.EventEmitter {
  /** @internal */
  constructor(noa, opts) {
    super();
    opts = opts || {};
    this.noa = noa;
    var domEl = opts.domElement || null;
    if (typeof domEl === "string") {
      domEl = document.querySelector(domEl);
    }
    this.element = domEl || createContainerDiv();
    this.canvas = getOrCreateCanvas(this.element);
    doCanvasBugfix(noa, this.canvas);
    this.supportsPointerLock = false;
    this.pointerInGame = false;
    this.isFocused = !!document.hasFocus();
    this.hasPointerLock = false;
    var pollTime = 10;
    this._shell = new MicroGameShell(this.element, pollTime);
    this._shell.tickRate = opts.tickRate;
    this._shell.maxRenderRate = opts.maxRenderRate;
    this._shell.stickyPointerLock = opts.stickyPointerLock;
    this._shell.stickyFullscreen = opts.stickyFullscreen;
    this._shell.maxTickTime = 50;
    this._shell.onTick = noa.tick.bind(noa);
    this._shell.onRender = noa.render.bind(noa);
    this._shell.onPointerLockChanged = (hasPL) => {
      this.hasPointerLock = hasPL;
      this.emit(hasPL ? "gainedPointerLock" : "lostPointerLock");
      if (hasPL) this.pointerInGame = true;
    };
    this._shell.onInit = () => {
      this._shell.onResize = noa.rendering.resize.bind(noa.rendering);
      detectPointerLock(this);
      this.element.addEventListener("mouseenter", () => {
        this.pointerInGame = true;
      });
      this.element.addEventListener("mouseleave", () => {
        this.pointerInGame = false;
      });
      window.addEventListener("focus", () => {
        this.isFocused = true;
      });
      window.addEventListener("blur", () => {
        this.isFocused = false;
      });
      var onFirstMousedown = () => {
        this.pointerInGame = true;
        this.isFocused = true;
        this.element.removeEventListener("mousedown", onFirstMousedown);
      };
      this.element.addEventListener("mousedown", onFirstMousedown);
      this.emit("DOMready");
      this._shell.onInit = null;
    };
  }
  /*
   *
   *
   *              PUBLIC API 
   *
   *
  */
  /** @internal */
  appendTo(htmlElement) {
    this.element.appendChild(htmlElement);
  }
  /** 
   * Sets whether `noa` should try to acquire or release pointerLock
  */
  setPointerLock(lock = false) {
    this._shell.pointerLock = !!lock;
  }
};
function createContainerDiv() {
  var container = document.createElement("div");
  container.tabIndex = 1;
  container.style.position = "fixed";
  container.style.left = "0px";
  container.style.right = "0px";
  container.style.top = "0px";
  container.style.bottom = "0px";
  container.style.height = "100%";
  container.style.overflow = "hidden";
  document.body.appendChild(container);
  document.body.style.overflow = "hidden";
  document.body.style.height = "100%";
  container.id = "noa-container";
  return container;
}
function getOrCreateCanvas(el) {
  var canvas = el.querySelector("canvas");
  if (!canvas) {
    canvas = document.createElement("canvas");
    canvas.style.position = "absolute";
    canvas.style.left = "0px";
    canvas.style.top = "0px";
    canvas.style.height = "100%";
    canvas.style.width = "100%";
    canvas.id = "noa-canvas";
    el.insertBefore(canvas, el.firstChild);
  }
  return canvas;
}
function detectPointerLock(self) {
  var lockElementExists = "pointerLockElement" in document || "mozPointerLockElement" in document || "webkitPointerLockElement" in document;
  if (lockElementExists) {
    self.supportsPointerLock = true;
    var listener = function(e) {
      self.supportsPointerLock = false;
      document.removeEventListener(e.type, listener);
    };
    document.addEventListener("touchmove", listener);
  }
}
function doCanvasBugfix(noa, canvas) {
  var ct = 0;
  var fixCanvas = () => {
    var w = canvas.width;
    canvas.width = w + 1;
    canvas.width = w;
    if (ct++ > 10) noa.off("beforeRender", fixCanvas);
  };
  noa.on("beforeRender", fixCanvas);
}

// ../../node_modules/noa-engine/src/lib/camera.js
var import_gl_vec3 = __toESM(require_gl_vec3());

// ../../node_modules/gl-matrix/esm/common.js
var EPSILON = 1e-6;
var ARRAY_TYPE = typeof Float32Array !== "undefined" ? Float32Array : Array;
var RANDOM = Math.random;
function round(a2) {
  if (a2 >= 0) return Math.round(a2);
  return a2 % 0.5 === 0 ? Math.floor(a2) : Math.round(a2);
}
var degree = Math.PI / 180;
var radian = 180 / Math.PI;

// ../../node_modules/gl-matrix/esm/mat3.js
function create() {
  var out = new ARRAY_TYPE(9);
  if (ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
  }
  out[0] = 1;
  out[4] = 1;
  out[8] = 1;
  return out;
}

// ../../node_modules/gl-matrix/esm/vec3.js
var vec3_exports = {};
__export(vec3_exports, {
  add: () => add,
  angle: () => angle,
  bezier: () => bezier,
  ceil: () => ceil,
  clone: () => clone,
  copy: () => copy,
  create: () => create2,
  cross: () => cross,
  dist: () => dist,
  distance: () => distance,
  div: () => div,
  divide: () => divide,
  dot: () => dot,
  equals: () => equals,
  exactEquals: () => exactEquals,
  floor: () => floor,
  forEach: () => forEach,
  fromValues: () => fromValues,
  hermite: () => hermite,
  inverse: () => inverse,
  len: () => len,
  length: () => length,
  lerp: () => lerp,
  max: () => max,
  min: () => min,
  mul: () => mul,
  multiply: () => multiply,
  negate: () => negate,
  normalize: () => normalize,
  random: () => random,
  rotateX: () => rotateX,
  rotateY: () => rotateY,
  rotateZ: () => rotateZ,
  round: () => round2,
  scale: () => scale,
  scaleAndAdd: () => scaleAndAdd,
  set: () => set,
  slerp: () => slerp,
  sqrDist: () => sqrDist,
  sqrLen: () => sqrLen,
  squaredDistance: () => squaredDistance,
  squaredLength: () => squaredLength,
  str: () => str,
  sub: () => sub,
  subtract: () => subtract,
  transformMat3: () => transformMat3,
  transformMat4: () => transformMat4,
  transformQuat: () => transformQuat,
  zero: () => zero
});
function create2() {
  var out = new ARRAY_TYPE(3);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }
  return out;
}
function clone(a2) {
  var out = new ARRAY_TYPE(3);
  out[0] = a2[0];
  out[1] = a2[1];
  out[2] = a2[2];
  return out;
}
function length(a2) {
  var x = a2[0];
  var y = a2[1];
  var z = a2[2];
  return Math.sqrt(x * x + y * y + z * z);
}
function fromValues(x, y, z) {
  var out = new ARRAY_TYPE(3);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}
function copy(out, a2) {
  out[0] = a2[0];
  out[1] = a2[1];
  out[2] = a2[2];
  return out;
}
function set(out, x, y, z) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}
function add(out, a2, b) {
  out[0] = a2[0] + b[0];
  out[1] = a2[1] + b[1];
  out[2] = a2[2] + b[2];
  return out;
}
function subtract(out, a2, b) {
  out[0] = a2[0] - b[0];
  out[1] = a2[1] - b[1];
  out[2] = a2[2] - b[2];
  return out;
}
function multiply(out, a2, b) {
  out[0] = a2[0] * b[0];
  out[1] = a2[1] * b[1];
  out[2] = a2[2] * b[2];
  return out;
}
function divide(out, a2, b) {
  out[0] = a2[0] / b[0];
  out[1] = a2[1] / b[1];
  out[2] = a2[2] / b[2];
  return out;
}
function ceil(out, a2) {
  out[0] = Math.ceil(a2[0]);
  out[1] = Math.ceil(a2[1]);
  out[2] = Math.ceil(a2[2]);
  return out;
}
function floor(out, a2) {
  out[0] = Math.floor(a2[0]);
  out[1] = Math.floor(a2[1]);
  out[2] = Math.floor(a2[2]);
  return out;
}
function min(out, a2, b) {
  out[0] = Math.min(a2[0], b[0]);
  out[1] = Math.min(a2[1], b[1]);
  out[2] = Math.min(a2[2], b[2]);
  return out;
}
function max(out, a2, b) {
  out[0] = Math.max(a2[0], b[0]);
  out[1] = Math.max(a2[1], b[1]);
  out[2] = Math.max(a2[2], b[2]);
  return out;
}
function round2(out, a2) {
  out[0] = round(a2[0]);
  out[1] = round(a2[1]);
  out[2] = round(a2[2]);
  return out;
}
function scale(out, a2, b) {
  out[0] = a2[0] * b;
  out[1] = a2[1] * b;
  out[2] = a2[2] * b;
  return out;
}
function scaleAndAdd(out, a2, b, scale3) {
  out[0] = a2[0] + b[0] * scale3;
  out[1] = a2[1] + b[1] * scale3;
  out[2] = a2[2] + b[2] * scale3;
  return out;
}
function distance(a2, b) {
  var x = b[0] - a2[0];
  var y = b[1] - a2[1];
  var z = b[2] - a2[2];
  return Math.sqrt(x * x + y * y + z * z);
}
function squaredDistance(a2, b) {
  var x = b[0] - a2[0];
  var y = b[1] - a2[1];
  var z = b[2] - a2[2];
  return x * x + y * y + z * z;
}
function squaredLength(a2) {
  var x = a2[0];
  var y = a2[1];
  var z = a2[2];
  return x * x + y * y + z * z;
}
function negate(out, a2) {
  out[0] = -a2[0];
  out[1] = -a2[1];
  out[2] = -a2[2];
  return out;
}
function inverse(out, a2) {
  out[0] = 1 / a2[0];
  out[1] = 1 / a2[1];
  out[2] = 1 / a2[2];
  return out;
}
function normalize(out, a2) {
  var x = a2[0];
  var y = a2[1];
  var z = a2[2];
  var len2 = x * x + y * y + z * z;
  if (len2 > 0) {
    len2 = 1 / Math.sqrt(len2);
  }
  out[0] = a2[0] * len2;
  out[1] = a2[1] * len2;
  out[2] = a2[2] * len2;
  return out;
}
function dot(a2, b) {
  return a2[0] * b[0] + a2[1] * b[1] + a2[2] * b[2];
}
function cross(out, a2, b) {
  var ax = a2[0], ay = a2[1], az = a2[2];
  var bx = b[0], by = b[1], bz = b[2];
  out[0] = ay * bz - az * by;
  out[1] = az * bx - ax * bz;
  out[2] = ax * by - ay * bx;
  return out;
}
function lerp(out, a2, b, t) {
  var ax = a2[0];
  var ay = a2[1];
  var az = a2[2];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  return out;
}
function slerp(out, a2, b, t) {
  var angle2 = Math.acos(Math.min(Math.max(dot(a2, b), -1), 1));
  var sinTotal = Math.sin(angle2);
  var ratioA = Math.sin((1 - t) * angle2) / sinTotal;
  var ratioB = Math.sin(t * angle2) / sinTotal;
  out[0] = ratioA * a2[0] + ratioB * b[0];
  out[1] = ratioA * a2[1] + ratioB * b[1];
  out[2] = ratioA * a2[2] + ratioB * b[2];
  return out;
}
function hermite(out, a2, b, c, d, t) {
  var factorTimes2 = t * t;
  var factor1 = factorTimes2 * (2 * t - 3) + 1;
  var factor2 = factorTimes2 * (t - 2) + t;
  var factor3 = factorTimes2 * (t - 1);
  var factor4 = factorTimes2 * (3 - 2 * t);
  out[0] = a2[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a2[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a2[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  return out;
}
function bezier(out, a2, b, c, d, t) {
  var inverseFactor = 1 - t;
  var inverseFactorTimesTwo = inverseFactor * inverseFactor;
  var factorTimes2 = t * t;
  var factor1 = inverseFactorTimesTwo * inverseFactor;
  var factor2 = 3 * t * inverseFactorTimesTwo;
  var factor3 = 3 * factorTimes2 * inverseFactor;
  var factor4 = factorTimes2 * t;
  out[0] = a2[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a2[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a2[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  return out;
}
function random(out, scale3) {
  scale3 = scale3 === void 0 ? 1 : scale3;
  var r = RANDOM() * 2 * Math.PI;
  var z = RANDOM() * 2 - 1;
  var zScale = Math.sqrt(1 - z * z) * scale3;
  out[0] = Math.cos(r) * zScale;
  out[1] = Math.sin(r) * zScale;
  out[2] = z * scale3;
  return out;
}
function transformMat4(out, a2, m) {
  var x = a2[0], y = a2[1], z = a2[2];
  var w = m[3] * x + m[7] * y + m[11] * z + m[15];
  w = w || 1;
  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
  return out;
}
function transformMat3(out, a2, m) {
  var x = a2[0], y = a2[1], z = a2[2];
  out[0] = x * m[0] + y * m[3] + z * m[6];
  out[1] = x * m[1] + y * m[4] + z * m[7];
  out[2] = x * m[2] + y * m[5] + z * m[8];
  return out;
}
function transformQuat(out, a2, q) {
  var qx = q[0], qy = q[1], qz = q[2], qw = q[3];
  var vx = a2[0], vy = a2[1], vz = a2[2];
  var tx = qy * vz - qz * vy;
  var ty = qz * vx - qx * vz;
  var tz = qx * vy - qy * vx;
  tx = tx + tx;
  ty = ty + ty;
  tz = tz + tz;
  out[0] = vx + qw * tx + qy * tz - qz * ty;
  out[1] = vy + qw * ty + qz * tx - qx * tz;
  out[2] = vz + qw * tz + qx * ty - qy * tx;
  return out;
}
function rotateX(out, a2, b, rad) {
  var p = [], r = [];
  p[0] = a2[0] - b[0];
  p[1] = a2[1] - b[1];
  p[2] = a2[2] - b[2];
  r[0] = p[0];
  r[1] = p[1] * Math.cos(rad) - p[2] * Math.sin(rad);
  r[2] = p[1] * Math.sin(rad) + p[2] * Math.cos(rad);
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
function rotateY(out, a2, b, rad) {
  var p = [], r = [];
  p[0] = a2[0] - b[0];
  p[1] = a2[1] - b[1];
  p[2] = a2[2] - b[2];
  r[0] = p[2] * Math.sin(rad) + p[0] * Math.cos(rad);
  r[1] = p[1];
  r[2] = p[2] * Math.cos(rad) - p[0] * Math.sin(rad);
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
function rotateZ(out, a2, b, rad) {
  var p = [], r = [];
  p[0] = a2[0] - b[0];
  p[1] = a2[1] - b[1];
  p[2] = a2[2] - b[2];
  r[0] = p[0] * Math.cos(rad) - p[1] * Math.sin(rad);
  r[1] = p[0] * Math.sin(rad) + p[1] * Math.cos(rad);
  r[2] = p[2];
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
function angle(a2, b) {
  var ax = a2[0], ay = a2[1], az = a2[2], bx = b[0], by = b[1], bz = b[2], mag = Math.sqrt((ax * ax + ay * ay + az * az) * (bx * bx + by * by + bz * bz)), cosine = mag && dot(a2, b) / mag;
  return Math.acos(Math.min(Math.max(cosine, -1), 1));
}
function zero(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  return out;
}
function str(a2) {
  return "vec3(" + a2[0] + ", " + a2[1] + ", " + a2[2] + ")";
}
function exactEquals(a2, b) {
  return a2[0] === b[0] && a2[1] === b[1] && a2[2] === b[2];
}
function equals(a2, b) {
  var a0 = a2[0], a1 = a2[1], a22 = a2[2];
  var b0 = b[0], b1 = b[1], b2 = b[2];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a22 - b2) <= EPSILON * Math.max(1, Math.abs(a22), Math.abs(b2));
}
var sub = subtract;
var mul = multiply;
var div = divide;
var dist = distance;
var sqrDist = squaredDistance;
var len = length;
var sqrLen = squaredLength;
var forEach = (function() {
  var vec = create2();
  return function(a2, stride, offset, count, fn, arg) {
    var i, l;
    if (!stride) {
      stride = 3;
    }
    if (!offset) {
      offset = 0;
    }
    if (count) {
      l = Math.min(count * stride + offset, a2.length);
    } else {
      l = a2.length;
    }
    for (i = offset; i < l; i += stride) {
      vec[0] = a2[i];
      vec[1] = a2[i + 1];
      vec[2] = a2[i + 2];
      fn(vec, vec, arg);
      a2[i] = vec[0];
      a2[i + 1] = vec[1];
      a2[i + 2] = vec[2];
    }
    return a2;
  };
})();

// ../../node_modules/gl-matrix/esm/vec4.js
function create3() {
  var out = new ARRAY_TYPE(4);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
  }
  return out;
}
function normalize2(out, a2) {
  var x = a2[0];
  var y = a2[1];
  var z = a2[2];
  var w = a2[3];
  var len2 = x * x + y * y + z * z + w * w;
  if (len2 > 0) {
    len2 = 1 / Math.sqrt(len2);
  }
  out[0] = x * len2;
  out[1] = y * len2;
  out[2] = z * len2;
  out[3] = w * len2;
  return out;
}
var forEach2 = (function() {
  var vec = create3();
  return function(a2, stride, offset, count, fn, arg) {
    var i, l;
    if (!stride) {
      stride = 4;
    }
    if (!offset) {
      offset = 0;
    }
    if (count) {
      l = Math.min(count * stride + offset, a2.length);
    } else {
      l = a2.length;
    }
    for (i = offset; i < l; i += stride) {
      vec[0] = a2[i];
      vec[1] = a2[i + 1];
      vec[2] = a2[i + 2];
      vec[3] = a2[i + 3];
      fn(vec, vec, arg);
      a2[i] = vec[0];
      a2[i + 1] = vec[1];
      a2[i + 2] = vec[2];
      a2[i + 3] = vec[3];
    }
    return a2;
  };
})();

// ../../node_modules/gl-matrix/esm/quat.js
function create4() {
  var out = new ARRAY_TYPE(4);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }
  out[3] = 1;
  return out;
}
function setAxisAngle(out, axis, rad) {
  rad = rad * 0.5;
  var s = Math.sin(rad);
  out[0] = s * axis[0];
  out[1] = s * axis[1];
  out[2] = s * axis[2];
  out[3] = Math.cos(rad);
  return out;
}
function slerp2(out, a2, b, t) {
  var ax = a2[0], ay = a2[1], az = a2[2], aw = a2[3];
  var bx = b[0], by = b[1], bz = b[2], bw = b[3];
  var omega, cosom, sinom, scale0, scale1;
  cosom = ax * bx + ay * by + az * bz + aw * bw;
  if (cosom < 0) {
    cosom = -cosom;
    bx = -bx;
    by = -by;
    bz = -bz;
    bw = -bw;
  }
  if (1 - cosom > EPSILON) {
    omega = Math.acos(cosom);
    sinom = Math.sin(omega);
    scale0 = Math.sin((1 - t) * omega) / sinom;
    scale1 = Math.sin(t * omega) / sinom;
  } else {
    scale0 = 1 - t;
    scale1 = t;
  }
  out[0] = scale0 * ax + scale1 * bx;
  out[1] = scale0 * ay + scale1 * by;
  out[2] = scale0 * az + scale1 * bz;
  out[3] = scale0 * aw + scale1 * bw;
  return out;
}
function fromMat3(out, m) {
  var fTrace = m[0] + m[4] + m[8];
  var fRoot;
  if (fTrace > 0) {
    fRoot = Math.sqrt(fTrace + 1);
    out[3] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot;
    out[0] = (m[5] - m[7]) * fRoot;
    out[1] = (m[6] - m[2]) * fRoot;
    out[2] = (m[1] - m[3]) * fRoot;
  } else {
    var i = 0;
    if (m[4] > m[0]) i = 1;
    if (m[8] > m[i * 3 + i]) i = 2;
    var j = (i + 1) % 3;
    var k = (i + 2) % 3;
    fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1);
    out[i] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot;
    out[3] = (m[j * 3 + k] - m[k * 3 + j]) * fRoot;
    out[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;
    out[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;
  }
  return out;
}
var normalize3 = normalize2;
var rotationTo = (function() {
  var tmpvec3 = create2();
  var xUnitVec3 = fromValues(1, 0, 0);
  var yUnitVec3 = fromValues(0, 1, 0);
  return function(out, a2, b) {
    var dot4 = dot(a2, b);
    if (dot4 < -0.999999) {
      cross(tmpvec3, xUnitVec3, a2);
      if (len(tmpvec3) < 1e-6) cross(tmpvec3, yUnitVec3, a2);
      normalize(tmpvec3, tmpvec3);
      setAxisAngle(out, tmpvec3, Math.PI);
      return out;
    } else if (dot4 > 0.999999) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
      out[3] = 1;
      return out;
    } else {
      cross(tmpvec3, a2, b);
      out[0] = tmpvec3[0];
      out[1] = tmpvec3[1];
      out[2] = tmpvec3[2];
      out[3] = 1 + dot4;
      return normalize3(out, out);
    }
  };
})();
var sqlerp = (function() {
  var temp1 = create4();
  var temp2 = create4();
  return function(out, a2, b, c, d, t) {
    slerp2(temp1, a2, d, t);
    slerp2(temp2, b, c, t);
    slerp2(out, temp1, temp2, 2 * t * (1 - t));
    return out;
  };
})();
var setAxes = (function() {
  var matr = create();
  return function(out, view, right, up) {
    matr[0] = right[0];
    matr[3] = right[1];
    matr[6] = right[2];
    matr[1] = up[0];
    matr[4] = up[1];
    matr[7] = up[2];
    matr[2] = -view[0];
    matr[5] = -view[1];
    matr[8] = -view[2];
    return normalize3(out, fromMat3(out, matr));
  };
})();

// ../../node_modules/gl-matrix/esm/vec2.js
function create5() {
  var out = new ARRAY_TYPE(2);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
  }
  return out;
}
var forEach3 = (function() {
  var vec = create5();
  return function(a2, stride, offset, count, fn, arg) {
    var i, l;
    if (!stride) {
      stride = 2;
    }
    if (!offset) {
      offset = 0;
    }
    if (count) {
      l = Math.min(count * stride + offset, a2.length);
    } else {
      l = a2.length;
    }
    for (i = offset; i < l; i += stride) {
      vec[0] = a2[i];
      vec[1] = a2[i + 1];
      fn(vec, vec, arg);
      a2[i] = vec[0];
      a2[i + 1] = vec[1];
    }
    return a2;
  };
})();

// ../../node_modules/aabb-3d/dist/index.js
var AABB = class _AABB {
  base;
  vec;
  max;
  mag;
  constructor(pos, vec) {
    const pos2 = vec3_exports.create();
    vec3_exports.add(pos2, pos, vec);
    this.base = vec3_exports.min(vec3_exports.create(), pos, pos2);
    this.vec = vec3_exports.clone(vec);
    this.max = vec3_exports.max(vec3_exports.create(), pos, pos2);
    this.mag = vec3_exports.length(this.vec);
  }
  width() {
    return this.vec[0];
  }
  height() {
    return this.vec[1];
  }
  depth() {
    return this.vec[2];
  }
  x0() {
    return this.base[0];
  }
  y0() {
    return this.base[1];
  }
  z0() {
    return this.base[2];
  }
  x1() {
    return this.max[0];
  }
  y1() {
    return this.max[1];
  }
  z1() {
    return this.max[2];
  }
  /**
   * Moves the box. Returns itself.
   */
  translate(by) {
    vec3_exports.add(this.max, this.max, by);
    vec3_exports.add(this.base, this.base, by);
    return this;
  }
  setPosition(pos) {
    vec3_exports.add(this.max, pos, this.vec);
    vec3_exports.copy(this.base, pos);
    return this;
  }
  /**
   * Returns a new `aabb` that surrounds both `aabb`'s.
   */
  expand(aabb) {
    const max2 = vec3_exports.create();
    const min2 = vec3_exports.create();
    vec3_exports.max(max2, aabb.max, this.max);
    vec3_exports.min(min2, aabb.base, this.base);
    vec3_exports.subtract(max2, max2, min2);
    return new _AABB(min2, max2);
  }
  /**
   * Returns `true` if the two bounding boxes intersect (or touch at all.)
   */
  intersects(aabb) {
    if (aabb.base[0] > this.max[0])
      return false;
    if (aabb.base[1] > this.max[1])
      return false;
    if (aabb.base[2] > this.max[2])
      return false;
    if (aabb.max[0] < this.base[0])
      return false;
    if (aabb.max[1] < this.base[1])
      return false;
    if (aabb.max[2] < this.base[2])
      return false;
    return true;
  }
  touches(aabb) {
    const intersection = this.union(aabb);
    return intersection !== null && (intersection.width() == 0 || intersection.height() == 0 || intersection.depth() == 0);
  }
  /**
   * Returns a new `aabb` representing the shared area of the
   * two `aabb`'s. returns `null` if the boxes don't intersect.
   */
  union(aabb) {
    if (!this.intersects(aabb))
      return null;
    const base_x = Math.max(aabb.base[0], this.base[0]);
    const base_y = Math.max(aabb.base[1], this.base[1]);
    const base_z = Math.max(aabb.base[2], this.base[2]);
    const max_x = Math.min(aabb.max[0], this.max[0]);
    const max_y = Math.min(aabb.max[1], this.max[1]);
    const max_z = Math.min(aabb.max[2], this.max[2]);
    return new _AABB([base_x, base_y, base_z], [max_x - base_x, max_y - base_y, max_z - base_z]);
  }
};

// ../../node_modules/noa-engine/src/lib/camera.js
var import_voxel_aabb_sweep = __toESM(require_voxel_aabb_sweep());
function CameraDefaults() {
  this.inverseX = false;
  this.inverseY = false;
  this.sensitivityMult = 1;
  this.sensitivityMultOutsidePointerlock = 0;
  this.sensitivityX = 10;
  this.sensitivityY = 10;
  this.initialZoom = 0;
  this.zoomSpeed = 0.2;
}
var tempVectors = [
  import_gl_vec3.default.create(),
  import_gl_vec3.default.create(),
  import_gl_vec3.default.create()
];
var originVector = import_gl_vec3.default.create();
var Camera2 = class {
  /** 
   * @internal 
   * @param {import('../index').Engine} noa
   * @param {Partial.<CameraDefaults>} opts
  */
  constructor(noa, opts) {
    opts = Object.assign({}, new CameraDefaults(), opts);
    this.noa = noa;
    this.sensitivityX = +opts.sensitivityX;
    this.sensitivityY = +opts.sensitivityY;
    this.inverseX = !!opts.inverseX;
    this.inverseY = !!opts.inverseY;
    this.sensitivityMult = opts.sensitivityMult;
    this.sensitivityMultOutsidePointerlock = opts.sensitivityMultOutsidePointerlock;
    this.heading = 0;
    this.pitch = 0;
    this.cameraTarget = this.noa.ents.createEntity(["position"]);
    var eyeOffset = 0.9 * noa.ents.getPositionData(noa.playerEntity).height;
    noa.ents.addComponent(this.cameraTarget, "followsEntity", {
      entity: noa.playerEntity,
      offset: [0, eyeOffset, 0]
    });
    this.zoomDistance = opts.initialZoom;
    this.zoomSpeed = opts.zoomSpeed;
    this.currentZoom = opts.initialZoom;
    this._dirVector = import_gl_vec3.default.fromValues(0, 0, 1);
  }
  /*
   * 
   * 
   *          API
   * 
   * 
  */
  /*
   *      Local position functions for high precision
  */
  /** @internal */
  _localGetTargetPosition() {
    var pdat = this.noa.ents.getPositionData(this.cameraTarget);
    var pos = tempVectors[0];
    return import_gl_vec3.default.copy(pos, pdat._renderPosition);
  }
  /** @internal */
  _localGetPosition() {
    var loc = this._localGetTargetPosition();
    if (this.currentZoom === 0) return loc;
    return import_gl_vec3.default.scaleAndAdd(loc, loc, this._dirVector, -this.currentZoom);
  }
  /**
   * Returns the camera's current target position - i.e. the player's 
   * eye position. When the camera is zoomed all the way in, 
   * this returns the same location as `camera.getPosition()`.
  */
  getTargetPosition() {
    var loc = this._localGetTargetPosition();
    var globalCamPos = tempVectors[1];
    return this.noa.localToGlobal(loc, globalCamPos);
  }
  /**
   * Returns the current camera position (read only)
  */
  getPosition() {
    var loc = this._localGetPosition();
    var globalCamPos = tempVectors[2];
    return this.noa.localToGlobal(loc, globalCamPos);
  }
  /**
   * Returns the camera direction vector (read only)
  */
  getDirection() {
    return this._dirVector;
  }
  /*
   * 
   * 
   * 
   *          internals below
   * 
   * 
   * 
  */
  /**
   * Called before render, if mouseLock etc. is applicable.
   * Applies current mouse x/y inputs to the camera angle and zoom
   * @internal
  */
  applyInputsToCamera() {
    var senseMult = this.sensitivityMult;
    if (this.noa.container.supportsPointerLock) {
      if (!this.noa.container.hasPointerLock) {
        senseMult *= this.sensitivityMultOutsidePointerlock;
      }
    }
    if (senseMult === 0) return;
    var pointerState = this.noa.inputs.pointerState;
    bugFix(pointerState);
    var conv = 66e-4 * Math.PI / 180;
    var dx2 = pointerState.dx * this.sensitivityX * senseMult * conv;
    var dy = pointerState.dy * this.sensitivityY * senseMult * conv;
    if (this.inverseX) dx2 = -dx2;
    if (this.inverseY) dy = -dy;
    var twopi = 2 * Math.PI;
    this.heading += dx2 < 0 ? dx2 + twopi : dx2;
    if (this.heading > twopi) this.heading -= twopi;
    var maxPitch = Math.PI / 2 - 1e-3;
    this.pitch = Math.max(-maxPitch, Math.min(maxPitch, this.pitch + dy));
    import_gl_vec3.default.set(this._dirVector, 0, 0, 1);
    var dir = this._dirVector;
    var origin = originVector;
    import_gl_vec3.default.rotateX(dir, dir, origin, this.pitch);
    import_gl_vec3.default.rotateY(dir, dir, origin, this.heading);
  }
  /**
   *  Called before all renders, pre- and post- entity render systems
   * @internal
  */
  updateBeforeEntityRenderSystems() {
    this.currentZoom += (this.zoomDistance - this.currentZoom) * this.zoomSpeed;
  }
  /** @internal */
  updateAfterEntityRenderSystems() {
    var maxZoom = cameraObstructionDistance(this);
    if (this.currentZoom > maxZoom) this.currentZoom = maxZoom;
  }
};
function cameraObstructionDistance(self) {
  if (!self._sweepBox) {
    self._sweepBox = new AABB([0, 0, 0], [0.2, 0.2, 0.2]);
    self._sweepGetVoxel = self.noa.world.getBlockSolidity.bind(self.noa.world);
    self._sweepVec = import_gl_vec3.default.create();
    self._sweepHit = () => true;
  }
  var pos = import_gl_vec3.default.copy(self._sweepVec, self._localGetTargetPosition());
  import_gl_vec3.default.add(pos, pos, self.noa.worldOriginOffset);
  for (var i = 0; i < 3; i++) pos[i] -= 0.1;
  self._sweepBox.setPosition(pos);
  var dist2 = Math.max(self.zoomDistance, self.currentZoom) + 0.1;
  import_gl_vec3.default.scale(self._sweepVec, self.getDirection(), -dist2);
  return (0, import_voxel_aabb_sweep.default)(self._sweepGetVoxel, self._sweepBox, self._sweepVec, self._sweepHit, true);
}
function bugFix(pointerState) {
  var dx2 = pointerState.dx;
  var dy = pointerState.dy;
  var badx = Math.abs(dx2) > 400 && Math.abs(dx2 / lastx) > 4;
  var bady = Math.abs(dy) > 400 && Math.abs(dy / lasty) > 4;
  if (badx || bady) {
    pointerState.dx = lastx;
    pointerState.dy = lasty;
    lastx = (lastx + dx2) / 2;
    lasty = (lasty + dy) / 2;
  } else {
    lastx = dx2 || 1;
    lasty = dy || 1;
  }
}
var lastx = 0;
var lasty = 0;

// ../../node_modules/noa-engine/src/lib/entities.js
var import_ent_comp = __toESM(require_ECS());
var import_gl_vec38 = __toESM(require_gl_vec3());

// ../../node_modules/noa-engine/src/components/position.js
var import_gl_vec32 = __toESM(require_gl_vec3());
var PositionState = class {
  constructor() {
    this.position = null;
    this.width = 0.8;
    this.height = 0.8;
    this._localPosition = null;
    this._renderPosition = null;
    this._extents = null;
  }
};
function position_default(noa) {
  return {
    name: "position",
    order: 60,
    state: new PositionState(),
    onAdd: function(eid, state) {
      var pos = [0, 0, 0];
      if (state.position) import_gl_vec32.default.copy(pos, state.position);
      state.position = pos;
      state._localPosition = import_gl_vec32.default.create();
      state._renderPosition = import_gl_vec32.default.create();
      state._extents = new Float32Array(6);
      noa.globalToLocal(state.position, null, state._localPosition);
      import_gl_vec32.default.copy(state._renderPosition, state._localPosition);
      updatePositionExtents(state);
    },
    onRemove: null,
    system: function(dt, states) {
      var off = noa.worldOriginOffset;
      for (var i = 0; i < states.length; i++) {
        var state = states[i];
        import_gl_vec32.default.add(state.position, state._localPosition, off);
        updatePositionExtents(state);
      }
    }
  };
}
function updatePositionExtents(state) {
  var hw = state.width / 2;
  var lpos = state._localPosition;
  var ext = state._extents;
  ext[0] = lpos[0] - hw;
  ext[1] = lpos[1];
  ext[2] = lpos[2] - hw;
  ext[3] = lpos[0] + hw;
  ext[4] = lpos[1] + state.height;
  ext[5] = lpos[2] + hw;
}

// ../../node_modules/noa-engine/src/components/physics.js
var import_gl_vec33 = __toESM(require_gl_vec3());
var PhysicsState = class {
  constructor() {
    this.body = null;
  }
};
function physics_default(noa) {
  return {
    name: "physics",
    order: 40,
    state: new PhysicsState(),
    onAdd: function(entID, state) {
      state.body = noa.physics.addBody();
      var posDat = noa.ents.getPositionData(state.__id);
      setPhysicsFromPosition(state, posDat);
    },
    onRemove: function(entID, state) {
      if (noa.ents.hasPosition(state.__id)) {
        var pdat = noa.ents.getPositionData(state.__id);
        setPositionFromPhysics(state, pdat);
        backtrackRenderPos(state, pdat, 0, false);
      }
      noa.physics.removeBody(state.body);
    },
    system: function(dt, states) {
      for (var i = 0; i < states.length; i++) {
        var state = states[i];
        var pdat = noa.ents.getPositionData(state.__id);
        setPositionFromPhysics(state, pdat);
      }
    },
    renderSystem: function(dt, states) {
      var tickPos = noa.positionInCurrentTick;
      var tickTime = 1e3 / noa.container._shell.tickRate;
      tickTime *= noa.timeScale;
      var tickMS = tickPos * tickTime;
      var backtrackAmt = (tickMS - tickTime) / 1e3;
      for (var i = 0; i < states.length; i++) {
        var state = states[i];
        var id = state.__id;
        var pdat = noa.ents.getPositionData(id);
        var smoothed = noa.ents.cameraSmoothed(id);
        backtrackRenderPos(state, pdat, backtrackAmt, smoothed);
      }
    }
  };
}
var local = import_gl_vec33.default.create();
function setPhysicsFromPosition(physState, posState) {
  var box = physState.body.aabb;
  var ext = posState._extents;
  import_gl_vec33.default.copy(box.base, ext);
  import_gl_vec33.default.set(box.vec, posState.width, posState.height, posState.width);
  import_gl_vec33.default.add(box.max, box.base, box.vec);
}
function setPositionFromPhysics(physState, posState) {
  var base = physState.body.aabb.base;
  var hw = posState.width / 2;
  import_gl_vec33.default.set(posState._localPosition, base[0] + hw, base[1], base[2] + hw);
}
function backtrackRenderPos(physState, posState, backtrackAmt, smoothed) {
  var vel = physState.body.velocity;
  import_gl_vec33.default.scaleAndAdd(local, posState._localPosition, vel, backtrackAmt);
  if (smoothed) import_gl_vec33.default.lerp(local, posState._renderPosition, local, 0.3);
  import_gl_vec33.default.copy(posState._renderPosition, local);
}

// ../../node_modules/noa-engine/src/components/collideEntities.js
var import_box_intersect = __toESM(require_box_intersect());
function collideEntities_default(noa) {
  var intervals = [];
  return {
    name: "collideEntities",
    order: 70,
    state: {
      cylinder: false,
      collideBits: 1 | 0,
      collideMask: 1 | 0,
      callback: null
    },
    onAdd: null,
    onRemove: null,
    system: function entityCollider(dt, states) {
      var ents = noa.ents;
      for (var i = 0; i < states.length; i++) {
        var id = states[i].__id;
        var dat = ents.getPositionData(id);
        intervals[i] = dat._extents;
      }
      intervals.length = states.length;
      (0, import_box_intersect.default)(intervals, function(a2, b) {
        var stateA = states[a2];
        var stateB = states[b];
        if (!stateA || !stateB) return;
        var intervalA = intervals[a2];
        var intervalB = intervals[b];
        if (cylindricalHitTest(stateA, stateB, intervalA, intervalB)) {
          handleCollision(noa, stateA, stateB);
        }
      });
    }
  };
  function handleCollision(noa2, stateA, stateB) {
    var idA = stateA.__id;
    var idB = stateB.__id;
    if (stateA.collideMask & stateB.collideBits) {
      if (stateA.callback) stateA.callback(idB);
    }
    if (stateB.collideMask & stateA.collideBits) {
      if (stateB.callback) stateB.callback(idA);
    }
    noa2.ents.onPairwiseEntityCollision(idA, idB);
  }
  function cylindricalHitTest(stateA, stateB, intervalA, intervalB) {
    if (stateA.cylinder) {
      if (stateB.cylinder) {
        return cylinderCylinderTest(intervalA, intervalB);
      } else {
        return cylinderBoxTest(intervalA, intervalB);
      }
    } else if (stateB.cylinder) {
      return cylinderBoxTest(intervalB, intervalA);
    }
    return true;
  }
  function cylinderCylinderTest(a2, b) {
    var rada = (a2[3] - a2[0]) / 2;
    var radb = (b[3] - b[0]) / 2;
    var dx2 = a2[0] + rada - (b[0] + radb);
    var dz = a2[2] + rada - (b[2] + radb);
    var distsq = dx2 * dx2 + dz * dz;
    var radsum = rada + radb;
    return distsq <= radsum * radsum;
  }
  function cylinderBoxTest(cyl, cube) {
    var rad = (cyl[3] - cyl[0]) / 2;
    var cx = cyl[0] + rad;
    var cz = cyl[2] + rad;
    var px = clamp(cx, cube[0], cube[3]);
    var pz = clamp(cz, cube[2], cube[5]);
    var dx2 = px - cx;
    var dz = pz - cz;
    var distsq = dx2 * dx2 + dz * dz;
    return distsq <= rad * rad;
  }
  function clamp(val, lo, hi) {
    return val < lo ? lo : val > hi ? hi : val;
  }
}

// ../../node_modules/noa-engine/src/components/collideTerrain.js
function collideTerrain_default(noa) {
  return {
    name: "collideTerrain",
    order: 0,
    state: {
      callback: null
    },
    onAdd: function(eid, state) {
      var ents = noa.entities;
      if (ents.hasPhysics(eid)) {
        var body = ents.getPhysics(eid).body;
        body.onCollide = function bodyOnCollide(impulse) {
          var cb = noa.ents.getCollideTerrain(eid).callback;
          if (cb) cb(impulse, eid);
        };
      }
    },
    onRemove: function(eid, state) {
      var ents = noa.entities;
      if (ents.hasPhysics(eid)) {
        ents.getPhysics(eid).body.onCollide = null;
      }
    }
  };
}

// ../../node_modules/noa-engine/src/components/fadeOnZoom.js
function fadeOnZoom_default(noa) {
  return {
    name: "fadeOnZoom",
    order: 99,
    state: {
      cutoff: 1.5
    },
    onAdd: null,
    onRemove: null,
    system: function fadeOnZoomProc(dt, states) {
      var zoom = noa.camera.currentZoom;
      for (var i = 0; i < states.length; i++) {
        checkZoom(states[i], zoom, noa);
      }
    }
  };
}
function checkZoom(state, zoom, noa) {
  if (!noa.ents.hasMesh(state.__id)) return;
  var mesh = noa.ents.getMeshData(state.__id).mesh;
  if (!mesh.metadata) return;
  var shouldHide = zoom < state.cutoff;
  noa.rendering.setMeshVisibility(mesh, !shouldHide);
}

// ../../node_modules/noa-engine/src/components/followsEntity.js
var import_gl_vec34 = __toESM(require_gl_vec3());
function followsEntity_default(noa) {
  return {
    name: "followsEntity",
    order: 50,
    state: {
      entity: 0 | 0,
      offset: null,
      onTargetMissing: null
    },
    onAdd: function(eid, state) {
      var off = import_gl_vec34.default.create();
      state.offset = state.offset ? import_gl_vec34.default.copy(off, state.offset) : off;
      updatePosition(state);
      updateRenderPosition(state);
    },
    onRemove: null,
    // on tick, copy over regular positions
    system: function followEntity(dt, states) {
      for (var i = 0; i < states.length; i++) {
        updatePosition(states[i]);
      }
    },
    // on render, copy over render positions
    renderSystem: function followEntityMesh(dt, states) {
      for (var i = 0; i < states.length; i++) {
        updateRenderPosition(states[i]);
      }
    }
  };
  function updatePosition(state) {
    var id = state.__id;
    var self = noa.ents.getPositionData(id);
    var other = noa.ents.getPositionData(state.entity);
    if (!other) {
      if (state.onTargetMissing) state.onTargetMissing(id);
      noa.ents.removeComponent(id, noa.ents.names.followsEntity);
    } else {
      import_gl_vec34.default.add(self._localPosition, other._localPosition, state.offset);
    }
  }
  function updateRenderPosition(state) {
    var id = state.__id;
    var self = noa.ents.getPositionData(id);
    var other = noa.ents.getPositionData(state.entity);
    if (other) {
      import_gl_vec34.default.add(self._renderPosition, other._renderPosition, state.offset);
    }
  }
}

// ../../node_modules/noa-engine/src/components/mesh.js
var import_gl_vec35 = __toESM(require_gl_vec3());
function mesh_default(noa) {
  return {
    name: "mesh",
    order: 100,
    state: {
      mesh: null,
      offset: null
    },
    onAdd: function(eid, state) {
      var posDat = noa.ents.getPositionData(eid);
      if (state.mesh) {
        noa.rendering.addMeshToScene(state.mesh, false, posDat.position);
      } else {
        throw new Error("Mesh component added without a mesh - probably a bug!");
      }
      if (!state.offset) state.offset = import_gl_vec35.default.create();
      var rpos = posDat._renderPosition;
      state.mesh.position.copyFromFloats(
        rpos[0] + state.offset[0],
        rpos[1] + state.offset[1],
        rpos[2] + state.offset[2]
      );
    },
    onRemove: function(eid, state) {
      state.mesh.dispose();
    },
    renderSystem: function(dt, states) {
      for (var i = 0; i < states.length; i++) {
        var state = states[i];
        var id = state.__id;
        var rpos = noa.ents.getPositionData(id)._renderPosition;
        state.mesh.position.copyFromFloats(
          rpos[0] + state.offset[0],
          rpos[1] + state.offset[1],
          rpos[2] + state.offset[2]
        );
      }
    }
  };
}

// ../../node_modules/noa-engine/src/components/movement.js
var import_gl_vec36 = __toESM(require_gl_vec3());
function MovementState() {
  this.heading = 0;
  this.running = false;
  this.jumping = false;
  this.maxSpeed = 10;
  this.moveForce = 30;
  this.responsiveness = 15;
  this.runningFriction = 0;
  this.standingFriction = 2;
  this.airMoveMult = 0.5;
  this.jumpImpulse = 10;
  this.jumpForce = 12;
  this.jumpTime = 500;
  this.airJumps = 1;
  this._jumpCount = 0;
  this._currjumptime = 0;
  this._isJumping = false;
}
function movement_default(noa) {
  return {
    name: "movement",
    order: 30,
    state: new MovementState(),
    onAdd: null,
    onRemove: null,
    system: function movementProcessor(dt, states) {
      var ents = noa.entities;
      for (var i = 0; i < states.length; i++) {
        var state = states[i];
        var phys = ents.getPhysics(state.__id);
        if (phys) applyMovementPhysics(dt, state, phys.body);
      }
    }
  };
}
var tempvec = import_gl_vec36.default.create();
var tempvec2 = import_gl_vec36.default.create();
var zeroVec = import_gl_vec36.default.create();
function applyMovementPhysics(dt, state, body) {
  var onGround = body.atRestY() < 0;
  var canjump = onGround || state._jumpCount < state.airJumps;
  if (onGround) {
    state._isJumping = false;
    state._jumpCount = 0;
  }
  if (state.jumping) {
    if (state._isJumping) {
      if (state._currjumptime > 0) {
        var jf = state.jumpForce;
        if (state._currjumptime < dt) jf *= state._currjumptime / dt;
        body.applyForce([0, jf, 0]);
        state._currjumptime -= dt;
      }
    } else if (canjump) {
      state._isJumping = true;
      if (!onGround) state._jumpCount++;
      state._currjumptime = state.jumpTime;
      body.applyImpulse([0, state.jumpImpulse, 0]);
      if (!onGround && body.velocity[1] < 0) body.velocity[1] = 0;
    }
  } else {
    state._isJumping = false;
  }
  var m = tempvec;
  var push = tempvec2;
  if (state.running) {
    var speed = state.maxSpeed;
    import_gl_vec36.default.set(m, 0, 0, speed);
    import_gl_vec36.default.rotateY(m, m, zeroVec, state.heading);
    import_gl_vec36.default.subtract(push, m, body.velocity);
    push[1] = 0;
    var pushLen = import_gl_vec36.default.length(push);
    import_gl_vec36.default.normalize(push, push);
    if (pushLen > 0) {
      var canPush = state.moveForce;
      if (!onGround) canPush *= state.airMoveMult;
      var pushAmt = state.responsiveness * pushLen;
      if (canPush > pushAmt) canPush = pushAmt;
      import_gl_vec36.default.scale(push, push, canPush);
      body.applyForce(push);
    }
    body.friction = state.runningFriction;
  } else {
    body.friction = state.standingFriction;
  }
}

// ../../node_modules/noa-engine/src/components/receivesInputs.js
function receivesInputs_default(noa) {
  return {
    name: "receivesInputs",
    order: 20,
    state: {},
    onAdd: null,
    onRemove: null,
    system: function inputProcessor(dt, states) {
      var ents = noa.entities;
      var inputState = noa.inputs.state;
      var camHeading = noa.camera.heading;
      for (var i = 0; i < states.length; i++) {
        var state = states[i];
        var moveState = ents.getMovement(state.__id);
        setMovementState(moveState, inputState, camHeading);
      }
    }
  };
}
function setMovementState(state, inputs, camHeading) {
  state.jumping = !!inputs.jump;
  var fb = inputs.forward ? inputs.backward ? 0 : 1 : inputs.backward ? -1 : 0;
  var rl = inputs.right ? inputs.left ? 0 : 1 : inputs.left ? -1 : 0;
  if ((fb | rl) === 0) {
    state.running = false;
  } else {
    state.running = true;
    if (fb) {
      if (fb == -1) camHeading += Math.PI;
      if (rl) {
        camHeading += Math.PI / 4 * fb * rl;
      }
    } else {
      camHeading += rl * Math.PI / 2;
    }
    state.heading = camHeading;
  }
}

// ../../node_modules/noa-engine/src/components/shadow.js
var import_gl_vec37 = __toESM(require_gl_vec3());

// ../../node_modules/@babylonjs/core/Meshes/Builders/discBuilder.js
function CreateDiscVertexData(options) {
  const positions = [];
  const indices = [];
  const normals = [];
  const uvs = [];
  const radius = options.radius || 0.5;
  const tessellation = options.tessellation || 64;
  const arc = options.arc && (options.arc <= 0 || options.arc > 1) ? 1 : options.arc || 1;
  const sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;
  positions.push(0, 0, 0);
  uvs.push(0.5, 0.5);
  const theta = Math.PI * 2 * arc;
  const step = arc === 1 ? theta / tessellation : theta / (tessellation - 1);
  let a2 = 0;
  for (let t = 0; t < tessellation; t++) {
    const x = Math.cos(a2);
    const y = Math.sin(a2);
    const u = (x + 1) / 2;
    const v = (1 - y) / 2;
    positions.push(radius * x, radius * y, 0);
    uvs.push(u, CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - v : v);
    a2 += step;
  }
  if (arc === 1) {
    positions.push(positions[3], positions[4], positions[5]);
    uvs.push(uvs[2], CompatibilityOptions.UseOpenGLOrientationForUV ? 1 - uvs[3] : uvs[3]);
  }
  const vertexNb = positions.length / 3;
  for (let i = 1; i < vertexNb - 1; i++) {
    indices.push(i + 1, 0, i);
  }
  VertexData.ComputeNormals(positions, indices, normals);
  VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);
  const vertexData = new VertexData();
  vertexData.indices = indices;
  vertexData.positions = positions;
  vertexData.normals = normals;
  vertexData.uvs = uvs;
  return vertexData;
}
function CreateDisc(name66, options = {}, scene = null) {
  const disc = new Mesh(name66, scene);
  options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);
  disc._originalBuilderSideOrientation = options.sideOrientation;
  const vertexData = CreateDiscVertexData(options);
  vertexData.applyToMesh(disc, options.updatable);
  return disc;
}
VertexData.CreateDisc = CreateDiscVertexData;
Mesh.CreateDisc = (name66, radius, tessellation, scene = null, updatable, sideOrientation) => {
  const options = {
    radius,
    tessellation,
    sideOrientation,
    updatable
  };
  return CreateDisc(name66, options, scene);
};

// ../../node_modules/@babylonjs/core/Meshes/instancedMesh.js
Mesh._instancedMeshFactory = (name66, mesh) => {
  const instance = new InstancedMesh(name66, mesh);
  if (mesh.instancedBuffers) {
    instance.instancedBuffers = {};
    for (const key in mesh.instancedBuffers) {
      instance.instancedBuffers[key] = mesh.instancedBuffers[key];
    }
  }
  return instance;
};
var InstancedMesh = class extends AbstractMesh {
  /**
   * Creates a new InstancedMesh object from the mesh source.
   * @param name defines the name of the instance
   * @param source the mesh to create the instance from
   */
  constructor(name66, source) {
    super(name66, source.getScene());
    this._indexInSourceMeshInstanceArray = -1;
    this._distanceToCamera = 0;
    source.addInstance(this);
    this._sourceMesh = source;
    this._unIndexed = source._unIndexed;
    this.position.copyFrom(source.position);
    this.rotation.copyFrom(source.rotation);
    this.scaling.copyFrom(source.scaling);
    if (source.rotationQuaternion) {
      this.rotationQuaternion = source.rotationQuaternion.clone();
    }
    this.animations = source.animations.slice();
    for (const range of source.getAnimationRanges()) {
      if (range != null) {
        this.createAnimationRange(range.name, range.from, range.to);
      }
    }
    this.infiniteDistance = source.infiniteDistance;
    this.setPivotMatrix(source.getPivotMatrix());
    this.refreshBoundingInfo(true, true);
    this._syncSubMeshes();
  }
  /**
   * @returns the string "InstancedMesh".
   */
  getClassName() {
    return "InstancedMesh";
  }
  /** Gets the list of lights affecting that mesh */
  get lightSources() {
    return this._sourceMesh._lightSources;
  }
  _resyncLightSources() {
  }
  _resyncLightSource() {
  }
  _removeLightSource() {
  }
  // Methods
  /**
   * If the source mesh receives shadows
   */
  get receiveShadows() {
    return this._sourceMesh.receiveShadows;
  }
  set receiveShadows(_value) {
    if (this._sourceMesh?.receiveShadows !== _value) {
      Tools.Warn("Setting receiveShadows on an instanced mesh has no effect");
    }
  }
  /**
   * The material of the source mesh
   */
  get material() {
    return this._sourceMesh.material;
  }
  set material(_value) {
    if (this._sourceMesh?.material !== _value) {
      Tools.Warn("Setting material on an instanced mesh has no effect");
    }
  }
  /**
   * Visibility of the source mesh
   */
  get visibility() {
    return this._sourceMesh.visibility;
  }
  set visibility(_value) {
    if (this._sourceMesh?.visibility !== _value) {
      Tools.Warn("Setting visibility on an instanced mesh has no effect");
    }
  }
  /**
   * Skeleton of the source mesh
   */
  get skeleton() {
    return this._sourceMesh.skeleton;
  }
  set skeleton(_value) {
    if (this._sourceMesh?.skeleton !== _value) {
      Tools.Warn("Setting skeleton on an instanced mesh has no effect");
    }
  }
  /**
   * Rendering ground id of the source mesh
   */
  get renderingGroupId() {
    return this._sourceMesh.renderingGroupId;
  }
  set renderingGroupId(value) {
    if (!this._sourceMesh || value === this._sourceMesh.renderingGroupId) {
      return;
    }
    Logger.Warn("Note - setting renderingGroupId of an instanced mesh has no effect on the scene");
  }
  /**
   * @returns the total number of vertices (integer).
   */
  getTotalVertices() {
    return this._sourceMesh ? this._sourceMesh.getTotalVertices() : 0;
  }
  /**
   * Returns a positive integer : the total number of indices in this mesh geometry.
   * @returns the number of indices or zero if the mesh has no geometry.
   */
  getTotalIndices() {
    return this._sourceMesh.getTotalIndices();
  }
  /**
   * The source mesh of the instance
   */
  get sourceMesh() {
    return this._sourceMesh;
  }
  /**
   * Creates a new InstancedMesh object from the mesh model.
   * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/copies/instances
   * @param name defines the name of the new instance
   * @returns a new InstancedMesh
   */
  createInstance(name66) {
    return this._sourceMesh.createInstance(name66);
  }
  /**
   * Is this node ready to be used/rendered
   * @param completeCheck defines if a complete check (including materials and lights) has to be done (false by default)
   * @returns {boolean} is it ready
   */
  isReady(completeCheck = false) {
    return this._sourceMesh.isReady(completeCheck, true);
  }
  /**
   * Returns an array of integers or a typed array (Int32Array, Uint32Array, Uint16Array) populated with the mesh indices.
   * @param kind kind of verticies to retrieve (eg. positions, normals, uvs, etc.)
   * @param copyWhenShared If true (default false) and and if the mesh geometry is shared among some other meshes, the returned array is a copy of the internal one.
   * @param forceCopy defines a boolean forcing the copy of the buffer no matter what the value of copyWhenShared is
   * @returns a float array or a Float32Array of the requested kind of data : positions, normals, uvs, etc.
   */
  getVerticesData(kind, copyWhenShared, forceCopy) {
    return this._sourceMesh.getVerticesData(kind, copyWhenShared, forceCopy);
  }
  /**
   * Sets the vertex data of the mesh geometry for the requested `kind`.
   * If the mesh has no geometry, a new Geometry object is set to the mesh and then passed this vertex data.
   * The `data` are either a numeric array either a Float32Array.
   * The parameter `updatable` is passed as is to the underlying Geometry object constructor (if initially none) or updater.
   * The parameter `stride` is an optional positive integer, it is usually automatically deducted from the `kind` (3 for positions or normals, 2 for UV, etc).
   * Note that a new underlying VertexBuffer object is created each call.
   * If the `kind` is the `PositionKind`, the mesh BoundingInfo is renewed, so the bounding box and sphere, and the mesh World Matrix is recomputed.
   *
   * Possible `kind` values :
   * - VertexBuffer.PositionKind
   * - VertexBuffer.UVKind
   * - VertexBuffer.UV2Kind
   * - VertexBuffer.UV3Kind
   * - VertexBuffer.UV4Kind
   * - VertexBuffer.UV5Kind
   * - VertexBuffer.UV6Kind
   * - VertexBuffer.ColorKind
   * - VertexBuffer.MatricesIndicesKind
   * - VertexBuffer.MatricesIndicesExtraKind
   * - VertexBuffer.MatricesWeightsKind
   * - VertexBuffer.MatricesWeightsExtraKind
   *
   * Returns the Mesh.
   * @param kind defines vertex data kind
   * @param data defines the data source
   * @param updatable defines if the data must be flagged as updatable (false as default)
   * @param stride defines the vertex stride (optional)
   * @returns the current mesh
   */
  setVerticesData(kind, data, updatable, stride) {
    if (this.sourceMesh) {
      this.sourceMesh.setVerticesData(kind, data, updatable, stride);
    }
    return this.sourceMesh;
  }
  /**
   * Updates the existing vertex data of the mesh geometry for the requested `kind`.
   * If the mesh has no geometry, it is simply returned as it is.
   * The `data` are either a numeric array either a Float32Array.
   * No new underlying VertexBuffer object is created.
   * If the `kind` is the `PositionKind` and if `updateExtends` is true, the mesh BoundingInfo is renewed, so the bounding box and sphere, and the mesh World Matrix is recomputed.
   * If the parameter `makeItUnique` is true, a new global geometry is created from this positions and is set to the mesh.
   *
   * Possible `kind` values :
   * - VertexBuffer.PositionKind
   * - VertexBuffer.UVKind
   * - VertexBuffer.UV2Kind
   * - VertexBuffer.UV3Kind
   * - VertexBuffer.UV4Kind
   * - VertexBuffer.UV5Kind
   * - VertexBuffer.UV6Kind
   * - VertexBuffer.ColorKind
   * - VertexBuffer.MatricesIndicesKind
   * - VertexBuffer.MatricesIndicesExtraKind
   * - VertexBuffer.MatricesWeightsKind
   * - VertexBuffer.MatricesWeightsExtraKind
   *
   * Returns the Mesh.
   * @param kind defines vertex data kind
   * @param data defines the data source
   * @param updateExtends defines if extends info of the mesh must be updated (can be null). This is mostly useful for "position" kind
   * @param makeItUnique defines it the updated vertex buffer must be flagged as unique (false by default)
   * @returns the source mesh
   */
  updateVerticesData(kind, data, updateExtends, makeItUnique) {
    if (this.sourceMesh) {
      this.sourceMesh.updateVerticesData(kind, data, updateExtends, makeItUnique);
    }
    return this.sourceMesh;
  }
  /**
   * Sets the mesh indices.
   * Expects an array populated with integers or a typed array (Int32Array, Uint32Array, Uint16Array).
   * If the mesh has no geometry, a new Geometry object is created and set to the mesh.
   * This method creates a new index buffer each call.
   * Returns the Mesh.
   * @param indices the source data
   * @param totalVertices defines the total number of vertices referenced by indices (could be null)
   * @returns source mesh
   */
  setIndices(indices, totalVertices = null) {
    if (this.sourceMesh) {
      this.sourceMesh.setIndices(indices, totalVertices);
    }
    return this.sourceMesh;
  }
  /**
   * Boolean : True if the mesh owns the requested kind of data.
   * @param kind defines which buffer to check (positions, indices, normals, etc). Possible `kind` values :
   * - VertexBuffer.PositionKind
   * - VertexBuffer.UVKind
   * - VertexBuffer.UV2Kind
   * - VertexBuffer.UV3Kind
   * - VertexBuffer.UV4Kind
   * - VertexBuffer.UV5Kind
   * - VertexBuffer.UV6Kind
   * - VertexBuffer.ColorKind
   * - VertexBuffer.MatricesIndicesKind
   * - VertexBuffer.MatricesIndicesExtraKind
   * - VertexBuffer.MatricesWeightsKind
   * - VertexBuffer.MatricesWeightsExtraKind
   * @returns true if data kind is present
   */
  isVerticesDataPresent(kind) {
    return this._sourceMesh.isVerticesDataPresent(kind);
  }
  /**
   * @returns an array of indices (IndicesArray).
   */
  getIndices() {
    return this._sourceMesh.getIndices();
  }
  get _positions() {
    return this._sourceMesh._positions;
  }
  /**
   * This method recomputes and sets a new BoundingInfo to the mesh unless it is locked.
   * This means the mesh underlying bounding box and sphere are recomputed.
   * @param applySkeleton defines whether to apply the skeleton before computing the bounding info
   * @param applyMorph  defines whether to apply the morph target before computing the bounding info
   * @returns the current mesh
   */
  refreshBoundingInfo(applySkeleton = false, applyMorph = false) {
    if (this.hasBoundingInfo && this.getBoundingInfo().isLocked) {
      return this;
    }
    const bias = this._sourceMesh.geometry ? this._sourceMesh.geometry.boundingBias : null;
    this._refreshBoundingInfo(this._sourceMesh._getPositionData(applySkeleton, applyMorph), bias);
    return this;
  }
  /** @internal */
  _preActivate() {
    if (this._currentLOD) {
      this._currentLOD._preActivate();
    }
    return this;
  }
  /**
   * @internal
   */
  _activate(renderId, intermediateRendering) {
    super._activate(renderId, intermediateRendering);
    if (!this._sourceMesh.subMeshes) {
      Logger.Warn("Instances should only be created for meshes with geometry.");
    }
    if (this._currentLOD) {
      const differentSign = this._currentLOD._getWorldMatrixDeterminant() >= 0 !== this._getWorldMatrixDeterminant() >= 0;
      if (differentSign) {
        this._internalAbstractMeshDataInfo._actAsRegularMesh = true;
        return true;
      }
      this._internalAbstractMeshDataInfo._actAsRegularMesh = false;
      this._currentLOD._registerInstanceForRenderId(this, renderId);
      if (intermediateRendering) {
        if (!this._currentLOD._internalAbstractMeshDataInfo._isActiveIntermediate) {
          this._currentLOD._internalAbstractMeshDataInfo._onlyForInstancesIntermediate = true;
          return true;
        }
      } else {
        if (!this._currentLOD._internalAbstractMeshDataInfo._isActive) {
          this._currentLOD._internalAbstractMeshDataInfo._onlyForInstances = true;
          return true;
        }
      }
    }
    return false;
  }
  /** @internal */
  _postActivate() {
    if (this._sourceMesh.edgesShareWithInstances && this._sourceMesh._edgesRenderer && this._sourceMesh._edgesRenderer.isEnabled && this._sourceMesh._renderingGroup) {
      this._sourceMesh._renderingGroup._edgesRenderers.pushNoDuplicate(this._sourceMesh._edgesRenderer);
      this._sourceMesh._edgesRenderer.customInstances.push(this.getWorldMatrix());
    } else if (this._edgesRenderer && this._edgesRenderer.isEnabled && this._sourceMesh._renderingGroup) {
      this._sourceMesh._renderingGroup._edgesRenderers.push(this._edgesRenderer);
    }
  }
  getWorldMatrix() {
    if (this._currentLOD && this._currentLOD.billboardMode !== TransformNode.BILLBOARDMODE_NONE && this._currentLOD._masterMesh !== this) {
      if (!this._billboardWorldMatrix) {
        this._billboardWorldMatrix = new Matrix();
      }
      const tempMaster = this._currentLOD._masterMesh;
      this._currentLOD._masterMesh = this;
      TmpVectors.Vector3[7].copyFrom(this._currentLOD.position);
      this._currentLOD.position.set(0, 0, 0);
      this._billboardWorldMatrix.copyFrom(this._currentLOD.computeWorldMatrix(true));
      this._currentLOD.position.copyFrom(TmpVectors.Vector3[7]);
      this._currentLOD._masterMesh = tempMaster;
      return this._billboardWorldMatrix;
    }
    return super.getWorldMatrix();
  }
  get isAnInstance() {
    return true;
  }
  /**
   * Returns the current associated LOD AbstractMesh.
   * @param camera defines the camera to use to pick the LOD level
   * @returns a Mesh or `null` if no LOD is associated with the AbstractMesh
   */
  getLOD(camera) {
    if (!camera) {
      return this;
    }
    const sourceMeshLODLevels = this.sourceMesh.getLODLevels();
    if (!sourceMeshLODLevels || sourceMeshLODLevels.length === 0) {
      this._currentLOD = this.sourceMesh;
    } else {
      const boundingInfo = this.getBoundingInfo();
      this._currentLOD = this.sourceMesh.getLOD(camera, boundingInfo.boundingSphere);
    }
    return this._currentLOD;
  }
  /**
   * @internal
   */
  _preActivateForIntermediateRendering(renderId) {
    return this.sourceMesh._preActivateForIntermediateRendering(renderId);
  }
  /** @internal */
  _syncSubMeshes() {
    this.releaseSubMeshes();
    if (this._sourceMesh.subMeshes) {
      for (let index = 0; index < this._sourceMesh.subMeshes.length; index++) {
        this._sourceMesh.subMeshes[index].clone(this, this._sourceMesh);
      }
    }
    return this;
  }
  /** @internal */
  _generatePointsArray() {
    return this._sourceMesh._generatePointsArray();
  }
  /** @internal */
  _updateBoundingInfo() {
    if (this.hasBoundingInfo) {
      this.getBoundingInfo().update(this.worldMatrixFromCache);
    } else {
      this.buildBoundingInfo(this.absolutePosition, this.absolutePosition, this.worldMatrixFromCache);
    }
    this._updateSubMeshesBoundingInfo(this.worldMatrixFromCache);
    return this;
  }
  /**
   * Creates a new InstancedMesh from the current mesh.
   *
   * Returns the clone.
   * @param name the cloned mesh name
   * @param newParent the optional Node to parent the clone to.
   * @param doNotCloneChildren if `true` the model children aren't cloned.
   * @param newSourceMesh if set this mesh will be used as the source mesh instead of ths instance's one
   * @returns the clone
   */
  clone(name66, newParent = null, doNotCloneChildren, newSourceMesh) {
    const result = (newSourceMesh || this._sourceMesh).createInstance(name66);
    DeepCopier.DeepCopy(this, result, [
      "name",
      "subMeshes",
      "uniqueId",
      "parent",
      "lightSources",
      "receiveShadows",
      "material",
      "visibility",
      "skeleton",
      "sourceMesh",
      "isAnInstance",
      "facetNb",
      "isFacetDataEnabled",
      "isBlocked",
      "useBones",
      "hasInstances",
      "collider",
      "edgesRenderer",
      "forward",
      "up",
      "right",
      "absolutePosition",
      "absoluteScaling",
      "absoluteRotationQuaternion",
      "isWorldMatrixFrozen",
      "nonUniformScaling",
      "behaviors",
      "worldMatrixFromCache",
      "hasThinInstances",
      "hasBoundingInfo"
    ], []);
    this.refreshBoundingInfo();
    if (newParent) {
      result.parent = newParent;
    }
    if (!doNotCloneChildren) {
      for (let index = 0; index < this.getScene().meshes.length; index++) {
        const mesh = this.getScene().meshes[index];
        if (mesh.parent === this) {
          mesh.clone(mesh.name, result);
        }
      }
    }
    result.computeWorldMatrix(true);
    this.onClonedObservable.notifyObservers(result);
    return result;
  }
  /**
   * Disposes the InstancedMesh.
   * Returns nothing.
   * @param doNotRecurse Set to true to not recurse into each children (recurse into each children by default)
   * @param disposeMaterialAndTextures Set to true to also dispose referenced materials and textures (false by default)
   */
  dispose(doNotRecurse, disposeMaterialAndTextures = false) {
    this._sourceMesh.removeInstance(this);
    super.dispose(doNotRecurse, disposeMaterialAndTextures);
  }
  /**
   * @internal
   */
  _serializeAsParent(serializationObject) {
    super._serializeAsParent(serializationObject);
    serializationObject.parentId = this._sourceMesh.uniqueId;
    serializationObject.parentInstanceIndex = this._indexInSourceMeshInstanceArray;
  }
  /**
   * Instantiate (when possible) or clone that node with its hierarchy
   * @param newParent defines the new parent to use for the instance (or clone)
   * @param options defines options to configure how copy is done
   * @param options.doNotInstantiate defines if the model must be instantiated or just cloned
   * @param options.newSourcedMesh newSourcedMesh the new source mesh for the instance (or clone)
   * @param onNewNodeCreated defines an option callback to call when a clone or an instance is created
   * @returns an instance (or a clone) of the current node with its hierarchy
   */
  instantiateHierarchy(newParent = null, options, onNewNodeCreated) {
    const clone3 = this.clone("Clone of " + (this.name || this.id), newParent || this.parent, true, options && options.newSourcedMesh);
    if (clone3) {
      if (onNewNodeCreated) {
        onNewNodeCreated(this, clone3);
      }
    }
    for (const child of this.getChildTransformNodes(true)) {
      child.instantiateHierarchy(clone3, options, onNewNodeCreated);
    }
    return clone3;
  }
};
Mesh.prototype.registerInstancedBuffer = function(kind, stride) {
  this._userInstancedBuffersStorage?.vertexBuffers[kind]?.dispose();
  if (!this.instancedBuffers) {
    this.instancedBuffers = {};
    for (const instance of this.instances) {
      instance.instancedBuffers = {};
    }
  }
  if (!this._userInstancedBuffersStorage) {
    this._userInstancedBuffersStorage = {
      data: {},
      vertexBuffers: {},
      strides: {},
      sizes: {},
      vertexArrayObjects: this.getEngine().getCaps().vertexArrayObject ? {} : void 0
    };
  }
  this.instancedBuffers[kind] = null;
  this._userInstancedBuffersStorage.strides[kind] = stride;
  this._userInstancedBuffersStorage.sizes[kind] = stride * 32;
  this._userInstancedBuffersStorage.data[kind] = new Float32Array(this._userInstancedBuffersStorage.sizes[kind]);
  this._userInstancedBuffersStorage.vertexBuffers[kind] = new VertexBuffer(this.getEngine(), this._userInstancedBuffersStorage.data[kind], kind, true, false, stride, true);
  for (const instance of this.instances) {
    instance.instancedBuffers[kind] = null;
  }
  this._invalidateInstanceVertexArrayObject();
  this._markSubMeshesAsAttributesDirty();
};
Mesh.prototype._processInstancedBuffers = function(visibleInstances, renderSelf) {
  const instanceCount = visibleInstances ? visibleInstances.length : 0;
  for (const kind in this.instancedBuffers) {
    let size = this._userInstancedBuffersStorage.sizes[kind];
    const stride = this._userInstancedBuffersStorage.strides[kind];
    const expectedSize = (instanceCount + 1) * stride;
    while (size < expectedSize) {
      size *= 2;
    }
    if (this._userInstancedBuffersStorage.data[kind].length != size) {
      this._userInstancedBuffersStorage.data[kind] = new Float32Array(size);
      this._userInstancedBuffersStorage.sizes[kind] = size;
      if (this._userInstancedBuffersStorage.vertexBuffers[kind]) {
        this._userInstancedBuffersStorage.vertexBuffers[kind].dispose();
        this._userInstancedBuffersStorage.vertexBuffers[kind] = null;
      }
    }
    const data = this._userInstancedBuffersStorage.data[kind];
    let offset = 0;
    if (renderSelf) {
      const value = this.instancedBuffers[kind];
      if (value.toArray) {
        value.toArray(data, offset);
      } else if (value.copyToArray) {
        value.copyToArray(data, offset);
      } else {
        data[offset] = value;
      }
      offset += stride;
    }
    for (let instanceIndex = 0; instanceIndex < instanceCount; instanceIndex++) {
      const instance = visibleInstances[instanceIndex];
      const value = instance.instancedBuffers[kind];
      if (value.toArray) {
        value.toArray(data, offset);
      } else if (value.copyToArray) {
        value.copyToArray(data, offset);
      } else {
        data[offset] = value;
      }
      offset += stride;
    }
    if (!this._userInstancedBuffersStorage.vertexBuffers[kind]) {
      this._userInstancedBuffersStorage.vertexBuffers[kind] = new VertexBuffer(this.getEngine(), this._userInstancedBuffersStorage.data[kind], kind, true, false, stride, true);
      this._invalidateInstanceVertexArrayObject();
    } else {
      this._userInstancedBuffersStorage.vertexBuffers[kind].updateDirectly(data, 0);
    }
  }
};
Mesh.prototype._invalidateInstanceVertexArrayObject = function() {
  if (!this._userInstancedBuffersStorage || this._userInstancedBuffersStorage.vertexArrayObjects === void 0) {
    return;
  }
  for (const kind in this._userInstancedBuffersStorage.vertexArrayObjects) {
    this.getEngine().releaseVertexArrayObject(this._userInstancedBuffersStorage.vertexArrayObjects[kind]);
  }
  this._userInstancedBuffersStorage.vertexArrayObjects = {};
};
Mesh.prototype._disposeInstanceSpecificData = function() {
  if (this._instanceDataStorage.instancesBuffer) {
    this._instanceDataStorage.instancesBuffer.dispose();
    this._instanceDataStorage.instancesBuffer = null;
  }
  while (this.instances.length) {
    this.instances[0].dispose();
  }
  for (const kind in this.instancedBuffers) {
    if (this._userInstancedBuffersStorage.vertexBuffers[kind]) {
      this._userInstancedBuffersStorage.vertexBuffers[kind].dispose();
    }
  }
  this._invalidateInstanceVertexArrayObject();
  this.instancedBuffers = {};
};

// ../../node_modules/noa-engine/src/components/shadow.js
function shadow_default(noa, distance2 = 10) {
  var shadowDist = distance2;
  var scene = noa.rendering.getScene();
  var disc = CreateDisc("shadow", { radius: 0.75, tessellation: 30 }, scene);
  disc.rotation.x = Math.PI / 2;
  var mat = noa.rendering.makeStandardMaterial("shadow_component_mat");
  mat.diffuseColor.set(0, 0, 0);
  mat.ambientColor.set(0, 0, 0);
  mat.alpha = 0.5;
  disc.material = mat;
  mat.freeze();
  noa.rendering.setMeshVisibility(disc, false);
  return {
    name: "shadow",
    order: 80,
    state: {
      size: 0.5,
      _mesh: null
    },
    onAdd: function(eid, state) {
      var mesh = disc.createInstance("shadow_instance");
      noa.rendering.addMeshToScene(mesh);
      mesh.setEnabled(false);
      state._mesh = mesh;
    },
    onRemove: function(eid, state) {
      state._mesh.dispose();
      state._mesh = null;
    },
    system: function shadowSystem(dt, states) {
      var cpos = noa.camera._localGetPosition();
      var dist2 = shadowDist;
      for (var i = 0; i < states.length; i++) {
        var state = states[i];
        var posState = noa.ents.getPositionData(state.__id);
        var physState = noa.ents.getPhysics(state.__id);
        updateShadowHeight(noa, posState, physState, state._mesh, state.size, dist2, cpos);
      }
    },
    renderSystem: function(dt, states) {
      for (var i = 0; i < states.length; i++) {
        var state = states[i];
        var rpos = noa.ents.getPositionData(state.__id)._renderPosition;
        var spos = state._mesh.position;
        spos.x = rpos[0];
        spos.z = rpos[2];
      }
    }
  };
}
var shadowPos = import_gl_vec37.default.fromValues(0, 0, 0);
var down = import_gl_vec37.default.fromValues(0, -1, 0);
function updateShadowHeight(noa, posDat, physDat, mesh, size, shadowDist, camPos) {
  var localY;
  if (physDat && physDat.body.resting[1] < 0) {
    localY = posDat._localPosition[1];
  } else {
    var res = noa._localPick(posDat._localPosition, down, shadowDist);
    if (!res) {
      mesh.setEnabled(false);
      return;
    }
    localY = res.position[1] - noa.worldOriginOffset[1];
  }
  localY = Math.round(localY);
  import_gl_vec37.default.copy(shadowPos, posDat._localPosition);
  shadowPos[1] = localY;
  var sqdist = import_gl_vec37.default.squaredDistance(camPos, shadowPos);
  var offset = 0.01 + 0.1 * (sqdist / 1600);
  if (offset > 0.1) offset = 0.1;
  mesh.position.y = localY + offset;
  var dist2 = posDat._localPosition[1] - localY;
  var scale3 = size * 0.7 * (1 - dist2 / shadowDist);
  mesh.scaling.copyFromFloats(scale3, scale3, scale3);
  mesh.setEnabled(true);
}

// ../../node_modules/noa-engine/src/components/smoothCamera.js
function smoothCamera_default(noa) {
  var compName = "smoothCamera";
  return {
    name: compName,
    order: 99,
    state: {
      time: 100.1
    },
    onAdd: null,
    onRemove: null,
    system: function(dt, states) {
      for (var i = 0; i < states.length; i++) {
        var state = states[i];
        state.time -= dt;
        if (state.time < 0) noa.ents.removeComponent(state.__id, compName);
      }
    }
  };
}

// ../../node_modules/noa-engine/src/lib/entities.js
var defaultOptions2 = {
  shadowDistance: 10
};
var Entities = class extends import_ent_comp.default {
  /** @internal */
  constructor(noa, opts) {
    super();
    opts = Object.assign({}, defaultOptions2, opts);
    var componentArgs = {
      "shadow": opts.shadowDistance
    };
    this.noa = noa;
    this.names = {};
    var compDefs = {
      collideEntities: collideEntities_default,
      collideTerrain: collideTerrain_default,
      fadeOnZoom: fadeOnZoom_default,
      followsEntity: followsEntity_default,
      mesh: mesh_default,
      movement: movement_default,
      physics: physics_default,
      position: position_default,
      receivesInputs: receivesInputs_default,
      shadow: shadow_default,
      smoothCamera: smoothCamera_default
    };
    Object.keys(compDefs).forEach((bareName) => {
      var arg = componentArgs[bareName] || void 0;
      var compFn = compDefs[bareName];
      var compDef = compFn(noa, arg);
      this.names[bareName] = this.createComponent(compDef);
    });
    this.cameraSmoothed = this.getComponentAccessor(this.names.smoothCamera);
    this.hasPhysics = this.getComponentAccessor(this.names.physics);
    this.hasPosition = this.getComponentAccessor(this.names.position);
    this.getPositionData = this.getStateAccessor(this.names.position);
    this.getPosition = (id) => {
      var state = this.getPositionData(id);
      return state ? state.position : null;
    };
    this.getPhysics = this.getStateAccessor(this.names.physics);
    this.getPhysicsBody = (id) => {
      var state = this.getPhysics(id);
      return state ? state.body : null;
    };
    this.hasMesh = this.getComponentAccessor(this.names.mesh);
    this.getMeshData = this.getStateAccessor(this.names.mesh);
    this.getMovement = this.getStateAccessor(this.names.movement);
    this.getCollideTerrain = this.getStateAccessor(this.names.collideTerrain);
    this.getCollideEntities = this.getStateAccessor(this.names.collideEntities);
    this.onPairwiseEntityCollision = function(id1, id2) {
    };
  }
  /*
   * 
   * 
   *      PUBLIC ENTITY STATE ACCESSORS
   * 
   * 
  */
  /** Set an entity's position, and update all derived state.
   * 
   * In general, always use this to set an entity's position unless
   * you're familiar with engine internals.
   * 
   * ```js
   * noa.ents.setPosition(playerEntity, [5, 6, 7])
   * noa.ents.setPosition(playerEntity, 5, 6, 7)  // also works
   * ```
   * 
   * @param {number} id
   */
  setPosition(id, pos, y = 0, z = 0) {
    if (typeof pos === "number") pos = [pos, y, z];
    var loc = this.noa.globalToLocal(pos, null, []);
    this._localSetPosition(id, loc);
  }
  /** Set an entity's size 
   * @param {number} xs
   * @param {number} ys
   * @param {number} zs
  */
  setEntitySize(id, xs, ys, zs) {
    var posDat = this.getPositionData(id);
    posDat.width = (xs + zs) / 2;
    posDat.height = ys;
    this._updateDerivedPositionData(id, posDat);
  }
  /**
   * called when engine rebases its local coords
   * @internal
   */
  _rebaseOrigin(delta) {
    for (var state of this.getStatesList(this.names.position)) {
      var locPos = state._localPosition;
      var hw = state.width / 2;
      nudgePosition(locPos, 0, -hw, hw, state.__id);
      nudgePosition(locPos, 1, 0, state.height, state.__id);
      nudgePosition(locPos, 2, -hw, hw, state.__id);
      import_gl_vec38.default.subtract(locPos, locPos, delta);
      this._updateDerivedPositionData(state.__id, state);
    }
  }
  /** @internal */
  _localGetPosition(id) {
    return this.getPositionData(id)._localPosition;
  }
  /** @internal */
  _localSetPosition(id, pos) {
    var posDat = this.getPositionData(id);
    import_gl_vec38.default.copy(posDat._localPosition, pos);
    this._updateDerivedPositionData(id, posDat);
  }
  /** 
   * helper to update everything derived from `_localPosition`
   * @internal 
  */
  _updateDerivedPositionData(id, posDat) {
    import_gl_vec38.default.copy(posDat._renderPosition, posDat._localPosition);
    var offset = this.noa.worldOriginOffset;
    import_gl_vec38.default.add(posDat.position, posDat._localPosition, offset);
    updatePositionExtents(posDat);
    var physDat = this.getPhysics(id);
    if (physDat) setPhysicsFromPosition(physDat, posDat);
  }
  /*
   *
   *
   *      OTHER ENTITY MANAGEMENT APIs
   * 
   *      note most APIs are on the original ECS module (ent-comp)
   *      these are some overlaid extras for noa
   *
   *
  */
  /** 
   * Safely add a component - if the entity already had the 
   * component, this will remove and re-add it.
  */
  addComponentAgain(id, name66, state) {
    if (this.hasComponent(id, name66)) this.removeComponent(id, name66);
    this.addComponent(id, name66, state);
  }
  /** 
   * Checks whether a voxel is obstructed by any entity (with the 
   * `collidesTerrain` component)
  */
  isTerrainBlocked(x, y, z) {
    var off = this.noa.worldOriginOffset;
    var xlocal = Math.floor(x - off[0]);
    var ylocal = Math.floor(y - off[1]);
    var zlocal = Math.floor(z - off[2]);
    var blockExt = [
      xlocal + 1e-3,
      ylocal + 1e-3,
      zlocal + 1e-3,
      xlocal + 0.999,
      ylocal + 0.999,
      zlocal + 0.999
    ];
    var list = this.getStatesList(this.names.collideTerrain);
    for (var i = 0; i < list.length; i++) {
      var id = list[i].__id;
      var ext = this.getPositionData(id)._extents;
      if (extentsOverlap(blockExt, ext)) return true;
    }
    return false;
  }
  /** 
   * Gets an array of all entities overlapping the given AABB
  */
  getEntitiesInAABB(box, withComponent) {
    var off = this.noa.worldOriginOffset;
    var testExtents = [
      box.base[0] - off[0],
      box.base[1] - off[1],
      box.base[2] - off[2],
      box.max[0] - off[0],
      box.max[1] - off[1],
      box.max[2] - off[2]
    ];
    var entStates;
    if (withComponent) {
      entStates = [];
      for (var compState of this.getStatesList(withComponent)) {
        var pdat = this.getPositionData(compState.__id);
        if (pdat) entStates.push(pdat);
      }
    } else {
      entStates = this.getStatesList(this.names.position);
    }
    var hits = [];
    for (var i = 0; i < entStates.length; i++) {
      var state = entStates[i];
      if (extentsOverlap(testExtents, state._extents)) {
        hits.push(state.__id);
      }
    }
    return hits;
  }
  /** 
   * Helper to set up a general entity, and populate with some common components depending on arguments.
  */
  add(position = null, width = 1, height = 1, mesh = null, meshOffset = null, doPhysics = false, shadow = false) {
    var self = this;
    var eid = this.createEntity();
    this.addComponent(eid, this.names.position, {
      position: position || import_gl_vec38.default.create(),
      width,
      height
    });
    if (doPhysics) {
      this.addComponent(eid, this.names.physics);
      var body = this.getPhysics(eid).body;
      var smoothName = this.names.smoothCamera;
      body.onStep = function() {
        self.addComponentAgain(eid, smoothName);
      };
    }
    if (mesh) {
      if (!meshOffset) meshOffset = import_gl_vec38.default.create();
      this.addComponent(eid, this.names.mesh, {
        mesh,
        offset: meshOffset
      });
    }
    if (shadow) {
      this.addComponent(eid, this.names.shadow, { size: width });
    }
    return eid;
  }
};
function nudgePosition(pos, index, dmin, dmax, id) {
  var min2 = pos[index] + dmin;
  var max2 = pos[index] + dmax;
  if (Math.abs(min2 - Math.round(min2)) < 2e-3) pos[index] += 2e-3;
  if (Math.abs(max2 - Math.round(max2)) < 1e-3) pos[index] -= 1e-3;
}
function extentsOverlap(extA, extB) {
  if (extA[0] > extB[3]) return false;
  if (extA[1] > extB[4]) return false;
  if (extA[2] > extB[5]) return false;
  if (extA[3] < extB[0]) return false;
  if (extA[4] < extB[1]) return false;
  if (extA[5] < extB[2]) return false;
  return true;
}

// ../../node_modules/noa-engine/src/lib/util.js
function removeUnorderedListItem(list, item) {
  var i = list.indexOf(item);
  if (i < 0) return;
  if (i === list.length - 1) {
    list.pop();
  } else {
    list[i] = list.pop();
  }
}
function locationHasher(i, j, k) {
  return i & 1023 | (j & 1023) << 10 | (k & 1023) << 20;
}
var ChunkStorage = class {
  constructor() {
    this.hash = {};
  }
  /** @returns {import('./chunk').Chunk} */
  getChunkByIndexes(i = 0, j = 0, k = 0) {
    return this.hash[locationHasher(i, j, k)] || null;
  }
  /** @param {import('./chunk').Chunk} chunk */
  storeChunkByIndexes(i = 0, j = 0, k = 0, chunk) {
    this.hash[locationHasher(i, j, k)] = chunk;
  }
  removeChunkByIndexes(i = 0, j = 0, k = 0) {
    delete this.hash[locationHasher(i, j, k)];
  }
};
var LocationQueue = class {
  constructor() {
    this.arr = [];
    this.hash = {};
  }
  forEach(cb, thisArg) {
    this.arr.forEach(cb, thisArg);
  }
  includes(i, j, k) {
    var id = locationHasher(i, j, k);
    return !!this.hash[id];
  }
  add(i, j, k, toFront = false) {
    var id = locationHasher(i, j, k);
    if (this.hash[id]) return;
    if (toFront) {
      this.arr.unshift([i, j, k, id]);
    } else {
      this.arr.push([i, j, k, id]);
    }
    this.hash[id] = true;
  }
  removeByIndex(ix) {
    var el = this.arr[ix];
    delete this.hash[el[3]];
    this.arr.splice(ix, 1);
  }
  remove(i, j, k) {
    var id = locationHasher(i, j, k);
    if (!this.hash[id]) return;
    delete this.hash[id];
    for (var ix = 0; ix < this.arr.length; ix++) {
      if (id === this.arr[ix][3]) {
        this.arr.splice(ix, 1);
        return;
      }
    }
    throw "internal bug with location queue - hash value overlapped";
  }
  count() {
    return this.arr.length;
  }
  isEmpty() {
    return this.arr.length === 0;
  }
  empty() {
    this.arr = [];
    this.hash = {};
  }
  pop() {
    var el = this.arr.pop();
    delete this.hash[el[3]];
    return el;
  }
  copyFrom(queue) {
    this.arr = queue.arr.slice();
    this.hash = {};
    for (var key in queue.hash) this.hash[key] = true;
  }
  sortByDistance(locToDist, reverse = false) {
    sortLocationArrByDistance(this.arr, locToDist, reverse);
  }
};
function sortLocationArrByDistance(arr, distFn, reverse) {
  var hash = {};
  for (var loc of arr) {
    hash[loc[3]] = distFn(loc[0], loc[1], loc[2]);
  }
  if (reverse) {
    arr.sort((a2, b) => hash[a2[3]] - hash[b[3]]);
  } else {
    arr.sort((a2, b) => hash[b[3]] - hash[a2[3]]);
  }
  hash = null;
}
function makeProfileHook(every, title = "", filter) {
  if (!(every > 0)) return () => {
  };
  var times = {};
  var started = 0, last = 0, iter = 0, total = 0;
  var start = () => {
    started = last = performance.now();
    iter++;
  };
  var add3 = (name66) => {
    var t = performance.now();
    times[name66] = (times[name66] || 0) + (t - last);
    last = t;
  };
  var report = () => {
    total += performance.now() - started;
    if (iter < every) return;
    var out = `${title}: ${(total / every).toFixed(2)}ms  --  `;
    out += Object.keys(times).map((name66) => {
      if (filter && times[name66] / total < 0.05) return "";
      return `${name66}: ${(times[name66] / iter).toFixed(2)}ms`;
    }).join("  ");
    console.log(out + `    (avg over ${every} runs)`);
    times = {};
    iter = total = 0;
  };
  return (state) => {
    if (state === "start") start();
    else if (state === "end") report();
    else add3(state);
  };
}

// ../../node_modules/@babylonjs/core/Meshes/thinInstanceMesh.js
Mesh.prototype.thinInstanceAdd = function(matrix, refresh = true) {
  if (!this.getScene().getEngine().getCaps().instancedArrays) {
    Logger.Error("Thin Instances are not supported on this device as Instanced Array extension not supported");
    return -1;
  }
  this._thinInstanceUpdateBufferSize("matrix", Array.isArray(matrix) ? matrix.length : 1);
  const index = this._thinInstanceDataStorage.instancesCount;
  if (Array.isArray(matrix)) {
    for (let i = 0; i < matrix.length; ++i) {
      this.thinInstanceSetMatrixAt(this._thinInstanceDataStorage.instancesCount++, matrix[i], i === matrix.length - 1 && refresh);
    }
  } else {
    this.thinInstanceSetMatrixAt(this._thinInstanceDataStorage.instancesCount++, matrix, refresh);
  }
  return index;
};
Mesh.prototype.thinInstanceAddSelf = function(refresh = true) {
  return this.thinInstanceAdd(Matrix.IdentityReadOnly, refresh);
};
Mesh.prototype.thinInstanceRegisterAttribute = function(kind, stride) {
  if (kind === VertexBuffer.ColorKind) {
    kind = VertexBuffer.ColorInstanceKind;
  }
  this.removeVerticesData(kind);
  this._thinInstanceInitializeUserStorage();
  this._userThinInstanceBuffersStorage.strides[kind] = stride;
  this._userThinInstanceBuffersStorage.sizes[kind] = stride * Math.max(32, this._thinInstanceDataStorage.instancesCount);
  this._userThinInstanceBuffersStorage.data[kind] = new Float32Array(this._userThinInstanceBuffersStorage.sizes[kind]);
  this._userThinInstanceBuffersStorage.vertexBuffers[kind] = new VertexBuffer(this.getEngine(), this._userThinInstanceBuffersStorage.data[kind], kind, true, false, stride, true);
  this.setVerticesBuffer(this._userThinInstanceBuffersStorage.vertexBuffers[kind]);
};
Mesh.prototype.thinInstanceSetMatrixAt = function(index, matrix, refresh = true) {
  if (!this._thinInstanceDataStorage.matrixData || index >= this._thinInstanceDataStorage.instancesCount) {
    return false;
  }
  const matrixData = this._thinInstanceDataStorage.matrixData;
  matrix.copyToArray(matrixData, index * 16);
  if (this._thinInstanceDataStorage.worldMatrices) {
    this._thinInstanceDataStorage.worldMatrices[index] = matrix;
  }
  if (refresh) {
    this.thinInstanceBufferUpdated("matrix");
    if (!this.doNotSyncBoundingInfo) {
      this.thinInstanceRefreshBoundingInfo(false);
    }
  }
  return true;
};
Mesh.prototype.thinInstanceSetAttributeAt = function(kind, index, value, refresh = true) {
  if (kind === VertexBuffer.ColorKind) {
    kind = VertexBuffer.ColorInstanceKind;
  }
  if (!this._userThinInstanceBuffersStorage || !this._userThinInstanceBuffersStorage.data[kind] || index >= this._thinInstanceDataStorage.instancesCount) {
    return false;
  }
  this._thinInstanceUpdateBufferSize(kind, 0);
  this._userThinInstanceBuffersStorage.data[kind].set(value, index * this._userThinInstanceBuffersStorage.strides[kind]);
  if (refresh) {
    this.thinInstanceBufferUpdated(kind);
  }
  return true;
};
Object.defineProperty(Mesh.prototype, "thinInstanceCount", {
  get: function() {
    return this._thinInstanceDataStorage.instancesCount;
  },
  set: function(value) {
    const matrixData = this._thinInstanceDataStorage.matrixData ?? this.source?._thinInstanceDataStorage.matrixData;
    const numMaxInstances = matrixData ? matrixData.length / 16 : 0;
    if (value <= numMaxInstances) {
      this._thinInstanceDataStorage.instancesCount = value;
    }
  },
  enumerable: true,
  configurable: true
});
Mesh.prototype._thinInstanceCreateMatrixBuffer = function(kind, buffer, staticBuffer = true) {
  const matrixBuffer = new Buffer(this.getEngine(), buffer, !staticBuffer, 16, false, true);
  for (let i = 0; i < 4; i++) {
    this.setVerticesBuffer(matrixBuffer.createVertexBuffer(kind + i, i * 4, 4));
  }
  return matrixBuffer;
};
Mesh.prototype.thinInstanceSetBuffer = function(kind, buffer, stride = 0, staticBuffer = true) {
  stride = stride || 16;
  if (kind === "matrix") {
    this._thinInstanceDataStorage.matrixBuffer?.dispose();
    this._thinInstanceDataStorage.matrixBuffer = null;
    this._thinInstanceDataStorage.matrixBufferSize = buffer ? buffer.length : 32 * stride;
    this._thinInstanceDataStorage.matrixData = buffer;
    this._thinInstanceDataStorage.worldMatrices = null;
    if (buffer !== null) {
      this._thinInstanceDataStorage.instancesCount = buffer.length / stride;
      this._thinInstanceDataStorage.matrixBuffer = this._thinInstanceCreateMatrixBuffer("world", buffer, staticBuffer);
      if (!this.doNotSyncBoundingInfo) {
        this.thinInstanceRefreshBoundingInfo(false);
      }
    } else {
      this._thinInstanceDataStorage.instancesCount = 0;
      if (!this.doNotSyncBoundingInfo) {
        this.refreshBoundingInfo();
      }
    }
  } else if (kind === "previousMatrix") {
    this._thinInstanceDataStorage.previousMatrixBuffer?.dispose();
    this._thinInstanceDataStorage.previousMatrixBuffer = null;
    this._thinInstanceDataStorage.previousMatrixData = buffer;
    if (buffer !== null) {
      this._thinInstanceDataStorage.previousMatrixBuffer = this._thinInstanceCreateMatrixBuffer("previousWorld", buffer, staticBuffer);
    }
  } else {
    if (kind === VertexBuffer.ColorKind) {
      kind = VertexBuffer.ColorInstanceKind;
    }
    if (buffer === null) {
      if (this._userThinInstanceBuffersStorage?.data[kind]) {
        this.removeVerticesData(kind);
        delete this._userThinInstanceBuffersStorage.data[kind];
        delete this._userThinInstanceBuffersStorage.strides[kind];
        delete this._userThinInstanceBuffersStorage.sizes[kind];
        delete this._userThinInstanceBuffersStorage.vertexBuffers[kind];
      }
    } else {
      this._thinInstanceInitializeUserStorage();
      this._userThinInstanceBuffersStorage.data[kind] = buffer;
      this._userThinInstanceBuffersStorage.strides[kind] = stride;
      this._userThinInstanceBuffersStorage.sizes[kind] = buffer.length;
      this._userThinInstanceBuffersStorage.vertexBuffers[kind] = new VertexBuffer(this.getEngine(), buffer, kind, !staticBuffer, false, stride, true);
      this.setVerticesBuffer(this._userThinInstanceBuffersStorage.vertexBuffers[kind]);
    }
  }
};
Mesh.prototype.thinInstanceBufferUpdated = function(kind) {
  if (kind === "matrix") {
    if (this.thinInstanceAllowAutomaticStaticBufferRecreation && this._thinInstanceDataStorage.matrixBuffer && !this._thinInstanceDataStorage.matrixBuffer.isUpdatable()) {
      this._thinInstanceRecreateBuffer(kind);
    }
    this._thinInstanceDataStorage.matrixBuffer?.updateDirectly(this._thinInstanceDataStorage.matrixData, 0, this._thinInstanceDataStorage.instancesCount);
  } else if (kind === "previousMatrix") {
    if (this.thinInstanceAllowAutomaticStaticBufferRecreation && this._thinInstanceDataStorage.previousMatrixBuffer && !this._thinInstanceDataStorage.previousMatrixBuffer.isUpdatable()) {
      this._thinInstanceRecreateBuffer(kind);
    }
    this._thinInstanceDataStorage.previousMatrixBuffer?.updateDirectly(this._thinInstanceDataStorage.previousMatrixData, 0, this._thinInstanceDataStorage.instancesCount);
  } else {
    if (kind === VertexBuffer.ColorKind) {
      kind = VertexBuffer.ColorInstanceKind;
    }
    if (this._userThinInstanceBuffersStorage?.vertexBuffers[kind]) {
      if (this.thinInstanceAllowAutomaticStaticBufferRecreation && !this._userThinInstanceBuffersStorage.vertexBuffers[kind].isUpdatable()) {
        this._thinInstanceRecreateBuffer(kind);
      }
      this._userThinInstanceBuffersStorage.vertexBuffers[kind].updateDirectly(this._userThinInstanceBuffersStorage.data[kind], 0);
    }
  }
};
Mesh.prototype.thinInstancePartialBufferUpdate = function(kind, data, offset) {
  if (kind === "matrix") {
    if (this._thinInstanceDataStorage.matrixBuffer) {
      this._thinInstanceDataStorage.matrixBuffer.updateDirectly(data, offset);
    }
  } else {
    if (kind === VertexBuffer.ColorKind) {
      kind = VertexBuffer.ColorInstanceKind;
    }
    if (this._userThinInstanceBuffersStorage?.vertexBuffers[kind]) {
      this._userThinInstanceBuffersStorage.vertexBuffers[kind].updateDirectly(data, offset);
    }
  }
};
Mesh.prototype.thinInstanceGetWorldMatrices = function() {
  if (!this._thinInstanceDataStorage.matrixData || !this._thinInstanceDataStorage.matrixBuffer) {
    return [];
  }
  const matrixData = this._thinInstanceDataStorage.matrixData;
  if (!this._thinInstanceDataStorage.worldMatrices) {
    this._thinInstanceDataStorage.worldMatrices = [];
    for (let i = 0; i < this._thinInstanceDataStorage.instancesCount; ++i) {
      this._thinInstanceDataStorage.worldMatrices[i] = Matrix.FromArray(matrixData, i * 16);
    }
  }
  return this._thinInstanceDataStorage.worldMatrices;
};
Mesh.prototype.thinInstanceRefreshBoundingInfo = function(forceRefreshParentInfo = false, applySkeleton = false, applyMorph = false) {
  if (!this._thinInstanceDataStorage.matrixData || !this._thinInstanceDataStorage.matrixBuffer) {
    return;
  }
  const vectors = this._thinInstanceDataStorage.boundingVectors;
  if (forceRefreshParentInfo || !this.rawBoundingInfo) {
    vectors.length = 0;
    this.refreshBoundingInfo(applySkeleton, applyMorph);
    const boundingInfo2 = this.getBoundingInfo();
    this.rawBoundingInfo = new BoundingInfo(boundingInfo2.minimum, boundingInfo2.maximum);
  }
  const boundingInfo = this.getBoundingInfo();
  const matrixData = this._thinInstanceDataStorage.matrixData;
  if (vectors.length === 0) {
    for (let v = 0; v < boundingInfo.boundingBox.vectors.length; ++v) {
      vectors.push(boundingInfo.boundingBox.vectors[v].clone());
    }
  }
  TmpVectors.Vector3[0].setAll(Number.POSITIVE_INFINITY);
  TmpVectors.Vector3[1].setAll(Number.NEGATIVE_INFINITY);
  for (let i = 0; i < this._thinInstanceDataStorage.instancesCount; ++i) {
    Matrix.FromArrayToRef(matrixData, i * 16, TmpVectors.Matrix[0]);
    for (let v = 0; v < vectors.length; ++v) {
      Vector3.TransformCoordinatesToRef(vectors[v], TmpVectors.Matrix[0], TmpVectors.Vector3[2]);
      TmpVectors.Vector3[0].minimizeInPlace(TmpVectors.Vector3[2]);
      TmpVectors.Vector3[1].maximizeInPlace(TmpVectors.Vector3[2]);
    }
  }
  boundingInfo.reConstruct(TmpVectors.Vector3[0], TmpVectors.Vector3[1]);
  this._updateBoundingInfo();
};
Mesh.prototype._thinInstanceRecreateBuffer = function(kind, staticBuffer = true) {
  if (kind === "matrix") {
    this._thinInstanceDataStorage.matrixBuffer?.dispose();
    this._thinInstanceDataStorage.matrixBuffer = this._thinInstanceCreateMatrixBuffer("world", this._thinInstanceDataStorage.matrixData, staticBuffer);
  } else if (kind === "previousMatrix") {
    if (this._scene.needsPreviousWorldMatrices) {
      this._thinInstanceDataStorage.previousMatrixBuffer?.dispose();
      this._thinInstanceDataStorage.previousMatrixBuffer = this._thinInstanceCreateMatrixBuffer("previousWorld", this._thinInstanceDataStorage.previousMatrixData ?? this._thinInstanceDataStorage.matrixData, staticBuffer);
    }
  } else {
    if (kind === VertexBuffer.ColorKind) {
      kind = VertexBuffer.ColorInstanceKind;
    }
    this._userThinInstanceBuffersStorage.vertexBuffers[kind]?.dispose();
    this._userThinInstanceBuffersStorage.vertexBuffers[kind] = new VertexBuffer(this.getEngine(), this._userThinInstanceBuffersStorage.data[kind], kind, !staticBuffer, false, this._userThinInstanceBuffersStorage.strides[kind], true);
    this.setVerticesBuffer(this._userThinInstanceBuffersStorage.vertexBuffers[kind]);
  }
};
Mesh.prototype._thinInstanceUpdateBufferSize = function(kind, numInstances = 1) {
  if (kind === VertexBuffer.ColorKind) {
    kind = VertexBuffer.ColorInstanceKind;
  }
  const kindIsMatrix = kind === "matrix";
  if (!kindIsMatrix && (!this._userThinInstanceBuffersStorage || !this._userThinInstanceBuffersStorage.strides[kind])) {
    return;
  }
  const stride = kindIsMatrix ? 16 : this._userThinInstanceBuffersStorage.strides[kind];
  const currentSize = kindIsMatrix ? this._thinInstanceDataStorage.matrixBufferSize : this._userThinInstanceBuffersStorage.sizes[kind];
  let data = kindIsMatrix ? this._thinInstanceDataStorage.matrixData : this._userThinInstanceBuffersStorage.data[kind];
  const bufferSize = (this._thinInstanceDataStorage.instancesCount + numInstances) * stride;
  let newSize = currentSize;
  while (newSize < bufferSize) {
    newSize *= 2;
  }
  if (!data || currentSize != newSize) {
    if (!data) {
      data = new Float32Array(newSize);
    } else {
      const newData = new Float32Array(newSize);
      newData.set(data, 0);
      data = newData;
    }
    if (kindIsMatrix) {
      this._thinInstanceDataStorage.matrixBuffer?.dispose();
      this._thinInstanceDataStorage.matrixBuffer = this._thinInstanceCreateMatrixBuffer("world", data, false);
      this._thinInstanceDataStorage.matrixData = data;
      this._thinInstanceDataStorage.matrixBufferSize = newSize;
      if (this._scene.needsPreviousWorldMatrices && !this._thinInstanceDataStorage.previousMatrixData) {
        this._thinInstanceDataStorage.previousMatrixBuffer?.dispose();
        this._thinInstanceDataStorage.previousMatrixBuffer = this._thinInstanceCreateMatrixBuffer("previousWorld", data, false);
      }
    } else {
      this._userThinInstanceBuffersStorage.vertexBuffers[kind]?.dispose();
      this._userThinInstanceBuffersStorage.data[kind] = data;
      this._userThinInstanceBuffersStorage.sizes[kind] = newSize;
      this._userThinInstanceBuffersStorage.vertexBuffers[kind] = new VertexBuffer(this.getEngine(), data, kind, true, false, stride, true);
      this.setVerticesBuffer(this._userThinInstanceBuffersStorage.vertexBuffers[kind]);
    }
  }
};
Mesh.prototype._thinInstanceInitializeUserStorage = function() {
  if (!this._userThinInstanceBuffersStorage) {
    this._userThinInstanceBuffersStorage = {
      data: {},
      sizes: {},
      vertexBuffers: {},
      strides: {}
    };
  }
};
Mesh.prototype._disposeThinInstanceSpecificData = function() {
  if (this._thinInstanceDataStorage?.matrixBuffer) {
    this._thinInstanceDataStorage.matrixBuffer.dispose();
    this._thinInstanceDataStorage.matrixBuffer = null;
  }
};

// ../../node_modules/noa-engine/src/lib/objectMesher.js
var PROFILE = 0;
function ObjectMesher(noa) {
  this.rootNode = new TransformNode("objectMeshRoot", noa.rendering.scene);
  var rebaseOffset = [0, 0, 0];
  var rebuildNextTick = false;
  var transformObj = new TransformNode("");
  this.allBaseMeshes = [];
  var managers = {};
  var getManager = (id) => {
    if (managers[id]) return managers[id];
    var mesh = noa.registry._blockMeshLookup[id];
    for (var id2 in managers) {
      var prev = managers[id2].mesh;
      if (prev === mesh || prev.geometry === mesh.geometry) {
        return managers[id] = managers[id2];
      }
    }
    this.allBaseMeshes.push(mesh);
    if (!mesh.metadata) mesh.metadata = {};
    mesh.metadata[objectMeshFlag] = true;
    return managers[id] = new InstanceManager(noa, mesh);
  };
  var objectMeshFlag = "noa_object_base_mesh";
  this.initChunk = function(chunk) {
    chunk._objectBlocks = {};
  };
  this.setObjectBlock = function(chunk, blockID, i, j, k) {
    var x = chunk.x + i;
    var y = chunk.y + j;
    var z = chunk.z + k;
    var key = `${x}:${y}:${z}`;
    var oldID = chunk._objectBlocks[key] || 0;
    if (oldID === blockID) return;
    if (oldID > 0) {
      var oldMgr = getManager(oldID);
      oldMgr.removeInstance(chunk, key);
    }
    if (blockID > 0) {
      var handlers = noa.registry._blockHandlerLookup[blockID];
      var onCreate = handlers && handlers.onCustomMeshCreate;
      if (onCreate) {
        transformObj.position.copyFromFloats(0.5, 0, 0.5);
        transformObj.scaling.setAll(1);
        transformObj.rotation.setAll(0);
        onCreate(transformObj, x, y, z);
      }
      var mgr = getManager(blockID);
      var xform = onCreate ? transformObj : null;
      mgr.addInstance(chunk, key, i, j, k, xform, rebaseOffset);
    }
    if (oldID > 0 && !blockID) delete chunk._objectBlocks[key];
    if (blockID > 0) chunk._objectBlocks[key] = blockID;
  };
  this.buildObjectMeshes = function() {
    profile_hook("start");
    for (var id in managers) {
      var mgr = managers[id];
      mgr.updateMatrix();
      if (mgr.count === 0) mgr.dispose();
      if (mgr.disposed) delete managers[id];
    }
    profile_hook("rebuilt");
    profile_hook("end");
  };
  this.disposeChunk = function(chunk) {
    for (var key in chunk._objectBlocks) {
      var id = chunk._objectBlocks[key];
      if (id > 0) {
        var mgr = getManager(id);
        mgr.removeInstance(chunk, key);
      }
    }
    chunk._objectBlocks = null;
    rebuildNextTick = true;
  };
  this.tick = function() {
    if (rebuildNextTick) {
      this.buildObjectMeshes();
      rebuildNextTick = false;
    }
  };
  this._rebaseOrigin = function(delta) {
    rebaseOffset[0] += delta[0];
    rebaseOffset[1] += delta[1];
    rebaseOffset[2] += delta[2];
    for (var id1 in managers) managers[id1].rebased = false;
    for (var id2 in managers) {
      var mgr = managers[id2];
      if (mgr.rebased) continue;
      for (var i = 0; i < mgr.count; i++) {
        var ix = i << 4;
        mgr.buffer[ix + 12] -= delta[0];
        mgr.buffer[ix + 13] -= delta[1];
        mgr.buffer[ix + 14] -= delta[2];
      }
      mgr.rebased = true;
      mgr.dirty = true;
    }
    rebuildNextTick = true;
  };
}
function InstanceManager(noa, mesh) {
  this.noa = noa;
  this.mesh = mesh;
  this.buffer = null;
  this.capacity = 0;
  this.count = 0;
  this.dirty = false;
  this.rebased = true;
  this.disposed = false;
  this.keyToIndex = {};
  this.locToKey = [];
  this.mesh.position.setAll(0);
  this.mesh.parent = noa._objectMesher.rootNode;
  this.noa.rendering.addMeshToScene(this.mesh, false);
  this.noa.emit("addingTerrainMesh", this.mesh);
  this.mesh.isPickable = false;
  this.mesh.doNotSyncBoundingInfo = true;
  this.mesh.alwaysSelectAsActiveMesh = true;
}
InstanceManager.prototype.dispose = function() {
  if (this.disposed) return;
  this.mesh.thinInstanceCount = 0;
  this.setCapacity(0);
  this.noa.emit("removingTerrainMesh", this.mesh);
  this.noa.rendering.setMeshVisibility(this.mesh, false);
  this.mesh = null;
  this.keyToIndex = null;
  this.locToKey = null;
  this.disposed = true;
};
InstanceManager.prototype.addInstance = function(chunk, key, i, j, k, transform, rebaseVec) {
  maybeExpandBuffer(this);
  var ix = this.count << 4;
  this.locToKey[this.count] = key;
  this.keyToIndex[key] = ix;
  if (transform) {
    transform.position.x += chunk.x - rebaseVec[0] + i;
    transform.position.y += chunk.y - rebaseVec[1] + j;
    transform.position.z += chunk.z - rebaseVec[2] + k;
    transform.computeWorldMatrix(true);
    var xformArr = transform._localMatrix._m;
    copyMatrixData(xformArr, 0, this.buffer, ix);
  } else {
    var matArray = tempMatrixArray;
    matArray[12] = chunk.x - rebaseVec[0] + i + 0.5;
    matArray[13] = chunk.y - rebaseVec[1] + j;
    matArray[14] = chunk.z - rebaseVec[2] + k + 0.5;
    copyMatrixData(matArray, 0, this.buffer, ix);
  }
  this.count++;
  this.dirty = true;
};
InstanceManager.prototype.removeInstance = function(chunk, key) {
  var remIndex = this.keyToIndex[key];
  if (!(remIndex >= 0)) throw "tried to remove object instance not in storage";
  delete this.keyToIndex[key];
  var remLoc = remIndex >> 4;
  var tailLoc = this.count - 1;
  if (remLoc !== tailLoc) {
    var tailIndex = tailLoc << 4;
    copyMatrixData(this.buffer, tailIndex, this.buffer, remIndex);
    var tailKey = this.locToKey[tailLoc];
    this.keyToIndex[tailKey] = remIndex;
    this.locToKey[remLoc] = tailKey;
  }
  this.count--;
  this.dirty = true;
  maybeContractBuffer(this);
};
InstanceManager.prototype.updateMatrix = function() {
  if (!this.dirty) return;
  this.mesh.thinInstanceCount = this.count;
  this.mesh.thinInstanceBufferUpdated("matrix");
  this.mesh.isVisible = this.count > 0;
  this.dirty = false;
};
InstanceManager.prototype.setCapacity = function(size = 4) {
  this.capacity = size;
  if (size === 0) {
    this.buffer = null;
  } else {
    var newBuff = new Float32Array(this.capacity * 16);
    if (this.buffer) {
      var len2 = Math.min(this.buffer.length, newBuff.length);
      for (var i = 0; i < len2; i++) newBuff[i] = this.buffer[i];
    }
    this.buffer = newBuff;
  }
  this.mesh.thinInstanceSetBuffer("matrix", this.buffer);
  this.updateMatrix();
};
function maybeExpandBuffer(mgr) {
  if (mgr.count < mgr.capacity) return;
  var size = Math.max(8, mgr.capacity * 2);
  mgr.setCapacity(size);
}
function maybeContractBuffer(mgr) {
  if (mgr.count > mgr.capacity * 0.4) return;
  if (mgr.capacity < 100) return;
  mgr.setCapacity(Math.round(mgr.capacity / 2));
  mgr.locToKey.length = Math.min(mgr.locToKey.length, mgr.capacity);
}
var tempMatrixArray = [
  1,
  0,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  0,
  1
];
function copyMatrixData(src, srcOff, dest, destOff) {
  for (var i = 0; i < 16; i++) dest[destOff + i] = src[srcOff + i];
}
var profile_hook = PROFILE ? makeProfileHook(PROFILE, "Object meshing") : () => {
};

// ../../node_modules/noa-engine/src/lib/terrainMesher.js
var import_ndarray = __toESM(require_ndarray());

// ../../node_modules/@babylonjs/core/Maths/math.size.js
var Size = class _Size {
  /**
   * Creates a Size object from the given width and height (floats).
   * @param width width of the new size
   * @param height height of the new size
   */
  constructor(width, height) {
    this.width = width;
    this.height = height;
  }
  /**
   * Returns a string with the Size width and height
   * @returns a string with the Size width and height
   */
  toString() {
    return `{W: ${this.width}, H: ${this.height}}`;
  }
  /**
   * "Size"
   * @returns the string "Size"
   */
  getClassName() {
    return "Size";
  }
  /**
   * Returns the Size hash code.
   * @returns a hash code for a unique width and height
   */
  getHashCode() {
    let hash = this.width | 0;
    hash = hash * 397 ^ (this.height | 0);
    return hash;
  }
  /**
   * Updates the current size from the given one.
   * @param src the given size
   */
  copyFrom(src) {
    this.width = src.width;
    this.height = src.height;
  }
  /**
   * Updates in place the current Size from the given floats.
   * @param width width of the new size
   * @param height height of the new size
   * @returns the updated Size.
   */
  copyFromFloats(width, height) {
    this.width = width;
    this.height = height;
    return this;
  }
  /**
   * Updates in place the current Size from the given floats.
   * @param width width to set
   * @param height height to set
   * @returns the updated Size.
   */
  set(width, height) {
    return this.copyFromFloats(width, height);
  }
  /**
   * Multiplies the width and height by numbers
   * @param w factor to multiple the width by
   * @param h factor to multiple the height by
   * @returns a new Size set with the multiplication result of the current Size and the given floats.
   */
  multiplyByFloats(w, h) {
    return new _Size(this.width * w, this.height * h);
  }
  /**
   * Clones the size
   * @returns a new Size copied from the given one.
   */
  clone() {
    return new _Size(this.width, this.height);
  }
  /**
   * True if the current Size and the given one width and height are strictly equal.
   * @param other the other size to compare against
   * @returns True if the current Size and the given one width and height are strictly equal.
   */
  equals(other) {
    if (!other) {
      return false;
    }
    return this.width === other.width && this.height === other.height;
  }
  /**
   * The surface of the Size : width * height (float).
   */
  get surface() {
    return this.width * this.height;
  }
  /**
   * Create a new size of zero
   * @returns a new Size set to (0.0, 0.0)
   */
  static Zero() {
    return new _Size(0, 0);
  }
  /**
   * Sums the width and height of two sizes
   * @param otherSize size to add to this size
   * @returns a new Size set as the addition result of the current Size and the given one.
   */
  add(otherSize) {
    const r = new _Size(this.width + otherSize.width, this.height + otherSize.height);
    return r;
  }
  /**
   * Subtracts the width and height of two
   * @param otherSize size to subtract to this size
   * @returns a new Size set as the subtraction result of  the given one from the current Size.
   */
  subtract(otherSize) {
    const r = new _Size(this.width - otherSize.width, this.height - otherSize.height);
    return r;
  }
  /**
   * Scales the width and height
   * @param scale the scale to multiply the width and height by
   * @returns a new Size set with the multiplication result of the current Size and the given floats.
   */
  scale(scale3) {
    return new _Size(this.width * scale3, this.height * scale3);
  }
  /**
   * Creates a new Size set at the linear interpolation "amount" between "start" and "end"
   * @param start starting size to lerp between
   * @param end end size to lerp between
   * @param amount amount to lerp between the start and end values
   * @returns a new Size set at the linear interpolation "amount" between "start" and "end"
   */
  static Lerp(start, end, amount) {
    const w = start.width + (end.width - start.width) * amount;
    const h = start.height + (end.height - start.height) * amount;
    return new _Size(w, h);
  }
};

// ../../node_modules/@babylonjs/core/Materials/Textures/thinTexture.js
var ThinTexture = class _ThinTexture {
  /**
   * | Value | Type               | Description |
   * | ----- | ------------------ | ----------- |
   * | 0     | CLAMP_ADDRESSMODE  |             |
   * | 1     | WRAP_ADDRESSMODE   |             |
   * | 2     | MIRROR_ADDRESSMODE |             |
   */
  get wrapU() {
    return this._wrapU;
  }
  set wrapU(value) {
    this._wrapU = value;
  }
  /**
   * | Value | Type               | Description |
   * | ----- | ------------------ | ----------- |
   * | 0     | CLAMP_ADDRESSMODE  |             |
   * | 1     | WRAP_ADDRESSMODE   |             |
   * | 2     | MIRROR_ADDRESSMODE |             |
   */
  get wrapV() {
    return this._wrapV;
  }
  set wrapV(value) {
    this._wrapV = value;
  }
  /**
   * How a texture is mapped.
   * Unused in thin texture mode.
   */
  get coordinatesMode() {
    return 0;
  }
  /**
   * Define if the texture is a cube texture or if false a 2d texture.
   */
  get isCube() {
    if (!this._texture) {
      return false;
    }
    return this._texture.isCube;
  }
  // eslint-disable-next-line @typescript-eslint/naming-convention
  set isCube(value) {
    if (!this._texture) {
      return;
    }
    this._texture.isCube = value;
  }
  /**
   * Define if the texture is a 3d texture (webgl 2) or if false a 2d texture.
   */
  get is3D() {
    if (!this._texture) {
      return false;
    }
    return this._texture.is3D;
  }
  // eslint-disable-next-line @typescript-eslint/naming-convention
  set is3D(value) {
    if (!this._texture) {
      return;
    }
    this._texture.is3D = value;
  }
  /**
   * Define if the texture is a 2d array texture (webgl 2) or if false a 2d texture.
   */
  get is2DArray() {
    if (!this._texture) {
      return false;
    }
    return this._texture.is2DArray;
  }
  // eslint-disable-next-line @typescript-eslint/naming-convention
  set is2DArray(value) {
    if (!this._texture) {
      return;
    }
    this._texture.is2DArray = value;
  }
  /**
   * Get the class name of the texture.
   * @returns "ThinTexture"
   */
  getClassName() {
    return "ThinTexture";
  }
  static _IsRenderTargetWrapper(texture) {
    return texture?._shareDepth !== void 0;
  }
  /**
   * Instantiates a new ThinTexture.
   * Base class of all the textures in babylon.
   * This can be used as an internal texture wrapper in ThinEngine to benefit from the cache
   * @param internalTexture Define the internalTexture to wrap. You can also pass a RenderTargetWrapper, in which case the texture will be the render target's texture
   */
  constructor(internalTexture) {
    this._wrapU = 1;
    this._wrapV = 1;
    this.wrapR = 1;
    this.anisotropicFilteringLevel = 4;
    this.delayLoadState = 0;
    this._texture = null;
    this._engine = null;
    this._cachedSize = Size.Zero();
    this._cachedBaseSize = Size.Zero();
    this._initialSamplingMode = 2;
    this._texture = _ThinTexture._IsRenderTargetWrapper(internalTexture) ? internalTexture.texture : internalTexture;
    if (this._texture) {
      this._engine = this._texture.getEngine();
    }
  }
  /**
   * Get if the texture is ready to be used (downloaded, converted, mip mapped...).
   * @returns true if fully ready
   */
  isReady() {
    if (this.delayLoadState === 4) {
      this.delayLoad();
      return false;
    }
    if (this._texture) {
      return this._texture.isReady;
    }
    return false;
  }
  /**
   * Triggers the load sequence in delayed load mode.
   */
  delayLoad() {
  }
  /**
   * Get the underlying lower level texture from Babylon.
   * @returns the internal texture
   */
  getInternalTexture() {
    return this._texture;
  }
  /**
   * Get the size of the texture.
   * @returns the texture size.
   */
  getSize() {
    if (this._texture) {
      if (this._texture.width) {
        this._cachedSize.width = this._texture.width;
        this._cachedSize.height = this._texture.height;
        return this._cachedSize;
      }
      if (this._texture._size) {
        this._cachedSize.width = this._texture._size;
        this._cachedSize.height = this._texture._size;
        return this._cachedSize;
      }
    }
    return this._cachedSize;
  }
  /**
   * Get the base size of the texture.
   * It can be different from the size if the texture has been resized for POT for instance
   * @returns the base size
   */
  getBaseSize() {
    if (!this.isReady() || !this._texture) {
      this._cachedBaseSize.width = 0;
      this._cachedBaseSize.height = 0;
      return this._cachedBaseSize;
    }
    if (this._texture._size) {
      this._cachedBaseSize.width = this._texture._size;
      this._cachedBaseSize.height = this._texture._size;
      return this._cachedBaseSize;
    }
    this._cachedBaseSize.width = this._texture.baseWidth;
    this._cachedBaseSize.height = this._texture.baseHeight;
    return this._cachedBaseSize;
  }
  /**
   * Get the current sampling mode associated with the texture.
   */
  get samplingMode() {
    if (!this._texture) {
      return this._initialSamplingMode;
    }
    return this._texture.samplingMode;
  }
  /**
   * Update the sampling mode of the texture.
   * Default is Trilinear mode.
   *
   * | Value | Type               | Description |
   * | ----- | ------------------ | ----------- |
   * | 1     | NEAREST_SAMPLINGMODE or NEAREST_NEAREST_MIPLINEAR  | Nearest is: mag = nearest, min = nearest, mip = linear |
   * | 2     | BILINEAR_SAMPLINGMODE or LINEAR_LINEAR_MIPNEAREST | Bilinear is: mag = linear, min = linear, mip = nearest |
   * | 3     | TRILINEAR_SAMPLINGMODE or LINEAR_LINEAR_MIPLINEAR | Trilinear is: mag = linear, min = linear, mip = linear |
   * | 4     | NEAREST_NEAREST_MIPNEAREST |             |
   * | 5    | NEAREST_LINEAR_MIPNEAREST |             |
   * | 6    | NEAREST_LINEAR_MIPLINEAR |             |
   * | 7    | NEAREST_LINEAR |             |
   * | 8    | NEAREST_NEAREST |             |
   * | 9   | LINEAR_NEAREST_MIPNEAREST |             |
   * | 10   | LINEAR_NEAREST_MIPLINEAR |             |
   * | 11   | LINEAR_LINEAR |             |
   * | 12   | LINEAR_NEAREST |             |
   *
   *    > _mag_: magnification filter (close to the viewer)
   *    > _min_: minification filter (far from the viewer)
   *    > _mip_: filter used between mip map levels
   *@param samplingMode Define the new sampling mode of the texture
   */
  updateSamplingMode(samplingMode) {
    if (this._texture && this._engine) {
      this._engine.updateTextureSamplingMode(samplingMode, this._texture);
    }
  }
  /**
   * Release and destroy the underlying lower level texture aka internalTexture.
   */
  releaseInternalTexture() {
    if (this._texture) {
      this._texture.dispose();
      this._texture = null;
    }
  }
  /**
   * Dispose the texture and release its associated resources.
   */
  dispose() {
    if (this._texture) {
      this.releaseInternalTexture();
      this._engine = null;
    }
  }
};

// ../../node_modules/@babylonjs/core/Materials/Textures/baseTexture.js
var BaseTexture = class _BaseTexture extends ThinTexture {
  /**
   * Define if the texture is having a usable alpha value (can be use for transparency or glossiness for instance).
   */
  set hasAlpha(value) {
    if (this._hasAlpha === value) {
      return;
    }
    this._hasAlpha = value;
    if (this._scene) {
      this._scene.markAllMaterialsAsDirty(1, (mat) => {
        return mat.hasTexture(this);
      });
    }
  }
  get hasAlpha() {
    return this._hasAlpha;
  }
  /**
   * Defines if the alpha value should be determined via the rgb values.
   * If true the luminance of the pixel might be used to find the corresponding alpha value.
   */
  set getAlphaFromRGB(value) {
    if (this._getAlphaFromRGB === value) {
      return;
    }
    this._getAlphaFromRGB = value;
    if (this._scene) {
      this._scene.markAllMaterialsAsDirty(1, (mat) => {
        return mat.hasTexture(this);
      });
    }
  }
  get getAlphaFromRGB() {
    return this._getAlphaFromRGB;
  }
  /**
   * Define the UV channel to use starting from 0 and defaulting to 0.
   * This is part of the texture as textures usually maps to one uv set.
   */
  set coordinatesIndex(value) {
    if (this._coordinatesIndex === value) {
      return;
    }
    this._coordinatesIndex = value;
    if (this._scene) {
      this._scene.markAllMaterialsAsDirty(1, (mat) => {
        return mat.hasTexture(this);
      });
    }
  }
  get coordinatesIndex() {
    return this._coordinatesIndex;
  }
  /**
   * How a texture is mapped.
   *
   * | Value | Type                                | Description |
   * | ----- | ----------------------------------- | ----------- |
   * | 0     | EXPLICIT_MODE                       |             |
   * | 1     | SPHERICAL_MODE                      |             |
   * | 2     | PLANAR_MODE                         |             |
   * | 3     | CUBIC_MODE                          |             |
   * | 4     | PROJECTION_MODE                     |             |
   * | 5     | SKYBOX_MODE                         |             |
   * | 6     | INVCUBIC_MODE                       |             |
   * | 7     | EQUIRECTANGULAR_MODE                |             |
   * | 8     | FIXED_EQUIRECTANGULAR_MODE          |             |
   * | 9     | FIXED_EQUIRECTANGULAR_MIRRORED_MODE |             |
   */
  set coordinatesMode(value) {
    if (this._coordinatesMode === value) {
      return;
    }
    this._coordinatesMode = value;
    if (this._scene) {
      this._scene.markAllMaterialsAsDirty(1, (mat) => {
        return mat.hasTexture(this);
      });
    }
  }
  get coordinatesMode() {
    return this._coordinatesMode;
  }
  /**
   * | Value | Type               | Description |
   * | ----- | ------------------ | ----------- |
   * | 0     | CLAMP_ADDRESSMODE  |             |
   * | 1     | WRAP_ADDRESSMODE   |             |
   * | 2     | MIRROR_ADDRESSMODE |             |
   */
  get wrapU() {
    return this._wrapU;
  }
  set wrapU(value) {
    this._wrapU = value;
  }
  /**
   * | Value | Type               | Description |
   * | ----- | ------------------ | ----------- |
   * | 0     | CLAMP_ADDRESSMODE  |             |
   * | 1     | WRAP_ADDRESSMODE   |             |
   * | 2     | MIRROR_ADDRESSMODE |             |
   */
  get wrapV() {
    return this._wrapV;
  }
  set wrapV(value) {
    this._wrapV = value;
  }
  /**
   * Define if the texture is a cube texture or if false a 2d texture.
   */
  get isCube() {
    if (!this._texture) {
      return this._isCube;
    }
    return this._texture.isCube;
  }
  // eslint-disable-next-line @typescript-eslint/naming-convention
  set isCube(value) {
    if (!this._texture) {
      this._isCube = value;
    } else {
      this._texture.isCube = value;
    }
  }
  /**
   * Define if the texture is a 3d texture (webgl 2) or if false a 2d texture.
   */
  get is3D() {
    if (!this._texture) {
      return false;
    }
    return this._texture.is3D;
  }
  // eslint-disable-next-line @typescript-eslint/naming-convention
  set is3D(value) {
    if (!this._texture) {
      return;
    }
    this._texture.is3D = value;
  }
  /**
   * Define if the texture is a 2d array texture (webgl 2) or if false a 2d texture.
   */
  get is2DArray() {
    if (!this._texture) {
      return false;
    }
    return this._texture.is2DArray;
  }
  // eslint-disable-next-line @typescript-eslint/naming-convention
  set is2DArray(value) {
    if (!this._texture) {
      return;
    }
    this._texture.is2DArray = value;
  }
  /**
   * Define if the texture contains data in gamma space (most of the png/jpg aside bump).
   * HDR texture are usually stored in linear space.
   * This only impacts the PBR and Background materials
   */
  get gammaSpace() {
    if (!this._texture) {
      return this._gammaSpace;
    } else {
      if (this._texture._gammaSpace === null) {
        this._texture._gammaSpace = this._gammaSpace;
      }
    }
    return this._texture._gammaSpace && !this._texture._useSRGBBuffer;
  }
  set gammaSpace(gamma) {
    if (!this._texture) {
      if (this._gammaSpace === gamma) {
        return;
      }
      this._gammaSpace = gamma;
    } else {
      if (this._texture._gammaSpace === gamma) {
        return;
      }
      this._texture._gammaSpace = gamma;
    }
    this.getScene()?.markAllMaterialsAsDirty(1, (mat) => {
      return mat.hasTexture(this);
    });
  }
  /**
   * Gets or sets whether or not the texture contains RGBD data.
   */
  get isRGBD() {
    return this._texture != null && this._texture._isRGBD;
  }
  set isRGBD(value) {
    if (value === this.isRGBD) {
      return;
    }
    if (this._texture) {
      this._texture._isRGBD = value;
    }
    this.getScene()?.markAllMaterialsAsDirty(1, (mat) => {
      return mat.hasTexture(this);
    });
  }
  /**
   * Are mip maps generated for this texture or not.
   */
  get noMipmap() {
    return false;
  }
  /**
   * With prefiltered texture, defined the offset used during the prefiltering steps.
   */
  get lodGenerationOffset() {
    if (this._texture) {
      return this._texture._lodGenerationOffset;
    }
    return 0;
  }
  set lodGenerationOffset(value) {
    if (this._texture) {
      this._texture._lodGenerationOffset = value;
    }
  }
  /**
   * With prefiltered texture, defined the scale used during the prefiltering steps.
   */
  get lodGenerationScale() {
    if (this._texture) {
      return this._texture._lodGenerationScale;
    }
    return 0;
  }
  set lodGenerationScale(value) {
    if (this._texture) {
      this._texture._lodGenerationScale = value;
    }
  }
  /**
   * With prefiltered texture, defined if the specular generation is based on a linear ramp.
   * By default we are using a log2 of the linear roughness helping to keep a better resolution for
   * average roughness values.
   */
  get linearSpecularLOD() {
    if (this._texture) {
      return this._texture._linearSpecularLOD;
    }
    return false;
  }
  set linearSpecularLOD(value) {
    if (this._texture) {
      this._texture._linearSpecularLOD = value;
    }
  }
  /**
   * In case a better definition than spherical harmonics is required for the diffuse part of the environment.
   * You can set the irradiance texture to rely on a texture instead of the spherical approach.
   * This texture need to have the same characteristics than its parent (Cube vs 2d, coordinates mode, Gamma/Linear, RGBD).
   */
  get irradianceTexture() {
    if (this._texture) {
      return this._texture._irradianceTexture;
    }
    return null;
  }
  set irradianceTexture(value) {
    if (this._texture) {
      this._texture._irradianceTexture = value;
    }
  }
  /**
   * Define the unique id of the texture in the scene.
   */
  get uid() {
    if (!this._uid) {
      this._uid = RandomGUID();
    }
    return this._uid;
  }
  /**
   * Return a string representation of the texture.
   * @returns the texture as a string
   */
  toString() {
    return this.name;
  }
  /**
   * Get the class name of the texture.
   * @returns "BaseTexture"
   */
  getClassName() {
    return "BaseTexture";
  }
  /**
   * Callback triggered when the texture has been disposed.
   * Kept for back compatibility, you can use the onDisposeObservable instead.
   */
  set onDispose(callback) {
    if (this._onDisposeObserver) {
      this.onDisposeObservable.remove(this._onDisposeObserver);
    }
    this._onDisposeObserver = this.onDisposeObservable.add(callback);
  }
  /**
   * Define if the texture is preventing a material to render or not.
   * If not and the texture is not ready, the engine will use a default black texture instead.
   */
  get isBlocking() {
    return true;
  }
  /**
   * Was there any loading error?
   */
  get loadingError() {
    return this._loadingError;
  }
  /**
   * If a loading error occurred this object will be populated with information about the error.
   */
  get errorObject() {
    return this._errorObject;
  }
  /**
   * Instantiates a new BaseTexture.
   * Base class of all the textures in babylon.
   * It groups all the common properties the materials, post process, lights... might need
   * in order to make a correct use of the texture.
   * @param sceneOrEngine Define the scene or engine the texture belongs to
   * @param internalTexture Define the internal texture associated with the texture
   */
  constructor(sceneOrEngine, internalTexture = null) {
    super(null);
    this.metadata = null;
    this.reservedDataStore = null;
    this._hasAlpha = false;
    this._getAlphaFromRGB = false;
    this.level = 1;
    this._coordinatesIndex = 0;
    this.optimizeUVAllocation = true;
    this._coordinatesMode = 0;
    this.wrapR = 1;
    this.anisotropicFilteringLevel = _BaseTexture.DEFAULT_ANISOTROPIC_FILTERING_LEVEL;
    this._isCube = false;
    this._gammaSpace = true;
    this.invertZ = false;
    this.lodLevelInAlpha = false;
    this.isRenderTarget = false;
    this._prefiltered = false;
    this._forceSerialize = false;
    this.animations = [];
    this.onDisposeObservable = new Observable();
    this._onDisposeObserver = null;
    this._scene = null;
    this._uid = null;
    this._parentContainer = null;
    this._loadingError = false;
    if (sceneOrEngine) {
      if (_BaseTexture._IsScene(sceneOrEngine)) {
        this._scene = sceneOrEngine;
      } else {
        this._engine = sceneOrEngine;
      }
    } else {
      this._scene = EngineStore.LastCreatedScene;
    }
    if (this._scene) {
      this.uniqueId = this._scene.getUniqueId();
      this._scene.addTexture(this);
      this._engine = this._scene.getEngine();
    }
    this._texture = internalTexture;
    this._uid = null;
  }
  /**
   * Get the scene the texture belongs to.
   * @returns the scene or null if undefined
   */
  getScene() {
    return this._scene;
  }
  /** @internal */
  _getEngine() {
    return this._engine;
  }
  /**
   * Checks if the texture has the same transform matrix than another texture
   * @param texture texture to check against
   * @returns true if the transforms are the same, else false
   */
  checkTransformsAreIdentical(texture) {
    return texture !== null;
  }
  /**
   * Get the texture transform matrix used to offset tile the texture for instance.
   * @returns the transformation matrix
   */
  getTextureMatrix() {
    return Matrix.IdentityReadOnly;
  }
  /**
   * Get the texture reflection matrix used to rotate/transform the reflection.
   * @returns the reflection matrix
   */
  getReflectionTextureMatrix() {
    return Matrix.IdentityReadOnly;
  }
  /**
   * Gets a suitable rotate/transform matrix when the texture is used for refraction.
   * There's a separate function from getReflectionTextureMatrix because refraction requires a special configuration of the matrix in right-handed mode.
   * @returns The refraction matrix
   */
  getRefractionTextureMatrix() {
    return this.getReflectionTextureMatrix();
  }
  /**
   * Get if the texture is ready to be consumed (either it is ready or it is not blocking)
   * @returns true if ready, not blocking or if there was an error loading the texture
   */
  isReadyOrNotBlocking() {
    return !this.isBlocking || this.isReady() || this.loadingError;
  }
  /**
   * Scales the texture if is `canRescale()`
   * @param ratio the resize factor we want to use to rescale
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  scale(ratio) {
  }
  /**
   * Get if the texture can rescale.
   */
  get canRescale() {
    return false;
  }
  /**
   * @internal
   */
  _getFromCache(url, noMipmap, sampling, invertY, useSRGBBuffer, isCube) {
    const engine = this._getEngine();
    if (!engine) {
      return null;
    }
    const correctedUseSRGBBuffer = engine._getUseSRGBBuffer(!!useSRGBBuffer, noMipmap);
    const texturesCache = engine.getLoadedTexturesCache();
    for (let index = 0; index < texturesCache.length; index++) {
      const texturesCacheEntry = texturesCache[index];
      if (useSRGBBuffer === void 0 || correctedUseSRGBBuffer === texturesCacheEntry._useSRGBBuffer) {
        if (invertY === void 0 || invertY === texturesCacheEntry.invertY) {
          if (texturesCacheEntry.url === url && texturesCacheEntry.generateMipMaps === !noMipmap) {
            if (!sampling || sampling === texturesCacheEntry.samplingMode) {
              if (isCube === void 0 || isCube === texturesCacheEntry.isCube) {
                texturesCacheEntry.incrementReferences();
                return texturesCacheEntry;
              }
            }
          }
        }
      }
    }
    return null;
  }
  /** @internal */
  _rebuild(_fromContextLost = false) {
  }
  /**
   * Clones the texture.
   * @returns the cloned texture
   */
  clone() {
    return null;
  }
  /**
   * Get the texture underlying type (INT, FLOAT...)
   */
  get textureType() {
    if (!this._texture) {
      return 0;
    }
    return this._texture.type !== void 0 ? this._texture.type : 0;
  }
  /**
   * Get the texture underlying format (RGB, RGBA...)
   */
  get textureFormat() {
    if (!this._texture) {
      return 5;
    }
    return this._texture.format !== void 0 ? this._texture.format : 5;
  }
  /**
   * Indicates that textures need to be re-calculated for all materials
   */
  _markAllSubMeshesAsTexturesDirty() {
    const scene = this.getScene();
    if (!scene) {
      return;
    }
    scene.markAllMaterialsAsDirty(1);
  }
  /**
   * Reads the pixels stored in the webgl texture and returns them as an ArrayBuffer.
   * This will returns an RGBA array buffer containing either in values (0-255) or
   * float values (0-1) depending of the underlying buffer type.
   * @param faceIndex defines the face of the texture to read (in case of cube texture)
   * @param level defines the LOD level of the texture to read (in case of Mip Maps)
   * @param buffer defines a user defined buffer to fill with data (can be null)
   * @param flushRenderer true to flush the renderer from the pending commands before reading the pixels
   * @param noDataConversion false to convert the data to Uint8Array (if texture type is UNSIGNED_BYTE) or to Float32Array (if texture type is anything but UNSIGNED_BYTE). If true, the type of the generated buffer (if buffer==null) will depend on the type of the texture
   * @param x defines the region x coordinates to start reading from (default to 0)
   * @param y defines the region y coordinates to start reading from (default to 0)
   * @param width defines the region width to read from (default to the texture size at level)
   * @param height defines the region width to read from (default to the texture size at level)
   * @returns The Array buffer promise containing the pixels data.
   */
  readPixels(faceIndex = 0, level = 0, buffer = null, flushRenderer = true, noDataConversion = false, x = 0, y = 0, width = Number.MAX_VALUE, height = Number.MAX_VALUE) {
    if (!this._texture) {
      return null;
    }
    const engine = this._getEngine();
    if (!engine) {
      return null;
    }
    const size = this.getSize();
    let maxWidth = size.width;
    let maxHeight = size.height;
    if (level !== 0) {
      maxWidth = maxWidth / Math.pow(2, level);
      maxHeight = maxHeight / Math.pow(2, level);
      maxWidth = Math.round(maxWidth);
      maxHeight = Math.round(maxHeight);
    }
    width = Math.min(maxWidth, width);
    height = Math.min(maxHeight, height);
    try {
      if (this._texture.isCube) {
        return engine._readTexturePixels(this._texture, width, height, faceIndex, level, buffer, flushRenderer, noDataConversion, x, y);
      }
      return engine._readTexturePixels(this._texture, width, height, -1, level, buffer, flushRenderer, noDataConversion, x, y);
    } catch (e) {
      return null;
    }
  }
  /**
   * @internal
   */
  _readPixelsSync(faceIndex = 0, level = 0, buffer = null, flushRenderer = true, noDataConversion = false) {
    if (!this._texture) {
      return null;
    }
    const size = this.getSize();
    let width = size.width;
    let height = size.height;
    const engine = this._getEngine();
    if (!engine) {
      return null;
    }
    if (level != 0) {
      width = width / Math.pow(2, level);
      height = height / Math.pow(2, level);
      width = Math.round(width);
      height = Math.round(height);
    }
    try {
      if (this._texture.isCube) {
        return engine._readTexturePixelsSync(this._texture, width, height, faceIndex, level, buffer, flushRenderer, noDataConversion);
      }
      return engine._readTexturePixelsSync(this._texture, width, height, -1, level, buffer, flushRenderer, noDataConversion);
    } catch (e) {
      return null;
    }
  }
  /** @internal */
  get _lodTextureHigh() {
    if (this._texture) {
      return this._texture._lodTextureHigh;
    }
    return null;
  }
  /** @internal */
  get _lodTextureMid() {
    if (this._texture) {
      return this._texture._lodTextureMid;
    }
    return null;
  }
  /** @internal */
  get _lodTextureLow() {
    if (this._texture) {
      return this._texture._lodTextureLow;
    }
    return null;
  }
  /**
   * Dispose the texture and release its associated resources.
   */
  dispose() {
    if (this._scene) {
      if (this._scene.stopAnimation) {
        this._scene.stopAnimation(this);
      }
      this._scene.removePendingData(this);
      const index = this._scene.textures.indexOf(this);
      if (index >= 0) {
        this._scene.textures.splice(index, 1);
      }
      this._scene.onTextureRemovedObservable.notifyObservers(this);
      this._scene = null;
      if (this._parentContainer) {
        const index2 = this._parentContainer.textures.indexOf(this);
        if (index2 > -1) {
          this._parentContainer.textures.splice(index2, 1);
        }
        this._parentContainer = null;
      }
    }
    this.onDisposeObservable.notifyObservers(this);
    this.onDisposeObservable.clear();
    this.metadata = null;
    super.dispose();
  }
  /**
   * Serialize the texture into a JSON representation that can be parsed later on.
   * @param allowEmptyName True to force serialization even if name is empty. Default: false
   * @returns the JSON representation of the texture
   */
  serialize(allowEmptyName = false) {
    if (!this.name && !allowEmptyName) {
      return null;
    }
    const serializationObject = SerializationHelper.Serialize(this);
    SerializationHelper.AppendSerializedAnimations(this, serializationObject);
    return serializationObject;
  }
  /**
   * Helper function to be called back once a list of texture contains only ready textures.
   * @param textures Define the list of textures to wait for
   * @param callback Define the callback triggered once the entire list will be ready
   */
  static WhenAllReady(textures, callback) {
    let numRemaining = textures.length;
    if (numRemaining === 0) {
      callback();
      return;
    }
    for (let i = 0; i < textures.length; i++) {
      const texture = textures[i];
      if (texture.isReady()) {
        if (--numRemaining === 0) {
          callback();
        }
      } else {
        const onLoadObservable = texture.onLoadObservable;
        if (onLoadObservable) {
          onLoadObservable.addOnce(() => {
            if (--numRemaining === 0) {
              callback();
            }
          });
        } else {
          if (--numRemaining === 0) {
            callback();
          }
        }
      }
    }
  }
  static _IsScene(sceneOrEngine) {
    return sceneOrEngine.getClassName() === "Scene";
  }
};
BaseTexture.DEFAULT_ANISOTROPIC_FILTERING_LEVEL = 4;
__decorate([
  serialize()
], BaseTexture.prototype, "uniqueId", void 0);
__decorate([
  serialize()
], BaseTexture.prototype, "name", void 0);
__decorate([
  serialize()
], BaseTexture.prototype, "metadata", void 0);
__decorate([
  serialize("hasAlpha")
], BaseTexture.prototype, "_hasAlpha", void 0);
__decorate([
  serialize("getAlphaFromRGB")
], BaseTexture.prototype, "_getAlphaFromRGB", void 0);
__decorate([
  serialize()
], BaseTexture.prototype, "level", void 0);
__decorate([
  serialize("coordinatesIndex")
], BaseTexture.prototype, "_coordinatesIndex", void 0);
__decorate([
  serialize()
], BaseTexture.prototype, "optimizeUVAllocation", void 0);
__decorate([
  serialize("coordinatesMode")
], BaseTexture.prototype, "_coordinatesMode", void 0);
__decorate([
  serialize()
], BaseTexture.prototype, "wrapU", null);
__decorate([
  serialize()
], BaseTexture.prototype, "wrapV", null);
__decorate([
  serialize()
], BaseTexture.prototype, "wrapR", void 0);
__decorate([
  serialize()
], BaseTexture.prototype, "anisotropicFilteringLevel", void 0);
__decorate([
  serialize()
], BaseTexture.prototype, "isCube", null);
__decorate([
  serialize()
], BaseTexture.prototype, "is3D", null);
__decorate([
  serialize()
], BaseTexture.prototype, "is2DArray", null);
__decorate([
  serialize()
], BaseTexture.prototype, "gammaSpace", null);
__decorate([
  serialize()
], BaseTexture.prototype, "invertZ", void 0);
__decorate([
  serialize()
], BaseTexture.prototype, "lodLevelInAlpha", void 0);
__decorate([
  serialize()
], BaseTexture.prototype, "lodGenerationOffset", null);
__decorate([
  serialize()
], BaseTexture.prototype, "lodGenerationScale", null);
__decorate([
  serialize()
], BaseTexture.prototype, "linearSpecularLOD", null);
__decorate([
  serializeAsTexture()
], BaseTexture.prototype, "irradianceTexture", null);
__decorate([
  serialize()
], BaseTexture.prototype, "isRenderTarget", void 0);

// ../../node_modules/@babylonjs/core/Misc/copyTools.js
function GenerateBase64StringFromPixelData(pixels, size, invertY = false) {
  const width = size.width;
  const height = size.height;
  if (pixels instanceof Float32Array) {
    let len2 = pixels.byteLength / pixels.BYTES_PER_ELEMENT;
    const npixels = new Uint8Array(len2);
    while (--len2 >= 0) {
      let val = pixels[len2];
      if (val < 0) {
        val = 0;
      } else if (val > 1) {
        val = 1;
      }
      npixels[len2] = val * 255;
    }
    pixels = npixels;
  }
  const canvas = document.createElement("canvas");
  canvas.width = width;
  canvas.height = height;
  const ctx = canvas.getContext("2d");
  if (!ctx) {
    return null;
  }
  const imageData = ctx.createImageData(width, height);
  const castData = imageData.data;
  castData.set(pixels);
  ctx.putImageData(imageData, 0, 0);
  if (invertY) {
    const canvas2 = document.createElement("canvas");
    canvas2.width = width;
    canvas2.height = height;
    const ctx2 = canvas2.getContext("2d");
    if (!ctx2) {
      return null;
    }
    ctx2.translate(0, height);
    ctx2.scale(1, -1);
    ctx2.drawImage(canvas, 0, 0);
    return canvas2.toDataURL("image/png");
  }
  return canvas.toDataURL("image/png");
}
function GenerateBase64StringFromTexture(texture, faceIndex = 0, level = 0) {
  const internalTexture = texture.getInternalTexture();
  if (!internalTexture) {
    return null;
  }
  const pixels = texture._readPixelsSync(faceIndex, level);
  if (!pixels) {
    return null;
  }
  return GenerateBase64StringFromPixelData(pixels, texture.getSize(), internalTexture.invertY);
}
async function GenerateBase64StringFromTextureAsync(texture, faceIndex = 0, level = 0) {
  const internalTexture = texture.getInternalTexture();
  if (!internalTexture) {
    return null;
  }
  const pixels = await texture.readPixels(faceIndex, level);
  if (!pixels) {
    return null;
  }
  return GenerateBase64StringFromPixelData(pixels, texture.getSize(), internalTexture.invertY);
}

// ../../node_modules/@babylonjs/core/Materials/Textures/texture.js
var Texture = class _Texture extends BaseTexture {
  /**
   * @internal
   */
  static _CreateVideoTexture(name66, src, scene, generateMipMaps = false, invertY = false, samplingMode = _Texture.TRILINEAR_SAMPLINGMODE, settings = {}, onError, format = 5) {
    throw _WarnImport("VideoTexture");
  }
  /**
   * Are mip maps generated for this texture or not.
   */
  get noMipmap() {
    return this._noMipmap;
  }
  /** Returns the texture mime type if it was defined by a loader (undefined else) */
  get mimeType() {
    return this._mimeType;
  }
  /**
   * Is the texture preventing material to render while loading.
   * If false, a default texture will be used instead of the loading one during the preparation step.
   */
  set isBlocking(value) {
    this._isBlocking = value;
  }
  get isBlocking() {
    return this._isBlocking;
  }
  /**
   * Gets a boolean indicating if the texture needs to be inverted on the y axis during loading
   */
  get invertY() {
    return this._invertY;
  }
  /**
   * Instantiates a new texture.
   * This represents a texture in babylon. It can be easily loaded from a network, base64 or html input.
   * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/materials_introduction#texture
   * @param url defines the url of the picture to load as a texture
   * @param sceneOrEngine defines the scene or engine the texture will belong to
   * @param noMipmapOrOptions defines if the texture will require mip maps or not or set of all options to create the texture
   * @param invertY defines if the texture needs to be inverted on the y axis during loading
   * @param samplingMode defines the sampling mode we want for the texture while fetching from it (Texture.NEAREST_SAMPLINGMODE...)
   * @param onLoad defines a callback triggered when the texture has been loaded
   * @param onError defines a callback triggered when an error occurred during the loading session
   * @param buffer defines the buffer to load the texture from in case the texture is loaded from a buffer representation
   * @param deleteBuffer defines if the buffer we are loading the texture from should be deleted after load
   * @param format defines the format of the texture we are trying to load (Engine.TEXTUREFORMAT_RGBA...)
   * @param mimeType defines an optional mime type information
   * @param loaderOptions options to be passed to the loader
   * @param creationFlags specific flags to use when creating the texture (1 for storage textures, for eg)
   * @param forcedExtension defines the extension to use to pick the right loader
   */
  constructor(url, sceneOrEngine, noMipmapOrOptions, invertY, samplingMode = _Texture.TRILINEAR_SAMPLINGMODE, onLoad = null, onError = null, buffer = null, deleteBuffer = false, format, mimeType, loaderOptions, creationFlags, forcedExtension) {
    super(sceneOrEngine);
    this.url = null;
    this.uOffset = 0;
    this.vOffset = 0;
    this.uScale = 1;
    this.vScale = 1;
    this.uAng = 0;
    this.vAng = 0;
    this.wAng = 0;
    this.uRotationCenter = 0.5;
    this.vRotationCenter = 0.5;
    this.wRotationCenter = 0.5;
    this.homogeneousRotationInUVTransform = false;
    this.inspectableCustomProperties = null;
    this._noMipmap = false;
    this._invertY = false;
    this._rowGenerationMatrix = null;
    this._cachedTextureMatrix = null;
    this._projectionModeMatrix = null;
    this._t0 = null;
    this._t1 = null;
    this._t2 = null;
    this._cachedUOffset = -1;
    this._cachedVOffset = -1;
    this._cachedUScale = 0;
    this._cachedVScale = 0;
    this._cachedUAng = -1;
    this._cachedVAng = -1;
    this._cachedWAng = -1;
    this._cachedReflectionProjectionMatrixId = -1;
    this._cachedURotationCenter = -1;
    this._cachedVRotationCenter = -1;
    this._cachedWRotationCenter = -1;
    this._cachedHomogeneousRotationInUVTransform = false;
    this._cachedReflectionTextureMatrix = null;
    this._cachedReflectionUOffset = -1;
    this._cachedReflectionVOffset = -1;
    this._cachedReflectionUScale = 0;
    this._cachedReflectionVScale = 0;
    this._cachedReflectionCoordinatesMode = -1;
    this._buffer = null;
    this._deleteBuffer = false;
    this._format = null;
    this._delayedOnLoad = null;
    this._delayedOnError = null;
    this.onLoadObservable = new Observable();
    this._isBlocking = true;
    this.name = url || "";
    this.url = url;
    let noMipmap;
    let useSRGBBuffer = false;
    let internalTexture = null;
    let gammaSpace = true;
    if (typeof noMipmapOrOptions === "object" && noMipmapOrOptions !== null) {
      noMipmap = noMipmapOrOptions.noMipmap ?? false;
      invertY = noMipmapOrOptions.invertY ?? (CompatibilityOptions.UseOpenGLOrientationForUV ? false : true);
      samplingMode = noMipmapOrOptions.samplingMode ?? _Texture.TRILINEAR_SAMPLINGMODE;
      onLoad = noMipmapOrOptions.onLoad ?? null;
      onError = noMipmapOrOptions.onError ?? null;
      buffer = noMipmapOrOptions.buffer ?? null;
      deleteBuffer = noMipmapOrOptions.deleteBuffer ?? false;
      format = noMipmapOrOptions.format;
      mimeType = noMipmapOrOptions.mimeType;
      loaderOptions = noMipmapOrOptions.loaderOptions;
      creationFlags = noMipmapOrOptions.creationFlags;
      useSRGBBuffer = noMipmapOrOptions.useSRGBBuffer ?? false;
      internalTexture = noMipmapOrOptions.internalTexture ?? null;
      gammaSpace = noMipmapOrOptions.gammaSpace ?? gammaSpace;
    } else {
      noMipmap = !!noMipmapOrOptions;
    }
    this._gammaSpace = gammaSpace;
    this._noMipmap = noMipmap;
    this._invertY = invertY === void 0 ? CompatibilityOptions.UseOpenGLOrientationForUV ? false : true : invertY;
    this._initialSamplingMode = samplingMode;
    this._buffer = buffer;
    this._deleteBuffer = deleteBuffer;
    this._mimeType = mimeType;
    this._loaderOptions = loaderOptions;
    this._creationFlags = creationFlags;
    this._useSRGBBuffer = useSRGBBuffer;
    this._forcedExtension = forcedExtension;
    if (format) {
      this._format = format;
    }
    const scene = this.getScene();
    const engine = this._getEngine();
    if (!engine) {
      return;
    }
    engine.onBeforeTextureInitObservable.notifyObservers(this);
    const load = () => {
      if (this._texture) {
        if (this._texture._invertVScale) {
          this.vScale *= -1;
          this.vOffset += 1;
        }
        if (this._texture._cachedWrapU !== null) {
          this.wrapU = this._texture._cachedWrapU;
          this._texture._cachedWrapU = null;
        }
        if (this._texture._cachedWrapV !== null) {
          this.wrapV = this._texture._cachedWrapV;
          this._texture._cachedWrapV = null;
        }
        if (this._texture._cachedWrapR !== null) {
          this.wrapR = this._texture._cachedWrapR;
          this._texture._cachedWrapR = null;
        }
      }
      if (this.onLoadObservable.hasObservers()) {
        this.onLoadObservable.notifyObservers(this);
      }
      if (onLoad) {
        onLoad();
      }
      if (!this.isBlocking && scene) {
        scene.resetCachedMaterial();
      }
    };
    const errorHandler = (message, exception) => {
      this._loadingError = true;
      this._errorObject = { message, exception };
      if (onError) {
        onError(message, exception);
      }
      _Texture.OnTextureLoadErrorObservable.notifyObservers(this);
    };
    if (!this.url && !internalTexture) {
      this._delayedOnLoad = load;
      this._delayedOnError = errorHandler;
      return;
    }
    this._texture = internalTexture ?? this._getFromCache(this.url, noMipmap, samplingMode, this._invertY, useSRGBBuffer, this.isCube);
    if (!this._texture) {
      if (!scene || !scene.useDelayedTextureLoading) {
        try {
          this._texture = engine.createTexture(this.url, noMipmap, this._invertY, scene, samplingMode, load, errorHandler, this._buffer, void 0, this._format, this._forcedExtension, mimeType, loaderOptions, creationFlags, useSRGBBuffer);
        } catch (e) {
          errorHandler("error loading", e);
          throw e;
        }
        if (deleteBuffer) {
          this._buffer = null;
        }
      } else {
        this.delayLoadState = 4;
        this._delayedOnLoad = load;
        this._delayedOnError = errorHandler;
      }
    } else {
      if (this._texture.isReady) {
        TimingTools.SetImmediate(() => load());
      } else {
        const loadObserver = this._texture.onLoadedObservable.add(load);
        this._texture.onErrorObservable.add((e) => {
          errorHandler(e.message, e.exception);
          this._texture?.onLoadedObservable.remove(loadObserver);
        });
      }
    }
  }
  /**
   * Update the url (and optional buffer) of this texture if url was null during construction.
   * @param url the url of the texture
   * @param buffer the buffer of the texture (defaults to null)
   * @param onLoad callback called when the texture is loaded  (defaults to null)
   * @param forcedExtension defines the extension to use to pick the right loader
   */
  updateURL(url, buffer = null, onLoad, forcedExtension) {
    if (this.url) {
      this.releaseInternalTexture();
      this.getScene().markAllMaterialsAsDirty(1, (mat) => {
        return mat.hasTexture(this);
      });
    }
    if (!this.name || this.name.startsWith("data:")) {
      this.name = url;
    }
    this.url = url;
    this._buffer = buffer;
    this._forcedExtension = forcedExtension;
    this.delayLoadState = 4;
    if (onLoad) {
      this._delayedOnLoad = onLoad;
    }
    this.delayLoad();
  }
  /**
   * Finish the loading sequence of a texture flagged as delayed load.
   * @internal
   */
  delayLoad() {
    if (this.delayLoadState !== 4) {
      return;
    }
    const scene = this.getScene();
    if (!scene) {
      return;
    }
    this.delayLoadState = 1;
    this._texture = this._getFromCache(this.url, this._noMipmap, this.samplingMode, this._invertY, this._useSRGBBuffer, this.isCube);
    if (!this._texture) {
      this._texture = scene.getEngine().createTexture(this.url, this._noMipmap, this._invertY, scene, this.samplingMode, this._delayedOnLoad, this._delayedOnError, this._buffer, null, this._format, this._forcedExtension, this._mimeType, this._loaderOptions, this._creationFlags, this._useSRGBBuffer);
      if (this._deleteBuffer) {
        this._buffer = null;
      }
    } else {
      if (this._delayedOnLoad) {
        if (this._texture.isReady) {
          TimingTools.SetImmediate(this._delayedOnLoad);
        } else {
          this._texture.onLoadedObservable.add(this._delayedOnLoad);
        }
      }
    }
    this._delayedOnLoad = null;
    this._delayedOnError = null;
  }
  _prepareRowForTextureGeneration(x, y, z, t) {
    x *= this._cachedUScale;
    y *= this._cachedVScale;
    x -= this.uRotationCenter * this._cachedUScale;
    y -= this.vRotationCenter * this._cachedVScale;
    z -= this.wRotationCenter;
    Vector3.TransformCoordinatesFromFloatsToRef(x, y, z, this._rowGenerationMatrix, t);
    t.x += this.uRotationCenter * this._cachedUScale + this._cachedUOffset;
    t.y += this.vRotationCenter * this._cachedVScale + this._cachedVOffset;
    t.z += this.wRotationCenter;
  }
  /**
   * Checks if the texture has the same transform matrix than another texture
   * @param texture texture to check against
   * @returns true if the transforms are the same, else false
   */
  checkTransformsAreIdentical(texture) {
    return texture !== null && this.uOffset === texture.uOffset && this.vOffset === texture.vOffset && this.uScale === texture.uScale && this.vScale === texture.vScale && this.uAng === texture.uAng && this.vAng === texture.vAng && this.wAng === texture.wAng;
  }
  /**
   * Get the current texture matrix which includes the requested offsetting, tiling and rotation components.
   * @param uBase The horizontal base offset multiplier (1 by default)
   * @returns the transform matrix of the texture.
   */
  getTextureMatrix(uBase = 1) {
    if (this.uOffset === this._cachedUOffset && this.vOffset === this._cachedVOffset && this.uScale * uBase === this._cachedUScale && this.vScale === this._cachedVScale && this.uAng === this._cachedUAng && this.vAng === this._cachedVAng && this.wAng === this._cachedWAng && this.uRotationCenter === this._cachedURotationCenter && this.vRotationCenter === this._cachedVRotationCenter && this.wRotationCenter === this._cachedWRotationCenter && this.homogeneousRotationInUVTransform === this._cachedHomogeneousRotationInUVTransform) {
      return this._cachedTextureMatrix;
    }
    this._cachedUOffset = this.uOffset;
    this._cachedVOffset = this.vOffset;
    this._cachedUScale = this.uScale * uBase;
    this._cachedVScale = this.vScale;
    this._cachedUAng = this.uAng;
    this._cachedVAng = this.vAng;
    this._cachedWAng = this.wAng;
    this._cachedURotationCenter = this.uRotationCenter;
    this._cachedVRotationCenter = this.vRotationCenter;
    this._cachedWRotationCenter = this.wRotationCenter;
    this._cachedHomogeneousRotationInUVTransform = this.homogeneousRotationInUVTransform;
    if (!this._cachedTextureMatrix || !this._rowGenerationMatrix) {
      this._cachedTextureMatrix = Matrix.Zero();
      this._rowGenerationMatrix = new Matrix();
      this._t0 = Vector3.Zero();
      this._t1 = Vector3.Zero();
      this._t2 = Vector3.Zero();
    }
    Matrix.RotationYawPitchRollToRef(this.vAng, this.uAng, this.wAng, this._rowGenerationMatrix);
    if (this.homogeneousRotationInUVTransform) {
      Matrix.TranslationToRef(-this._cachedURotationCenter, -this._cachedVRotationCenter, -this._cachedWRotationCenter, TmpVectors.Matrix[0]);
      Matrix.TranslationToRef(this._cachedURotationCenter, this._cachedVRotationCenter, this._cachedWRotationCenter, TmpVectors.Matrix[1]);
      Matrix.ScalingToRef(this._cachedUScale, this._cachedVScale, 0, TmpVectors.Matrix[2]);
      Matrix.TranslationToRef(this._cachedUOffset, this._cachedVOffset, 0, TmpVectors.Matrix[3]);
      TmpVectors.Matrix[0].multiplyToRef(this._rowGenerationMatrix, this._cachedTextureMatrix);
      this._cachedTextureMatrix.multiplyToRef(TmpVectors.Matrix[1], this._cachedTextureMatrix);
      this._cachedTextureMatrix.multiplyToRef(TmpVectors.Matrix[2], this._cachedTextureMatrix);
      this._cachedTextureMatrix.multiplyToRef(TmpVectors.Matrix[3], this._cachedTextureMatrix);
      this._cachedTextureMatrix.setRowFromFloats(2, this._cachedTextureMatrix.m[12], this._cachedTextureMatrix.m[13], this._cachedTextureMatrix.m[14], 1);
    } else {
      this._prepareRowForTextureGeneration(0, 0, 0, this._t0);
      this._prepareRowForTextureGeneration(1, 0, 0, this._t1);
      this._prepareRowForTextureGeneration(0, 1, 0, this._t2);
      this._t1.subtractInPlace(this._t0);
      this._t2.subtractInPlace(this._t0);
      Matrix.FromValuesToRef(this._t1.x, this._t1.y, this._t1.z, 0, this._t2.x, this._t2.y, this._t2.z, 0, this._t0.x, this._t0.y, this._t0.z, 0, 0, 0, 0, 1, this._cachedTextureMatrix);
    }
    const scene = this.getScene();
    if (!scene) {
      return this._cachedTextureMatrix;
    }
    if (this.optimizeUVAllocation) {
      scene.markAllMaterialsAsDirty(1, (mat) => {
        return mat.hasTexture(this);
      });
    }
    return this._cachedTextureMatrix;
  }
  /**
   * Get the current matrix used to apply reflection. This is useful to rotate an environment texture for instance.
   * @returns The reflection texture transform
   */
  getReflectionTextureMatrix() {
    const scene = this.getScene();
    if (!scene) {
      return this._cachedReflectionTextureMatrix;
    }
    if (this.uOffset === this._cachedReflectionUOffset && this.vOffset === this._cachedReflectionVOffset && this.uScale === this._cachedReflectionUScale && this.vScale === this._cachedReflectionVScale && this.coordinatesMode === this._cachedReflectionCoordinatesMode) {
      if (this.coordinatesMode === _Texture.PROJECTION_MODE) {
        if (this._cachedReflectionProjectionMatrixId === scene.getProjectionMatrix().updateFlag) {
          return this._cachedReflectionTextureMatrix;
        }
      } else {
        return this._cachedReflectionTextureMatrix;
      }
    }
    if (!this._cachedReflectionTextureMatrix) {
      this._cachedReflectionTextureMatrix = Matrix.Zero();
    }
    if (!this._projectionModeMatrix) {
      this._projectionModeMatrix = Matrix.Zero();
    }
    const flagMaterialsAsTextureDirty = this._cachedReflectionCoordinatesMode !== this.coordinatesMode;
    this._cachedReflectionUOffset = this.uOffset;
    this._cachedReflectionVOffset = this.vOffset;
    this._cachedReflectionUScale = this.uScale;
    this._cachedReflectionVScale = this.vScale;
    this._cachedReflectionCoordinatesMode = this.coordinatesMode;
    switch (this.coordinatesMode) {
      case _Texture.PLANAR_MODE: {
        Matrix.IdentityToRef(this._cachedReflectionTextureMatrix);
        this._cachedReflectionTextureMatrix[0] = this.uScale;
        this._cachedReflectionTextureMatrix[5] = this.vScale;
        this._cachedReflectionTextureMatrix[12] = this.uOffset;
        this._cachedReflectionTextureMatrix[13] = this.vOffset;
        break;
      }
      case _Texture.PROJECTION_MODE: {
        Matrix.FromValuesToRef(0.5, 0, 0, 0, 0, -0.5, 0, 0, 0, 0, 0, 0, 0.5, 0.5, 1, 1, this._projectionModeMatrix);
        const projectionMatrix = scene.getProjectionMatrix();
        this._cachedReflectionProjectionMatrixId = projectionMatrix.updateFlag;
        projectionMatrix.multiplyToRef(this._projectionModeMatrix, this._cachedReflectionTextureMatrix);
        break;
      }
      default:
        Matrix.IdentityToRef(this._cachedReflectionTextureMatrix);
        break;
    }
    if (flagMaterialsAsTextureDirty) {
      scene.markAllMaterialsAsDirty(1, (mat) => {
        return mat.hasTexture(this);
      });
    }
    return this._cachedReflectionTextureMatrix;
  }
  /**
   * Clones the texture.
   * @returns the cloned texture
   */
  clone() {
    const options = {
      noMipmap: this._noMipmap,
      invertY: this._invertY,
      samplingMode: this.samplingMode,
      onLoad: void 0,
      onError: void 0,
      buffer: this._texture ? this._texture._buffer : void 0,
      deleteBuffer: this._deleteBuffer,
      format: this.textureFormat,
      mimeType: this.mimeType,
      loaderOptions: this._loaderOptions,
      creationFlags: this._creationFlags,
      useSRGBBuffer: this._useSRGBBuffer
    };
    return SerializationHelper.Clone(() => {
      return new _Texture(this._texture ? this._texture.url : null, this.getScene(), options);
    }, this);
  }
  /**
   * Serialize the texture to a JSON representation we can easily use in the respective Parse function.
   * @returns The JSON representation of the texture
   */
  serialize() {
    const savedName = this.name;
    if (!_Texture.SerializeBuffers) {
      if (this.name.startsWith("data:")) {
        this.name = "";
      }
    }
    if (this.name.startsWith("data:") && this.url === this.name) {
      this.url = "";
    }
    const serializationObject = super.serialize(_Texture._SerializeInternalTextureUniqueId);
    if (!serializationObject) {
      return null;
    }
    if (_Texture.SerializeBuffers || _Texture.ForceSerializeBuffers) {
      if (typeof this._buffer === "string" && this._buffer.substr(0, 5) === "data:") {
        serializationObject.base64String = this._buffer;
        serializationObject.name = serializationObject.name.replace("data:", "");
      } else if (this.url && this.url.startsWith("data:") && this._buffer instanceof Uint8Array) {
        serializationObject.base64String = "data:image/png;base64," + EncodeArrayBufferToBase64(this._buffer);
      } else if (_Texture.ForceSerializeBuffers || this.url && this.url.startsWith("blob:") || this._forceSerialize) {
        serializationObject.base64String = !this._engine || this._engine._features.supportSyncTextureRead ? GenerateBase64StringFromTexture(this) : GenerateBase64StringFromTextureAsync(this);
      }
    }
    serializationObject.invertY = this._invertY;
    serializationObject.samplingMode = this.samplingMode;
    serializationObject._creationFlags = this._creationFlags;
    serializationObject._useSRGBBuffer = this._useSRGBBuffer;
    if (_Texture._SerializeInternalTextureUniqueId) {
      serializationObject.internalTextureUniqueId = this._texture?.uniqueId ?? void 0;
    }
    serializationObject.noMipmap = this._noMipmap;
    this.name = savedName;
    return serializationObject;
  }
  /**
   * Get the current class name of the texture useful for serialization or dynamic coding.
   * @returns "Texture"
   */
  getClassName() {
    return "Texture";
  }
  /**
   * Dispose the texture and release its associated resources.
   */
  dispose() {
    super.dispose();
    this.onLoadObservable.clear();
    this._delayedOnLoad = null;
    this._delayedOnError = null;
    this._buffer = null;
  }
  /**
   * Parse the JSON representation of a texture in order to recreate the texture in the given scene.
   * @param parsedTexture Define the JSON representation of the texture
   * @param scene Define the scene the parsed texture should be instantiated in
   * @param rootUrl Define the root url of the parsing sequence in the case of relative dependencies
   * @returns The parsed texture if successful
   */
  static Parse(parsedTexture, scene, rootUrl) {
    if (parsedTexture.customType) {
      const customTexture = InstantiationTools.Instantiate(parsedTexture.customType);
      const parsedCustomTexture = customTexture.Parse(parsedTexture, scene, rootUrl);
      if (parsedTexture.samplingMode && parsedCustomTexture.updateSamplingMode && parsedCustomTexture._samplingMode) {
        if (parsedCustomTexture._samplingMode !== parsedTexture.samplingMode) {
          parsedCustomTexture.updateSamplingMode(parsedTexture.samplingMode);
        }
      }
      return parsedCustomTexture;
    }
    if (parsedTexture.isCube && !parsedTexture.isRenderTarget) {
      return _Texture._CubeTextureParser(parsedTexture, scene, rootUrl);
    }
    const hasInternalTextureUniqueId = parsedTexture.internalTextureUniqueId !== void 0;
    if (!parsedTexture.name && !parsedTexture.isRenderTarget && !hasInternalTextureUniqueId) {
      return null;
    }
    let internalTexture;
    if (hasInternalTextureUniqueId) {
      const cache = scene.getEngine().getLoadedTexturesCache();
      for (const texture2 of cache) {
        if (texture2.uniqueId === parsedTexture.internalTextureUniqueId) {
          internalTexture = texture2;
          break;
        }
      }
    }
    const onLoaded = (texture2) => {
      if (texture2 && texture2._texture) {
        texture2._texture._cachedWrapU = null;
        texture2._texture._cachedWrapV = null;
        texture2._texture._cachedWrapR = null;
      }
      if (parsedTexture.samplingMode) {
        const sampling = parsedTexture.samplingMode;
        if (texture2 && texture2.samplingMode !== sampling) {
          texture2.updateSamplingMode(sampling);
        }
      }
      if (texture2 && parsedTexture.animations) {
        for (let animationIndex = 0; animationIndex < parsedTexture.animations.length; animationIndex++) {
          const parsedAnimation = parsedTexture.animations[animationIndex];
          const internalClass = GetClass("BABYLON.Animation");
          if (internalClass) {
            texture2.animations.push(internalClass.Parse(parsedAnimation));
          }
        }
      }
      if (hasInternalTextureUniqueId && !internalTexture) {
        texture2?._texture?._setUniqueId(parsedTexture.internalTextureUniqueId);
      }
    };
    const texture = SerializationHelper.Parse(() => {
      let generateMipMaps = true;
      if (parsedTexture.noMipmap) {
        generateMipMaps = false;
      }
      if (parsedTexture.mirrorPlane) {
        const mirrorTexture = _Texture._CreateMirror(parsedTexture.name, parsedTexture.renderTargetSize, scene, generateMipMaps);
        mirrorTexture._waitingRenderList = parsedTexture.renderList;
        mirrorTexture.mirrorPlane = Plane.FromArray(parsedTexture.mirrorPlane);
        onLoaded(mirrorTexture);
        return mirrorTexture;
      } else if (parsedTexture.isRenderTarget) {
        let renderTargetTexture = null;
        if (parsedTexture.isCube) {
          if (scene.reflectionProbes) {
            for (let index = 0; index < scene.reflectionProbes.length; index++) {
              const probe = scene.reflectionProbes[index];
              if (probe.name === parsedTexture.name) {
                return probe.cubeTexture;
              }
            }
          }
        } else {
          renderTargetTexture = _Texture._CreateRenderTargetTexture(parsedTexture.name, parsedTexture.renderTargetSize, scene, generateMipMaps, parsedTexture._creationFlags ?? 0);
          renderTargetTexture._waitingRenderList = parsedTexture.renderList;
        }
        onLoaded(renderTargetTexture);
        return renderTargetTexture;
      } else if (parsedTexture.isVideo) {
        const texture2 = _Texture._CreateVideoTexture(rootUrl + (parsedTexture.url || parsedTexture.name), rootUrl + (parsedTexture.src || parsedTexture.url), scene, generateMipMaps, parsedTexture.invertY, parsedTexture.samplingMode, parsedTexture.settings || {});
        onLoaded(texture2);
        return texture2;
      } else {
        let texture2;
        if (parsedTexture.base64String && !internalTexture) {
          texture2 = _Texture.CreateFromBase64String(parsedTexture.base64String, parsedTexture.base64String, scene, !generateMipMaps, parsedTexture.invertY, parsedTexture.samplingMode, () => {
            onLoaded(texture2);
          }, parsedTexture._creationFlags ?? 0, parsedTexture._useSRGBBuffer ?? false);
          texture2.name = parsedTexture.name;
        } else {
          let url;
          if (parsedTexture.name && (parsedTexture.name.indexOf("://") > 0 || parsedTexture.name.startsWith("data:"))) {
            url = parsedTexture.name;
          } else {
            url = rootUrl + parsedTexture.name;
          }
          if (parsedTexture.url && (parsedTexture.url.startsWith("data:") || _Texture.UseSerializedUrlIfAny)) {
            url = parsedTexture.url;
          }
          const options = {
            noMipmap: !generateMipMaps,
            invertY: parsedTexture.invertY,
            samplingMode: parsedTexture.samplingMode,
            onLoad: () => {
              onLoaded(texture2);
            },
            internalTexture
          };
          texture2 = new _Texture(url, scene, options);
        }
        return texture2;
      }
    }, parsedTexture, scene);
    return texture;
  }
  /**
   * Creates a texture from its base 64 representation.
   * @param data Define the base64 payload without the data: prefix
   * @param name Define the name of the texture in the scene useful fo caching purpose for instance
   * @param scene Define the scene the texture should belong to
   * @param noMipmapOrOptions defines if the texture will require mip maps or not or set of all options to create the texture
   * @param invertY define if the texture needs to be inverted on the y axis during loading
   * @param samplingMode define the sampling mode we want for the texture while fetching from it (Texture.NEAREST_SAMPLINGMODE...)
   * @param onLoad define a callback triggered when the texture has been loaded
   * @param onError define a callback triggered when an error occurred during the loading session
   * @param format define the format of the texture we are trying to load (Engine.TEXTUREFORMAT_RGBA...)
   * @param creationFlags specific flags to use when creating the texture (1 for storage textures, for eg)
   * @returns the created texture
   */
  static CreateFromBase64String(data, name66, scene, noMipmapOrOptions, invertY, samplingMode = _Texture.TRILINEAR_SAMPLINGMODE, onLoad = null, onError = null, format = 5, creationFlags) {
    return new _Texture("data:" + name66, scene, noMipmapOrOptions, invertY, samplingMode, onLoad, onError, data, false, format, void 0, void 0, creationFlags);
  }
  /**
   * Creates a texture from its data: representation. (data: will be added in case only the payload has been passed in)
   * @param name Define the name of the texture in the scene useful fo caching purpose for instance
   * @param buffer define the buffer to load the texture from in case the texture is loaded from a buffer representation
   * @param scene Define the scene the texture should belong to
   * @param deleteBuffer define if the buffer we are loading the texture from should be deleted after load
   * @param noMipmapOrOptions defines if the texture will require mip maps or not or set of all options to create the texture
   * @param invertY define if the texture needs to be inverted on the y axis during loading
   * @param samplingMode define the sampling mode we want for the texture while fetching from it (Texture.NEAREST_SAMPLINGMODE...)
   * @param onLoad define a callback triggered when the texture has been loaded
   * @param onError define a callback triggered when an error occurred during the loading session
   * @param format define the format of the texture we are trying to load (Engine.TEXTUREFORMAT_RGBA...)
   * @param creationFlags specific flags to use when creating the texture (1 for storage textures, for eg)
   * @returns the created texture
   */
  static LoadFromDataString(name66, buffer, scene, deleteBuffer = false, noMipmapOrOptions, invertY = true, samplingMode = _Texture.TRILINEAR_SAMPLINGMODE, onLoad = null, onError = null, format = 5, creationFlags) {
    if (name66.substr(0, 5) !== "data:") {
      name66 = "data:" + name66;
    }
    return new _Texture(name66, scene, noMipmapOrOptions, invertY, samplingMode, onLoad, onError, buffer, deleteBuffer, format, void 0, void 0, creationFlags);
  }
};
Texture.SerializeBuffers = true;
Texture.ForceSerializeBuffers = false;
Texture.OnTextureLoadErrorObservable = new Observable();
Texture._SerializeInternalTextureUniqueId = false;
Texture._CubeTextureParser = (jsonTexture, scene, rootUrl) => {
  throw _WarnImport("CubeTexture");
};
Texture._CreateMirror = (name66, renderTargetSize, scene, generateMipMaps) => {
  throw _WarnImport("MirrorTexture");
};
Texture._CreateRenderTargetTexture = (name66, renderTargetSize, scene, generateMipMaps, creationFlags) => {
  throw _WarnImport("RenderTargetTexture");
};
Texture.NEAREST_SAMPLINGMODE = 1;
Texture.NEAREST_NEAREST_MIPLINEAR = 8;
Texture.BILINEAR_SAMPLINGMODE = 2;
Texture.LINEAR_LINEAR_MIPNEAREST = 11;
Texture.TRILINEAR_SAMPLINGMODE = 3;
Texture.LINEAR_LINEAR_MIPLINEAR = 3;
Texture.NEAREST_NEAREST_MIPNEAREST = 4;
Texture.NEAREST_LINEAR_MIPNEAREST = 5;
Texture.NEAREST_LINEAR_MIPLINEAR = 6;
Texture.NEAREST_LINEAR = 7;
Texture.NEAREST_NEAREST = 1;
Texture.LINEAR_NEAREST_MIPNEAREST = 9;
Texture.LINEAR_NEAREST_MIPLINEAR = 10;
Texture.LINEAR_LINEAR = 2;
Texture.LINEAR_NEAREST = 12;
Texture.EXPLICIT_MODE = 0;
Texture.SPHERICAL_MODE = 1;
Texture.PLANAR_MODE = 2;
Texture.CUBIC_MODE = 3;
Texture.PROJECTION_MODE = 4;
Texture.SKYBOX_MODE = 5;
Texture.INVCUBIC_MODE = 6;
Texture.EQUIRECTANGULAR_MODE = 7;
Texture.FIXED_EQUIRECTANGULAR_MODE = 8;
Texture.FIXED_EQUIRECTANGULAR_MIRRORED_MODE = 9;
Texture.CLAMP_ADDRESSMODE = 0;
Texture.WRAP_ADDRESSMODE = 1;
Texture.MIRROR_ADDRESSMODE = 2;
Texture.UseSerializedUrlIfAny = false;
__decorate([
  serialize()
], Texture.prototype, "url", void 0);
__decorate([
  serialize()
], Texture.prototype, "uOffset", void 0);
__decorate([
  serialize()
], Texture.prototype, "vOffset", void 0);
__decorate([
  serialize()
], Texture.prototype, "uScale", void 0);
__decorate([
  serialize()
], Texture.prototype, "vScale", void 0);
__decorate([
  serialize()
], Texture.prototype, "uAng", void 0);
__decorate([
  serialize()
], Texture.prototype, "vAng", void 0);
__decorate([
  serialize()
], Texture.prototype, "wAng", void 0);
__decorate([
  serialize()
], Texture.prototype, "uRotationCenter", void 0);
__decorate([
  serialize()
], Texture.prototype, "vRotationCenter", void 0);
__decorate([
  serialize()
], Texture.prototype, "wRotationCenter", void 0);
__decorate([
  serialize()
], Texture.prototype, "homogeneousRotationInUVTransform", void 0);
__decorate([
  serialize()
], Texture.prototype, "isBlocking", null);
RegisterClass("BABYLON.Texture", Texture);
SerializationHelper._TextureParser = Texture.Parse;

// ../../node_modules/@babylonjs/core/Materials/materialPluginManager.js
var rxOption = new RegExp("^([gimus]+)!");
var MaterialPluginManager = class _MaterialPluginManager {
  /**
   * Creates a new instance of the plugin manager
   * @param material material that this manager will manage the plugins for
   */
  constructor(material) {
    this._plugins = [];
    this._activePlugins = [];
    this._activePluginsForExtraEvents = [];
    this._material = material;
    this._scene = material.getScene();
    this._engine = this._scene.getEngine();
  }
  /**
   * @internal
   */
  _addPlugin(plugin) {
    for (let i = 0; i < this._plugins.length; ++i) {
      if (this._plugins[i].name === plugin.name) {
        return false;
      }
    }
    if (this._material._uniformBufferLayoutBuilt) {
      throw `The plugin "${plugin.name}" can't be added to the material "${this._material.name}" because this material has already been used for rendering! Please add plugins to materials before any rendering with this material occurs.`;
    }
    const pluginClassName = plugin.getClassName();
    if (!_MaterialPluginManager._MaterialPluginClassToMainDefine[pluginClassName]) {
      _MaterialPluginManager._MaterialPluginClassToMainDefine[pluginClassName] = "MATERIALPLUGIN_" + ++_MaterialPluginManager._MaterialPluginCounter;
    }
    this._material._callbackPluginEventGeneric = (id, info) => this._handlePluginEvent(id, info);
    this._plugins.push(plugin);
    this._plugins.sort((a2, b) => a2.priority - b.priority);
    this._codeInjectionPoints = {};
    const defineNamesFromPlugins = {};
    defineNamesFromPlugins[_MaterialPluginManager._MaterialPluginClassToMainDefine[pluginClassName]] = {
      type: "boolean",
      default: true
    };
    for (const plugin2 of this._plugins) {
      plugin2.collectDefines(defineNamesFromPlugins);
      this._collectPointNames("vertex", plugin2.getCustomCode("vertex"));
      this._collectPointNames("fragment", plugin2.getCustomCode("fragment"));
    }
    this._defineNamesFromPlugins = defineNamesFromPlugins;
    return true;
  }
  /**
   * @internal
   */
  _activatePlugin(plugin) {
    if (this._activePlugins.indexOf(plugin) === -1) {
      this._activePlugins.push(plugin);
      this._activePlugins.sort((a2, b) => a2.priority - b.priority);
      this._material._callbackPluginEventIsReadyForSubMesh = this._handlePluginEventIsReadyForSubMesh.bind(this);
      this._material._callbackPluginEventPrepareDefinesBeforeAttributes = this._handlePluginEventPrepareDefinesBeforeAttributes.bind(this);
      this._material._callbackPluginEventPrepareDefines = this._handlePluginEventPrepareDefines.bind(this);
      this._material._callbackPluginEventBindForSubMesh = this._handlePluginEventBindForSubMesh.bind(this);
      if (plugin.registerForExtraEvents) {
        this._activePluginsForExtraEvents.push(plugin);
        this._activePluginsForExtraEvents.sort((a2, b) => a2.priority - b.priority);
        this._material._callbackPluginEventHasRenderTargetTextures = this._handlePluginEventHasRenderTargetTextures.bind(this);
        this._material._callbackPluginEventFillRenderTargetTextures = this._handlePluginEventFillRenderTargetTextures.bind(this);
        this._material._callbackPluginEventHardBindForSubMesh = this._handlePluginEventHardBindForSubMesh.bind(this);
      }
    }
  }
  /**
   * Gets a plugin from the list of plugins managed by this manager
   * @param name name of the plugin
   * @returns the plugin if found, else null
   */
  getPlugin(name66) {
    for (let i = 0; i < this._plugins.length; ++i) {
      if (this._plugins[i].name === name66) {
        return this._plugins[i];
      }
    }
    return null;
  }
  _handlePluginEventIsReadyForSubMesh(eventData) {
    let isReady = true;
    for (const plugin of this._activePlugins) {
      isReady = isReady && plugin.isReadyForSubMesh(eventData.defines, this._scene, this._engine, eventData.subMesh);
    }
    eventData.isReadyForSubMesh = isReady;
  }
  _handlePluginEventPrepareDefinesBeforeAttributes(eventData) {
    for (const plugin of this._activePlugins) {
      plugin.prepareDefinesBeforeAttributes(eventData.defines, this._scene, eventData.mesh);
    }
  }
  _handlePluginEventPrepareDefines(eventData) {
    for (const plugin of this._activePlugins) {
      plugin.prepareDefines(eventData.defines, this._scene, eventData.mesh);
    }
  }
  _handlePluginEventHardBindForSubMesh(eventData) {
    for (const plugin of this._activePluginsForExtraEvents) {
      plugin.hardBindForSubMesh(this._material._uniformBuffer, this._scene, this._engine, eventData.subMesh);
    }
  }
  _handlePluginEventBindForSubMesh(eventData) {
    for (const plugin of this._activePlugins) {
      plugin.bindForSubMesh(this._material._uniformBuffer, this._scene, this._engine, eventData.subMesh);
    }
  }
  _handlePluginEventHasRenderTargetTextures(eventData) {
    let hasRenderTargetTextures = false;
    for (const plugin of this._activePluginsForExtraEvents) {
      hasRenderTargetTextures = plugin.hasRenderTargetTextures();
      if (hasRenderTargetTextures) {
        break;
      }
    }
    eventData.hasRenderTargetTextures = hasRenderTargetTextures;
  }
  _handlePluginEventFillRenderTargetTextures(eventData) {
    for (const plugin of this._activePluginsForExtraEvents) {
      plugin.fillRenderTargetTextures(eventData.renderTargets);
    }
  }
  _handlePluginEvent(id, info) {
    switch (id) {
      case MaterialPluginEvent.GetActiveTextures: {
        const eventData = info;
        for (const plugin of this._activePlugins) {
          plugin.getActiveTextures(eventData.activeTextures);
        }
        break;
      }
      case MaterialPluginEvent.GetAnimatables: {
        const eventData = info;
        for (const plugin of this._activePlugins) {
          plugin.getAnimatables(eventData.animatables);
        }
        break;
      }
      case MaterialPluginEvent.HasTexture: {
        const eventData = info;
        let hasTexture = false;
        for (const plugin of this._activePlugins) {
          hasTexture = plugin.hasTexture(eventData.texture);
          if (hasTexture) {
            break;
          }
        }
        eventData.hasTexture = hasTexture;
        break;
      }
      case MaterialPluginEvent.Disposed: {
        const eventData = info;
        for (const plugin of this._plugins) {
          plugin.dispose(eventData.forceDisposeTextures);
        }
        break;
      }
      case MaterialPluginEvent.GetDefineNames: {
        const eventData = info;
        eventData.defineNames = this._defineNamesFromPlugins;
        break;
      }
      case MaterialPluginEvent.PrepareEffect: {
        const eventData = info;
        for (const plugin of this._activePlugins) {
          eventData.fallbackRank = plugin.addFallbacks(eventData.defines, eventData.fallbacks, eventData.fallbackRank);
          plugin.getAttributes(eventData.attributes, this._scene, eventData.mesh);
        }
        if (this._uniformList.length > 0) {
          eventData.uniforms.push(...this._uniformList);
        }
        if (this._samplerList.length > 0) {
          eventData.samplers.push(...this._samplerList);
        }
        if (this._uboList.length > 0) {
          eventData.uniformBuffersNames.push(...this._uboList);
        }
        eventData.customCode = this._injectCustomCode(eventData, eventData.customCode);
        break;
      }
      case MaterialPluginEvent.PrepareUniformBuffer: {
        const eventData = info;
        this._uboDeclaration = "";
        this._vertexDeclaration = "";
        this._fragmentDeclaration = "";
        this._uniformList = [];
        this._samplerList = [];
        this._uboList = [];
        for (const plugin of this._plugins) {
          const uniforms = plugin.getUniforms();
          if (uniforms) {
            if (uniforms.ubo) {
              for (const uniform of uniforms.ubo) {
                if (uniform.size && uniform.type) {
                  const arraySize = uniform.arraySize ?? 0;
                  eventData.ubo.addUniform(uniform.name, uniform.size, arraySize);
                  this._uboDeclaration += `${uniform.type} ${uniform.name}${arraySize > 0 ? `[${arraySize}]` : ""};
`;
                }
                this._uniformList.push(uniform.name);
              }
            }
            if (uniforms.vertex) {
              this._vertexDeclaration += uniforms.vertex + "\n";
            }
            if (uniforms.fragment) {
              this._fragmentDeclaration += uniforms.fragment + "\n";
            }
          }
          plugin.getSamplers(this._samplerList);
          plugin.getUniformBuffersNames(this._uboList);
        }
        break;
      }
    }
  }
  _collectPointNames(shaderType, customCode) {
    if (!customCode) {
      return;
    }
    for (const pointName in customCode) {
      if (!this._codeInjectionPoints[shaderType]) {
        this._codeInjectionPoints[shaderType] = {};
      }
      this._codeInjectionPoints[shaderType][pointName] = true;
    }
  }
  _injectCustomCode(eventData, existingCallback) {
    return (shaderType, code) => {
      if (existingCallback) {
        code = existingCallback(shaderType, code);
      }
      if (this._uboDeclaration) {
        code = code.replace("#define ADDITIONAL_UBO_DECLARATION", this._uboDeclaration);
      }
      if (this._vertexDeclaration) {
        code = code.replace("#define ADDITIONAL_VERTEX_DECLARATION", this._vertexDeclaration);
      }
      if (this._fragmentDeclaration) {
        code = code.replace("#define ADDITIONAL_FRAGMENT_DECLARATION", this._fragmentDeclaration);
      }
      const points = this._codeInjectionPoints?.[shaderType];
      if (!points) {
        return code;
      }
      let processorOptions = null;
      for (let pointName in points) {
        let injectedCode = "";
        for (const plugin of this._activePlugins) {
          let customCode = plugin.getCustomCode(shaderType)?.[pointName];
          if (!customCode) {
            continue;
          }
          if (plugin.resolveIncludes) {
            if (processorOptions === null) {
              const shaderLanguage = ShaderLanguage.GLSL;
              processorOptions = {
                defines: [],
                indexParameters: eventData.indexParameters,
                isFragment: false,
                shouldUseHighPrecisionShader: this._engine._shouldUseHighPrecisionShader,
                processor: void 0,
                supportsUniformBuffers: this._engine.supportsUniformBuffers,
                shadersRepository: ShaderStore.GetShadersRepository(shaderLanguage),
                includesShadersStore: ShaderStore.GetIncludesShadersStore(shaderLanguage),
                version: void 0,
                platformName: this._engine.shaderPlatformName,
                processingContext: void 0,
                isNDCHalfZRange: this._engine.isNDCHalfZRange,
                useReverseDepthBuffer: this._engine.useReverseDepthBuffer,
                processCodeAfterIncludes: void 0
                // not used by _ProcessIncludes
              };
            }
            processorOptions.isFragment = shaderType === "fragment";
            ShaderProcessor._ProcessIncludes(customCode, processorOptions, (code2) => customCode = code2);
          }
          injectedCode += customCode + "\n";
        }
        if (injectedCode.length > 0) {
          if (pointName.charAt(0) === "!") {
            pointName = pointName.substring(1);
            let regexFlags = "g";
            if (pointName.charAt(0) === "!") {
              regexFlags = "";
              pointName = pointName.substring(1);
            } else {
              const matchOption = rxOption.exec(pointName);
              if (matchOption && matchOption.length >= 2) {
                regexFlags = matchOption[1];
                pointName = pointName.substring(regexFlags.length + 1);
              }
            }
            if (regexFlags.indexOf("g") < 0) {
              regexFlags += "g";
            }
            const sourceCode = code;
            const rx = new RegExp(pointName, regexFlags);
            let match = rx.exec(sourceCode);
            while (match !== null) {
              let newCode = injectedCode;
              for (let i = 0; i < match.length; ++i) {
                newCode = newCode.replace("$" + i, match[i]);
              }
              code = code.replace(match[0], newCode);
              match = rx.exec(sourceCode);
            }
          } else {
            const fullPointName = "#define " + pointName;
            code = code.replace(fullPointName, "\n" + injectedCode + "\n" + fullPointName);
          }
        }
      }
      return code;
    };
  }
};
MaterialPluginManager._MaterialPluginClassToMainDefine = {};
MaterialPluginManager._MaterialPluginCounter = 0;
(() => {
  EngineStore.OnEnginesDisposedObservable.add(() => {
    UnregisterAllMaterialPlugins();
  });
})();
var plugins = [];
var inited = false;
var observer = null;
function UnregisterAllMaterialPlugins() {
  plugins.length = 0;
  inited = false;
  Material.OnEventObservable.remove(observer);
  observer = null;
}

// ../../node_modules/@babylonjs/core/Materials/materialPluginBase.js
var MaterialPluginBase = class {
  _enable(enable) {
    if (enable) {
      this._pluginManager._activatePlugin(this);
    }
  }
  /**
   * Creates a new material plugin
   * @param material parent material of the plugin
   * @param name name of the plugin
   * @param priority priority of the plugin
   * @param defines list of defines used by the plugin. The value of the property is the default value for this property
   * @param addToPluginList true to add the plugin to the list of plugins managed by the material plugin manager of the material (default: true)
   * @param enable true to enable the plugin (it is handy if the plugin does not handle properties to switch its current activation)
   * @param resolveIncludes Indicates that any #include directive in the plugin code must be replaced by the corresponding code (default: false)
   */
  constructor(material, name66, priority, defines, addToPluginList = true, enable = false, resolveIncludes = false) {
    this.priority = 500;
    this.resolveIncludes = false;
    this.registerForExtraEvents = false;
    this._material = material;
    this.name = name66;
    this.priority = priority;
    this.resolveIncludes = resolveIncludes;
    if (!material.pluginManager) {
      material.pluginManager = new MaterialPluginManager(material);
      material.onDisposeObservable.add(() => {
        material.pluginManager = void 0;
      });
    }
    this._pluginDefineNames = defines;
    this._pluginManager = material.pluginManager;
    if (addToPluginList) {
      this._pluginManager._addPlugin(this);
    }
    if (enable) {
      this._enable(true);
    }
    this.markAllDefinesAsDirty = material._dirtyCallbacks[63];
  }
  /**
   * Gets the current class name useful for serialization or dynamic coding.
   * @returns The class name.
   */
  getClassName() {
    return "MaterialPluginBase";
  }
  /**
   * Specifies that the submesh is ready to be used.
   * @param defines the list of "defines" to update.
   * @param scene defines the scene the material belongs to.
   * @param engine the engine this scene belongs to.
   * @param subMesh the submesh to check for readiness
   * @returns - boolean indicating that the submesh is ready or not.
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  isReadyForSubMesh(defines, scene, engine, subMesh) {
    return true;
  }
  /**
   * Binds the material data (this function is called even if mustRebind() returns false)
   * @param uniformBuffer defines the Uniform buffer to fill in.
   * @param scene defines the scene the material belongs to.
   * @param engine defines the engine the material belongs to.
   * @param subMesh the submesh to bind data for
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  hardBindForSubMesh(uniformBuffer, scene, engine, subMesh) {
  }
  /**
   * Binds the material data.
   * @param uniformBuffer defines the Uniform buffer to fill in.
   * @param scene defines the scene the material belongs to.
   * @param engine the engine this scene belongs to.
   * @param subMesh the submesh to bind data for
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  bindForSubMesh(uniformBuffer, scene, engine, subMesh) {
  }
  /**
   * Disposes the resources of the material.
   * @param forceDisposeTextures - Forces the disposal of all textures.
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  dispose(forceDisposeTextures) {
  }
  /**
   * Returns a list of custom shader code fragments to customize the shader.
   * @param shaderType "vertex" or "fragment"
   * @returns null if no code to be added, or a list of pointName =\> code.
   * Note that `pointName` can also be a regular expression if it starts with a `!`.
   * In that case, the string found by the regular expression (if any) will be
   * replaced by the code provided.
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  getCustomCode(shaderType) {
    return null;
  }
  /**
   * Collects all defines.
   * @param defines The object to append to.
   */
  collectDefines(defines) {
    if (!this._pluginDefineNames) {
      return;
    }
    for (const key of Object.keys(this._pluginDefineNames)) {
      if (key[0] === "_") {
        continue;
      }
      const type = typeof this._pluginDefineNames[key];
      defines[key] = {
        type: type === "number" ? "number" : type === "string" ? "string" : type === "boolean" ? "boolean" : "object",
        default: this._pluginDefineNames[key]
      };
    }
  }
  /**
   * Sets the defines for the next rendering. Called before PrepareDefinesForAttributes is called.
   * @param defines the list of "defines" to update.
   * @param scene defines the scene to the material belongs to.
   * @param mesh the mesh being rendered
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  prepareDefinesBeforeAttributes(defines, scene, mesh) {
  }
  /**
   * Sets the defines for the next rendering
   * @param defines the list of "defines" to update.
   * @param scene defines the scene to the material belongs to.
   * @param mesh the mesh being rendered
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  prepareDefines(defines, scene, mesh) {
  }
  /**
   * Checks to see if a texture is used in the material.
   * @param texture - Base texture to use.
   * @returns - Boolean specifying if a texture is used in the material.
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  hasTexture(texture) {
    return false;
  }
  /**
   * Gets a boolean indicating that current material needs to register RTT
   * @returns true if this uses a render target otherwise false.
   */
  hasRenderTargetTextures() {
    return false;
  }
  /**
   * Fills the list of render target textures.
   * @param renderTargets the list of render targets to update
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  fillRenderTargetTextures(renderTargets) {
  }
  /**
   * Returns an array of the actively used textures.
   * @param activeTextures Array of BaseTextures
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  getActiveTextures(activeTextures) {
  }
  /**
   * Returns the animatable textures.
   * @param animatables Array of animatable textures.
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  getAnimatables(animatables) {
  }
  /**
   * Add fallbacks to the effect fallbacks list.
   * @param defines defines the Base texture to use.
   * @param fallbacks defines the current fallback list.
   * @param currentRank defines the current fallback rank.
   * @returns the new fallback rank.
   */
  addFallbacks(defines, fallbacks, currentRank) {
    return currentRank;
  }
  /**
   * Gets the samplers used by the plugin.
   * @param samplers list that the sampler names should be added to.
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  getSamplers(samplers) {
  }
  /**
   * Gets the attributes used by the plugin.
   * @param attributes list that the attribute names should be added to.
   * @param scene the scene that the material belongs to.
   * @param mesh the mesh being rendered.
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  getAttributes(attributes, scene, mesh) {
  }
  /**
   * Gets the uniform buffers names added by the plugin.
   * @param ubos list that the ubo names should be added to.
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  getUniformBuffersNames(ubos) {
  }
  /**
   * Gets the description of the uniforms to add to the ubo (if engine supports ubos) or to inject directly in the vertex/fragment shaders (if engine does not support ubos)
   * @returns the description of the uniforms
   */
  getUniforms() {
    return {};
  }
  /**
   * Makes a duplicate of the current configuration into another one.
   * @param plugin define the config where to copy the info
   */
  copyTo(plugin) {
    SerializationHelper.Clone(() => plugin, this);
  }
  /**
   * Serializes this plugin configuration.
   * @returns - An object with the serialized config.
   */
  serialize() {
    return SerializationHelper.Serialize(this);
  }
  /**
   * Parses a plugin configuration from a serialized object.
   * @param source - Serialized object.
   * @param scene Defines the scene we are parsing for
   * @param rootUrl Defines the rootUrl to load from
   */
  parse(source, scene, rootUrl) {
    SerializationHelper.Parse(() => this, source, scene, rootUrl);
  }
};
__decorate([
  serialize()
], MaterialPluginBase.prototype, "name", void 0);
__decorate([
  serialize()
], MaterialPluginBase.prototype, "priority", void 0);
__decorate([
  serialize()
], MaterialPluginBase.prototype, "resolveIncludes", void 0);
__decorate([
  serialize()
], MaterialPluginBase.prototype, "registerForExtraEvents", void 0);

// ../../node_modules/@babylonjs/core/Engines/Extensions/engine.rawTexture.js
ThinEngine.prototype.updateRawTexture = function(texture, data, format, invertY, compression = null, type = 0, useSRGBBuffer = false) {
  if (!texture) {
    return;
  }
  const internalSizedFomat = this._getRGBABufferInternalSizedFormat(type, format, useSRGBBuffer);
  const internalFormat = this._getInternalFormat(format);
  const textureType = this._getWebGLTextureType(type);
  this._bindTextureDirectly(this._gl.TEXTURE_2D, texture, true);
  this._unpackFlipY(invertY === void 0 ? true : invertY ? true : false);
  if (!this._doNotHandleContextLost) {
    texture._bufferView = data;
    texture.format = format;
    texture.type = type;
    texture.invertY = invertY;
    texture._compression = compression;
  }
  if (texture.width % 4 !== 0) {
    this._gl.pixelStorei(this._gl.UNPACK_ALIGNMENT, 1);
  }
  if (compression && data) {
    this._gl.compressedTexImage2D(this._gl.TEXTURE_2D, 0, this.getCaps().s3tc[compression], texture.width, texture.height, 0, data);
  } else {
    this._gl.texImage2D(this._gl.TEXTURE_2D, 0, internalSizedFomat, texture.width, texture.height, 0, internalFormat, textureType, data);
  }
  if (texture.generateMipMaps) {
    this._gl.generateMipmap(this._gl.TEXTURE_2D);
  }
  this._bindTextureDirectly(this._gl.TEXTURE_2D, null);
  texture.isReady = true;
};
ThinEngine.prototype.createRawTexture = function(data, width, height, format, generateMipMaps, invertY, samplingMode, compression = null, type = 0, creationFlags = 0, useSRGBBuffer = false) {
  const texture = new InternalTexture(this, InternalTextureSource.Raw);
  texture.baseWidth = width;
  texture.baseHeight = height;
  texture.width = width;
  texture.height = height;
  texture.format = format;
  texture.generateMipMaps = generateMipMaps;
  texture.samplingMode = samplingMode;
  texture.invertY = invertY;
  texture._compression = compression;
  texture.type = type;
  texture._useSRGBBuffer = this._getUseSRGBBuffer(useSRGBBuffer, !generateMipMaps);
  if (!this._doNotHandleContextLost) {
    texture._bufferView = data;
  }
  this.updateRawTexture(texture, data, format, invertY, compression, type, texture._useSRGBBuffer);
  this._bindTextureDirectly(this._gl.TEXTURE_2D, texture, true);
  const filters = this._getSamplingParameters(samplingMode, generateMipMaps);
  this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MAG_FILTER, filters.mag);
  this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MIN_FILTER, filters.min);
  if (generateMipMaps) {
    this._gl.generateMipmap(this._gl.TEXTURE_2D);
  }
  this._bindTextureDirectly(this._gl.TEXTURE_2D, null);
  this._internalTexturesCache.push(texture);
  return texture;
};
ThinEngine.prototype.createRawCubeTexture = function(data, size, format, type, generateMipMaps, invertY, samplingMode, compression = null) {
  const gl = this._gl;
  const texture = new InternalTexture(this, InternalTextureSource.CubeRaw);
  texture.isCube = true;
  texture.format = format;
  texture.type = type;
  if (!this._doNotHandleContextLost) {
    texture._bufferViewArray = data;
  }
  const textureType = this._getWebGLTextureType(type);
  let internalFormat = this._getInternalFormat(format);
  if (internalFormat === gl.RGB) {
    internalFormat = gl.RGBA;
  }
  if (textureType === gl.FLOAT && !this._caps.textureFloatLinearFiltering) {
    generateMipMaps = false;
    samplingMode = 1;
    Logger.Warn("Float texture filtering is not supported. Mipmap generation and sampling mode are forced to false and TEXTURE_NEAREST_SAMPLINGMODE, respectively.");
  } else if (textureType === this._gl.HALF_FLOAT_OES && !this._caps.textureHalfFloatLinearFiltering) {
    generateMipMaps = false;
    samplingMode = 1;
    Logger.Warn("Half float texture filtering is not supported. Mipmap generation and sampling mode are forced to false and TEXTURE_NEAREST_SAMPLINGMODE, respectively.");
  } else if (textureType === gl.FLOAT && !this._caps.textureFloatRender) {
    generateMipMaps = false;
    Logger.Warn("Render to float textures is not supported. Mipmap generation forced to false.");
  } else if (textureType === gl.HALF_FLOAT && !this._caps.colorBufferFloat) {
    generateMipMaps = false;
    Logger.Warn("Render to half float textures is not supported. Mipmap generation forced to false.");
  }
  const width = size;
  const height = width;
  texture.width = width;
  texture.height = height;
  texture.invertY = invertY;
  texture._compression = compression;
  const isPot = !this.needPOTTextures || IsExponentOfTwo(texture.width) && IsExponentOfTwo(texture.height);
  if (!isPot) {
    generateMipMaps = false;
  }
  if (data) {
    this.updateRawCubeTexture(texture, data, format, type, invertY, compression);
  } else {
    const internalSizedFomat = this._getRGBABufferInternalSizedFormat(type);
    const level = 0;
    this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, texture, true);
    for (let faceIndex = 0; faceIndex < 6; faceIndex++) {
      if (compression) {
        gl.compressedTexImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex, level, this.getCaps().s3tc[compression], texture.width, texture.height, 0, void 0);
      } else {
        gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex, level, internalSizedFomat, texture.width, texture.height, 0, internalFormat, textureType, null);
      }
    }
    this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, null);
  }
  this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, texture, true);
  if (data && generateMipMaps) {
    this._gl.generateMipmap(this._gl.TEXTURE_CUBE_MAP);
  }
  const filters = this._getSamplingParameters(samplingMode, generateMipMaps);
  gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, filters.mag);
  gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, filters.min);
  gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, null);
  texture.generateMipMaps = generateMipMaps;
  texture.samplingMode = samplingMode;
  texture.isReady = true;
  return texture;
};
ThinEngine.prototype.updateRawCubeTexture = function(texture, data, format, type, invertY, compression = null, level = 0) {
  texture._bufferViewArray = data;
  texture.format = format;
  texture.type = type;
  texture.invertY = invertY;
  texture._compression = compression;
  const gl = this._gl;
  const textureType = this._getWebGLTextureType(type);
  let internalFormat = this._getInternalFormat(format);
  const internalSizedFomat = this._getRGBABufferInternalSizedFormat(type);
  let needConversion = false;
  if (internalFormat === gl.RGB) {
    internalFormat = gl.RGBA;
    needConversion = true;
  }
  this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, texture, true);
  this._unpackFlipY(invertY === void 0 ? true : invertY ? true : false);
  if (texture.width % 4 !== 0) {
    gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
  }
  for (let faceIndex = 0; faceIndex < 6; faceIndex++) {
    let faceData = data[faceIndex];
    if (compression) {
      gl.compressedTexImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex, level, this.getCaps().s3tc[compression], texture.width, texture.height, 0, faceData);
    } else {
      if (needConversion) {
        faceData = _convertRGBtoRGBATextureData(faceData, texture.width, texture.height, type);
      }
      gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex, level, internalSizedFomat, texture.width, texture.height, 0, internalFormat, textureType, faceData);
    }
  }
  const isPot = !this.needPOTTextures || IsExponentOfTwo(texture.width) && IsExponentOfTwo(texture.height);
  if (isPot && texture.generateMipMaps && level === 0) {
    this._gl.generateMipmap(this._gl.TEXTURE_CUBE_MAP);
  }
  this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, null);
  texture.isReady = true;
};
ThinEngine.prototype.createRawCubeTextureFromUrl = function(url, scene, size, format, type, noMipmap, callback, mipmapGenerator, onLoad = null, onError = null, samplingMode = 3, invertY = false) {
  const gl = this._gl;
  const texture = this.createRawCubeTexture(null, size, format, type, !noMipmap, invertY, samplingMode, null);
  scene?.addPendingData(texture);
  texture.url = url;
  texture.isReady = false;
  this._internalTexturesCache.push(texture);
  const onerror = (request, exception) => {
    scene?.removePendingData(texture);
    if (onError && request) {
      onError(request.status + " " + request.statusText, exception);
    }
  };
  const internalCallback = (data) => {
    const width = texture.width;
    const faceDataArrays = callback(data);
    if (!faceDataArrays) {
      return;
    }
    if (mipmapGenerator) {
      const textureType = this._getWebGLTextureType(type);
      let internalFormat = this._getInternalFormat(format);
      const internalSizedFomat = this._getRGBABufferInternalSizedFormat(type);
      let needConversion = false;
      if (internalFormat === gl.RGB) {
        internalFormat = gl.RGBA;
        needConversion = true;
      }
      this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, texture, true);
      this._unpackFlipY(false);
      const mipData = mipmapGenerator(faceDataArrays);
      for (let level = 0; level < mipData.length; level++) {
        const mipSize = width >> level;
        for (let faceIndex = 0; faceIndex < 6; faceIndex++) {
          let mipFaceData = mipData[level][faceIndex];
          if (needConversion) {
            mipFaceData = _convertRGBtoRGBATextureData(mipFaceData, mipSize, mipSize, type);
          }
          gl.texImage2D(faceIndex, level, internalSizedFomat, mipSize, mipSize, 0, internalFormat, textureType, mipFaceData);
        }
      }
      this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, null);
    } else {
      this.updateRawCubeTexture(texture, faceDataArrays, format, type, invertY);
    }
    texture.isReady = true;
    scene?.removePendingData(texture);
    texture.onLoadedObservable.notifyObservers(texture);
    texture.onLoadedObservable.clear();
    if (onLoad) {
      onLoad();
    }
  };
  this._loadFile(url, (data) => {
    internalCallback(data);
  }, void 0, scene?.offlineProvider, true, onerror);
  return texture;
};
function _convertRGBtoRGBATextureData(rgbData, width, height, textureType) {
  let rgbaData;
  let val1 = 1;
  if (textureType === 1) {
    rgbaData = new Float32Array(width * height * 4);
  } else if (textureType === 2) {
    rgbaData = new Uint16Array(width * height * 4);
    val1 = 15360;
  } else if (textureType === 7) {
    rgbaData = new Uint32Array(width * height * 4);
  } else {
    rgbaData = new Uint8Array(width * height * 4);
  }
  for (let x = 0; x < width; x++) {
    for (let y = 0; y < height; y++) {
      const index = (y * width + x) * 3;
      const newIndex = (y * width + x) * 4;
      rgbaData[newIndex + 0] = rgbData[index + 0];
      rgbaData[newIndex + 1] = rgbData[index + 1];
      rgbaData[newIndex + 2] = rgbData[index + 2];
      rgbaData[newIndex + 3] = val1;
    }
  }
  return rgbaData;
}
function _makeCreateRawTextureFunction(is3D) {
  return function(data, width, height, depth, format, generateMipMaps, invertY, samplingMode, compression = null, textureType = 0) {
    const target = is3D ? this._gl.TEXTURE_3D : this._gl.TEXTURE_2D_ARRAY;
    const source = is3D ? InternalTextureSource.Raw3D : InternalTextureSource.Raw2DArray;
    const texture = new InternalTexture(this, source);
    texture.baseWidth = width;
    texture.baseHeight = height;
    texture.baseDepth = depth;
    texture.width = width;
    texture.height = height;
    texture.depth = depth;
    texture.format = format;
    texture.type = textureType;
    texture.generateMipMaps = generateMipMaps;
    texture.samplingMode = samplingMode;
    if (is3D) {
      texture.is3D = true;
    } else {
      texture.is2DArray = true;
    }
    if (!this._doNotHandleContextLost) {
      texture._bufferView = data;
    }
    if (is3D) {
      this.updateRawTexture3D(texture, data, format, invertY, compression, textureType);
    } else {
      this.updateRawTexture2DArray(texture, data, format, invertY, compression, textureType);
    }
    this._bindTextureDirectly(target, texture, true);
    const filters = this._getSamplingParameters(samplingMode, generateMipMaps);
    this._gl.texParameteri(target, this._gl.TEXTURE_MAG_FILTER, filters.mag);
    this._gl.texParameteri(target, this._gl.TEXTURE_MIN_FILTER, filters.min);
    if (generateMipMaps) {
      this._gl.generateMipmap(target);
    }
    this._bindTextureDirectly(target, null);
    this._internalTexturesCache.push(texture);
    return texture;
  };
}
ThinEngine.prototype.createRawTexture2DArray = _makeCreateRawTextureFunction(false);
ThinEngine.prototype.createRawTexture3D = _makeCreateRawTextureFunction(true);
function _makeUpdateRawTextureFunction(is3D) {
  return function(texture, data, format, invertY, compression = null, textureType = 0) {
    const target = is3D ? this._gl.TEXTURE_3D : this._gl.TEXTURE_2D_ARRAY;
    const internalType = this._getWebGLTextureType(textureType);
    const internalFormat = this._getInternalFormat(format);
    const internalSizedFomat = this._getRGBABufferInternalSizedFormat(textureType, format);
    this._bindTextureDirectly(target, texture, true);
    this._unpackFlipY(invertY === void 0 ? true : invertY ? true : false);
    if (!this._doNotHandleContextLost) {
      texture._bufferView = data;
      texture.format = format;
      texture.invertY = invertY;
      texture._compression = compression;
    }
    if (texture.width % 4 !== 0) {
      this._gl.pixelStorei(this._gl.UNPACK_ALIGNMENT, 1);
    }
    if (compression && data) {
      this._gl.compressedTexImage3D(target, 0, this.getCaps().s3tc[compression], texture.width, texture.height, texture.depth, 0, data);
    } else {
      this._gl.texImage3D(target, 0, internalSizedFomat, texture.width, texture.height, texture.depth, 0, internalFormat, internalType, data);
    }
    if (texture.generateMipMaps) {
      this._gl.generateMipmap(target);
    }
    this._bindTextureDirectly(target, null);
    texture.isReady = true;
  };
}
ThinEngine.prototype.updateRawTexture2DArray = _makeUpdateRawTextureFunction(false);
ThinEngine.prototype.updateRawTexture3D = _makeUpdateRawTextureFunction(true);

// ../../node_modules/@babylonjs/core/Materials/Textures/rawTexture2DArray.js
var RawTexture2DArray = class _RawTexture2DArray extends Texture {
  /**
   * Gets the number of layers of the texture
   */
  get depth() {
    return this._depth;
  }
  /**
   * Create a new RawTexture2DArray
   * @param data defines the data of the texture
   * @param width defines the width of the texture
   * @param height defines the height of the texture
   * @param depth defines the number of layers of the texture
   * @param format defines the texture format to use
   * @param scene defines the hosting scene
   * @param generateMipMaps defines a boolean indicating if mip levels should be generated (true by default)
   * @param invertY defines if texture must be stored with Y axis inverted
   * @param samplingMode defines the sampling mode to use (Texture.TRILINEAR_SAMPLINGMODE by default)
   * @param textureType defines the texture Type (Engine.TEXTURETYPE_UNSIGNED_INT, Engine.TEXTURETYPE_FLOAT...)
   * @param creationFlags specific flags to use when creating the texture (1 for storage textures, for eg)
   */
  constructor(data, width, height, depth, format, scene, generateMipMaps = true, invertY = false, samplingMode = Texture.TRILINEAR_SAMPLINGMODE, textureType = 0, creationFlags) {
    super(null, scene, !generateMipMaps, invertY);
    this.format = format;
    this._texture = scene.getEngine().createRawTexture2DArray(data, width, height, depth, format, generateMipMaps, invertY, samplingMode, null, textureType, creationFlags);
    this._depth = depth;
    this.is2DArray = true;
  }
  /**
   * Update the texture with new data
   * @param data defines the data to store in the texture
   */
  update(data) {
    if (!this._texture) {
      return;
    }
    this._getEngine().updateRawTexture2DArray(this._texture, data, this._texture.format, this._texture.invertY, null, this._texture.type);
  }
  /**
   * Creates a RGBA texture from some data.
   * @param data Define the texture data
   * @param width Define the width of the texture
   * @param height Define the height of the texture
   * @param depth defines the number of layers of the texture
   * @param scene defines the scene the texture will belong to
   * @param generateMipMaps Define whether or not to create mip maps for the texture
   * @param invertY define if the data should be flipped on Y when uploaded to the GPU
   * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)
   * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)
   * @returns the RGBA texture
   */
  static CreateRGBATexture(data, width, height, depth, scene, generateMipMaps = true, invertY = false, samplingMode = 3, type = 0) {
    return new _RawTexture2DArray(data, width, height, depth, 5, scene, generateMipMaps, invertY, samplingMode, type);
  }
};

// ../../node_modules/noa-engine/src/lib/terrainMaterials.js
var TerrainMatManager = class {
  /** @param {import('../index').Engine} noa  */
  constructor(noa) {
    this._defaultMat = noa.rendering.makeStandardMaterial("base-terrain");
    this._defaultMat.freeze();
    this.allMaterials = [this._defaultMat];
    this.noa = noa;
    this._idCounter = 1e3;
    this._blockMatIDtoTerrainID = {};
    this._terrainIDtoMatObject = {};
    this._texURLtoTerrainID = {};
    this._renderMatToTerrainID = /* @__PURE__ */ new Map();
  }
  /** 
   * Maps a given `matID` (from noa.registry) to a unique ID of which 
   * terrain material can be used for that block material.
   * This lets the terrain mesher map which blocks can be merged into
   * the same meshes.
   * Internally, this accessor also creates the material for each 
   * terrainMatID as they are first encountered.
   */
  getTerrainMatId(blockMatID) {
    if (blockMatID in this._blockMatIDtoTerrainID) {
      return this._blockMatIDtoTerrainID[blockMatID];
    }
    var terrID = decideTerrainMatID(this, blockMatID);
    if (!(terrID in this._terrainIDtoMatObject)) {
      var mat = createTerrainMat(this, blockMatID);
      this.allMaterials.push(mat);
      this._terrainIDtoMatObject[terrID] = mat;
    }
    this._blockMatIDtoTerrainID[blockMatID] = terrID;
    return terrID;
  }
  /**
   * Get a Babylon Material object, given a terrainMatID (gotten from this module)
   */
  getMaterial(terrainMatID = 1) {
    return this._terrainIDtoMatObject[terrainMatID];
  }
};
function decideTerrainMatID(self, blockMatID = 0) {
  var matInfo = self.noa.registry.getMaterialData(blockMatID);
  if (matInfo.renderMat) {
    var mat = matInfo.renderMat;
    if (!self._renderMatToTerrainID.has(mat)) {
      self._renderMatToTerrainID.set(mat, self._idCounter++);
    }
    return self._renderMatToTerrainID.get(mat);
  }
  if (matInfo.texture) {
    var url = matInfo.texture;
    if (!(url in self._texURLtoTerrainID)) {
      self._texURLtoTerrainID[url] = self._idCounter++;
    }
    return self._texURLtoTerrainID[url];
  }
  var alpha = matInfo.alpha;
  if (alpha > 0 && alpha < 1) return 10 + Math.round(alpha * 100);
  return 1;
}
function createTerrainMat(self, blockMatID = 0) {
  var matInfo = self.noa.registry.getMaterialData(blockMatID);
  if (matInfo.renderMat) return matInfo.renderMat;
  if (!matInfo.texture) {
    var needsAlpha = matInfo.alpha > 0 && matInfo.alpha < 1;
    if (!needsAlpha) return self._defaultMat;
    var matName = "terrain-alpha-" + blockMatID;
    var plainMat = self.noa.rendering.makeStandardMaterial(matName);
    plainMat.alpha = matInfo.alpha;
    plainMat.freeze();
    return plainMat;
  }
  var scene = self.noa.rendering.getScene();
  var mat = self.noa.rendering.makeStandardMaterial("terrain-textured-" + blockMatID);
  var texURL = matInfo.texture;
  var sampling = Texture.NEAREST_SAMPLINGMODE;
  var tex = new Texture(texURL, scene, true, false, sampling);
  if (matInfo.texHasAlpha) tex.hasAlpha = true;
  mat.diffuseTexture = tex;
  if (matInfo.atlasIndex >= 0) {
    new TerrainMaterialPlugin(mat, tex);
    if (self.noa.registry._textureNeedsAlpha(matInfo.texture)) {
      tex.hasAlpha = true;
    }
  }
  mat.freeze();
  return mat;
}
var TerrainMaterialPlugin = class extends MaterialPluginBase {
  constructor(material, texture) {
    var priority = 200;
    var defines = { "NOA_TWOD_ARRAY_TEXTURE": false };
    super(material, "TestPlugin", priority, defines);
    this._enable(true);
    this._atlasTextureArray = null;
    texture.onLoadObservable.add((tex) => {
      this.setTextureArrayData(tex);
    });
  }
  setTextureArrayData(texture) {
    var { width, height } = texture.getSize();
    var numLayers = Math.round(height / width);
    height = width;
    var data = texture._readPixelsSync();
    var format = Engine.TEXTUREFORMAT_RGBA;
    var genMipMaps = true;
    var invertY = false;
    var mode = Texture.NEAREST_SAMPLINGMODE;
    var scene = texture.getScene();
    this._atlasTextureArray = new RawTexture2DArray(
      data,
      width,
      height,
      numLayers,
      format,
      scene,
      genMipMaps,
      invertY,
      mode
    );
  }
  prepareDefines(defines, scene, mesh) {
    defines["NOA_TWOD_ARRAY_TEXTURE"] = true;
  }
  getClassName() {
    return "TerrainMaterialPluginName";
  }
  getSamplers(samplers) {
    samplers.push("atlasTexture");
  }
  getAttributes(attributes) {
    attributes.push("texAtlasIndices");
  }
  getUniforms() {
    return { ubo: [] };
  }
  bindForSubMesh(uniformBuffer, scene, engine, subMesh) {
    if (this._atlasTextureArray) {
      uniformBuffer.setTexture("atlasTexture", this._atlasTextureArray);
    }
  }
  getCustomCode(shaderType) {
    if (shaderType === "vertex") return {
      "CUSTOM_VERTEX_MAIN_BEGIN": `
                texAtlasIndex = texAtlasIndices;
            `,
      "CUSTOM_VERTEX_DEFINITIONS": `
                uniform highp sampler2DArray atlasTexture;
                attribute float texAtlasIndices;
                varying float texAtlasIndex;
            `
    };
    if (shaderType === "fragment") return {
      "!baseColor\\=texture2D\\(diffuseSampler,vDiffuseUV\\+uvOffset\\);": `baseColor = texture(atlasTexture, vec3(vDiffuseUV, texAtlasIndex));`,
      "CUSTOM_FRAGMENT_DEFINITIONS": `
                uniform highp sampler2DArray atlasTexture;
                varying float texAtlasIndex;
            `
    };
    return null;
  }
};

// ../../node_modules/noa-engine/src/lib/terrainMesher.js
var PROFILE_EVERY = 0;
function TerrainMesher(noa) {
  var terrainMatManager = new TerrainMatManager(noa);
  this.allTerrainMaterials = terrainMatManager.allMaterials;
  this._defaultMaterial = terrainMatManager._defaultMat;
  var greedyMesher = new GreedyMesher(noa, terrainMatManager);
  var meshBuilder = new MeshBuilder(noa, terrainMatManager);
  this.initChunk = function(chunk) {
    chunk._terrainMeshes.length = 0;
  };
  this.disposeChunk = function(chunk) {
    chunk._terrainMeshes.forEach((mesh) => {
      noa.emit("removingTerrainMesh", mesh);
      mesh.dispose();
    });
    chunk._terrainMeshes.length = 0;
  };
  this.meshChunk = function(chunk, ignoreMaterials = false) {
    profile_hook2("start");
    this.disposeChunk(chunk);
    profile_hook2("cleanup");
    var faceDataSet = greedyMesher.mesh(chunk, ignoreMaterials);
    profile_hook2("geom");
    var meshes = meshBuilder.buildMesh(chunk, faceDataSet, ignoreMaterials);
    profile_hook2("build");
    profile_hook2("end");
    meshes.forEach((mesh) => {
      mesh.cullingStrategy = Mesh.CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY;
      noa.rendering.addMeshToScene(mesh, true, chunk.pos, this);
      noa.emit("addingTerrainMesh", mesh);
      mesh.freezeNormals();
      mesh.freezeWorldMatrix();
      chunk._terrainMeshes.push(mesh);
      if (!mesh.metadata) mesh.metadata = {};
      mesh.metadata[terrainMeshFlag] = true;
    });
  };
  var terrainMeshFlag = "noa_chunk_terrain_mesh";
}
function MeshedFaceData() {
  this.terrainID = 0;
  this.numFaces = 0;
  this.matIDs = [];
  this.dirs = [];
  this.is = [];
  this.js = [];
  this.ks = [];
  this.wids = [];
  this.hts = [];
  this.packedAO = [];
}
function GreedyMesher(noa, terrainMatManager) {
  var maskCache = new Int16Array(16);
  var aoMaskCache = new Int16Array(16);
  var realGetTerrainID = terrainMatManager.getTerrainMatId.bind(terrainMatManager);
  var fakeGetTerrainID = (matID) => 1;
  var terrainIDgetter = realGetTerrainID;
  this.mesh = function(chunk, ignoreMaterials) {
    var cs = chunk.size;
    terrainIDgetter = ignoreMaterials ? fakeGetTerrainID : realGetTerrainID;
    var edgesOnly = chunk._isEmpty || chunk._isFull;
    var faceDataSet = {};
    faceDataPool.reset();
    for (var d = 0; d < 3; ++d) {
      var u = d === 2 ? 0 : 2;
      var v = d === 1 ? 0 : 1;
      var nabVoxelsArr = chunk._neighbors.data.map((c) => {
        if (c && c.voxels) return c.voxels.transpose(d, u, v);
        return null;
      });
      var nabVoxelsT = (0, import_ndarray.default)(nabVoxelsArr, [3, 3, 3]).lo(1, 1, 1).transpose(d, u, v);
      if (maskCache.length < cs * cs) {
        maskCache = new Int16Array(cs * cs);
        aoMaskCache = new Int16Array(cs * cs);
      }
      prepareSolidityLookup(nabVoxelsT, cs);
      var prev = nabVoxelsT.get(-1, 0, 0);
      var here = nabVoxelsT.get(0, 0, 0);
      if (prev) {
        var prevOff = prev.lo(cs, 0, 0);
        var nFaces = constructMeshMask(d, prevOff, -1, here, 0);
        if (nFaces > 0) {
          constructGeometryFromMasks(0, d, u, v, cs, cs, nFaces, faceDataSet);
        }
      }
      if (edgesOnly) continue;
      for (var i = 0; i < cs - 1; i++) {
        if (d === 1) {
          var v1 = chunk._wholeLayerVoxel[i];
          if (v1 >= 0 && v1 === chunk._wholeLayerVoxel[i + 1]) {
            continue;
          }
        }
        var layerVoxRef = d === 1 ? null : chunk._wholeLayerVoxel;
        var nf = constructMeshMask(d, here, i, here, i + 1, layerVoxRef);
        if (nf > 0) {
          constructGeometryFromMasks(i + 1, d, u, v, cs, cs, nf, faceDataSet);
        }
      }
    }
    return faceDataSet;
  };
  function prepareSolidityLookup(nabVoxelsT, size) {
    if (solidityLookupInittedSize !== size) {
      solidityLookupInittedSize = size;
      voxelIDtoSolidity = noa.registry._solidityLookup;
      for (var x = -1; x < size + 1; x++) {
        var loc = x < 0 ? 0 : x < size ? 1 : 2;
        coordToLoc[x + 1] = [0, 1, 2][loc];
        edgeCoordLookup[x + 1] = [size - 1, x, 0][loc];
        missingCoordLookup[x + 1] = [0, x, size - 1][loc];
      }
    }
    var centerChunk = nabVoxelsT.get(0, 0, 0);
    for (var i = 0; i < 3; i++) {
      for (var j = 0; j < 3; j++) {
        for (var k = 0; k < 3; k++) {
          var ix = i * 9 + j * 3 + k;
          var nab = nabVoxelsT.get(i - 1, j - 1, k - 1);
          var type = 0;
          if (!nab) type = 1;
          if (nab === centerChunk) type = 2;
          voxTypeLookup[ix] = type;
          voxLookup[ix] = nab || centerChunk;
        }
      }
    }
  }
  var solidityLookupInittedSize = -1;
  var voxelIDtoSolidity = [false, true];
  var voxLookup = Array(27).fill(null);
  var voxTypeLookup = Array(27).fill(0);
  var coordToLoc = [0, 1, 1, 1, 1, 1, 2];
  var edgeCoordLookup = [3, 0, 1, 2, 3, 0];
  var missingCoordLookup = [0, 0, 1, 2, 3, 3];
  function voxelIsSolid(i, j, k) {
    var li = coordToLoc[i + 1];
    var lj = coordToLoc[j + 1];
    var lk = coordToLoc[k + 1];
    var ix = li * 9 + lj * 3 + lk;
    var voxArray = voxLookup[ix];
    var type = voxTypeLookup[ix];
    if (type === 2) {
      return voxelIDtoSolidity[voxArray.get(i, j, k)];
    }
    var lookup = [edgeCoordLookup, missingCoordLookup][type];
    var ci = lookup[i + 1];
    var cj = lookup[j + 1];
    var ck = lookup[k + 1];
    return voxelIDtoSolidity[voxArray.get(ci, cj, ck)];
  }
  function constructMeshMask(d, arrA, iA, arrB, iB, wholeLayerVoxel = null) {
    var len2 = arrA.shape[1];
    var mask = maskCache;
    var aoMask = aoMaskCache;
    var doAO = noa.rendering.useAO;
    var skipRevAo = noa.rendering.revAoVal === noa.rendering.aoVals[0];
    var opacityLookup = noa.registry._opacityLookup;
    var getMaterial = noa.registry.getBlockFaceMaterial;
    var materialDir = d * 2;
    var n = 0;
    var indexA = arrA.index(iA, 0, 0);
    var jstrideA = arrA.stride[1];
    var kstrideA = arrA.stride[2];
    var indexB = arrB.index(iB, 0, 0);
    var jstrideB = arrB.stride[1];
    var kstrideB = arrB.stride[2];
    var facesFound = 0;
    for (var k = 0; k < len2; ++k) {
      var dA = indexA;
      var dB = indexB;
      indexA += kstrideA;
      indexB += kstrideB;
      if (wholeLayerVoxel && wholeLayerVoxel[k] >= 0) {
        n += len2;
        continue;
      }
      for (var j = 0; j < len2; j++, n++, dA += jstrideA, dB += jstrideB) {
        var id0 = arrA.data[dA];
        var id1 = arrB.data[dB];
        if (id0 === id1) continue;
        var op0 = opacityLookup[id0];
        var op1 = opacityLookup[id1];
        if (op0 && op1) continue;
        var m0 = getMaterial(id0, materialDir);
        var m1 = getMaterial(id1, materialDir + 1);
        if (m0 === m1) continue;
        if (op0 || m1 === 0) {
          mask[n] = m0;
          if (doAO) aoMask[n] = packAOMask(voxelIsSolid, iB, iA, j, k, skipRevAo);
          facesFound++;
        } else if (op1 || m0 === 0) {
          mask[n] = -m1;
          if (doAO) aoMask[n] = packAOMask(voxelIsSolid, iA, iB, j, k, skipRevAo);
          facesFound++;
        } else {
        }
      }
    }
    return facesFound;
  }
  function constructGeometryFromMasks(i, d, u, v, len1, len2, numFaces, faceDataSet) {
    var doAO = noa.rendering.useAO;
    var mask = maskCache;
    var aomask = aoMaskCache;
    var n = 0;
    var materialDir = d * 2;
    var x = [0, 0, 0];
    x[d] = i;
    var maskCompareFcn = doAO ? maskCompare : maskCompare_noAO;
    for (var k = 0; k < len2; ++k) {
      var w = 1;
      var h = 1;
      for (var j = 0; j < len1; j += w, n += w) {
        var maskVal = mask[n] | 0;
        if (!maskVal) {
          w = 1;
          continue;
        }
        var ao = aomask[n] | 0;
        for (w = 1; w < len1 - j; ++w) {
          if (!maskCompareFcn(n + w, mask, maskVal, aomask, ao)) break;
        }
        OUTER:
          for (h = 1; h < len2 - k; ++h) {
            for (var m = 0; m < w; ++m) {
              var ix = n + m + h * len1;
              if (!maskCompareFcn(ix, mask, maskVal, aomask, ao)) break OUTER;
            }
          }
        var matID = Math.abs(maskVal);
        var terrainID = terrainIDgetter(matID);
        if (!(terrainID in faceDataSet)) {
          var fdFromPool = faceDataPool.get();
          fdFromPool.numFaces = 0;
          fdFromPool.terrainID = terrainID;
          faceDataSet[terrainID] = fdFromPool;
        }
        var faceData = faceDataSet[terrainID];
        var nf = faceData.numFaces;
        faceData.numFaces++;
        faceData.matIDs[nf] = matID;
        x[u] = j;
        x[v] = k;
        faceData.is[nf] = x[0];
        faceData.js[nf] = x[1];
        faceData.ks[nf] = x[2];
        faceData.wids[nf] = w;
        faceData.hts[nf] = h;
        faceData.packedAO[nf] = ao;
        faceData.dirs[nf] = maskVal > 0 ? materialDir : materialDir + 1;
        for (var hx = 0; hx < h; ++hx) {
          for (var wx = 0; wx < w; ++wx) {
            mask[n + wx + hx * len1] = 0;
          }
        }
        numFaces -= w * h;
        if (numFaces === 0) return;
      }
    }
  }
  function maskCompare(index, mask, maskVal, aomask, aoVal) {
    if (maskVal !== mask[index]) return false;
    if (aoVal !== aomask[index]) return false;
    return true;
  }
  function maskCompare_noAO(index, mask, maskVal, aomask, aoVal) {
    if (maskVal !== mask[index]) return false;
    return true;
  }
}
var faceDataPool = /* @__PURE__ */ (() => {
  var arr = [], ix = 0;
  var get = () => {
    if (ix >= arr.length) arr.push(new MeshedFaceData());
    ix++;
    return arr[ix - 1];
  };
  var reset = () => {
    ix = 0;
  };
  return { get, reset };
})();
function MeshBuilder(noa, terrainMatManager) {
  this.buildMesh = function(chunk, faceDataSet, ignoreMaterials) {
    var scene = noa.rendering.getScene();
    var doAO = noa.rendering.useAO;
    var aoVals = noa.rendering.aoVals;
    var revAoVal = noa.rendering.revAoVal;
    var atlasIndexLookup = noa.registry._matAtlasIndexLookup;
    var matColorLookup = noa.registry._materialColorLookup;
    var white = [1, 1, 1];
    var meshes = [];
    for (var key in faceDataSet) {
      var faceData = faceDataSet[key];
      var terrainID = faceData.terrainID;
      var usesAtlas = false;
      if (!ignoreMaterials) {
        var firstIx = atlasIndexLookup[faceData.matIDs[0]];
        usesAtlas = firstIx >= 0;
      }
      var nf = faceData.numFaces;
      var indices = new Uint16Array(nf * 6);
      var positions = new Float32Array(nf * 12);
      var normals = new Float32Array(nf * 12);
      var colors = new Float32Array(nf * 16);
      var uvs = new Float32Array(nf * 8);
      var atlasIndexes;
      if (usesAtlas) atlasIndexes = new Float32Array(nf * 4);
      for (var f = 0; f < faceData.numFaces; f++) {
        var matID = faceData.matIDs[f];
        var materialDir = faceData.dirs[f];
        var i = faceData.is[f];
        var j = faceData.js[f];
        var k = faceData.ks[f];
        var w = faceData.wids[f];
        var h = faceData.hts[f];
        var axis = materialDir / 2 | 0;
        var dir = materialDir % 2 ? -1 : 1;
        addPositionValues(positions, f, i, j, k, axis, w, h);
        addUVs(uvs, f, axis, w, h, dir);
        var norms = [0, 0, 0];
        norms[axis] = dir;
        addNormalValues(normals, f, norms);
        var ao = faceData.packedAO[f];
        var [A, B, C, D] = unpackAOMask(ao);
        var triDir = decideTriDir(A, B, C, D);
        addIndexValues(indices, f, axis, dir, triDir);
        if (usesAtlas) {
          var atlasIndex = atlasIndexLookup[matID];
          addAtlasIndices(atlasIndexes, f, atlasIndex);
        }
        var matColor = matColorLookup[matID] || white;
        if (doAO) {
          pushMeshColors(colors, f, matColor, aoVals, revAoVal, A, B, C, D);
        } else {
          pushMeshColors_noAO(colors, f, matColor);
        }
      }
      var name66 = `chunk_${chunk.requestID}_${terrainID}`;
      var mesh = new Mesh(name66, scene);
      var vdat = new VertexData();
      vdat.positions = positions;
      vdat.indices = indices;
      vdat.normals = normals;
      vdat.colors = colors;
      vdat.uvs = uvs;
      vdat.applyToMesh(mesh);
      if (usesAtlas) {
        mesh.setVerticesData("texAtlasIndices", atlasIndexes, false, 1);
      }
      mesh.isPickable = false;
      mesh.doNotSyncBoundingInfo = true;
      mesh._refreshBoundingInfo = () => mesh;
      if (!ignoreMaterials) {
        mesh.material = terrainMatManager.getMaterial(terrainID);
      }
      meshes.push(mesh);
    }
    return meshes;
  };
  function addPositionValues(posArr, faceNum, i, j, k, axis, w, h) {
    var offset = faceNum * 12;
    var loc = [i, j, k];
    var du = [0, 0, 0];
    var dv2 = [0, 0, 0];
    du[axis === 2 ? 0 : 2] = w;
    dv2[axis === 1 ? 0 : 1] = h;
    for (var ix = 0; ix < 3; ix++) {
      posArr[offset + ix] = loc[ix];
      posArr[offset + 3 + ix] = loc[ix] + du[ix];
      posArr[offset + 6 + ix] = loc[ix] + du[ix] + dv2[ix];
      posArr[offset + 9 + ix] = loc[ix] + dv2[ix];
    }
  }
  function addUVs(uvArr, faceNum, d, w, h, dir) {
    var offset = faceNum * 8;
    var epsilon = 0;
    for (var i = 0; i < 8; i++) uvArr[offset + i] = epsilon;
    if (d === 0) {
      uvArr[offset + 1] = uvArr[offset + 3] = h - epsilon;
      uvArr[offset + 2] = uvArr[offset + 4] = dir * w;
    } else if (d === 1) {
      uvArr[offset + 1] = uvArr[offset + 7] = w - epsilon;
      uvArr[offset + 4] = uvArr[offset + 6] = dir * h;
    } else {
      uvArr[offset + 1] = uvArr[offset + 3] = h - epsilon;
      uvArr[offset + 2] = uvArr[offset + 4] = -dir * w;
    }
  }
  function addNormalValues(normArr, faceNum, norms) {
    var offset = faceNum * 12;
    for (var i = 0; i < 12; i++) {
      normArr[offset + i] = norms[i % 3];
    }
  }
  function addIndexValues(indArr, faceNum, axis, dir, triDir) {
    var offset = faceNum * 6;
    var baseIndex = faceNum * 4;
    if (axis === 0) dir = -dir;
    var ix = dir < 0 ? 0 : 1;
    if (!triDir) ix += 2;
    var indexVals = indexLists[ix];
    for (var i = 0; i < 6; i++) {
      indArr[offset + i] = baseIndex + indexVals[i];
    }
  }
  var indexLists = [
    [0, 1, 2, 0, 2, 3],
    // base
    [0, 2, 1, 0, 3, 2],
    // flipped
    [1, 2, 3, 1, 3, 0],
    // opposite triDir
    [1, 3, 2, 1, 0, 3]
    // opposite triDir
  ];
  function addAtlasIndices(indArr, faceNum, atlasIndex) {
    var offset = faceNum * 4;
    for (var i = 0; i < 4; i++) {
      indArr[offset + i] = atlasIndex;
    }
  }
  function decideTriDir(A, B, C, D) {
    if (A === C) {
      return D === B ? D === 2 : true;
    } else {
      return D === B ? false : A + C > D + B;
    }
  }
  function pushMeshColors_noAO(colors, faceNum, col) {
    var offset = faceNum * 16;
    for (var i = 0; i < 16; i += 4) {
      colors[offset + i] = col[0];
      colors[offset + i + 1] = col[1];
      colors[offset + i + 2] = col[2];
      colors[offset + i + 3] = 1;
    }
  }
  function pushMeshColors(colors, faceNum, col, aoVals, revAo, A, B, C, D) {
    var offset = faceNum * 16;
    pushAOColor(colors, offset, col, A, aoVals, revAo);
    pushAOColor(colors, offset + 4, col, D, aoVals, revAo);
    pushAOColor(colors, offset + 8, col, C, aoVals, revAo);
    pushAOColor(colors, offset + 12, col, B, aoVals, revAo);
  }
  function pushAOColor(colors, ix, baseCol, ao, aoVals, revAoVal) {
    var mult = ao === 0 ? revAoVal : aoVals[ao - 1];
    colors[ix] = baseCol[0] * mult;
    colors[ix + 1] = baseCol[1] * mult;
    colors[ix + 2] = baseCol[2] * mult;
    colors[ix + 3] = 1;
  }
}
function packAOMask(isSolid, ipos, ineg, j, k, skipReverse = false) {
  var A = 1;
  var B = 1;
  var D = 1;
  var C = 1;
  if (isSolid(ipos, j + 1, k)) {
    ++D;
    ++C;
  }
  if (isSolid(ipos, j - 1, k)) {
    ++A;
    ++B;
  }
  if (isSolid(ipos, j, k + 1)) {
    ++B;
    ++C;
  }
  if (isSolid(ipos, j, k - 1)) {
    ++A;
    ++D;
  }
  var facingSolid = isSolid(ipos, j, k);
  if (facingSolid) {
    C = C === 3 || isSolid(ipos, j + 1, k + 1) ? 3 : 2;
    B = B === 3 || isSolid(ipos, j - 1, k + 1) ? 3 : 2;
    D = D === 3 || isSolid(ipos, j + 1, k - 1) ? 3 : 2;
    A = A === 3 || isSolid(ipos, j - 1, k - 1) ? 3 : 2;
    return C << 6 | D << 4 | B << 2 | A;
  }
  if (skipReverse) {
    if (C === 1 && isSolid(ipos, j + 1, k + 1)) {
      C = 2;
    }
    if (B === 1 && isSolid(ipos, j - 1, k + 1)) {
      B = 2;
    }
    if (D === 1 && isSolid(ipos, j + 1, k - 1)) {
      D = 2;
    }
    if (A === 1 && isSolid(ipos, j - 1, k - 1)) {
      A = 2;
    }
    return C << 6 | D << 4 | B << 2 | A;
  }
  if (C === 1) {
    if (isSolid(ipos, j + 1, k + 1)) {
      C = 2;
    } else if (!isSolid(ineg, j, k + 1) || !isSolid(ineg, j + 1, k) || !isSolid(ineg, j + 1, k + 1)) {
      C = 0;
    }
  }
  if (D === 1) {
    if (isSolid(ipos, j + 1, k - 1)) {
      D = 2;
    } else if (!isSolid(ineg, j, k - 1) || !isSolid(ineg, j + 1, k) || !isSolid(ineg, j + 1, k - 1)) {
      D = 0;
    }
  }
  if (B === 1) {
    if (isSolid(ipos, j - 1, k + 1)) {
      B = 2;
    } else if (!isSolid(ineg, j, k + 1) || !isSolid(ineg, j - 1, k) || !isSolid(ineg, j - 1, k + 1)) {
      B = 0;
    }
  }
  if (A === 1) {
    if (isSolid(ipos, j - 1, k - 1)) {
      A = 2;
    } else if (!isSolid(ineg, j, k - 1) || !isSolid(ineg, j - 1, k) || !isSolid(ineg, j - 1, k - 1)) {
      A = 0;
    }
  }
  return C << 6 | D << 4 | B << 2 | A;
}
function unpackAOMask(aomask) {
  var A = aomask & 3;
  var B = aomask >> 2 & 3;
  var D = aomask >> 4 & 3;
  var C = aomask >> 6 & 3;
  return [A, B, C, D];
}
var profile_hook2 = PROFILE_EVERY ? makeProfileHook(PROFILE_EVERY, "Meshing") : () => {
};

// ../../node_modules/noa-engine/src/lib/registry.js
var defaults = {
  texturePath: ""
};
var MAX_BLOCK_ID = (1 << 16) - 1;
var Registry = class {
  /** 
   * @internal 
   * @param {import('../index').Engine} noa
  */
  constructor(noa, opts) {
    opts = Object.assign({}, defaults, opts);
    this.noa = noa;
    this._texturePath = opts.texturePath;
    var matIDs = {};
    var blockSolidity = [false];
    var blockOpacity = [false];
    var blockIsFluid = [false];
    var blockIsObject = [false];
    var blockProps = [null];
    var blockMeshes = [null];
    var blockHandlers = [null];
    var blockIsPlain = [false];
    var blockMats = [0, 0, 0, 0, 0, 0];
    var matColorLookup = [null];
    var matAtlasIndexLookup = [-1];
    var matDefs = [];
    this.registerBlock = function(id = 1, options = null) {
      var defaults3 = new BlockOptions(options && options.fluid);
      var opts2 = Object.assign({}, defaults3, options || {});
      if (id < 1 || id > MAX_BLOCK_ID) throw "Block id out of range: " + id;
      while (id > blockSolidity.length) {
        this.registerBlock(blockSolidity.length, {});
      }
      blockSolidity[id] = !!opts2.solid;
      blockOpacity[id] = !!opts2.opaque;
      blockIsFluid[id] = !!opts2.fluid;
      blockIsObject[id] = !!opts2.blockMesh;
      blockMeshes[id] = opts2.blockMesh || null;
      var mat = opts2.material || null;
      var mats;
      if (!mat) {
        mats = [null, null, null, null, null, null];
      } else if (typeof mat == "string") {
        mats = [mat, mat, mat, mat, mat, mat];
      } else if (mat.length && mat.length == 2) {
        mats = [mat[1], mat[1], mat[0], mat[0], mat[1], mat[1]];
      } else if (mat.length && mat.length == 3) {
        mats = [mat[2], mat[2], mat[0], mat[1], mat[2], mat[2]];
      } else if (mat.length && mat.length == 6) {
        mats = mat;
      } else throw "Invalid material parameter: " + mat;
      for (var i = 0; i < 6; ++i) {
        blockMats[id * 6 + i] = getMaterialId(this, matIDs, mats[i], true);
      }
      blockProps[id] = {};
      if (blockIsFluid[id]) {
        blockProps[id].fluidDensity = opts2.fluidDensity;
        blockProps[id].viscosity = opts2.viscosity;
      }
      var hasHandler = opts2.onLoad || opts2.onUnload || opts2.onSet || opts2.onUnset || opts2.onCustomMeshCreate;
      blockHandlers[id] = hasHandler ? new BlockCallbackHolder(opts2) : null;
      var isPlain = blockSolidity[id] && blockOpacity[id] && !hasHandler && !blockIsFluid[id] && !blockIsObject[id];
      blockIsPlain[id] = isPlain;
      return id;
    };
    this.registerMaterial = function(name66 = "?", options = null) {
      if (Array.isArray(options)) {
        throw 'This API changed signatures in v0.33, please use: `noa.registry.registerMaterial("name", optionsObj)`';
      }
      var opts2 = Object.assign(new MaterialOptions(), options || {});
      var matID = matIDs[name66] || matDefs.length;
      matIDs[name66] = matID;
      var texURL = opts2.textureURL ? this._texturePath + opts2.textureURL : "";
      var alpha = 1;
      var color = opts2.color || [1, 1, 1];
      if (color.length === 4) alpha = color.pop();
      if (texURL) color = null;
      matColorLookup[matID] = color;
      matAtlasIndexLookup[matID] = opts2.atlasIndex;
      matDefs[matID] = {
        color,
        alpha,
        texture: texURL,
        texHasAlpha: !!opts2.texHasAlpha,
        atlasIndex: opts2.atlasIndex,
        renderMat: opts2.renderMaterial
      };
      return matID;
    };
    this.getBlockSolidity = function(id) {
      return blockSolidity[id];
    };
    this.getBlockOpacity = function(id) {
      return blockOpacity[id];
    };
    this.getBlockFluidity = function(id) {
      return blockIsFluid[id];
    };
    this.getBlockProps = function(id) {
      return blockProps[id];
    };
    this.getBlockFaceMaterial = function(blockId, dir) {
      return blockMats[blockId * 6 + dir];
    };
    this.getMaterialData = function(matID) {
      return matDefs[matID];
    };
    this._textureNeedsAlpha = function(tex = "") {
      return matDefs.some((def) => {
        if (def.texture !== tex) return false;
        return def.texHasAlpha;
      });
    };
    this._solidityLookup = blockSolidity;
    this._opacityLookup = blockOpacity;
    this._fluidityLookup = blockIsFluid;
    this._objectLookup = blockIsObject;
    this._blockMeshLookup = blockMeshes;
    this._blockHandlerLookup = blockHandlers;
    this._blockIsPlainLookup = blockIsPlain;
    this._materialColorLookup = matColorLookup;
    this._matAtlasIndexLookup = matAtlasIndexLookup;
    this.registerMaterial("dirt", { color: [0.4, 0.3, 0] });
    this.registerBlock(1, { material: "dirt" });
  }
};
function getMaterialId(reg, matIDs, name66, lazyInit) {
  if (!name66) return 0;
  var id = matIDs[name66];
  if (id === void 0 && lazyInit) id = reg.registerMaterial(name66);
  return id;
}
function BlockCallbackHolder(opts) {
  this.onLoad = opts.onLoad || null;
  this.onUnload = opts.onUnload || null;
  this.onSet = opts.onSet || null;
  this.onUnset = opts.onUnset || null;
  this.onCustomMeshCreate = opts.onCustomMeshCreate || null;
}
function BlockOptions(isFluid = false) {
  this.solid = isFluid ? false : true;
  this.opaque = isFluid ? false : true;
  this.fluid = false;
  this.material = null;
  this.blockMesh = null;
  this.fluidDensity = 1;
  this.viscosity = 0.5;
  this.onLoad = null;
  this.onUnload = null;
  this.onSet = null;
  this.onUnset = null;
  this.onCustomMeshCreate = null;
}
function MaterialOptions() {
  this.color = null;
  this.textureURL = null;
  this.texHasAlpha = false;
  this.atlasIndex = -1;
  this.renderMaterial = null;
}

// ../../node_modules/noa-engine/src/lib/rendering.js
var import_gl_vec39 = __toESM(require_gl_vec3());

// ../../node_modules/@babylonjs/core/Culling/Octrees/octreeBlock.js
var OctreeBlock = class _OctreeBlock {
  /**
   * Creates a new block
   * @param minPoint defines the minimum vector (in world space) of the block's bounding box
   * @param maxPoint defines the maximum vector (in world space) of the block's bounding box
   * @param capacity defines the maximum capacity of this block (if capacity is reached the block will be split into sub blocks)
   * @param depth defines the current depth of this block in the octree
   * @param maxDepth defines the maximal depth allowed (beyond this value, the capacity is ignored)
   * @param creationFunc defines a callback to call when an element is added to the block
   */
  constructor(minPoint, maxPoint, capacity, depth, maxDepth, creationFunc) {
    this.entries = [];
    this._boundingVectors = new Array();
    this._capacity = capacity;
    this._depth = depth;
    this._maxDepth = maxDepth;
    this._creationFunc = creationFunc;
    this._minPoint = minPoint;
    this._maxPoint = maxPoint;
    this._boundingVectors.push(minPoint.clone());
    this._boundingVectors.push(maxPoint.clone());
    this._boundingVectors.push(minPoint.clone());
    this._boundingVectors[2].x = maxPoint.x;
    this._boundingVectors.push(minPoint.clone());
    this._boundingVectors[3].y = maxPoint.y;
    this._boundingVectors.push(minPoint.clone());
    this._boundingVectors[4].z = maxPoint.z;
    this._boundingVectors.push(maxPoint.clone());
    this._boundingVectors[5].z = minPoint.z;
    this._boundingVectors.push(maxPoint.clone());
    this._boundingVectors[6].x = minPoint.x;
    this._boundingVectors.push(maxPoint.clone());
    this._boundingVectors[7].y = minPoint.y;
  }
  // Property
  /**
   * Gets the maximum capacity of this block (if capacity is reached the block will be split into sub blocks)
   */
  get capacity() {
    return this._capacity;
  }
  /**
   * Gets the minimum vector (in world space) of the block's bounding box
   */
  get minPoint() {
    return this._minPoint;
  }
  /**
   * Gets the maximum vector (in world space) of the block's bounding box
   */
  get maxPoint() {
    return this._maxPoint;
  }
  // Methods
  /**
   * Add a new element to this block
   * @param entry defines the element to add
   */
  addEntry(entry) {
    if (this.blocks) {
      for (let index = 0; index < this.blocks.length; index++) {
        const block = this.blocks[index];
        block.addEntry(entry);
      }
      return;
    }
    this._creationFunc(entry, this);
    if (this.entries.length > this.capacity && this._depth < this._maxDepth) {
      this.createInnerBlocks();
    }
  }
  /**
   * Remove an element from this block
   * @param entry defines the element to remove
   */
  removeEntry(entry) {
    if (this.blocks) {
      for (let index = 0; index < this.blocks.length; index++) {
        const block = this.blocks[index];
        block.removeEntry(entry);
      }
      return;
    }
    const entryIndex = this.entries.indexOf(entry);
    if (entryIndex > -1) {
      this.entries.splice(entryIndex, 1);
    }
  }
  /**
   * Add an array of elements to this block
   * @param entries defines the array of elements to add
   */
  addEntries(entries) {
    for (let index = 0; index < entries.length; index++) {
      const mesh = entries[index];
      this.addEntry(mesh);
    }
  }
  /**
   * Test if the current block intersects the frustum planes and if yes, then add its content to the selection array
   * @param frustumPlanes defines the frustum planes to test
   * @param selection defines the array to store current content if selection is positive
   * @param allowDuplicate defines if the selection array can contains duplicated entries
   */
  select(frustumPlanes, selection, allowDuplicate) {
    if (BoundingBox.IsInFrustum(this._boundingVectors, frustumPlanes)) {
      if (this.blocks) {
        for (let index = 0; index < this.blocks.length; index++) {
          const block = this.blocks[index];
          block.select(frustumPlanes, selection, allowDuplicate);
        }
        return;
      }
      if (allowDuplicate) {
        selection.concat(this.entries);
      } else {
        selection.concatWithNoDuplicate(this.entries);
      }
    }
  }
  /**
   * Test if the current block intersect with the given bounding sphere and if yes, then add its content to the selection array
   * @param sphereCenter defines the bounding sphere center
   * @param sphereRadius defines the bounding sphere radius
   * @param selection defines the array to store current content if selection is positive
   * @param allowDuplicate defines if the selection array can contains duplicated entries
   */
  intersects(sphereCenter, sphereRadius, selection, allowDuplicate) {
    if (BoundingBox.IntersectsSphere(this._minPoint, this._maxPoint, sphereCenter, sphereRadius)) {
      if (this.blocks) {
        for (let index = 0; index < this.blocks.length; index++) {
          const block = this.blocks[index];
          block.intersects(sphereCenter, sphereRadius, selection, allowDuplicate);
        }
        return;
      }
      if (allowDuplicate) {
        selection.concat(this.entries);
      } else {
        selection.concatWithNoDuplicate(this.entries);
      }
    }
  }
  /**
   * Test if the current block intersect with the given ray and if yes, then add its content to the selection array
   * @param ray defines the ray to test with
   * @param selection defines the array to store current content if selection is positive
   */
  intersectsRay(ray, selection) {
    if (ray.intersectsBoxMinMax(this._minPoint, this._maxPoint)) {
      if (this.blocks) {
        for (let index = 0; index < this.blocks.length; index++) {
          const block = this.blocks[index];
          block.intersectsRay(ray, selection);
        }
        return;
      }
      selection.concatWithNoDuplicate(this.entries);
    }
  }
  /**
   * Subdivide the content into child blocks (this block will then be empty)
   */
  createInnerBlocks() {
    _OctreeBlock._CreateBlocks(this._minPoint, this._maxPoint, this.entries, this._capacity, this._depth, this._maxDepth, this, this._creationFunc);
    this.entries.splice(0);
  }
  /**
   * @internal
   */
  static _CreateBlocks(worldMin, worldMax, entries, maxBlockCapacity, currentDepth, maxDepth, target, creationFunc) {
    target.blocks = new Array();
    const blockSize = new Vector3((worldMax.x - worldMin.x) / 2, (worldMax.y - worldMin.y) / 2, (worldMax.z - worldMin.z) / 2);
    for (let x = 0; x < 2; x++) {
      for (let y = 0; y < 2; y++) {
        for (let z = 0; z < 2; z++) {
          const localMin = worldMin.add(blockSize.multiplyByFloats(x, y, z));
          const localMax = worldMin.add(blockSize.multiplyByFloats(x + 1, y + 1, z + 1));
          const block = new _OctreeBlock(localMin, localMax, maxBlockCapacity, currentDepth + 1, maxDepth, creationFunc);
          block.addEntries(entries);
          target.blocks.push(block);
        }
      }
    }
  }
};

// ../../node_modules/@babylonjs/core/Culling/Octrees/octree.js
var Octree = class {
  /**
   * Creates a octree
   * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/optimizeOctrees
   * @param creationFunc function to be used to instantiate the octree
   * @param maxBlockCapacity defines the maximum number of meshes you want on your octree's leaves (default: 64)
   * @param maxDepth defines the maximum depth (sub-levels) for your octree. Default value is 2, which means 8 8 8 = 512 blocks :) (This parameter takes precedence over capacity.)
   */
  constructor(creationFunc, maxBlockCapacity, maxDepth = 2) {
    this.maxDepth = maxDepth;
    this.dynamicContent = [];
    this._maxBlockCapacity = maxBlockCapacity || 64;
    this._selectionContent = new SmartArrayNoDuplicate(1024);
    this._creationFunc = creationFunc;
  }
  // Methods
  /**
   * Updates the octree by adding blocks for the passed in meshes within the min and max world parameters
   * @param worldMin worldMin for the octree blocks var blockSize = new Vector3((worldMax.x - worldMin.x) / 2, (worldMax.y - worldMin.y) / 2, (worldMax.z - worldMin.z) / 2);
   * @param worldMax worldMax for the octree blocks var blockSize = new Vector3((worldMax.x - worldMin.x) / 2, (worldMax.y - worldMin.y) / 2, (worldMax.z - worldMin.z) / 2);
   * @param entries meshes to be added to the octree blocks
   */
  update(worldMin, worldMax, entries) {
    OctreeBlock._CreateBlocks(worldMin, worldMax, entries, this._maxBlockCapacity, 0, this.maxDepth, this, this._creationFunc);
  }
  /**
   * Adds a mesh to the octree
   * @param entry Mesh to add to the octree
   */
  addMesh(entry) {
    for (let index = 0; index < this.blocks.length; index++) {
      const block = this.blocks[index];
      block.addEntry(entry);
    }
  }
  /**
   * Remove an element from the octree
   * @param entry defines the element to remove
   */
  removeMesh(entry) {
    for (let index = 0; index < this.blocks.length; index++) {
      const block = this.blocks[index];
      block.removeEntry(entry);
    }
  }
  /**
   * Selects an array of meshes within the frustum
   * @param frustumPlanes The frustum planes to use which will select all meshes within it
   * @param allowDuplicate If duplicate objects are allowed in the resulting object array
   * @returns array of meshes within the frustum
   */
  select(frustumPlanes, allowDuplicate) {
    this._selectionContent.reset();
    for (let index = 0; index < this.blocks.length; index++) {
      const block = this.blocks[index];
      block.select(frustumPlanes, this._selectionContent, allowDuplicate);
    }
    if (allowDuplicate) {
      this._selectionContent.concat(this.dynamicContent);
    } else {
      this._selectionContent.concatWithNoDuplicate(this.dynamicContent);
    }
    return this._selectionContent;
  }
  /**
   * Test if the octree intersect with the given bounding sphere and if yes, then add its content to the selection array
   * @param sphereCenter defines the bounding sphere center
   * @param sphereRadius defines the bounding sphere radius
   * @param allowDuplicate defines if the selection array can contains duplicated entries
   * @returns an array of objects that intersect the sphere
   */
  intersects(sphereCenter, sphereRadius, allowDuplicate) {
    this._selectionContent.reset();
    for (let index = 0; index < this.blocks.length; index++) {
      const block = this.blocks[index];
      block.intersects(sphereCenter, sphereRadius, this._selectionContent, allowDuplicate);
    }
    if (allowDuplicate) {
      this._selectionContent.concat(this.dynamicContent);
    } else {
      this._selectionContent.concatWithNoDuplicate(this.dynamicContent);
    }
    return this._selectionContent;
  }
  /**
   * Test if the octree intersect with the given ray and if yes, then add its content to resulting array
   * @param ray defines the ray to test with
   * @returns array of intersected objects
   */
  intersectsRay(ray) {
    this._selectionContent.reset();
    for (let index = 0; index < this.blocks.length; index++) {
      const block = this.blocks[index];
      block.intersectsRay(ray, this._selectionContent);
    }
    this._selectionContent.concatWithNoDuplicate(this.dynamicContent);
    return this._selectionContent;
  }
};
Octree.CreationFuncForMeshes = (entry, block) => {
  const boundingInfo = entry.getBoundingInfo();
  if (!entry.isBlocked && boundingInfo.boundingBox.intersectsMinMax(block.minPoint, block.maxPoint)) {
    block.entries.push(entry);
  }
};
Octree.CreationFuncForSubMeshes = (entry, block) => {
  const boundingInfo = entry.getBoundingInfo();
  if (boundingInfo.boundingBox.intersectsMinMax(block.minPoint, block.maxPoint)) {
    block.entries.push(entry);
  }
};

// ../../node_modules/@babylonjs/core/Culling/ray.js
var Ray = class _Ray {
  /**
   * Creates a new ray
   * @param origin origin point
   * @param direction direction
   * @param length length of the ray
   * @param epsilon The epsilon value to use when calculating the ray/triangle intersection (default: 0)
   */
  constructor(origin, direction, length4 = Number.MAX_VALUE, epsilon = Epsilon) {
    this.origin = origin;
    this.direction = direction;
    this.length = length4;
    this.epsilon = epsilon;
  }
  // Methods
  /**
   * Clone the current ray
   * @returns a new ray
   */
  clone() {
    return new _Ray(this.origin.clone(), this.direction.clone(), this.length);
  }
  /**
   * Checks if the ray intersects a box
   * This does not account for the ray length by design to improve perfs.
   * @param minimum bound of the box
   * @param maximum bound of the box
   * @param intersectionTreshold extra extend to be added to the box in all direction
   * @returns if the box was hit
   */
  intersectsBoxMinMax(minimum, maximum, intersectionTreshold = 0) {
    const newMinimum = _Ray._TmpVector3[0].copyFromFloats(minimum.x - intersectionTreshold, minimum.y - intersectionTreshold, minimum.z - intersectionTreshold);
    const newMaximum = _Ray._TmpVector3[1].copyFromFloats(maximum.x + intersectionTreshold, maximum.y + intersectionTreshold, maximum.z + intersectionTreshold);
    let d = 0;
    let maxValue = Number.MAX_VALUE;
    let inv;
    let min2;
    let max2;
    let temp;
    if (Math.abs(this.direction.x) < 1e-7) {
      if (this.origin.x < newMinimum.x || this.origin.x > newMaximum.x) {
        return false;
      }
    } else {
      inv = 1 / this.direction.x;
      min2 = (newMinimum.x - this.origin.x) * inv;
      max2 = (newMaximum.x - this.origin.x) * inv;
      if (max2 === -Infinity) {
        max2 = Infinity;
      }
      if (min2 > max2) {
        temp = min2;
        min2 = max2;
        max2 = temp;
      }
      d = Math.max(min2, d);
      maxValue = Math.min(max2, maxValue);
      if (d > maxValue) {
        return false;
      }
    }
    if (Math.abs(this.direction.y) < 1e-7) {
      if (this.origin.y < newMinimum.y || this.origin.y > newMaximum.y) {
        return false;
      }
    } else {
      inv = 1 / this.direction.y;
      min2 = (newMinimum.y - this.origin.y) * inv;
      max2 = (newMaximum.y - this.origin.y) * inv;
      if (max2 === -Infinity) {
        max2 = Infinity;
      }
      if (min2 > max2) {
        temp = min2;
        min2 = max2;
        max2 = temp;
      }
      d = Math.max(min2, d);
      maxValue = Math.min(max2, maxValue);
      if (d > maxValue) {
        return false;
      }
    }
    if (Math.abs(this.direction.z) < 1e-7) {
      if (this.origin.z < newMinimum.z || this.origin.z > newMaximum.z) {
        return false;
      }
    } else {
      inv = 1 / this.direction.z;
      min2 = (newMinimum.z - this.origin.z) * inv;
      max2 = (newMaximum.z - this.origin.z) * inv;
      if (max2 === -Infinity) {
        max2 = Infinity;
      }
      if (min2 > max2) {
        temp = min2;
        min2 = max2;
        max2 = temp;
      }
      d = Math.max(min2, d);
      maxValue = Math.min(max2, maxValue);
      if (d > maxValue) {
        return false;
      }
    }
    return true;
  }
  /**
   * Checks if the ray intersects a box
   * This does not account for the ray lenght by design to improve perfs.
   * @param box the bounding box to check
   * @param intersectionTreshold extra extend to be added to the BoundingBox in all direction
   * @returns if the box was hit
   */
  intersectsBox(box, intersectionTreshold = 0) {
    return this.intersectsBoxMinMax(box.minimum, box.maximum, intersectionTreshold);
  }
  /**
   * If the ray hits a sphere
   * @param sphere the bounding sphere to check
   * @param intersectionTreshold extra extend to be added to the BoundingSphere in all direction
   * @returns true if it hits the sphere
   */
  intersectsSphere(sphere, intersectionTreshold = 0) {
    const x = sphere.center.x - this.origin.x;
    const y = sphere.center.y - this.origin.y;
    const z = sphere.center.z - this.origin.z;
    const pyth = x * x + y * y + z * z;
    const radius = sphere.radius + intersectionTreshold;
    const rr = radius * radius;
    if (pyth <= rr) {
      return true;
    }
    const dot4 = x * this.direction.x + y * this.direction.y + z * this.direction.z;
    if (dot4 < 0) {
      return false;
    }
    const temp = pyth - dot4 * dot4;
    return temp <= rr;
  }
  /**
   * If the ray hits a triange
   * @param vertex0 triangle vertex
   * @param vertex1 triangle vertex
   * @param vertex2 triangle vertex
   * @returns intersection information if hit
   */
  intersectsTriangle(vertex0, vertex1, vertex2) {
    const edge1 = _Ray._TmpVector3[0];
    const edge2 = _Ray._TmpVector3[1];
    const pvec = _Ray._TmpVector3[2];
    const tvec = _Ray._TmpVector3[3];
    const qvec = _Ray._TmpVector3[4];
    vertex1.subtractToRef(vertex0, edge1);
    vertex2.subtractToRef(vertex0, edge2);
    Vector3.CrossToRef(this.direction, edge2, pvec);
    const det = Vector3.Dot(edge1, pvec);
    if (det === 0) {
      return null;
    }
    const invdet = 1 / det;
    this.origin.subtractToRef(vertex0, tvec);
    const bv = Vector3.Dot(tvec, pvec) * invdet;
    if (bv < -this.epsilon || bv > 1 + this.epsilon) {
      return null;
    }
    Vector3.CrossToRef(tvec, edge1, qvec);
    const bw = Vector3.Dot(this.direction, qvec) * invdet;
    if (bw < -this.epsilon || bv + bw > 1 + this.epsilon) {
      return null;
    }
    const distance2 = Vector3.Dot(edge2, qvec) * invdet;
    if (distance2 > this.length) {
      return null;
    }
    return new IntersectionInfo(1 - bv - bw, bv, distance2);
  }
  /**
   * Checks if ray intersects a plane
   * @param plane the plane to check
   * @returns the distance away it was hit
   */
  intersectsPlane(plane) {
    let distance2;
    const result1 = Vector3.Dot(plane.normal, this.direction);
    if (Math.abs(result1) < 999999997475243e-21) {
      return null;
    } else {
      const result2 = Vector3.Dot(plane.normal, this.origin);
      distance2 = (-plane.d - result2) / result1;
      if (distance2 < 0) {
        if (distance2 < -999999997475243e-21) {
          return null;
        } else {
          return 0;
        }
      }
      return distance2;
    }
  }
  /**
   * Calculate the intercept of a ray on a given axis
   * @param axis to check 'x' | 'y' | 'z'
   * @param offset from axis interception (i.e. an offset of 1y is intercepted above ground)
   * @returns a vector containing the coordinates where 'axis' is equal to zero (else offset), or null if there is no intercept.
   */
  intersectsAxis(axis, offset = 0) {
    switch (axis) {
      case "y": {
        const t = (this.origin.y - offset) / this.direction.y;
        if (t > 0) {
          return null;
        }
        return new Vector3(this.origin.x + this.direction.x * -t, offset, this.origin.z + this.direction.z * -t);
      }
      case "x": {
        const t = (this.origin.x - offset) / this.direction.x;
        if (t > 0) {
          return null;
        }
        return new Vector3(offset, this.origin.y + this.direction.y * -t, this.origin.z + this.direction.z * -t);
      }
      case "z": {
        const t = (this.origin.z - offset) / this.direction.z;
        if (t > 0) {
          return null;
        }
        return new Vector3(this.origin.x + this.direction.x * -t, this.origin.y + this.direction.y * -t, offset);
      }
      default:
        return null;
    }
  }
  /**
   * Checks if ray intersects a mesh. The ray is defined in WORLD space. A mesh triangle can be picked both from its front and back sides,
   * irrespective of orientation.
   * @param mesh the mesh to check
   * @param fastCheck defines if the first intersection will be used (and not the closest)
   * @param trianglePredicate defines an optional predicate used to select faces when a mesh intersection is detected
   * @param onlyBoundingInfo defines a boolean indicating if picking should only happen using bounding info (false by default)
   * @param worldToUse defines the world matrix to use to get the world coordinate of the intersection point
   * @param skipBoundingInfo a boolean indicating if we should skip the bounding info check
   * @returns picking info of the intersection
   */
  intersectsMesh(mesh, fastCheck, trianglePredicate, onlyBoundingInfo = false, worldToUse, skipBoundingInfo = false) {
    const tm = TmpVectors.Matrix[0];
    mesh.getWorldMatrix().invertToRef(tm);
    if (this._tmpRay) {
      _Ray.TransformToRef(this, tm, this._tmpRay);
    } else {
      this._tmpRay = _Ray.Transform(this, tm);
    }
    return mesh.intersects(this._tmpRay, fastCheck, trianglePredicate, onlyBoundingInfo, worldToUse, skipBoundingInfo);
  }
  /**
   * Checks if ray intersects a mesh
   * @param meshes the meshes to check
   * @param fastCheck defines if the first intersection will be used (and not the closest)
   * @param results array to store result in
   * @returns Array of picking infos
   */
  intersectsMeshes(meshes, fastCheck, results) {
    if (results) {
      results.length = 0;
    } else {
      results = [];
    }
    for (let i = 0; i < meshes.length; i++) {
      const pickInfo = this.intersectsMesh(meshes[i], fastCheck);
      if (pickInfo.hit) {
        results.push(pickInfo);
      }
    }
    results.sort(this._comparePickingInfo);
    return results;
  }
  _comparePickingInfo(pickingInfoA, pickingInfoB) {
    if (pickingInfoA.distance < pickingInfoB.distance) {
      return -1;
    } else if (pickingInfoA.distance > pickingInfoB.distance) {
      return 1;
    } else {
      return 0;
    }
  }
  /**
   * Intersection test between the ray and a given segment within a given tolerance (threshold)
   * @param sega the first point of the segment to test the intersection against
   * @param segb the second point of the segment to test the intersection against
   * @param threshold the tolerance margin, if the ray doesn't intersect the segment but is close to the given threshold, the intersection is successful
   * @returns the distance from the ray origin to the intersection point if there's intersection, or -1 if there's no intersection
   */
  intersectionSegment(sega, segb, threshold) {
    const o = this.origin;
    const u = TmpVectors.Vector3[0];
    const rsegb = TmpVectors.Vector3[1];
    const v = TmpVectors.Vector3[2];
    const w = TmpVectors.Vector3[3];
    segb.subtractToRef(sega, u);
    this.direction.scaleToRef(_Ray._Rayl, v);
    o.addToRef(v, rsegb);
    sega.subtractToRef(o, w);
    const a2 = Vector3.Dot(u, u);
    const b = Vector3.Dot(u, v);
    const c = Vector3.Dot(v, v);
    const d = Vector3.Dot(u, w);
    const e = Vector3.Dot(v, w);
    const D = a2 * c - b * b;
    let sN, sD = D;
    let tN, tD = D;
    if (D < _Ray._Smallnum) {
      sN = 0;
      sD = 1;
      tN = e;
      tD = c;
    } else {
      sN = b * e - c * d;
      tN = a2 * e - b * d;
      if (sN < 0) {
        sN = 0;
        tN = e;
        tD = c;
      } else if (sN > sD) {
        sN = sD;
        tN = e + b;
        tD = c;
      }
    }
    if (tN < 0) {
      tN = 0;
      if (-d < 0) {
        sN = 0;
      } else if (-d > a2) {
        sN = sD;
      } else {
        sN = -d;
        sD = a2;
      }
    } else if (tN > tD) {
      tN = tD;
      if (-d + b < 0) {
        sN = 0;
      } else if (-d + b > a2) {
        sN = sD;
      } else {
        sN = -d + b;
        sD = a2;
      }
    }
    const sc = Math.abs(sN) < _Ray._Smallnum ? 0 : sN / sD;
    const tc = Math.abs(tN) < _Ray._Smallnum ? 0 : tN / tD;
    const qtc = TmpVectors.Vector3[4];
    v.scaleToRef(tc, qtc);
    const qsc = TmpVectors.Vector3[5];
    u.scaleToRef(sc, qsc);
    qsc.addInPlace(w);
    const dP = TmpVectors.Vector3[6];
    qsc.subtractToRef(qtc, dP);
    const isIntersected = tc > 0 && tc <= this.length && dP.lengthSquared() < threshold * threshold;
    if (isIntersected) {
      return qsc.length();
    }
    return -1;
  }
  /**
   * Update the ray from viewport position
   * @param x position
   * @param y y position
   * @param viewportWidth viewport width
   * @param viewportHeight viewport height
   * @param world world matrix
   * @param view view matrix
   * @param projection projection matrix
   * @param enableDistantPicking defines if picking should handle large values for mesh position/scaling (false by default)
   * @returns this ray updated
   */
  update(x, y, viewportWidth, viewportHeight, world, view, projection, enableDistantPicking = false) {
    if (enableDistantPicking) {
      if (!_Ray._RayDistant) {
        _Ray._RayDistant = _Ray.Zero();
      }
      _Ray._RayDistant.unprojectRayToRef(x, y, viewportWidth, viewportHeight, Matrix.IdentityReadOnly, view, projection);
      const tm = TmpVectors.Matrix[0];
      world.invertToRef(tm);
      _Ray.TransformToRef(_Ray._RayDistant, tm, this);
    } else {
      this.unprojectRayToRef(x, y, viewportWidth, viewportHeight, world, view, projection);
    }
    return this;
  }
  // Statics
  /**
   * Creates a ray with origin and direction of 0,0,0
   * @returns the new ray
   */
  static Zero() {
    return new _Ray(Vector3.Zero(), Vector3.Zero());
  }
  /**
   * Creates a new ray from screen space and viewport
   * @param x position
   * @param y y position
   * @param viewportWidth viewport width
   * @param viewportHeight viewport height
   * @param world world matrix
   * @param view view matrix
   * @param projection projection matrix
   * @returns new ray
   */
  static CreateNew(x, y, viewportWidth, viewportHeight, world, view, projection) {
    const result = _Ray.Zero();
    return result.update(x, y, viewportWidth, viewportHeight, world, view, projection);
  }
  /**
   * Function will create a new transformed ray starting from origin and ending at the end point. Ray's length will be set, and ray will be
   * transformed to the given world matrix.
   * @param origin The origin point
   * @param end The end point
   * @param world a matrix to transform the ray to. Default is the identity matrix.
   * @returns the new ray
   */
  static CreateNewFromTo(origin, end, world = Matrix.IdentityReadOnly) {
    const result = new _Ray(new Vector3(0, 0, 0), new Vector3(0, 0, 0));
    return _Ray.CreateFromToToRef(origin, end, result, world);
  }
  /**
   * Function will update a transformed ray starting from origin and ending at the end point. Ray's length will be set, and ray will be
   * transformed to the given world matrix.
   * @param origin The origin point
   * @param end The end point
   * @param result the object to store the result
   * @param world a matrix to transform the ray to. Default is the identity matrix.
   * @returns the ref ray
   */
  static CreateFromToToRef(origin, end, result, world = Matrix.IdentityReadOnly) {
    result.origin.copyFrom(origin);
    const direction = end.subtractToRef(origin, result.direction);
    const length4 = Math.sqrt(direction.x * direction.x + direction.y * direction.y + direction.z * direction.z);
    result.length = length4;
    result.direction.normalize();
    return _Ray.TransformToRef(result, world, result);
  }
  /**
   * Transforms a ray by a matrix
   * @param ray ray to transform
   * @param matrix matrix to apply
   * @returns the resulting new ray
   */
  static Transform(ray, matrix) {
    const result = new _Ray(new Vector3(0, 0, 0), new Vector3(0, 0, 0));
    _Ray.TransformToRef(ray, matrix, result);
    return result;
  }
  /**
   * Transforms a ray by a matrix
   * @param ray ray to transform
   * @param matrix matrix to apply
   * @param result ray to store result in
   * @returns the updated result ray
   */
  static TransformToRef(ray, matrix, result) {
    Vector3.TransformCoordinatesToRef(ray.origin, matrix, result.origin);
    Vector3.TransformNormalToRef(ray.direction, matrix, result.direction);
    result.length = ray.length;
    result.epsilon = ray.epsilon;
    const dir = result.direction;
    const len2 = dir.length();
    if (!(len2 === 0 || len2 === 1)) {
      const num = 1 / len2;
      dir.x *= num;
      dir.y *= num;
      dir.z *= num;
      result.length *= len2;
    }
    return result;
  }
  /**
   * Unproject a ray from screen space to object space
   * @param sourceX defines the screen space x coordinate to use
   * @param sourceY defines the screen space y coordinate to use
   * @param viewportWidth defines the current width of the viewport
   * @param viewportHeight defines the current height of the viewport
   * @param world defines the world matrix to use (can be set to Identity to go to world space)
   * @param view defines the view matrix to use
   * @param projection defines the projection matrix to use
   */
  unprojectRayToRef(sourceX, sourceY, viewportWidth, viewportHeight, world, view, projection) {
    const matrix = TmpVectors.Matrix[0];
    world.multiplyToRef(view, matrix);
    matrix.multiplyToRef(projection, matrix);
    matrix.invert();
    const engine = EngineStore.LastCreatedEngine;
    const nearScreenSource = TmpVectors.Vector3[0];
    nearScreenSource.x = sourceX / viewportWidth * 2 - 1;
    nearScreenSource.y = -(sourceY / viewportHeight * 2 - 1);
    nearScreenSource.z = engine?.useReverseDepthBuffer ? 1 : engine?.isNDCHalfZRange ? 0 : -1;
    const farScreenSource = TmpVectors.Vector3[1].copyFromFloats(nearScreenSource.x, nearScreenSource.y, 1 - 1e-8);
    const nearVec3 = TmpVectors.Vector3[2];
    const farVec3 = TmpVectors.Vector3[3];
    Vector3._UnprojectFromInvertedMatrixToRef(nearScreenSource, matrix, nearVec3);
    Vector3._UnprojectFromInvertedMatrixToRef(farScreenSource, matrix, farVec3);
    this.origin.copyFrom(nearVec3);
    farVec3.subtractToRef(nearVec3, this.direction);
    this.direction.normalize();
  }
};
Ray._TmpVector3 = ArrayTools.BuildArray(6, Vector3.Zero);
Ray._RayDistant = Ray.Zero();
Ray._Smallnum = 1e-8;
Ray._Rayl = 1e9;
Scene.prototype.createPickingRay = function(x, y, world, camera, cameraViewSpace = false) {
  const result = Ray.Zero();
  this.createPickingRayToRef(x, y, world, result, camera, cameraViewSpace);
  return result;
};
Scene.prototype.createPickingRayToRef = function(x, y, world, result, camera, cameraViewSpace = false, enableDistantPicking = false) {
  const engine = this.getEngine();
  if (!camera && !(camera = this.activeCamera)) {
    return this;
  }
  const cameraViewport = camera.viewport;
  const renderHeight = engine.getRenderHeight();
  const { x: vx, y: vy, width, height } = cameraViewport.toGlobal(engine.getRenderWidth(), renderHeight);
  const levelInv = 1 / engine.getHardwareScalingLevel();
  x = x * levelInv - vx;
  y = y * levelInv - (renderHeight - vy - height);
  result.update(x, y, width, height, world ? world : Matrix.IdentityReadOnly, cameraViewSpace ? Matrix.IdentityReadOnly : camera.getViewMatrix(), camera.getProjectionMatrix(), enableDistantPicking);
  return this;
};
Scene.prototype.createPickingRayInCameraSpace = function(x, y, camera) {
  const result = Ray.Zero();
  this.createPickingRayInCameraSpaceToRef(x, y, result, camera);
  return result;
};
Scene.prototype.createPickingRayInCameraSpaceToRef = function(x, y, result, camera) {
  if (!PickingInfo) {
    return this;
  }
  const engine = this.getEngine();
  if (!camera && !(camera = this.activeCamera)) {
    throw new Error("Active camera not set");
  }
  const cameraViewport = camera.viewport;
  const renderHeight = engine.getRenderHeight();
  const { x: vx, y: vy, width, height } = cameraViewport.toGlobal(engine.getRenderWidth(), renderHeight);
  const identity = Matrix.Identity();
  const levelInv = 1 / engine.getHardwareScalingLevel();
  x = x * levelInv - vx;
  y = y * levelInv - (renderHeight - vy - height);
  result.update(x, y, width, height, identity, identity, camera.getProjectionMatrix());
  return this;
};
Scene.prototype._internalPickForMesh = function(pickingInfo, rayFunction, mesh, world, fastCheck, onlyBoundingInfo, trianglePredicate, skipBoundingInfo) {
  const ray = rayFunction(world, mesh.enableDistantPicking);
  const result = mesh.intersects(ray, fastCheck, trianglePredicate, onlyBoundingInfo, world, skipBoundingInfo);
  if (!result || !result.hit) {
    return null;
  }
  if (!fastCheck && pickingInfo != null && result.distance >= pickingInfo.distance) {
    return null;
  }
  return result;
};
Scene.prototype._internalPick = function(rayFunction, predicate, fastCheck, onlyBoundingInfo, trianglePredicate) {
  let pickingInfo = null;
  const computeWorldMatrixForCamera = !!(this.activeCameras && this.activeCameras.length > 1 && this.cameraToUseForPointers !== this.activeCamera);
  const currentCamera = this.cameraToUseForPointers || this.activeCamera;
  for (let meshIndex = 0; meshIndex < this.meshes.length; meshIndex++) {
    const mesh = this.meshes[meshIndex];
    if (predicate) {
      if (!predicate(mesh)) {
        continue;
      }
    } else if (!mesh.isEnabled() || !mesh.isVisible || !mesh.isPickable) {
      continue;
    }
    const forceCompute = computeWorldMatrixForCamera && mesh.isWorldMatrixCameraDependent();
    const world = mesh.computeWorldMatrix(forceCompute, currentCamera);
    if (mesh.hasThinInstances && mesh.thinInstanceEnablePicking) {
      const result = this._internalPickForMesh(pickingInfo, rayFunction, mesh, world, true, true, trianglePredicate);
      if (result) {
        if (onlyBoundingInfo) {
          return result;
        }
        const tmpMatrix = TmpVectors.Matrix[1];
        const thinMatrices = mesh.thinInstanceGetWorldMatrices();
        for (let index = 0; index < thinMatrices.length; index++) {
          const thinMatrix = thinMatrices[index];
          thinMatrix.multiplyToRef(world, tmpMatrix);
          const result2 = this._internalPickForMesh(pickingInfo, rayFunction, mesh, tmpMatrix, fastCheck, onlyBoundingInfo, trianglePredicate, true);
          if (result2) {
            pickingInfo = result2;
            pickingInfo.thinInstanceIndex = index;
            if (fastCheck) {
              return pickingInfo;
            }
          }
        }
      }
    } else {
      const result = this._internalPickForMesh(pickingInfo, rayFunction, mesh, world, fastCheck, onlyBoundingInfo, trianglePredicate);
      if (result) {
        pickingInfo = result;
        if (fastCheck) {
          return pickingInfo;
        }
      }
    }
  }
  return pickingInfo || new PickingInfo();
};
Scene.prototype._internalMultiPick = function(rayFunction, predicate, trianglePredicate) {
  if (!PickingInfo) {
    return null;
  }
  const pickingInfos = [];
  const computeWorldMatrixForCamera = !!(this.activeCameras && this.activeCameras.length > 1 && this.cameraToUseForPointers !== this.activeCamera);
  const currentCamera = this.cameraToUseForPointers || this.activeCamera;
  for (let meshIndex = 0; meshIndex < this.meshes.length; meshIndex++) {
    const mesh = this.meshes[meshIndex];
    if (predicate) {
      if (!predicate(mesh)) {
        continue;
      }
    } else if (!mesh.isEnabled() || !mesh.isVisible || !mesh.isPickable) {
      continue;
    }
    const forceCompute = computeWorldMatrixForCamera && mesh.isWorldMatrixCameraDependent();
    const world = mesh.computeWorldMatrix(forceCompute, currentCamera);
    if (mesh.hasThinInstances && mesh.thinInstanceEnablePicking) {
      const result = this._internalPickForMesh(null, rayFunction, mesh, world, true, true, trianglePredicate);
      if (result) {
        const tmpMatrix = TmpVectors.Matrix[1];
        const thinMatrices = mesh.thinInstanceGetWorldMatrices();
        for (let index = 0; index < thinMatrices.length; index++) {
          const thinMatrix = thinMatrices[index];
          thinMatrix.multiplyToRef(world, tmpMatrix);
          const result2 = this._internalPickForMesh(null, rayFunction, mesh, tmpMatrix, false, false, trianglePredicate, true);
          if (result2) {
            result2.thinInstanceIndex = index;
            pickingInfos.push(result2);
          }
        }
      }
    } else {
      const result = this._internalPickForMesh(null, rayFunction, mesh, world, false, false, trianglePredicate);
      if (result) {
        pickingInfos.push(result);
      }
    }
  }
  return pickingInfos;
};
Scene.prototype.pickWithBoundingInfo = function(x, y, predicate, fastCheck, camera) {
  if (!PickingInfo) {
    return null;
  }
  const result = this._internalPick((world) => {
    if (!this._tempPickingRay) {
      this._tempPickingRay = Ray.Zero();
    }
    this.createPickingRayToRef(x, y, world, this._tempPickingRay, camera || null);
    return this._tempPickingRay;
  }, predicate, fastCheck, true);
  if (result) {
    result.ray = this.createPickingRay(x, y, Matrix.Identity(), camera || null);
  }
  return result;
};
Object.defineProperty(Scene.prototype, "_pickingAvailable", {
  get: () => true,
  enumerable: false,
  configurable: false
});
Scene.prototype.pick = function(x, y, predicate, fastCheck, camera, trianglePredicate, _enableDistantPicking = false) {
  const result = this._internalPick((world, enableDistantPicking) => {
    if (!this._tempPickingRay) {
      this._tempPickingRay = Ray.Zero();
    }
    this.createPickingRayToRef(x, y, world, this._tempPickingRay, camera || null, false, enableDistantPicking);
    return this._tempPickingRay;
  }, predicate, fastCheck, false, trianglePredicate);
  if (result) {
    result.ray = this.createPickingRay(x, y, Matrix.Identity(), camera || null);
  }
  return result;
};
Scene.prototype.pickWithRay = function(ray, predicate, fastCheck, trianglePredicate) {
  const result = this._internalPick((world) => {
    if (!this._pickWithRayInverseMatrix) {
      this._pickWithRayInverseMatrix = Matrix.Identity();
    }
    world.invertToRef(this._pickWithRayInverseMatrix);
    if (!this._cachedRayForTransform) {
      this._cachedRayForTransform = Ray.Zero();
    }
    Ray.TransformToRef(ray, this._pickWithRayInverseMatrix, this._cachedRayForTransform);
    return this._cachedRayForTransform;
  }, predicate, fastCheck, false, trianglePredicate);
  if (result) {
    result.ray = ray;
  }
  return result;
};
Scene.prototype.multiPick = function(x, y, predicate, camera, trianglePredicate) {
  return this._internalMultiPick((world) => this.createPickingRay(x, y, world, camera || null), predicate, trianglePredicate);
};
Scene.prototype.multiPickWithRay = function(ray, predicate, trianglePredicate) {
  return this._internalMultiPick((world) => {
    if (!this._pickWithRayInverseMatrix) {
      this._pickWithRayInverseMatrix = Matrix.Identity();
    }
    world.invertToRef(this._pickWithRayInverseMatrix);
    if (!this._cachedRayForTransform) {
      this._cachedRayForTransform = Ray.Zero();
    }
    Ray.TransformToRef(ray, this._pickWithRayInverseMatrix, this._cachedRayForTransform);
    return this._cachedRayForTransform;
  }, predicate, trianglePredicate);
};
Camera.prototype.getForwardRay = function(length4 = 100, transform, origin) {
  return this.getForwardRayToRef(new Ray(Vector3.Zero(), Vector3.Zero(), length4), length4, transform, origin);
};
Camera.prototype.getForwardRayToRef = function(refRay, length4 = 100, transform, origin) {
  if (!transform) {
    transform = this.getWorldMatrix();
  }
  refRay.length = length4;
  if (origin) {
    refRay.origin.copyFrom(origin);
  } else {
    refRay.origin.copyFrom(this.position);
  }
  const forward = TmpVectors.Vector3[2];
  forward.set(0, 0, this._scene.useRightHandedSystem ? -1 : 1);
  const worldForward = TmpVectors.Vector3[3];
  Vector3.TransformNormalToRef(forward, transform, worldForward);
  Vector3.NormalizeToRef(worldForward, refRay.direction);
  return refRay;
};

// ../../node_modules/@babylonjs/core/Culling/Octrees/octreeSceneComponent.js
Scene.prototype.createOrUpdateSelectionOctree = function(maxCapacity = 64, maxDepth = 2) {
  let component = this._getComponent(SceneComponentConstants.NAME_OCTREE);
  if (!component) {
    component = new OctreeSceneComponent(this);
    this._addComponent(component);
  }
  if (!this._selectionOctree) {
    this._selectionOctree = new Octree(Octree.CreationFuncForMeshes, maxCapacity, maxDepth);
  }
  const worldExtends = this.getWorldExtends();
  this._selectionOctree.update(worldExtends.min, worldExtends.max, this.meshes);
  return this._selectionOctree;
};
Object.defineProperty(Scene.prototype, "selectionOctree", {
  get: function() {
    return this._selectionOctree;
  },
  enumerable: true,
  configurable: true
});
AbstractMesh.prototype.createOrUpdateSubmeshesOctree = function(maxCapacity = 64, maxDepth = 2) {
  const scene = this.getScene();
  let component = scene._getComponent(SceneComponentConstants.NAME_OCTREE);
  if (!component) {
    component = new OctreeSceneComponent(scene);
    scene._addComponent(component);
  }
  if (!this._submeshesOctree) {
    this._submeshesOctree = new Octree(Octree.CreationFuncForSubMeshes, maxCapacity, maxDepth);
  }
  this.computeWorldMatrix(true);
  const boundingInfo = this.getBoundingInfo();
  const bbox = boundingInfo.boundingBox;
  this._submeshesOctree.update(bbox.minimumWorld, bbox.maximumWorld, this.subMeshes);
  return this._submeshesOctree;
};
var OctreeSceneComponent = class {
  /**
   * Creates a new instance of the component for the given scene
   * @param scene Defines the scene to register the component in
   */
  constructor(scene) {
    this.name = SceneComponentConstants.NAME_OCTREE;
    this.checksIsEnabled = true;
    this._tempRay = new Ray(Vector3.Zero(), new Vector3(1, 1, 1));
    scene = scene || EngineStore.LastCreatedScene;
    if (!scene) {
      return;
    }
    this.scene = scene;
    this.scene.getActiveMeshCandidates = () => this.getActiveMeshCandidates();
    this.scene.getActiveSubMeshCandidates = (mesh) => this.getActiveSubMeshCandidates(mesh);
    this.scene.getCollidingSubMeshCandidates = (mesh, collider) => this.getCollidingSubMeshCandidates(mesh, collider);
    this.scene.getIntersectingSubMeshCandidates = (mesh, localRay) => this.getIntersectingSubMeshCandidates(mesh, localRay);
  }
  /**
   * Registers the component in a given scene
   */
  register() {
    this.scene.onMeshRemovedObservable.add((mesh) => {
      const sceneOctree = this.scene.selectionOctree;
      if (sceneOctree !== void 0 && sceneOctree !== null) {
        const index = sceneOctree.dynamicContent.indexOf(mesh);
        if (index !== -1) {
          sceneOctree.dynamicContent.splice(index, 1);
        }
      }
    });
    this.scene.onMeshImportedObservable.add((mesh) => {
      const sceneOctree = this.scene.selectionOctree;
      if (sceneOctree !== void 0 && sceneOctree !== null) {
        sceneOctree.addMesh(mesh);
      }
    });
  }
  /**
   * Return the list of active meshes
   * @returns the list of active meshes
   */
  getActiveMeshCandidates() {
    return this.scene._selectionOctree?.select(this.scene.frustumPlanes) || this.scene._getDefaultMeshCandidates();
  }
  /**
   * Return the list of active sub meshes
   * @param mesh The mesh to get the candidates sub meshes from
   * @returns the list of active sub meshes
   */
  getActiveSubMeshCandidates(mesh) {
    if (mesh._submeshesOctree && mesh.useOctreeForRenderingSelection) {
      const intersections = mesh._submeshesOctree.select(this.scene.frustumPlanes);
      return intersections;
    }
    return this.scene._getDefaultSubMeshCandidates(mesh);
  }
  /**
   * Return the list of sub meshes intersecting with a given local ray
   * @param mesh defines the mesh to find the submesh for
   * @param localRay defines the ray in local space
   * @returns the list of intersecting sub meshes
   */
  getIntersectingSubMeshCandidates(mesh, localRay) {
    if (mesh._submeshesOctree && mesh.useOctreeForPicking) {
      Ray.TransformToRef(localRay, mesh.getWorldMatrix(), this._tempRay);
      const intersections = mesh._submeshesOctree.intersectsRay(this._tempRay);
      return intersections;
    }
    return this.scene._getDefaultSubMeshCandidates(mesh);
  }
  /**
   * Return the list of sub meshes colliding with a collider
   * @param mesh defines the mesh to find the submesh for
   * @param collider defines the collider to evaluate the collision against
   * @returns the list of colliding sub meshes
   */
  getCollidingSubMeshCandidates(mesh, collider) {
    if (mesh._submeshesOctree && mesh.useOctreeForCollisions) {
      const radius = collider._velocityWorldLength + Math.max(collider._radius.x, collider._radius.y, collider._radius.z);
      const intersections = mesh._submeshesOctree.intersects(collider._basePointWorld, radius);
      return intersections;
    }
    return this.scene._getDefaultSubMeshCandidates(mesh);
  }
  /**
   * Rebuilds the elements related to this component in case of
   * context lost for instance.
   */
  rebuild() {
  }
  /**
   * Disposes the component and the associated resources.
   */
  dispose() {
  }
};

// ../../node_modules/noa-engine/src/lib/sceneOctreeManager.js
var SceneOctreeManager = class {
  /** @internal */
  constructor(rendering, blockSize) {
    var scene = rendering.scene;
    scene._addComponent(new OctreeSceneComponent(scene));
    var octreeBlock = "noa_octree_block";
    var inDynamicList = "noa_in_dynamic_list";
    var inOctreeBlock = "noa_in_octree_block";
    var octree = new Octree(NOP);
    scene._selectionOctree = octree;
    octree.blocks = [];
    var octBlocksHash = {};
    this.rebase = (offset) => {
      recurseRebaseBlocks(octree, offset);
    };
    this.addMesh = (mesh, isStatic, pos, chunk) => {
      if (!mesh.metadata) mesh.metadata = {};
      if (!isStatic) {
        if (mesh.metadata[inDynamicList]) return;
        octree.dynamicContent.push(mesh);
        mesh.metadata[inDynamicList] = true;
        return;
      }
      var ci = Math.floor(pos[0] / bs);
      var cj = Math.floor(pos[1] / bs);
      var ck = Math.floor(pos[2] / bs);
      var mapKey = locationHasher(ci, cj, ck);
      var block = octBlocksHash[mapKey];
      if (!block) {
        var gloc = [ci * bs, cj * bs, ck * bs];
        var loc = [0, 0, 0];
        rendering.noa.globalToLocal(gloc, null, loc);
        block = makeOctreeBlock(loc, bs);
        octree.blocks.push(block);
        octBlocksHash[mapKey] = block;
        block._noaMapKey = mapKey;
      }
      block.entries.push(mesh);
      mesh.metadata[octreeBlock] = block;
      mesh.metadata[inOctreeBlock] = true;
      mesh.alwaysSelectAsActiveMesh = true;
    };
    this.removeMesh = (mesh) => {
      if (!mesh.metadata) return;
      if (mesh.metadata[inDynamicList]) {
        removeUnorderedListItem(octree.dynamicContent, mesh);
        mesh.metadata[inDynamicList] = false;
      }
      if (mesh.metadata[inOctreeBlock]) {
        var block = mesh.metadata[octreeBlock];
        if (block && block.entries) {
          removeUnorderedListItem(block.entries, mesh);
          if (block.entries.length === 0) {
            delete octBlocksHash[block._noaMapKey];
            removeUnorderedListItem(octree.blocks, block);
          }
        }
        mesh.metadata[octreeBlock] = null;
        mesh.metadata[inOctreeBlock] = false;
      }
    };
    this.setMeshVisibility = (mesh, visible = false) => {
      if (mesh.metadata[octreeBlock]) {
        if (mesh.metadata[inOctreeBlock] === visible) return;
        var block = mesh.metadata[octreeBlock];
        if (block && block.entries) {
          if (visible) {
            block.entries.push(mesh);
          } else {
            removeUnorderedListItem(block.entries, mesh);
          }
        }
        mesh.metadata[inOctreeBlock] = visible;
      } else {
        if (mesh.metadata[inDynamicList] === visible) return;
        if (visible) {
          octree.dynamicContent.push(mesh);
        } else {
          removeUnorderedListItem(octree.dynamicContent, mesh);
        }
        mesh.metadata[inDynamicList] = visible;
      }
    };
    var NOP = () => {
    };
    var bs = blockSize * rendering.noa.world._chunkSize;
    var recurseRebaseBlocks = (parent, offset) => {
      parent.blocks.forEach((child) => {
        child.minPoint.subtractInPlace(offset);
        child.maxPoint.subtractInPlace(offset);
        child._boundingVectors.forEach((v) => v.subtractInPlace(offset));
        if (child.blocks) recurseRebaseBlocks(child, offset);
      });
    };
    var makeOctreeBlock = (minPt, size) => {
      var min2 = new Vector3(minPt[0], minPt[1], minPt[2]);
      var max2 = new Vector3(minPt[0] + size, minPt[1] + size, minPt[2] + size);
      return new OctreeBlock(min2, max2, void 0, void 0, void 0, NOP);
    };
  }
};

// ../../node_modules/@babylonjs/core/Cameras/targetCamera.js
Node.AddNodeConstructor("TargetCamera", (name66, scene) => {
  return () => new TargetCamera(name66, Vector3.Zero(), scene);
});
var TargetCamera = class _TargetCamera extends Camera {
  /**
   * Instantiates a target camera that takes a mesh or position as a target and continues to look at it while it moves.
   * This is the base of the follow, arc rotate cameras and Free camera
   * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras
   * @param name Defines the name of the camera in the scene
   * @param position Defines the start position of the camera in the scene
   * @param scene Defines the scene the camera belongs to
   * @param setActiveOnSceneIfNoneActive Defines whether the camera should be marked as active if not other active cameras have been defined
   */
  constructor(name66, position, scene, setActiveOnSceneIfNoneActive = true) {
    super(name66, position, scene, setActiveOnSceneIfNoneActive);
    this._tmpUpVector = Vector3.Zero();
    this._tmpTargetVector = Vector3.Zero();
    this.cameraDirection = new Vector3(0, 0, 0);
    this.cameraRotation = new Vector2(0, 0);
    this.ignoreParentScaling = false;
    this.updateUpVectorFromRotation = false;
    this._tmpQuaternion = new Quaternion();
    this.rotation = new Vector3(0, 0, 0);
    this.speed = 2;
    this.noRotationConstraint = false;
    this.invertRotation = false;
    this.inverseRotationSpeed = 0.2;
    this.lockedTarget = null;
    this._currentTarget = Vector3.Zero();
    this._initialFocalDistance = 1;
    this._viewMatrix = Matrix.Zero();
    this._camMatrix = Matrix.Zero();
    this._cameraTransformMatrix = Matrix.Zero();
    this._cameraRotationMatrix = Matrix.Zero();
    this._referencePoint = new Vector3(0, 0, 1);
    this._transformedReferencePoint = Vector3.Zero();
    this._deferredPositionUpdate = new Vector3();
    this._deferredRotationQuaternionUpdate = new Quaternion();
    this._deferredRotationUpdate = new Vector3();
    this._deferredUpdated = false;
    this._deferOnly = false;
    this._defaultUp = Vector3.Up();
    this._cachedRotationZ = 0;
    this._cachedQuaternionRotationZ = 0;
  }
  /**
   * Gets the position in front of the camera at a given distance.
   * @param distance The distance from the camera we want the position to be
   * @returns the position
   */
  getFrontPosition(distance2) {
    this.getWorldMatrix();
    const direction = this.getTarget().subtract(this.position);
    direction.normalize();
    direction.scaleInPlace(distance2);
    return this.globalPosition.add(direction);
  }
  /** @internal */
  _getLockedTargetPosition() {
    if (!this.lockedTarget) {
      return null;
    }
    if (this.lockedTarget.absolutePosition) {
      const lockedTarget = this.lockedTarget;
      const m = lockedTarget.computeWorldMatrix();
      m.getTranslationToRef(lockedTarget.absolutePosition);
    }
    return this.lockedTarget.absolutePosition || this.lockedTarget;
  }
  /**
   * Store current camera state of the camera (fov, position, rotation, etc..)
   * @returns the camera
   */
  storeState() {
    this._storedPosition = this.position.clone();
    this._storedRotation = this.rotation.clone();
    if (this.rotationQuaternion) {
      this._storedRotationQuaternion = this.rotationQuaternion.clone();
    }
    return super.storeState();
  }
  /**
   * Restored camera state. You must call storeState() first
   * @returns whether it was successful or not
   * @internal
   */
  _restoreStateValues() {
    if (!super._restoreStateValues()) {
      return false;
    }
    this.position = this._storedPosition.clone();
    this.rotation = this._storedRotation.clone();
    if (this.rotationQuaternion) {
      this.rotationQuaternion = this._storedRotationQuaternion.clone();
    }
    this.cameraDirection.copyFromFloats(0, 0, 0);
    this.cameraRotation.copyFromFloats(0, 0);
    return true;
  }
  /** @internal */
  _initCache() {
    super._initCache();
    this._cache.lockedTarget = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
    this._cache.rotation = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
    this._cache.rotationQuaternion = new Quaternion(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
  }
  /**
   * @internal
   */
  _updateCache(ignoreParentClass) {
    if (!ignoreParentClass) {
      super._updateCache();
    }
    const lockedTargetPosition = this._getLockedTargetPosition();
    if (!lockedTargetPosition) {
      this._cache.lockedTarget = null;
    } else {
      if (!this._cache.lockedTarget) {
        this._cache.lockedTarget = lockedTargetPosition.clone();
      } else {
        this._cache.lockedTarget.copyFrom(lockedTargetPosition);
      }
    }
    this._cache.rotation.copyFrom(this.rotation);
    if (this.rotationQuaternion) {
      this._cache.rotationQuaternion.copyFrom(this.rotationQuaternion);
    }
  }
  // Synchronized
  /** @internal */
  _isSynchronizedViewMatrix() {
    if (!super._isSynchronizedViewMatrix()) {
      return false;
    }
    const lockedTargetPosition = this._getLockedTargetPosition();
    return (this._cache.lockedTarget ? this._cache.lockedTarget.equals(lockedTargetPosition) : !lockedTargetPosition) && (this.rotationQuaternion ? this.rotationQuaternion.equals(this._cache.rotationQuaternion) : this._cache.rotation.equals(this.rotation));
  }
  // Methods
  /** @internal */
  _computeLocalCameraSpeed() {
    const engine = this.getEngine();
    return this.speed * Math.sqrt(engine.getDeltaTime() / (engine.getFps() * 100));
  }
  // Target
  /**
   * Defines the target the camera should look at.
   * @param target Defines the new target as a Vector
   */
  setTarget(target) {
    this.upVector.normalize();
    this._initialFocalDistance = target.subtract(this.position).length();
    if (this.position.z === target.z) {
      this.position.z += Epsilon;
    }
    this._referencePoint.normalize().scaleInPlace(this._initialFocalDistance);
    Matrix.LookAtLHToRef(this.position, target, this._defaultUp, this._camMatrix);
    this._camMatrix.invert();
    this.rotation.x = Math.atan(this._camMatrix.m[6] / this._camMatrix.m[10]);
    const vDir = target.subtract(this.position);
    if (vDir.x >= 0) {
      this.rotation.y = -Math.atan(vDir.z / vDir.x) + Math.PI / 2;
    } else {
      this.rotation.y = -Math.atan(vDir.z / vDir.x) - Math.PI / 2;
    }
    this.rotation.z = 0;
    if (isNaN(this.rotation.x)) {
      this.rotation.x = 0;
    }
    if (isNaN(this.rotation.y)) {
      this.rotation.y = 0;
    }
    if (isNaN(this.rotation.z)) {
      this.rotation.z = 0;
    }
    if (this.rotationQuaternion) {
      Quaternion.RotationYawPitchRollToRef(this.rotation.y, this.rotation.x, this.rotation.z, this.rotationQuaternion);
    }
  }
  /**
   * Defines the target point of the camera.
   * The camera looks towards it form the radius distance.
   */
  get target() {
    return this.getTarget();
  }
  set target(value) {
    this.setTarget(value);
  }
  /**
   * Return the current target position of the camera. This value is expressed in local space.
   * @returns the target position
   */
  getTarget() {
    return this._currentTarget;
  }
  /** @internal */
  _decideIfNeedsToMove() {
    return Math.abs(this.cameraDirection.x) > 0 || Math.abs(this.cameraDirection.y) > 0 || Math.abs(this.cameraDirection.z) > 0;
  }
  /** @internal */
  _updatePosition() {
    if (this.parent) {
      this.parent.getWorldMatrix().invertToRef(TmpVectors.Matrix[0]);
      Vector3.TransformNormalToRef(this.cameraDirection, TmpVectors.Matrix[0], TmpVectors.Vector3[0]);
      this._deferredPositionUpdate.addInPlace(TmpVectors.Vector3[0]);
      if (!this._deferOnly) {
        this.position.copyFrom(this._deferredPositionUpdate);
      } else {
        this._deferredUpdated = true;
      }
      return;
    }
    this._deferredPositionUpdate.addInPlace(this.cameraDirection);
    if (!this._deferOnly) {
      this.position.copyFrom(this._deferredPositionUpdate);
    } else {
      this._deferredUpdated = true;
    }
  }
  /** @internal */
  _checkInputs() {
    const directionMultiplier = this.invertRotation ? -this.inverseRotationSpeed : 1;
    const needToMove = this._decideIfNeedsToMove();
    const needToRotate = this.cameraRotation.x || this.cameraRotation.y;
    this._deferredUpdated = false;
    this._deferredRotationUpdate.copyFrom(this.rotation);
    this._deferredPositionUpdate.copyFrom(this.position);
    if (this.rotationQuaternion) {
      this._deferredRotationQuaternionUpdate.copyFrom(this.rotationQuaternion);
    }
    if (needToMove) {
      this._updatePosition();
    }
    if (needToRotate) {
      if (this.rotationQuaternion) {
        this.rotationQuaternion.toEulerAnglesToRef(this._deferredRotationUpdate);
      }
      this._deferredRotationUpdate.x += this.cameraRotation.x * directionMultiplier;
      this._deferredRotationUpdate.y += this.cameraRotation.y * directionMultiplier;
      if (!this.noRotationConstraint) {
        const limit = 1.570796;
        if (this._deferredRotationUpdate.x > limit) {
          this._deferredRotationUpdate.x = limit;
        }
        if (this._deferredRotationUpdate.x < -limit) {
          this._deferredRotationUpdate.x = -limit;
        }
      }
      if (!this._deferOnly) {
        this.rotation.copyFrom(this._deferredRotationUpdate);
      } else {
        this._deferredUpdated = true;
      }
      if (this.rotationQuaternion) {
        const len2 = this._deferredRotationUpdate.lengthSquared();
        if (len2) {
          Quaternion.RotationYawPitchRollToRef(this._deferredRotationUpdate.y, this._deferredRotationUpdate.x, this._deferredRotationUpdate.z, this._deferredRotationQuaternionUpdate);
          if (!this._deferOnly) {
            this.rotationQuaternion.copyFrom(this._deferredRotationQuaternionUpdate);
          } else {
            this._deferredUpdated = true;
          }
        }
      }
    }
    if (needToMove) {
      if (Math.abs(this.cameraDirection.x) < this.speed * Epsilon) {
        this.cameraDirection.x = 0;
      }
      if (Math.abs(this.cameraDirection.y) < this.speed * Epsilon) {
        this.cameraDirection.y = 0;
      }
      if (Math.abs(this.cameraDirection.z) < this.speed * Epsilon) {
        this.cameraDirection.z = 0;
      }
      this.cameraDirection.scaleInPlace(this.inertia);
    }
    if (needToRotate) {
      if (Math.abs(this.cameraRotation.x) < this.speed * Epsilon) {
        this.cameraRotation.x = 0;
      }
      if (Math.abs(this.cameraRotation.y) < this.speed * Epsilon) {
        this.cameraRotation.y = 0;
      }
      this.cameraRotation.scaleInPlace(this.inertia);
    }
    super._checkInputs();
  }
  _updateCameraRotationMatrix() {
    if (this.rotationQuaternion) {
      this.rotationQuaternion.toRotationMatrix(this._cameraRotationMatrix);
    } else {
      Matrix.RotationYawPitchRollToRef(this.rotation.y, this.rotation.x, this.rotation.z, this._cameraRotationMatrix);
    }
  }
  /**
   * Update the up vector to apply the rotation of the camera (So if you changed the camera rotation.z this will let you update the up vector as well)
   * @returns the current camera
   */
  _rotateUpVectorWithCameraRotationMatrix() {
    Vector3.TransformNormalToRef(this._defaultUp, this._cameraRotationMatrix, this.upVector);
    return this;
  }
  /** @internal */
  _getViewMatrix() {
    if (this.lockedTarget) {
      this.setTarget(this._getLockedTargetPosition());
    }
    this._updateCameraRotationMatrix();
    if (this.rotationQuaternion && this._cachedQuaternionRotationZ != this.rotationQuaternion.z) {
      this._rotateUpVectorWithCameraRotationMatrix();
      this._cachedQuaternionRotationZ = this.rotationQuaternion.z;
    } else if (this._cachedRotationZ !== this.rotation.z) {
      this._rotateUpVectorWithCameraRotationMatrix();
      this._cachedRotationZ = this.rotation.z;
    }
    Vector3.TransformCoordinatesToRef(this._referencePoint, this._cameraRotationMatrix, this._transformedReferencePoint);
    this.position.addToRef(this._transformedReferencePoint, this._currentTarget);
    if (this.updateUpVectorFromRotation) {
      if (this.rotationQuaternion) {
        Axis.Y.rotateByQuaternionToRef(this.rotationQuaternion, this.upVector);
      } else {
        Quaternion.FromEulerVectorToRef(this.rotation, this._tmpQuaternion);
        Axis.Y.rotateByQuaternionToRef(this._tmpQuaternion, this.upVector);
      }
    }
    this._computeViewMatrix(this.position, this._currentTarget, this.upVector);
    return this._viewMatrix;
  }
  _computeViewMatrix(position, target, up) {
    if (this.ignoreParentScaling) {
      if (this.parent) {
        const parentWorldMatrix = this.parent.getWorldMatrix();
        Vector3.TransformCoordinatesToRef(position, parentWorldMatrix, this._globalPosition);
        Vector3.TransformCoordinatesToRef(target, parentWorldMatrix, this._tmpTargetVector);
        Vector3.TransformNormalToRef(up, parentWorldMatrix, this._tmpUpVector);
        this._markSyncedWithParent();
      } else {
        this._globalPosition.copyFrom(position);
        this._tmpTargetVector.copyFrom(target);
        this._tmpUpVector.copyFrom(up);
      }
      if (this.getScene().useRightHandedSystem) {
        Matrix.LookAtRHToRef(this._globalPosition, this._tmpTargetVector, this._tmpUpVector, this._viewMatrix);
      } else {
        Matrix.LookAtLHToRef(this._globalPosition, this._tmpTargetVector, this._tmpUpVector, this._viewMatrix);
      }
      return;
    }
    if (this.getScene().useRightHandedSystem) {
      Matrix.LookAtRHToRef(position, target, up, this._viewMatrix);
    } else {
      Matrix.LookAtLHToRef(position, target, up, this._viewMatrix);
    }
    if (this.parent) {
      const parentWorldMatrix = this.parent.getWorldMatrix();
      this._viewMatrix.invert();
      this._viewMatrix.multiplyToRef(parentWorldMatrix, this._viewMatrix);
      this._viewMatrix.getTranslationToRef(this._globalPosition);
      this._viewMatrix.invert();
      this._markSyncedWithParent();
    } else {
      this._globalPosition.copyFrom(position);
    }
  }
  /**
   * @internal
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  createRigCamera(name66, cameraIndex) {
    if (this.cameraRigMode !== Camera.RIG_MODE_NONE) {
      const rigCamera = new _TargetCamera(name66, this.position.clone(), this.getScene());
      rigCamera.isRigCamera = true;
      rigCamera.rigParent = this;
      if (this.cameraRigMode === Camera.RIG_MODE_VR) {
        if (!this.rotationQuaternion) {
          this.rotationQuaternion = new Quaternion();
        }
        rigCamera._cameraRigParams = {};
        rigCamera.rotationQuaternion = new Quaternion();
      }
      rigCamera.mode = this.mode;
      rigCamera.orthoLeft = this.orthoLeft;
      rigCamera.orthoRight = this.orthoRight;
      rigCamera.orthoTop = this.orthoTop;
      rigCamera.orthoBottom = this.orthoBottom;
      return rigCamera;
    }
    return null;
  }
  /**
   * @internal
   */
  _updateRigCameras() {
    const camLeft = this._rigCameras[0];
    const camRight = this._rigCameras[1];
    this.computeWorldMatrix();
    switch (this.cameraRigMode) {
      case Camera.RIG_MODE_STEREOSCOPIC_ANAGLYPH:
      case Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL:
      case Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED:
      case Camera.RIG_MODE_STEREOSCOPIC_OVERUNDER:
      case Camera.RIG_MODE_STEREOSCOPIC_INTERLACED: {
        const leftSign = this.cameraRigMode === Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED ? 1 : -1;
        const rightSign = this.cameraRigMode === Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED ? -1 : 1;
        this._getRigCamPositionAndTarget(this._cameraRigParams.stereoHalfAngle * leftSign, camLeft);
        this._getRigCamPositionAndTarget(this._cameraRigParams.stereoHalfAngle * rightSign, camRight);
        break;
      }
      case Camera.RIG_MODE_VR:
        if (camLeft.rotationQuaternion) {
          camLeft.rotationQuaternion.copyFrom(this.rotationQuaternion);
          camRight.rotationQuaternion.copyFrom(this.rotationQuaternion);
        } else {
          camLeft.rotation.copyFrom(this.rotation);
          camRight.rotation.copyFrom(this.rotation);
        }
        camLeft.position.copyFrom(this.position);
        camRight.position.copyFrom(this.position);
        break;
    }
    super._updateRigCameras();
  }
  _getRigCamPositionAndTarget(halfSpace, rigCamera) {
    const target = this.getTarget();
    target.subtractToRef(this.position, _TargetCamera._TargetFocalPoint);
    _TargetCamera._TargetFocalPoint.normalize().scaleInPlace(this._initialFocalDistance);
    const newFocalTarget = _TargetCamera._TargetFocalPoint.addInPlace(this.position);
    Matrix.TranslationToRef(-newFocalTarget.x, -newFocalTarget.y, -newFocalTarget.z, _TargetCamera._TargetTransformMatrix);
    _TargetCamera._TargetTransformMatrix.multiplyToRef(Matrix.RotationAxis(rigCamera.upVector, halfSpace), _TargetCamera._RigCamTransformMatrix);
    Matrix.TranslationToRef(newFocalTarget.x, newFocalTarget.y, newFocalTarget.z, _TargetCamera._TargetTransformMatrix);
    _TargetCamera._RigCamTransformMatrix.multiplyToRef(_TargetCamera._TargetTransformMatrix, _TargetCamera._RigCamTransformMatrix);
    Vector3.TransformCoordinatesToRef(this.position, _TargetCamera._RigCamTransformMatrix, rigCamera.position);
    rigCamera.setTarget(newFocalTarget);
  }
  /**
   * Gets the current object class name.
   * @returns the class name
   */
  getClassName() {
    return "TargetCamera";
  }
};
TargetCamera._RigCamTransformMatrix = new Matrix();
TargetCamera._TargetTransformMatrix = new Matrix();
TargetCamera._TargetFocalPoint = new Vector3();
__decorate([
  serializeAsVector3()
], TargetCamera.prototype, "rotation", void 0);
__decorate([
  serialize()
], TargetCamera.prototype, "speed", void 0);
__decorate([
  serializeAsMeshReference("lockedTargetId")
], TargetCamera.prototype, "lockedTarget", void 0);

// ../../node_modules/@babylonjs/core/Cameras/cameraInputsManager.js
var CameraInputTypes = {};
var CameraInputsManager = class {
  /**
   * Instantiate a new Camera Input Manager.
   * @param camera Defines the camera the input manager belongs to
   */
  constructor(camera) {
    this.attachedToElement = false;
    this.attached = {};
    this.camera = camera;
    this.checkInputs = () => {
    };
  }
  /**
   * Add an input method to a camera
   * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs
   * @param input Camera input method
   */
  add(input) {
    const type = input.getSimpleName();
    if (this.attached[type]) {
      Logger.Warn("camera input of type " + type + " already exists on camera");
      return;
    }
    this.attached[type] = input;
    input.camera = this.camera;
    if (input.checkInputs) {
      this.checkInputs = this._addCheckInputs(input.checkInputs.bind(input));
    }
    if (this.attachedToElement) {
      input.attachControl(this.noPreventDefault);
    }
  }
  /**
   * Remove a specific input method from a camera
   * example: camera.inputs.remove(camera.inputs.attached.mouse);
   * @param inputToRemove camera input method
   */
  remove(inputToRemove) {
    for (const cam in this.attached) {
      const input = this.attached[cam];
      if (input === inputToRemove) {
        input.detachControl();
        input.camera = null;
        delete this.attached[cam];
        this.rebuildInputCheck();
        return;
      }
    }
  }
  /**
   * Remove a specific input type from a camera
   * example: camera.inputs.remove("ArcRotateCameraGamepadInput");
   * @param inputType the type of the input to remove
   */
  removeByType(inputType) {
    for (const cam in this.attached) {
      const input = this.attached[cam];
      if (input.getClassName() === inputType) {
        input.detachControl();
        input.camera = null;
        delete this.attached[cam];
        this.rebuildInputCheck();
      }
    }
  }
  _addCheckInputs(fn) {
    const current = this.checkInputs;
    return () => {
      current();
      fn();
    };
  }
  /**
   * Attach the input controls to the currently attached dom element to listen the events from.
   * @param input Defines the input to attach
   */
  attachInput(input) {
    if (this.attachedToElement) {
      input.attachControl(this.noPreventDefault);
    }
  }
  /**
   * Attach the current manager inputs controls to a specific dom element to listen the events from.
   * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)
   */
  attachElement(noPreventDefault = false) {
    if (this.attachedToElement) {
      return;
    }
    noPreventDefault = Camera.ForceAttachControlToAlwaysPreventDefault ? false : noPreventDefault;
    this.attachedToElement = true;
    this.noPreventDefault = noPreventDefault;
    for (const cam in this.attached) {
      this.attached[cam].attachControl(noPreventDefault);
    }
  }
  /**
   * Detach the current manager inputs controls from a specific dom element.
   * @param disconnect Defines whether the input should be removed from the current list of attached inputs
   */
  detachElement(disconnect = false) {
    for (const cam in this.attached) {
      this.attached[cam].detachControl();
      if (disconnect) {
        this.attached[cam].camera = null;
      }
    }
    this.attachedToElement = false;
  }
  /**
   * Rebuild the dynamic inputCheck function from the current list of
   * defined inputs in the manager.
   */
  rebuildInputCheck() {
    this.checkInputs = () => {
    };
    for (const cam in this.attached) {
      const input = this.attached[cam];
      if (input.checkInputs) {
        this.checkInputs = this._addCheckInputs(input.checkInputs.bind(input));
      }
    }
  }
  /**
   * Remove all attached input methods from a camera
   */
  clear() {
    if (this.attachedToElement) {
      this.detachElement(true);
    }
    this.attached = {};
    this.attachedToElement = false;
    this.checkInputs = () => {
    };
  }
  /**
   * Serialize the current input manager attached to a camera.
   * This ensures than once parsed,
   * the input associated to the camera will be identical to the current ones
   * @param serializedCamera Defines the camera serialization JSON the input serialization should write to
   */
  serialize(serializedCamera) {
    const inputs = {};
    for (const cam in this.attached) {
      const input = this.attached[cam];
      const res = SerializationHelper.Serialize(input);
      inputs[input.getClassName()] = res;
    }
    serializedCamera.inputsmgr = inputs;
  }
  /**
   * Parses an input manager serialized JSON to restore the previous list of inputs
   * and states associated to a camera.
   * @param parsedCamera Defines the JSON to parse
   */
  parse(parsedCamera) {
    const parsedInputs = parsedCamera.inputsmgr;
    if (parsedInputs) {
      this.clear();
      for (const n in parsedInputs) {
        const construct = CameraInputTypes[n];
        if (construct) {
          const parsedinput = parsedInputs[n];
          const input = SerializationHelper.Parse(() => {
            return new construct();
          }, parsedinput, null);
          this.add(input);
        }
      }
    } else {
      for (const n in this.attached) {
        const construct = CameraInputTypes[this.attached[n].getClassName()];
        if (construct) {
          const input = SerializationHelper.Parse(() => {
            return new construct();
          }, parsedCamera, null);
          this.remove(this.attached[n]);
          this.add(input);
        }
      }
    }
  }
};

// ../../node_modules/@babylonjs/core/Cameras/Inputs/freeCameraKeyboardMoveInput.js
var FreeCameraKeyboardMoveInput = class {
  constructor() {
    this.keysUp = [38];
    this.keysUpward = [33];
    this.keysDown = [40];
    this.keysDownward = [34];
    this.keysLeft = [37];
    this.keysRight = [39];
    this.rotationSpeed = 0.5;
    this.keysRotateLeft = [];
    this.keysRotateRight = [];
    this.keysRotateUp = [];
    this.keysRotateDown = [];
    this._keys = new Array();
  }
  /**
   * Attach the input controls to a specific dom element to get the input from.
   * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)
   */
  attachControl(noPreventDefault) {
    noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);
    if (this._onCanvasBlurObserver) {
      return;
    }
    this._scene = this.camera.getScene();
    this._engine = this._scene.getEngine();
    this._onCanvasBlurObserver = this._engine.onCanvasBlurObservable.add(() => {
      this._keys.length = 0;
    });
    this._onKeyboardObserver = this._scene.onKeyboardObservable.add((info) => {
      const evt = info.event;
      if (!evt.metaKey) {
        if (info.type === KeyboardEventTypes.KEYDOWN) {
          if (this.keysUp.indexOf(evt.keyCode) !== -1 || this.keysDown.indexOf(evt.keyCode) !== -1 || this.keysLeft.indexOf(evt.keyCode) !== -1 || this.keysRight.indexOf(evt.keyCode) !== -1 || this.keysUpward.indexOf(evt.keyCode) !== -1 || this.keysDownward.indexOf(evt.keyCode) !== -1 || this.keysRotateLeft.indexOf(evt.keyCode) !== -1 || this.keysRotateRight.indexOf(evt.keyCode) !== -1 || this.keysRotateUp.indexOf(evt.keyCode) !== -1 || this.keysRotateDown.indexOf(evt.keyCode) !== -1) {
            const index = this._keys.indexOf(evt.keyCode);
            if (index === -1) {
              this._keys.push(evt.keyCode);
            }
            if (!noPreventDefault) {
              evt.preventDefault();
            }
          }
        } else {
          if (this.keysUp.indexOf(evt.keyCode) !== -1 || this.keysDown.indexOf(evt.keyCode) !== -1 || this.keysLeft.indexOf(evt.keyCode) !== -1 || this.keysRight.indexOf(evt.keyCode) !== -1 || this.keysUpward.indexOf(evt.keyCode) !== -1 || this.keysDownward.indexOf(evt.keyCode) !== -1 || this.keysRotateLeft.indexOf(evt.keyCode) !== -1 || this.keysRotateRight.indexOf(evt.keyCode) !== -1 || this.keysRotateUp.indexOf(evt.keyCode) !== -1 || this.keysRotateDown.indexOf(evt.keyCode) !== -1) {
            const index = this._keys.indexOf(evt.keyCode);
            if (index >= 0) {
              this._keys.splice(index, 1);
            }
            if (!noPreventDefault) {
              evt.preventDefault();
            }
          }
        }
      }
    });
  }
  /**
   * Detach the current controls from the specified dom element.
   */
  detachControl() {
    if (this._scene) {
      if (this._onKeyboardObserver) {
        this._scene.onKeyboardObservable.remove(this._onKeyboardObserver);
      }
      if (this._onCanvasBlurObserver) {
        this._engine.onCanvasBlurObservable.remove(this._onCanvasBlurObserver);
      }
      this._onKeyboardObserver = null;
      this._onCanvasBlurObserver = null;
    }
    this._keys.length = 0;
  }
  /**
   * Update the current camera state depending on the inputs that have been used this frame.
   * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.
   */
  checkInputs() {
    if (this._onKeyboardObserver) {
      const camera = this.camera;
      for (let index = 0; index < this._keys.length; index++) {
        const keyCode = this._keys[index];
        const speed = camera._computeLocalCameraSpeed();
        if (this.keysLeft.indexOf(keyCode) !== -1) {
          camera._localDirection.copyFromFloats(-speed, 0, 0);
        } else if (this.keysUp.indexOf(keyCode) !== -1) {
          camera._localDirection.copyFromFloats(0, 0, speed);
        } else if (this.keysRight.indexOf(keyCode) !== -1) {
          camera._localDirection.copyFromFloats(speed, 0, 0);
        } else if (this.keysDown.indexOf(keyCode) !== -1) {
          camera._localDirection.copyFromFloats(0, 0, -speed);
        } else if (this.keysUpward.indexOf(keyCode) !== -1) {
          camera._localDirection.copyFromFloats(0, speed, 0);
        } else if (this.keysDownward.indexOf(keyCode) !== -1) {
          camera._localDirection.copyFromFloats(0, -speed, 0);
        } else if (this.keysRotateLeft.indexOf(keyCode) !== -1) {
          camera._localDirection.copyFromFloats(0, 0, 0);
          camera.cameraRotation.y -= this._getLocalRotation();
        } else if (this.keysRotateRight.indexOf(keyCode) !== -1) {
          camera._localDirection.copyFromFloats(0, 0, 0);
          camera.cameraRotation.y += this._getLocalRotation();
        } else if (this.keysRotateUp.indexOf(keyCode) !== -1) {
          camera._localDirection.copyFromFloats(0, 0, 0);
          camera.cameraRotation.x -= this._getLocalRotation();
        } else if (this.keysRotateDown.indexOf(keyCode) !== -1) {
          camera._localDirection.copyFromFloats(0, 0, 0);
          camera.cameraRotation.x += this._getLocalRotation();
        }
        if (camera.getScene().useRightHandedSystem) {
          camera._localDirection.z *= -1;
        }
        camera.getViewMatrix().invertToRef(camera._cameraTransformMatrix);
        Vector3.TransformNormalToRef(camera._localDirection, camera._cameraTransformMatrix, camera._transformedDirection);
        camera.cameraDirection.addInPlace(camera._transformedDirection);
      }
    }
  }
  /**
   * Gets the class name of the current input.
   * @returns the class name
   */
  getClassName() {
    return "FreeCameraKeyboardMoveInput";
  }
  /** @internal */
  _onLostFocus() {
    this._keys.length = 0;
  }
  /**
   * Get the friendly name associated with the input class.
   * @returns the input friendly name
   */
  getSimpleName() {
    return "keyboard";
  }
  _getLocalRotation() {
    const handednessMultiplier = this.camera._calculateHandednessMultiplier();
    const rotation = this.rotationSpeed * this._engine.getDeltaTime() / 1e3 * handednessMultiplier;
    return rotation;
  }
};
__decorate([
  serialize()
], FreeCameraKeyboardMoveInput.prototype, "keysUp", void 0);
__decorate([
  serialize()
], FreeCameraKeyboardMoveInput.prototype, "keysUpward", void 0);
__decorate([
  serialize()
], FreeCameraKeyboardMoveInput.prototype, "keysDown", void 0);
__decorate([
  serialize()
], FreeCameraKeyboardMoveInput.prototype, "keysDownward", void 0);
__decorate([
  serialize()
], FreeCameraKeyboardMoveInput.prototype, "keysLeft", void 0);
__decorate([
  serialize()
], FreeCameraKeyboardMoveInput.prototype, "keysRight", void 0);
__decorate([
  serialize()
], FreeCameraKeyboardMoveInput.prototype, "rotationSpeed", void 0);
__decorate([
  serialize()
], FreeCameraKeyboardMoveInput.prototype, "keysRotateLeft", void 0);
__decorate([
  serialize()
], FreeCameraKeyboardMoveInput.prototype, "keysRotateRight", void 0);
__decorate([
  serialize()
], FreeCameraKeyboardMoveInput.prototype, "keysRotateUp", void 0);
__decorate([
  serialize()
], FreeCameraKeyboardMoveInput.prototype, "keysRotateDown", void 0);
CameraInputTypes["FreeCameraKeyboardMoveInput"] = FreeCameraKeyboardMoveInput;

// ../../node_modules/@babylonjs/core/Cameras/Inputs/freeCameraMouseInput.js
var FreeCameraMouseInput = class {
  /**
   * Manage the mouse inputs to control the movement of a free camera.
   * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs
   * @param touchEnabled Defines if touch is enabled or not
   */
  constructor(touchEnabled = true) {
    this.touchEnabled = touchEnabled;
    this.buttons = [0, 1, 2];
    this.angularSensibility = 2e3;
    this._previousPosition = null;
    this.onPointerMovedObservable = new Observable();
    this._allowCameraRotation = true;
    this._currentActiveButton = -1;
    this._activePointerId = -1;
  }
  /**
   * Attach the input controls to a specific dom element to get the input from.
   * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)
   */
  attachControl(noPreventDefault) {
    noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);
    const engine = this.camera.getEngine();
    const element = engine.getInputElement();
    if (!this._pointerInput) {
      this._pointerInput = (p) => {
        const evt = p.event;
        const isTouch = evt.pointerType === "touch";
        if (!this.touchEnabled && isTouch) {
          return;
        }
        if (p.type !== PointerEventTypes.POINTERMOVE && this.buttons.indexOf(evt.button) === -1) {
          return;
        }
        const srcElement = evt.target;
        if (p.type === PointerEventTypes.POINTERDOWN) {
          if (isTouch && this._activePointerId !== -1 || !isTouch && this._currentActiveButton !== -1) {
            return;
          }
          this._activePointerId = evt.pointerId;
          try {
            srcElement?.setPointerCapture(evt.pointerId);
          } catch (e) {
          }
          if (this._currentActiveButton === -1) {
            this._currentActiveButton = evt.button;
          }
          this._previousPosition = {
            x: evt.clientX,
            y: evt.clientY
          };
          if (!noPreventDefault) {
            evt.preventDefault();
            element && element.focus();
          }
          if (engine.isPointerLock && this._onMouseMove) {
            this._onMouseMove(p.event);
          }
        } else if (p.type === PointerEventTypes.POINTERUP) {
          if (isTouch && this._activePointerId !== evt.pointerId || !isTouch && this._currentActiveButton !== evt.button) {
            return;
          }
          try {
            srcElement?.releasePointerCapture(evt.pointerId);
          } catch (e) {
          }
          this._currentActiveButton = -1;
          this._previousPosition = null;
          if (!noPreventDefault) {
            evt.preventDefault();
          }
          this._activePointerId = -1;
        } else if (p.type === PointerEventTypes.POINTERMOVE && (this._activePointerId === evt.pointerId || !isTouch)) {
          if (engine.isPointerLock && this._onMouseMove) {
            this._onMouseMove(p.event);
          } else if (this._previousPosition) {
            const handednessMultiplier = this.camera._calculateHandednessMultiplier();
            const offsetX = (evt.clientX - this._previousPosition.x) * handednessMultiplier;
            const offsetY = evt.clientY - this._previousPosition.y;
            if (this._allowCameraRotation) {
              this.camera.cameraRotation.y += offsetX / this.angularSensibility;
              this.camera.cameraRotation.x += offsetY / this.angularSensibility;
            }
            this.onPointerMovedObservable.notifyObservers({ offsetX, offsetY });
            this._previousPosition = {
              x: evt.clientX,
              y: evt.clientY
            };
            if (!noPreventDefault) {
              evt.preventDefault();
            }
          }
        }
      };
    }
    this._onMouseMove = (evt) => {
      if (!engine.isPointerLock) {
        return;
      }
      const handednessMultiplier = this.camera._calculateHandednessMultiplier();
      const offsetX = evt.movementX * handednessMultiplier;
      this.camera.cameraRotation.y += offsetX / this.angularSensibility;
      const offsetY = evt.movementY;
      this.camera.cameraRotation.x += offsetY / this.angularSensibility;
      this._previousPosition = null;
      if (!noPreventDefault) {
        evt.preventDefault();
      }
    };
    this._observer = this.camera.getScene()._inputManager._addCameraPointerObserver(this._pointerInput, PointerEventTypes.POINTERDOWN | PointerEventTypes.POINTERUP | PointerEventTypes.POINTERMOVE);
    if (element) {
      this._contextMenuBind = (evt) => this.onContextMenu(evt);
      element.addEventListener("contextmenu", this._contextMenuBind, false);
    }
  }
  /**
   * Called on JS contextmenu event.
   * Override this method to provide functionality.
   * @param evt the context menu event
   */
  onContextMenu(evt) {
    evt.preventDefault();
  }
  /**
   * Detach the current controls from the specified dom element.
   */
  detachControl() {
    if (this._observer) {
      this.camera.getScene()._inputManager._removeCameraPointerObserver(this._observer);
      if (this._contextMenuBind) {
        const engine = this.camera.getEngine();
        const element = engine.getInputElement();
        element && element.removeEventListener("contextmenu", this._contextMenuBind);
      }
      if (this.onPointerMovedObservable) {
        this.onPointerMovedObservable.clear();
      }
      this._observer = null;
      this._onMouseMove = null;
      this._previousPosition = null;
    }
    this._activePointerId = -1;
    this._currentActiveButton = -1;
  }
  /**
   * Gets the class name of the current input.
   * @returns the class name
   */
  getClassName() {
    return "FreeCameraMouseInput";
  }
  /**
   * Get the friendly name associated with the input class.
   * @returns the input friendly name
   */
  getSimpleName() {
    return "mouse";
  }
};
__decorate([
  serialize()
], FreeCameraMouseInput.prototype, "buttons", void 0);
__decorate([
  serialize()
], FreeCameraMouseInput.prototype, "angularSensibility", void 0);
CameraInputTypes["FreeCameraMouseInput"] = FreeCameraMouseInput;

// ../../node_modules/@babylonjs/core/Cameras/Inputs/BaseCameraMouseWheelInput.js
var BaseCameraMouseWheelInput = class {
  constructor() {
    this.wheelPrecisionX = 3;
    this.wheelPrecisionY = 3;
    this.wheelPrecisionZ = 3;
    this.onChangedObservable = new Observable();
    this._wheelDeltaX = 0;
    this._wheelDeltaY = 0;
    this._wheelDeltaZ = 0;
    this._ffMultiplier = 12;
    this._normalize = 120;
  }
  /**
   * Attach the input controls to a specific dom element to get the input from.
   * @param noPreventDefault Defines whether event caught by the controls
   *   should call preventdefault().
   *   (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)
   */
  attachControl(noPreventDefault) {
    noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);
    this._wheel = (pointer) => {
      if (pointer.type !== PointerEventTypes.POINTERWHEEL) {
        return;
      }
      const event = pointer.event;
      const platformScale = event.deltaMode === EventConstants.DOM_DELTA_LINE ? this._ffMultiplier : 1;
      this._wheelDeltaX += this.wheelPrecisionX * platformScale * event.deltaX / this._normalize;
      this._wheelDeltaY -= this.wheelPrecisionY * platformScale * event.deltaY / this._normalize;
      this._wheelDeltaZ += this.wheelPrecisionZ * platformScale * event.deltaZ / this._normalize;
      if (event.preventDefault) {
        if (!noPreventDefault) {
          event.preventDefault();
        }
      }
    };
    this._observer = this.camera.getScene()._inputManager._addCameraPointerObserver(this._wheel, PointerEventTypes.POINTERWHEEL);
  }
  /**
   * Detach the current controls from the specified dom element.
   */
  detachControl() {
    if (this._observer) {
      this.camera.getScene()._inputManager._removeCameraPointerObserver(this._observer);
      this._observer = null;
      this._wheel = null;
    }
    if (this.onChangedObservable) {
      this.onChangedObservable.clear();
    }
  }
  /**
   * Called for each rendered frame.
   */
  checkInputs() {
    this.onChangedObservable.notifyObservers({
      wheelDeltaX: this._wheelDeltaX,
      wheelDeltaY: this._wheelDeltaY,
      wheelDeltaZ: this._wheelDeltaZ
    });
    this._wheelDeltaX = 0;
    this._wheelDeltaY = 0;
    this._wheelDeltaZ = 0;
  }
  /**
   * Gets the class name of the current input.
   * @returns the class name
   */
  getClassName() {
    return "BaseCameraMouseWheelInput";
  }
  /**
   * Get the friendly name associated with the input class.
   * @returns the input friendly name
   */
  getSimpleName() {
    return "mousewheel";
  }
};
__decorate([
  serialize()
], BaseCameraMouseWheelInput.prototype, "wheelPrecisionX", void 0);
__decorate([
  serialize()
], BaseCameraMouseWheelInput.prototype, "wheelPrecisionY", void 0);
__decorate([
  serialize()
], BaseCameraMouseWheelInput.prototype, "wheelPrecisionZ", void 0);

// ../../node_modules/@babylonjs/core/Cameras/Inputs/freeCameraMouseWheelInput.js
var _CameraProperty;
(function(_CameraProperty2) {
  _CameraProperty2[_CameraProperty2["MoveRelative"] = 0] = "MoveRelative";
  _CameraProperty2[_CameraProperty2["RotateRelative"] = 1] = "RotateRelative";
  _CameraProperty2[_CameraProperty2["MoveScene"] = 2] = "MoveScene";
})(_CameraProperty || (_CameraProperty = {}));
var FreeCameraMouseWheelInput = class extends BaseCameraMouseWheelInput {
  constructor() {
    super(...arguments);
    this._moveRelative = Vector3.Zero();
    this._rotateRelative = Vector3.Zero();
    this._moveScene = Vector3.Zero();
    this._wheelXAction = _CameraProperty.MoveRelative;
    this._wheelXActionCoordinate = Coordinate.X;
    this._wheelYAction = _CameraProperty.MoveRelative;
    this._wheelYActionCoordinate = Coordinate.Z;
    this._wheelZAction = null;
    this._wheelZActionCoordinate = null;
  }
  /**
   * Gets the class name of the current input.
   * @returns the class name
   */
  getClassName() {
    return "FreeCameraMouseWheelInput";
  }
  /**
   * Set which movement axis (relative to camera's orientation) the mouse
   * wheel's X axis controls.
   * @param axis The axis to be moved. Set null to clear.
   */
  set wheelXMoveRelative(axis) {
    if (axis === null && this._wheelXAction !== _CameraProperty.MoveRelative) {
      return;
    }
    this._wheelXAction = _CameraProperty.MoveRelative;
    this._wheelXActionCoordinate = axis;
  }
  /**
   * Get the configured movement axis (relative to camera's orientation) the
   * mouse wheel's X axis controls.
   * @returns The configured axis or null if none.
   */
  get wheelXMoveRelative() {
    if (this._wheelXAction !== _CameraProperty.MoveRelative) {
      return null;
    }
    return this._wheelXActionCoordinate;
  }
  /**
   * Set which movement axis (relative to camera's orientation) the mouse
   * wheel's Y axis controls.
   * @param axis The axis to be moved. Set null to clear.
   */
  set wheelYMoveRelative(axis) {
    if (axis === null && this._wheelYAction !== _CameraProperty.MoveRelative) {
      return;
    }
    this._wheelYAction = _CameraProperty.MoveRelative;
    this._wheelYActionCoordinate = axis;
  }
  /**
   * Get the configured movement axis (relative to camera's orientation) the
   * mouse wheel's Y axis controls.
   * @returns The configured axis or null if none.
   */
  get wheelYMoveRelative() {
    if (this._wheelYAction !== _CameraProperty.MoveRelative) {
      return null;
    }
    return this._wheelYActionCoordinate;
  }
  /**
   * Set which movement axis (relative to camera's orientation) the mouse
   * wheel's Z axis controls.
   * @param axis The axis to be moved. Set null to clear.
   */
  set wheelZMoveRelative(axis) {
    if (axis === null && this._wheelZAction !== _CameraProperty.MoveRelative) {
      return;
    }
    this._wheelZAction = _CameraProperty.MoveRelative;
    this._wheelZActionCoordinate = axis;
  }
  /**
   * Get the configured movement axis (relative to camera's orientation) the
   * mouse wheel's Z axis controls.
   * @returns The configured axis or null if none.
   */
  get wheelZMoveRelative() {
    if (this._wheelZAction !== _CameraProperty.MoveRelative) {
      return null;
    }
    return this._wheelZActionCoordinate;
  }
  /**
   * Set which rotation axis (relative to camera's orientation) the mouse
   * wheel's X axis controls.
   * @param axis The axis to be moved. Set null to clear.
   */
  set wheelXRotateRelative(axis) {
    if (axis === null && this._wheelXAction !== _CameraProperty.RotateRelative) {
      return;
    }
    this._wheelXAction = _CameraProperty.RotateRelative;
    this._wheelXActionCoordinate = axis;
  }
  /**
   * Get the configured rotation axis (relative to camera's orientation) the
   * mouse wheel's X axis controls.
   * @returns The configured axis or null if none.
   */
  get wheelXRotateRelative() {
    if (this._wheelXAction !== _CameraProperty.RotateRelative) {
      return null;
    }
    return this._wheelXActionCoordinate;
  }
  /**
   * Set which rotation axis (relative to camera's orientation) the mouse
   * wheel's Y axis controls.
   * @param axis The axis to be moved. Set null to clear.
   */
  set wheelYRotateRelative(axis) {
    if (axis === null && this._wheelYAction !== _CameraProperty.RotateRelative) {
      return;
    }
    this._wheelYAction = _CameraProperty.RotateRelative;
    this._wheelYActionCoordinate = axis;
  }
  /**
   * Get the configured rotation axis (relative to camera's orientation) the
   * mouse wheel's Y axis controls.
   * @returns The configured axis or null if none.
   */
  get wheelYRotateRelative() {
    if (this._wheelYAction !== _CameraProperty.RotateRelative) {
      return null;
    }
    return this._wheelYActionCoordinate;
  }
  /**
   * Set which rotation axis (relative to camera's orientation) the mouse
   * wheel's Z axis controls.
   * @param axis The axis to be moved. Set null to clear.
   */
  set wheelZRotateRelative(axis) {
    if (axis === null && this._wheelZAction !== _CameraProperty.RotateRelative) {
      return;
    }
    this._wheelZAction = _CameraProperty.RotateRelative;
    this._wheelZActionCoordinate = axis;
  }
  /**
   * Get the configured rotation axis (relative to camera's orientation) the
   * mouse wheel's Z axis controls.
   * @returns The configured axis or null if none.
   */
  get wheelZRotateRelative() {
    if (this._wheelZAction !== _CameraProperty.RotateRelative) {
      return null;
    }
    return this._wheelZActionCoordinate;
  }
  /**
   * Set which movement axis (relative to the scene) the mouse wheel's X axis
   * controls.
   * @param axis The axis to be moved. Set null to clear.
   */
  set wheelXMoveScene(axis) {
    if (axis === null && this._wheelXAction !== _CameraProperty.MoveScene) {
      return;
    }
    this._wheelXAction = _CameraProperty.MoveScene;
    this._wheelXActionCoordinate = axis;
  }
  /**
   * Get the configured movement axis (relative to the scene) the mouse wheel's
   * X axis controls.
   * @returns The configured axis or null if none.
   */
  get wheelXMoveScene() {
    if (this._wheelXAction !== _CameraProperty.MoveScene) {
      return null;
    }
    return this._wheelXActionCoordinate;
  }
  /**
   * Set which movement axis (relative to the scene) the mouse wheel's Y axis
   * controls.
   * @param axis The axis to be moved. Set null to clear.
   */
  set wheelYMoveScene(axis) {
    if (axis === null && this._wheelYAction !== _CameraProperty.MoveScene) {
      return;
    }
    this._wheelYAction = _CameraProperty.MoveScene;
    this._wheelYActionCoordinate = axis;
  }
  /**
   * Get the configured movement axis (relative to the scene) the mouse wheel's
   * Y axis controls.
   * @returns The configured axis or null if none.
   */
  get wheelYMoveScene() {
    if (this._wheelYAction !== _CameraProperty.MoveScene) {
      return null;
    }
    return this._wheelYActionCoordinate;
  }
  /**
   * Set which movement axis (relative to the scene) the mouse wheel's Z axis
   * controls.
   * @param axis The axis to be moved. Set null to clear.
   */
  set wheelZMoveScene(axis) {
    if (axis === null && this._wheelZAction !== _CameraProperty.MoveScene) {
      return;
    }
    this._wheelZAction = _CameraProperty.MoveScene;
    this._wheelZActionCoordinate = axis;
  }
  /**
   * Get the configured movement axis (relative to the scene) the mouse wheel's
   * Z axis controls.
   * @returns The configured axis or null if none.
   */
  get wheelZMoveScene() {
    if (this._wheelZAction !== _CameraProperty.MoveScene) {
      return null;
    }
    return this._wheelZActionCoordinate;
  }
  /**
   * Called for each rendered frame.
   */
  checkInputs() {
    if (this._wheelDeltaX === 0 && this._wheelDeltaY === 0 && this._wheelDeltaZ == 0) {
      return;
    }
    this._moveRelative.setAll(0);
    this._rotateRelative.setAll(0);
    this._moveScene.setAll(0);
    this._updateCamera();
    if (this.camera.getScene().useRightHandedSystem) {
      this._moveRelative.z *= -1;
    }
    const cameraTransformMatrix = Matrix.Zero();
    this.camera.getViewMatrix().invertToRef(cameraTransformMatrix);
    const transformedDirection = Vector3.Zero();
    Vector3.TransformNormalToRef(this._moveRelative, cameraTransformMatrix, transformedDirection);
    this.camera.cameraRotation.x += this._rotateRelative.x / 200;
    this.camera.cameraRotation.y += this._rotateRelative.y / 200;
    this.camera.cameraDirection.addInPlace(transformedDirection);
    this.camera.cameraDirection.addInPlace(this._moveScene);
    super.checkInputs();
  }
  /**
   * Update the camera according to any configured properties for the 3
   * mouse-wheel axis.
   */
  _updateCamera() {
    this._updateCameraProperty(this._wheelDeltaX, this._wheelXAction, this._wheelXActionCoordinate);
    this._updateCameraProperty(this._wheelDeltaY, this._wheelYAction, this._wheelYActionCoordinate);
    this._updateCameraProperty(this._wheelDeltaZ, this._wheelZAction, this._wheelZActionCoordinate);
  }
  /**
   * Update one property of the camera.
   * @param value
   * @param cameraProperty
   * @param coordinate
   */
  _updateCameraProperty(value, cameraProperty, coordinate) {
    if (value === 0) {
      return;
    }
    if (cameraProperty === null || coordinate === null) {
      return;
    }
    let action = null;
    switch (cameraProperty) {
      case _CameraProperty.MoveRelative:
        action = this._moveRelative;
        break;
      case _CameraProperty.RotateRelative:
        action = this._rotateRelative;
        break;
      case _CameraProperty.MoveScene:
        action = this._moveScene;
        break;
    }
    switch (coordinate) {
      case Coordinate.X:
        action.set(value, 0, 0);
        break;
      case Coordinate.Y:
        action.set(0, value, 0);
        break;
      case Coordinate.Z:
        action.set(0, 0, value);
        break;
    }
  }
};
__decorate([
  serialize()
], FreeCameraMouseWheelInput.prototype, "wheelXMoveRelative", null);
__decorate([
  serialize()
], FreeCameraMouseWheelInput.prototype, "wheelYMoveRelative", null);
__decorate([
  serialize()
], FreeCameraMouseWheelInput.prototype, "wheelZMoveRelative", null);
__decorate([
  serialize()
], FreeCameraMouseWheelInput.prototype, "wheelXRotateRelative", null);
__decorate([
  serialize()
], FreeCameraMouseWheelInput.prototype, "wheelYRotateRelative", null);
__decorate([
  serialize()
], FreeCameraMouseWheelInput.prototype, "wheelZRotateRelative", null);
__decorate([
  serialize()
], FreeCameraMouseWheelInput.prototype, "wheelXMoveScene", null);
__decorate([
  serialize()
], FreeCameraMouseWheelInput.prototype, "wheelYMoveScene", null);
__decorate([
  serialize()
], FreeCameraMouseWheelInput.prototype, "wheelZMoveScene", null);
CameraInputTypes["FreeCameraMouseWheelInput"] = FreeCameraMouseWheelInput;

// ../../node_modules/@babylonjs/core/Cameras/Inputs/freeCameraTouchInput.js
var FreeCameraTouchInput = class {
  /**
   * Manage the touch inputs to control the movement of a free camera.
   * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs
   * @param allowMouse Defines if mouse events can be treated as touch events
   */
  constructor(allowMouse = false) {
    this.allowMouse = allowMouse;
    this.touchAngularSensibility = 2e5;
    this.touchMoveSensibility = 250;
    this.singleFingerRotate = false;
    this._offsetX = null;
    this._offsetY = null;
    this._pointerPressed = new Array();
    this._isSafari = Tools.IsSafari();
  }
  /**
   * Attach the input controls to a specific dom element to get the input from.
   * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)
   */
  attachControl(noPreventDefault) {
    noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);
    let previousPosition = null;
    if (this._pointerInput === void 0) {
      this._onLostFocus = () => {
        this._offsetX = null;
        this._offsetY = null;
      };
      this._pointerInput = (p) => {
        const evt = p.event;
        const isMouseEvent = evt.pointerType === "mouse" || this._isSafari && typeof evt.pointerType === "undefined";
        if (!this.allowMouse && isMouseEvent) {
          return;
        }
        if (p.type === PointerEventTypes.POINTERDOWN) {
          if (!noPreventDefault) {
            evt.preventDefault();
          }
          this._pointerPressed.push(evt.pointerId);
          if (this._pointerPressed.length !== 1) {
            return;
          }
          previousPosition = {
            x: evt.clientX,
            y: evt.clientY
          };
        } else if (p.type === PointerEventTypes.POINTERUP) {
          if (!noPreventDefault) {
            evt.preventDefault();
          }
          const index = this._pointerPressed.indexOf(evt.pointerId);
          if (index === -1) {
            return;
          }
          this._pointerPressed.splice(index, 1);
          if (index != 0) {
            return;
          }
          previousPosition = null;
          this._offsetX = null;
          this._offsetY = null;
        } else if (p.type === PointerEventTypes.POINTERMOVE) {
          if (!noPreventDefault) {
            evt.preventDefault();
          }
          if (!previousPosition) {
            return;
          }
          const index = this._pointerPressed.indexOf(evt.pointerId);
          if (index != 0) {
            return;
          }
          this._offsetX = evt.clientX - previousPosition.x;
          this._offsetY = -(evt.clientY - previousPosition.y);
        }
      };
    }
    this._observer = this.camera.getScene()._inputManager._addCameraPointerObserver(this._pointerInput, PointerEventTypes.POINTERDOWN | PointerEventTypes.POINTERUP | PointerEventTypes.POINTERMOVE);
    if (this._onLostFocus) {
      const engine = this.camera.getEngine();
      const element = engine.getInputElement();
      element && element.addEventListener("blur", this._onLostFocus);
    }
  }
  /**
   * Detach the current controls from the specified dom element.
   */
  detachControl() {
    if (this._pointerInput) {
      if (this._observer) {
        this.camera.getScene()._inputManager._removeCameraPointerObserver(this._observer);
        this._observer = null;
      }
      if (this._onLostFocus) {
        const engine = this.camera.getEngine();
        const element = engine.getInputElement();
        element && element.removeEventListener("blur", this._onLostFocus);
        this._onLostFocus = null;
      }
      this._pointerPressed.length = 0;
      this._offsetX = null;
      this._offsetY = null;
    }
  }
  /**
   * Update the current camera state depending on the inputs that have been used this frame.
   * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.
   */
  checkInputs() {
    if (this._offsetX === null || this._offsetY === null) {
      return;
    }
    if (this._offsetX === 0 && this._offsetY === 0) {
      return;
    }
    const camera = this.camera;
    const handednessMultiplier = camera._calculateHandednessMultiplier();
    camera.cameraRotation.y = handednessMultiplier * this._offsetX / this.touchAngularSensibility;
    const rotateCamera = this.singleFingerRotate && this._pointerPressed.length === 1 || !this.singleFingerRotate && this._pointerPressed.length > 1;
    if (rotateCamera) {
      camera.cameraRotation.x = -this._offsetY / this.touchAngularSensibility;
    } else {
      const speed = camera._computeLocalCameraSpeed();
      const direction = new Vector3(0, 0, this.touchMoveSensibility !== 0 ? speed * this._offsetY / this.touchMoveSensibility : 0);
      Matrix.RotationYawPitchRollToRef(camera.rotation.y, camera.rotation.x, 0, camera._cameraRotationMatrix);
      camera.cameraDirection.addInPlace(Vector3.TransformCoordinates(direction, camera._cameraRotationMatrix));
    }
  }
  /**
   * Gets the class name of the current input.
   * @returns the class name
   */
  getClassName() {
    return "FreeCameraTouchInput";
  }
  /**
   * Get the friendly name associated with the input class.
   * @returns the input friendly name
   */
  getSimpleName() {
    return "touch";
  }
};
__decorate([
  serialize()
], FreeCameraTouchInput.prototype, "touchAngularSensibility", void 0);
__decorate([
  serialize()
], FreeCameraTouchInput.prototype, "touchMoveSensibility", void 0);
CameraInputTypes["FreeCameraTouchInput"] = FreeCameraTouchInput;

// ../../node_modules/@babylonjs/core/Cameras/freeCameraInputsManager.js
var FreeCameraInputsManager = class extends CameraInputsManager {
  /**
   * Instantiates a new FreeCameraInputsManager.
   * @param camera Defines the camera the inputs belong to
   */
  constructor(camera) {
    super(camera);
    this._mouseInput = null;
    this._mouseWheelInput = null;
  }
  /**
   * Add keyboard input support to the input manager.
   * @returns the current input manager
   */
  addKeyboard() {
    this.add(new FreeCameraKeyboardMoveInput());
    return this;
  }
  /**
   * Add mouse input support to the input manager.
   * @param touchEnabled if the FreeCameraMouseInput should support touch (default: true)
   * @returns the current input manager
   */
  addMouse(touchEnabled = true) {
    if (!this._mouseInput) {
      this._mouseInput = new FreeCameraMouseInput(touchEnabled);
      this.add(this._mouseInput);
    }
    return this;
  }
  /**
   * Removes the mouse input support from the manager
   * @returns the current input manager
   */
  removeMouse() {
    if (this._mouseInput) {
      this.remove(this._mouseInput);
    }
    return this;
  }
  /**
   * Add mouse wheel input support to the input manager.
   * @returns the current input manager
   */
  addMouseWheel() {
    if (!this._mouseWheelInput) {
      this._mouseWheelInput = new FreeCameraMouseWheelInput();
      this.add(this._mouseWheelInput);
    }
    return this;
  }
  /**
   * Removes the mouse wheel input support from the manager
   * @returns the current input manager
   */
  removeMouseWheel() {
    if (this._mouseWheelInput) {
      this.remove(this._mouseWheelInput);
    }
    return this;
  }
  /**
   * Add touch input support to the input manager.
   * @returns the current input manager
   */
  addTouch() {
    this.add(new FreeCameraTouchInput());
    return this;
  }
  /**
   * Remove all attached input methods from a camera
   */
  clear() {
    super.clear();
    this._mouseInput = null;
  }
};

// ../../node_modules/@babylonjs/core/Cameras/freeCamera.js
var FreeCamera = class extends TargetCamera {
  /**
   * Gets the input sensibility for a mouse input. (default is 2000.0)
   * Higher values reduce sensitivity.
   */
  get angularSensibility() {
    const mouse = this.inputs.attached["mouse"];
    if (mouse) {
      return mouse.angularSensibility;
    }
    return 0;
  }
  /**
   * Sets the input sensibility for a mouse input. (default is 2000.0)
   * Higher values reduce sensitivity.
   */
  set angularSensibility(value) {
    const mouse = this.inputs.attached["mouse"];
    if (mouse) {
      mouse.angularSensibility = value;
    }
  }
  /**
   * Gets or Set the list of keyboard keys used to control the forward move of the camera.
   */
  get keysUp() {
    const keyboard = this.inputs.attached["keyboard"];
    if (keyboard) {
      return keyboard.keysUp;
    }
    return [];
  }
  set keysUp(value) {
    const keyboard = this.inputs.attached["keyboard"];
    if (keyboard) {
      keyboard.keysUp = value;
    }
  }
  /**
   * Gets or Set the list of keyboard keys used to control the upward move of the camera.
   */
  get keysUpward() {
    const keyboard = this.inputs.attached["keyboard"];
    if (keyboard) {
      return keyboard.keysUpward;
    }
    return [];
  }
  set keysUpward(value) {
    const keyboard = this.inputs.attached["keyboard"];
    if (keyboard) {
      keyboard.keysUpward = value;
    }
  }
  /**
   * Gets or Set the list of keyboard keys used to control the backward move of the camera.
   */
  get keysDown() {
    const keyboard = this.inputs.attached["keyboard"];
    if (keyboard) {
      return keyboard.keysDown;
    }
    return [];
  }
  set keysDown(value) {
    const keyboard = this.inputs.attached["keyboard"];
    if (keyboard) {
      keyboard.keysDown = value;
    }
  }
  /**
   * Gets or Set the list of keyboard keys used to control the downward move of the camera.
   */
  get keysDownward() {
    const keyboard = this.inputs.attached["keyboard"];
    if (keyboard) {
      return keyboard.keysDownward;
    }
    return [];
  }
  set keysDownward(value) {
    const keyboard = this.inputs.attached["keyboard"];
    if (keyboard) {
      keyboard.keysDownward = value;
    }
  }
  /**
   * Gets or Set the list of keyboard keys used to control the left strafe move of the camera.
   */
  get keysLeft() {
    const keyboard = this.inputs.attached["keyboard"];
    if (keyboard) {
      return keyboard.keysLeft;
    }
    return [];
  }
  set keysLeft(value) {
    const keyboard = this.inputs.attached["keyboard"];
    if (keyboard) {
      keyboard.keysLeft = value;
    }
  }
  /**
   * Gets or Set the list of keyboard keys used to control the right strafe move of the camera.
   */
  get keysRight() {
    const keyboard = this.inputs.attached["keyboard"];
    if (keyboard) {
      return keyboard.keysRight;
    }
    return [];
  }
  set keysRight(value) {
    const keyboard = this.inputs.attached["keyboard"];
    if (keyboard) {
      keyboard.keysRight = value;
    }
  }
  /**
   * Gets or Set the list of keyboard keys used to control the left rotation move of the camera.
   */
  get keysRotateLeft() {
    const keyboard = this.inputs.attached["keyboard"];
    if (keyboard) {
      return keyboard.keysRotateLeft;
    }
    return [];
  }
  set keysRotateLeft(value) {
    const keyboard = this.inputs.attached["keyboard"];
    if (keyboard) {
      keyboard.keysRotateLeft = value;
    }
  }
  /**
   * Gets or Set the list of keyboard keys used to control the right rotation move of the camera.
   */
  get keysRotateRight() {
    const keyboard = this.inputs.attached["keyboard"];
    if (keyboard) {
      return keyboard.keysRotateRight;
    }
    return [];
  }
  set keysRotateRight(value) {
    const keyboard = this.inputs.attached["keyboard"];
    if (keyboard) {
      keyboard.keysRotateRight = value;
    }
  }
  /**
   * Gets or Set the list of keyboard keys used to control the up rotation move of the camera.
   */
  get keysRotateUp() {
    const keyboard = this.inputs.attached["keyboard"];
    if (keyboard) {
      return keyboard.keysRotateUp;
    }
    return [];
  }
  set keysRotateUp(value) {
    const keyboard = this.inputs.attached["keyboard"];
    if (keyboard) {
      keyboard.keysRotateUp = value;
    }
  }
  /**
   * Gets or Set the list of keyboard keys used to control the down rotation move of the camera.
   */
  get keysRotateDown() {
    const keyboard = this.inputs.attached["keyboard"];
    if (keyboard) {
      return keyboard.keysRotateDown;
    }
    return [];
  }
  set keysRotateDown(value) {
    const keyboard = this.inputs.attached["keyboard"];
    if (keyboard) {
      keyboard.keysRotateDown = value;
    }
  }
  /**
   * Instantiates a Free Camera.
   * This represents a free type of camera. It can be useful in First Person Shooter game for instance.
   * Please consider using the new UniversalCamera instead as it adds more functionality like touch to this camera.
   * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_introduction#universal-camera
   * @param name Define the name of the camera in the scene
   * @param position Define the start position of the camera in the scene
   * @param scene Define the scene the camera belongs to
   * @param setActiveOnSceneIfNoneActive Defines whether the camera should be marked as active if not other active cameras have been defined
   */
  constructor(name66, position, scene, setActiveOnSceneIfNoneActive = true) {
    super(name66, position, scene, setActiveOnSceneIfNoneActive);
    this.ellipsoid = new Vector3(0.5, 1, 0.5);
    this.ellipsoidOffset = new Vector3(0, 0, 0);
    this.checkCollisions = false;
    this.applyGravity = false;
    this._needMoveForGravity = false;
    this._oldPosition = Vector3.Zero();
    this._diffPosition = Vector3.Zero();
    this._newPosition = Vector3.Zero();
    this._collisionMask = -1;
    this._onCollisionPositionChange = (collisionId, newPosition, collidedMesh = null) => {
      this._newPosition.copyFrom(newPosition);
      this._newPosition.subtractToRef(this._oldPosition, this._diffPosition);
      if (this._diffPosition.length() > Engine.CollisionsEpsilon) {
        this.position.addToRef(this._diffPosition, this._deferredPositionUpdate);
        if (!this._deferOnly) {
          this.position.copyFrom(this._deferredPositionUpdate);
        } else {
          this._deferredUpdated = true;
        }
        if (this.onCollide && collidedMesh) {
          this.onCollide(collidedMesh);
        }
      }
    };
    this.inputs = new FreeCameraInputsManager(this);
    this.inputs.addKeyboard().addMouse();
  }
  /**
   * Attached controls to the current camera.
   * @param ignored defines an ignored parameter kept for backward compatibility.
   * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)
   */
  attachControl(ignored, noPreventDefault) {
    noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);
    this.inputs.attachElement(noPreventDefault);
  }
  /**
   * Detach the current controls from the specified dom element.
   */
  detachControl() {
    this.inputs.detachElement();
    this.cameraDirection = new Vector3(0, 0, 0);
    this.cameraRotation = new Vector2(0, 0);
  }
  /**
   * Define a collision mask to limit the list of object the camera can collide with
   */
  get collisionMask() {
    return this._collisionMask;
  }
  set collisionMask(mask) {
    this._collisionMask = !isNaN(mask) ? mask : -1;
  }
  /**
   * @internal
   */
  _collideWithWorld(displacement) {
    let globalPosition;
    if (this.parent) {
      globalPosition = Vector3.TransformCoordinates(this.position, this.parent.getWorldMatrix());
    } else {
      globalPosition = this.position;
    }
    globalPosition.subtractFromFloatsToRef(0, this.ellipsoid.y, 0, this._oldPosition);
    this._oldPosition.addInPlace(this.ellipsoidOffset);
    const coordinator = this.getScene().collisionCoordinator;
    if (!this._collider) {
      this._collider = coordinator.createCollider();
    }
    this._collider._radius = this.ellipsoid;
    this._collider.collisionMask = this._collisionMask;
    let actualDisplacement = displacement;
    if (this.applyGravity) {
      actualDisplacement = displacement.add(this.getScene().gravity);
    }
    coordinator.getNewPosition(this._oldPosition, actualDisplacement, this._collider, 3, null, this._onCollisionPositionChange, this.uniqueId);
  }
  /** @internal */
  _checkInputs() {
    if (!this._localDirection) {
      this._localDirection = Vector3.Zero();
      this._transformedDirection = Vector3.Zero();
    }
    this.inputs.checkInputs();
    super._checkInputs();
  }
  /**
   * Enable movement without a user input. This allows gravity to always be applied.
   */
  set needMoveForGravity(value) {
    this._needMoveForGravity = value;
  }
  /**
   * When true, gravity is applied whether there is user input or not.
   */
  get needMoveForGravity() {
    return this._needMoveForGravity;
  }
  /** @internal */
  _decideIfNeedsToMove() {
    return this._needMoveForGravity || Math.abs(this.cameraDirection.x) > 0 || Math.abs(this.cameraDirection.y) > 0 || Math.abs(this.cameraDirection.z) > 0;
  }
  /** @internal */
  _updatePosition() {
    if (this.checkCollisions && this.getScene().collisionsEnabled) {
      this._collideWithWorld(this.cameraDirection);
    } else {
      super._updatePosition();
    }
  }
  /**
   * Destroy the camera and release the current resources hold by it.
   */
  dispose() {
    this.inputs.clear();
    super.dispose();
  }
  /**
   * Gets the current object class name.
   * @returns the class name
   */
  getClassName() {
    return "FreeCamera";
  }
};
__decorate([
  serializeAsVector3()
], FreeCamera.prototype, "ellipsoid", void 0);
__decorate([
  serializeAsVector3()
], FreeCamera.prototype, "ellipsoidOffset", void 0);
__decorate([
  serialize()
], FreeCamera.prototype, "checkCollisions", void 0);
__decorate([
  serialize()
], FreeCamera.prototype, "applyGravity", void 0);

// ../../node_modules/@babylonjs/core/Lights/light.js
var Light = class _Light extends Node {
  /**
   * Defines how far from the source the light is impacting in scene units.
   * Note: Unused in PBR material as the distance light falloff is defined following the inverse squared falloff.
   */
  get range() {
    return this._range;
  }
  /**
   * Defines how far from the source the light is impacting in scene units.
   * Note: Unused in PBR material as the distance light falloff is defined following the inverse squared falloff.
   */
  set range(value) {
    this._range = value;
    this._inverseSquaredRange = 1 / (this.range * this.range);
  }
  /**
   * Gets the photometric scale used to interpret the intensity.
   * This is only relevant with PBR Materials where the light intensity can be defined in a physical way.
   */
  get intensityMode() {
    return this._intensityMode;
  }
  /**
   * Sets the photometric scale used to interpret the intensity.
   * This is only relevant with PBR Materials where the light intensity can be defined in a physical way.
   */
  set intensityMode(value) {
    this._intensityMode = value;
    this._computePhotometricScale();
  }
  /**
   * Gets the light radius used by PBR Materials to simulate soft area lights.
   */
  get radius() {
    return this._radius;
  }
  /**
   * sets the light radius used by PBR Materials to simulate soft area lights.
   */
  set radius(value) {
    this._radius = value;
    this._computePhotometricScale();
  }
  /**
   * Gets whether or not the shadows are enabled for this light. This can help turning off/on shadow without detaching
   * the current shadow generator.
   */
  get shadowEnabled() {
    return this._shadowEnabled;
  }
  /**
   * Sets whether or not the shadows are enabled for this light. This can help turning off/on shadow without detaching
   * the current shadow generator.
   */
  set shadowEnabled(value) {
    if (this._shadowEnabled === value) {
      return;
    }
    this._shadowEnabled = value;
    this._markMeshesAsLightDirty();
  }
  /**
   * Gets the only meshes impacted by this light.
   */
  get includedOnlyMeshes() {
    return this._includedOnlyMeshes;
  }
  /**
   * Sets the only meshes impacted by this light.
   */
  set includedOnlyMeshes(value) {
    this._includedOnlyMeshes = value;
    this._hookArrayForIncludedOnly(value);
  }
  /**
   * Gets the meshes not impacted by this light.
   */
  get excludedMeshes() {
    return this._excludedMeshes;
  }
  /**
   * Sets the meshes not impacted by this light.
   */
  set excludedMeshes(value) {
    this._excludedMeshes = value;
    this._hookArrayForExcluded(value);
  }
  /**
   * Gets the layer id use to find what meshes are not impacted by the light.
   * Inactive if 0
   */
  get excludeWithLayerMask() {
    return this._excludeWithLayerMask;
  }
  /**
   * Sets the layer id use to find what meshes are not impacted by the light.
   * Inactive if 0
   */
  set excludeWithLayerMask(value) {
    this._excludeWithLayerMask = value;
    this._resyncMeshes();
  }
  /**
   * Gets the layer id use to find what meshes are impacted by the light.
   * Inactive if 0
   */
  get includeOnlyWithLayerMask() {
    return this._includeOnlyWithLayerMask;
  }
  /**
   * Sets the layer id use to find what meshes are impacted by the light.
   * Inactive if 0
   */
  set includeOnlyWithLayerMask(value) {
    this._includeOnlyWithLayerMask = value;
    this._resyncMeshes();
  }
  /**
   * Gets the lightmap mode of this light (should be one of the constants defined by Light.LIGHTMAP_x)
   */
  get lightmapMode() {
    return this._lightmapMode;
  }
  /**
   * Sets the lightmap mode of this light (should be one of the constants defined by Light.LIGHTMAP_x)
   */
  set lightmapMode(value) {
    if (this._lightmapMode === value) {
      return;
    }
    this._lightmapMode = value;
    this._markMeshesAsLightDirty();
  }
  /**
   * Returns the view matrix.
   * @param _faceIndex The index of the face for which we want to extract the view matrix. Only used for point light types.
   * @returns The view matrix. Can be null, if a view matrix cannot be defined for the type of light considered (as for a hemispherical light, for example).
   */
  getViewMatrix(_faceIndex) {
    return null;
  }
  /**
   * Returns the projection matrix.
   * Note that viewMatrix and renderList are optional and are only used by lights that calculate the projection matrix from a list of meshes (e.g. directional lights with automatic extents calculation).
   * @param _viewMatrix The view transform matrix of the light (optional).
   * @param _renderList The list of meshes to take into account when calculating the projection matrix (optional).
   * @returns The projection matrix. Can be null, if a projection matrix cannot be defined for the type of light considered (as for a hemispherical light, for example).
   */
  getProjectionMatrix(_viewMatrix, _renderList) {
    return null;
  }
  /**
   * Creates a Light object in the scene.
   * Documentation : https://doc.babylonjs.com/features/featuresDeepDive/lights/lights_introduction
   * @param name The friendly name of the light
   * @param scene The scene the light belongs too
   */
  constructor(name66, scene) {
    super(name66, scene);
    this.diffuse = new Color3(1, 1, 1);
    this.specular = new Color3(1, 1, 1);
    this.falloffType = _Light.FALLOFF_DEFAULT;
    this.intensity = 1;
    this._range = Number.MAX_VALUE;
    this._inverseSquaredRange = 0;
    this._photometricScale = 1;
    this._intensityMode = _Light.INTENSITYMODE_AUTOMATIC;
    this._radius = 1e-5;
    this.renderPriority = 0;
    this._shadowEnabled = true;
    this._excludeWithLayerMask = 0;
    this._includeOnlyWithLayerMask = 0;
    this._lightmapMode = 0;
    this._shadowGenerators = null;
    this._excludedMeshesIds = new Array();
    this._includedOnlyMeshesIds = new Array();
    this._isLight = true;
    this.getScene().addLight(this);
    this._uniformBuffer = new UniformBuffer(this.getScene().getEngine(), void 0, void 0, name66);
    this._buildUniformLayout();
    this.includedOnlyMeshes = [];
    this.excludedMeshes = [];
    this._resyncMeshes();
  }
  /**
   * Sets the passed Effect "effect" with the Light textures.
   * @param effect The effect to update
   * @param lightIndex The index of the light in the effect to update
   * @returns The light
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  transferTexturesToEffect(effect, lightIndex) {
    return this;
  }
  /**
   * Binds the lights information from the scene to the effect for the given mesh.
   * @param lightIndex Light index
   * @param scene The scene where the light belongs to
   * @param effect The effect we are binding the data to
   * @param useSpecular Defines if specular is supported
   * @param receiveShadows Defines if the effect (mesh) we bind the light for receives shadows
   */
  _bindLight(lightIndex, scene, effect, useSpecular, receiveShadows = true) {
    const iAsString = lightIndex.toString();
    let needUpdate = false;
    this._uniformBuffer.bindToEffect(effect, "Light" + iAsString);
    if (this._renderId !== scene.getRenderId() || this._lastUseSpecular !== useSpecular || !this._uniformBuffer.useUbo) {
      this._renderId = scene.getRenderId();
      this._lastUseSpecular = useSpecular;
      const scaledIntensity = this.getScaledIntensity();
      this.transferToEffect(effect, iAsString);
      this.diffuse.scaleToRef(scaledIntensity, TmpColors.Color3[0]);
      this._uniformBuffer.updateColor4("vLightDiffuse", TmpColors.Color3[0], this.range, iAsString);
      if (useSpecular) {
        this.specular.scaleToRef(scaledIntensity, TmpColors.Color3[1]);
        this._uniformBuffer.updateColor4("vLightSpecular", TmpColors.Color3[1], this.radius, iAsString);
      }
      needUpdate = true;
    }
    this.transferTexturesToEffect(effect, iAsString);
    if (scene.shadowsEnabled && this.shadowEnabled && receiveShadows) {
      const shadowGenerator = this.getShadowGenerator(scene.activeCamera) ?? this.getShadowGenerator();
      if (shadowGenerator) {
        shadowGenerator.bindShadowLight(iAsString, effect);
        needUpdate = true;
      }
    }
    if (needUpdate) {
      this._uniformBuffer.update();
    } else {
      this._uniformBuffer.bindUniformBuffer();
    }
  }
  /**
   * Returns the string "Light".
   * @returns the class name
   */
  getClassName() {
    return "Light";
  }
  /**
   * Converts the light information to a readable string for debug purpose.
   * @param fullDetails Supports for multiple levels of logging within scene loading
   * @returns the human readable light info
   */
  toString(fullDetails) {
    let ret = "Name: " + this.name;
    ret += ", type: " + ["Point", "Directional", "Spot", "Hemispheric"][this.getTypeID()];
    if (this.animations) {
      for (let i = 0; i < this.animations.length; i++) {
        ret += ", animation[0]: " + this.animations[i].toString(fullDetails);
      }
    }
    return ret;
  }
  /** @internal */
  _syncParentEnabledState() {
    super._syncParentEnabledState();
    if (!this.isDisposed()) {
      this._resyncMeshes();
    }
  }
  /**
   * Set the enabled state of this node.
   * @param value - the new enabled state
   */
  setEnabled(value) {
    super.setEnabled(value);
    this._resyncMeshes();
  }
  /**
   * Returns the Light associated shadow generator if any.
   * @param camera Camera for which the shadow generator should be retrieved (default: null). If null, retrieves the default shadow generator
   * @returns the associated shadow generator.
   */
  getShadowGenerator(camera = null) {
    if (this._shadowGenerators === null) {
      return null;
    }
    return this._shadowGenerators.get(camera) ?? null;
  }
  /**
   * Returns all the shadow generators associated to this light
   * @returns
   */
  getShadowGenerators() {
    return this._shadowGenerators;
  }
  /**
   * Returns a Vector3, the absolute light position in the World.
   * @returns the world space position of the light
   */
  getAbsolutePosition() {
    return Vector3.Zero();
  }
  /**
   * Specifies if the light will affect the passed mesh.
   * @param mesh The mesh to test against the light
   * @returns true the mesh is affected otherwise, false.
   */
  canAffectMesh(mesh) {
    if (!mesh) {
      return true;
    }
    if (this.includedOnlyMeshes && this.includedOnlyMeshes.length > 0 && this.includedOnlyMeshes.indexOf(mesh) === -1) {
      return false;
    }
    if (this.excludedMeshes && this.excludedMeshes.length > 0 && this.excludedMeshes.indexOf(mesh) !== -1) {
      return false;
    }
    if (this.includeOnlyWithLayerMask !== 0 && (this.includeOnlyWithLayerMask & mesh.layerMask) === 0) {
      return false;
    }
    if (this.excludeWithLayerMask !== 0 && this.excludeWithLayerMask & mesh.layerMask) {
      return false;
    }
    return true;
  }
  /**
   * Releases resources associated with this node.
   * @param doNotRecurse Set to true to not recurse into each children (recurse into each children by default)
   * @param disposeMaterialAndTextures Set to true to also dispose referenced materials and textures (false by default)
   */
  dispose(doNotRecurse, disposeMaterialAndTextures = false) {
    if (this._shadowGenerators) {
      const iterator = this._shadowGenerators.values();
      for (let key = iterator.next(); key.done !== true; key = iterator.next()) {
        const shadowGenerator = key.value;
        shadowGenerator.dispose();
      }
      this._shadowGenerators = null;
    }
    this.getScene().stopAnimation(this);
    if (this._parentContainer) {
      const index = this._parentContainer.lights.indexOf(this);
      if (index > -1) {
        this._parentContainer.lights.splice(index, 1);
      }
      this._parentContainer = null;
    }
    for (const mesh of this.getScene().meshes) {
      mesh._removeLightSource(this, true);
    }
    this._uniformBuffer.dispose();
    this.getScene().removeLight(this);
    super.dispose(doNotRecurse, disposeMaterialAndTextures);
  }
  /**
   * Returns the light type ID (integer).
   * @returns The light Type id as a constant defines in Light.LIGHTTYPEID_x
   */
  getTypeID() {
    return 0;
  }
  /**
   * Returns the intensity scaled by the Photometric Scale according to the light type and intensity mode.
   * @returns the scaled intensity in intensity mode unit
   */
  getScaledIntensity() {
    return this._photometricScale * this.intensity;
  }
  /**
   * Returns a new Light object, named "name", from the current one.
   * @param name The name of the cloned light
   * @param newParent The parent of this light, if it has one
   * @returns the new created light
   */
  clone(name66, newParent = null) {
    const constructor = _Light.GetConstructorFromName(this.getTypeID(), name66, this.getScene());
    if (!constructor) {
      return null;
    }
    const clonedLight = SerializationHelper.Clone(constructor, this);
    if (name66) {
      clonedLight.name = name66;
    }
    if (newParent) {
      clonedLight.parent = newParent;
    }
    clonedLight.setEnabled(this.isEnabled());
    this.onClonedObservable.notifyObservers(clonedLight);
    return clonedLight;
  }
  /**
   * Serializes the current light into a Serialization object.
   * @returns the serialized object.
   */
  serialize() {
    const serializationObject = SerializationHelper.Serialize(this);
    serializationObject.uniqueId = this.uniqueId;
    serializationObject.type = this.getTypeID();
    if (this.parent) {
      this.parent._serializeAsParent(serializationObject);
    }
    if (this.excludedMeshes.length > 0) {
      serializationObject.excludedMeshesIds = [];
      this.excludedMeshes.forEach((mesh) => {
        serializationObject.excludedMeshesIds.push(mesh.id);
      });
    }
    if (this.includedOnlyMeshes.length > 0) {
      serializationObject.includedOnlyMeshesIds = [];
      this.includedOnlyMeshes.forEach((mesh) => {
        serializationObject.includedOnlyMeshesIds.push(mesh.id);
      });
    }
    SerializationHelper.AppendSerializedAnimations(this, serializationObject);
    serializationObject.ranges = this.serializeAnimationRanges();
    serializationObject.isEnabled = this.isEnabled();
    return serializationObject;
  }
  /**
   * Creates a new typed light from the passed type (integer) : point light = 0, directional light = 1, spot light = 2, hemispheric light = 3.
   * This new light is named "name" and added to the passed scene.
   * @param type Type according to the types available in Light.LIGHTTYPEID_x
   * @param name The friendly name of the light
   * @param scene The scene the new light will belong to
   * @returns the constructor function
   */
  static GetConstructorFromName(type, name66, scene) {
    const constructorFunc = Node.Construct("Light_Type_" + type, name66, scene);
    if (constructorFunc) {
      return constructorFunc;
    }
    return null;
  }
  /**
   * Parses the passed "parsedLight" and returns a new instanced Light from this parsing.
   * @param parsedLight The JSON representation of the light
   * @param scene The scene to create the parsed light in
   * @returns the created light after parsing
   */
  static Parse(parsedLight, scene) {
    const constructor = _Light.GetConstructorFromName(parsedLight.type, parsedLight.name, scene);
    if (!constructor) {
      return null;
    }
    const light = SerializationHelper.Parse(constructor, parsedLight, scene);
    if (parsedLight.excludedMeshesIds) {
      light._excludedMeshesIds = parsedLight.excludedMeshesIds;
    }
    if (parsedLight.includedOnlyMeshesIds) {
      light._includedOnlyMeshesIds = parsedLight.includedOnlyMeshesIds;
    }
    if (parsedLight.parentId !== void 0) {
      light._waitingParentId = parsedLight.parentId;
    }
    if (parsedLight.parentInstanceIndex !== void 0) {
      light._waitingParentInstanceIndex = parsedLight.parentInstanceIndex;
    }
    if (parsedLight.falloffType !== void 0) {
      light.falloffType = parsedLight.falloffType;
    }
    if (parsedLight.lightmapMode !== void 0) {
      light.lightmapMode = parsedLight.lightmapMode;
    }
    if (parsedLight.animations) {
      for (let animationIndex = 0; animationIndex < parsedLight.animations.length; animationIndex++) {
        const parsedAnimation = parsedLight.animations[animationIndex];
        const internalClass = GetClass("BABYLON.Animation");
        if (internalClass) {
          light.animations.push(internalClass.Parse(parsedAnimation));
        }
      }
      Node.ParseAnimationRanges(light, parsedLight, scene);
    }
    if (parsedLight.autoAnimate) {
      scene.beginAnimation(light, parsedLight.autoAnimateFrom, parsedLight.autoAnimateTo, parsedLight.autoAnimateLoop, parsedLight.autoAnimateSpeed || 1);
    }
    if (parsedLight.isEnabled !== void 0) {
      light.setEnabled(parsedLight.isEnabled);
    }
    return light;
  }
  _hookArrayForExcluded(array) {
    const oldPush = array.push;
    array.push = (...items) => {
      const result = oldPush.apply(array, items);
      for (const item of items) {
        item._resyncLightSource(this);
      }
      return result;
    };
    const oldSplice = array.splice;
    array.splice = (index, deleteCount) => {
      const deleted = oldSplice.apply(array, [index, deleteCount]);
      for (const item of deleted) {
        item._resyncLightSource(this);
      }
      return deleted;
    };
    for (const item of array) {
      item._resyncLightSource(this);
    }
  }
  _hookArrayForIncludedOnly(array) {
    const oldPush = array.push;
    array.push = (...items) => {
      const result = oldPush.apply(array, items);
      this._resyncMeshes();
      return result;
    };
    const oldSplice = array.splice;
    array.splice = (index, deleteCount) => {
      const deleted = oldSplice.apply(array, [index, deleteCount]);
      this._resyncMeshes();
      return deleted;
    };
    this._resyncMeshes();
  }
  _resyncMeshes() {
    for (const mesh of this.getScene().meshes) {
      mesh._resyncLightSource(this);
    }
  }
  /**
   * Forces the meshes to update their light related information in their rendering used effects
   * @internal Internal Use Only
   */
  _markMeshesAsLightDirty() {
    for (const mesh of this.getScene().meshes) {
      if (mesh.lightSources.indexOf(this) !== -1) {
        mesh._markSubMeshesAsLightDirty();
      }
    }
  }
  /**
   * Recomputes the cached photometric scale if needed.
   */
  _computePhotometricScale() {
    this._photometricScale = this._getPhotometricScale();
    this.getScene().resetCachedMaterial();
  }
  /**
   * @returns the Photometric Scale according to the light type and intensity mode.
   */
  _getPhotometricScale() {
    let photometricScale = 0;
    const lightTypeID = this.getTypeID();
    let photometricMode = this.intensityMode;
    if (photometricMode === _Light.INTENSITYMODE_AUTOMATIC) {
      if (lightTypeID === _Light.LIGHTTYPEID_DIRECTIONALLIGHT) {
        photometricMode = _Light.INTENSITYMODE_ILLUMINANCE;
      } else {
        photometricMode = _Light.INTENSITYMODE_LUMINOUSINTENSITY;
      }
    }
    switch (lightTypeID) {
      case _Light.LIGHTTYPEID_POINTLIGHT:
      case _Light.LIGHTTYPEID_SPOTLIGHT:
        switch (photometricMode) {
          case _Light.INTENSITYMODE_LUMINOUSPOWER:
            photometricScale = 1 / (4 * Math.PI);
            break;
          case _Light.INTENSITYMODE_LUMINOUSINTENSITY:
            photometricScale = 1;
            break;
          case _Light.INTENSITYMODE_LUMINANCE:
            photometricScale = this.radius * this.radius;
            break;
        }
        break;
      case _Light.LIGHTTYPEID_DIRECTIONALLIGHT:
        switch (photometricMode) {
          case _Light.INTENSITYMODE_ILLUMINANCE:
            photometricScale = 1;
            break;
          case _Light.INTENSITYMODE_LUMINANCE: {
            let apexAngleRadians = this.radius;
            apexAngleRadians = Math.max(apexAngleRadians, 1e-3);
            const solidAngle = 2 * Math.PI * (1 - Math.cos(apexAngleRadians));
            photometricScale = solidAngle;
            break;
          }
        }
        break;
      case _Light.LIGHTTYPEID_HEMISPHERICLIGHT:
        photometricScale = 1;
        break;
    }
    return photometricScale;
  }
  /**
   * Reorder the light in the scene according to their defined priority.
   * @internal Internal Use Only
   */
  _reorderLightsInScene() {
    const scene = this.getScene();
    if (this._renderPriority != 0) {
      scene.requireLightSorting = true;
    }
    this.getScene().sortLightsByPriority();
  }
};
Light.FALLOFF_DEFAULT = LightConstants.FALLOFF_DEFAULT;
Light.FALLOFF_PHYSICAL = LightConstants.FALLOFF_PHYSICAL;
Light.FALLOFF_GLTF = LightConstants.FALLOFF_GLTF;
Light.FALLOFF_STANDARD = LightConstants.FALLOFF_STANDARD;
Light.LIGHTMAP_DEFAULT = LightConstants.LIGHTMAP_DEFAULT;
Light.LIGHTMAP_SPECULAR = LightConstants.LIGHTMAP_SPECULAR;
Light.LIGHTMAP_SHADOWSONLY = LightConstants.LIGHTMAP_SHADOWSONLY;
Light.INTENSITYMODE_AUTOMATIC = LightConstants.INTENSITYMODE_AUTOMATIC;
Light.INTENSITYMODE_LUMINOUSPOWER = LightConstants.INTENSITYMODE_LUMINOUSPOWER;
Light.INTENSITYMODE_LUMINOUSINTENSITY = LightConstants.INTENSITYMODE_LUMINOUSINTENSITY;
Light.INTENSITYMODE_ILLUMINANCE = LightConstants.INTENSITYMODE_ILLUMINANCE;
Light.INTENSITYMODE_LUMINANCE = LightConstants.INTENSITYMODE_LUMINANCE;
Light.LIGHTTYPEID_POINTLIGHT = LightConstants.LIGHTTYPEID_POINTLIGHT;
Light.LIGHTTYPEID_DIRECTIONALLIGHT = LightConstants.LIGHTTYPEID_DIRECTIONALLIGHT;
Light.LIGHTTYPEID_SPOTLIGHT = LightConstants.LIGHTTYPEID_SPOTLIGHT;
Light.LIGHTTYPEID_HEMISPHERICLIGHT = LightConstants.LIGHTTYPEID_HEMISPHERICLIGHT;
__decorate([
  serializeAsColor3()
], Light.prototype, "diffuse", void 0);
__decorate([
  serializeAsColor3()
], Light.prototype, "specular", void 0);
__decorate([
  serialize()
], Light.prototype, "falloffType", void 0);
__decorate([
  serialize()
], Light.prototype, "intensity", void 0);
__decorate([
  serialize()
], Light.prototype, "range", null);
__decorate([
  serialize()
], Light.prototype, "intensityMode", null);
__decorate([
  serialize()
], Light.prototype, "radius", null);
__decorate([
  serialize()
], Light.prototype, "_renderPriority", void 0);
__decorate([
  expandToProperty("_reorderLightsInScene")
], Light.prototype, "renderPriority", void 0);
__decorate([
  serialize("shadowEnabled")
], Light.prototype, "_shadowEnabled", void 0);
__decorate([
  serialize("excludeWithLayerMask")
], Light.prototype, "_excludeWithLayerMask", void 0);
__decorate([
  serialize("includeOnlyWithLayerMask")
], Light.prototype, "_includeOnlyWithLayerMask", void 0);
__decorate([
  serialize("lightmapMode")
], Light.prototype, "_lightmapMode", void 0);

// ../../node_modules/@babylonjs/core/Lights/shadowLight.js
var ShadowLight = class extends Light {
  constructor() {
    super(...arguments);
    this._needProjectionMatrixCompute = true;
    this._viewMatrix = Matrix.Identity();
    this._projectionMatrix = Matrix.Identity();
  }
  _setPosition(value) {
    this._position = value;
  }
  /**
   * Sets the position the shadow will be casted from. Also use as the light position for both
   * point and spot lights.
   */
  get position() {
    return this._position;
  }
  /**
   * Sets the position the shadow will be casted from. Also use as the light position for both
   * point and spot lights.
   */
  set position(value) {
    this._setPosition(value);
  }
  _setDirection(value) {
    this._direction = value;
  }
  /**
   * In 2d mode (needCube being false), gets the direction used to cast the shadow.
   * Also use as the light direction on spot and directional lights.
   */
  get direction() {
    return this._direction;
  }
  /**
   * In 2d mode (needCube being false), sets the direction used to cast the shadow.
   * Also use as the light direction on spot and directional lights.
   */
  set direction(value) {
    this._setDirection(value);
  }
  /**
   * Gets the shadow projection clipping minimum z value.
   */
  get shadowMinZ() {
    return this._shadowMinZ;
  }
  /**
   * Sets the shadow projection clipping minimum z value.
   */
  set shadowMinZ(value) {
    this._shadowMinZ = value;
    this.forceProjectionMatrixCompute();
  }
  /**
   * Sets the shadow projection clipping maximum z value.
   */
  get shadowMaxZ() {
    return this._shadowMaxZ;
  }
  /**
   * Gets the shadow projection clipping maximum z value.
   */
  set shadowMaxZ(value) {
    this._shadowMaxZ = value;
    this.forceProjectionMatrixCompute();
  }
  /**
   * Computes the transformed information (transformedPosition and transformedDirection in World space) of the current light
   * @returns true if the information has been computed, false if it does not need to (no parenting)
   */
  computeTransformedInformation() {
    if (this.parent && this.parent.getWorldMatrix) {
      if (!this.transformedPosition) {
        this.transformedPosition = Vector3.Zero();
      }
      Vector3.TransformCoordinatesToRef(this.position, this.parent.getWorldMatrix(), this.transformedPosition);
      if (this.direction) {
        if (!this.transformedDirection) {
          this.transformedDirection = Vector3.Zero();
        }
        Vector3.TransformNormalToRef(this.direction, this.parent.getWorldMatrix(), this.transformedDirection);
      }
      return true;
    }
    return false;
  }
  /**
   * Return the depth scale used for the shadow map.
   * @returns the depth scale.
   */
  getDepthScale() {
    return 50;
  }
  /**
   * Get the direction to use to render the shadow map. In case of cube texture, the face index can be passed.
   * @param faceIndex The index of the face we are computed the direction to generate shadow
   * @returns The set direction in 2d mode otherwise the direction to the cubemap face if needCube() is true
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  getShadowDirection(faceIndex) {
    return this.transformedDirection ? this.transformedDirection : this.direction;
  }
  /**
   * If computeTransformedInformation has been called, returns the ShadowLight absolute position in the world. Otherwise, returns the local position.
   * @returns the position vector in world space
   */
  getAbsolutePosition() {
    return this.transformedPosition ? this.transformedPosition : this.position;
  }
  /**
   * Sets the ShadowLight direction toward the passed target.
   * @param target The point to target in local space
   * @returns the updated ShadowLight direction
   */
  setDirectionToTarget(target) {
    this.direction = Vector3.Normalize(target.subtract(this.position));
    return this.direction;
  }
  /**
   * Returns the light rotation in euler definition.
   * @returns the x y z rotation in local space.
   */
  getRotation() {
    this.direction.normalize();
    const xaxis = Vector3.Cross(this.direction, Axis.Y);
    const yaxis = Vector3.Cross(xaxis, this.direction);
    return Vector3.RotationFromAxis(xaxis, yaxis, this.direction);
  }
  /**
   * Returns whether or not the shadow generation require a cube texture or a 2d texture.
   * @returns true if a cube texture needs to be use
   */
  needCube() {
    return false;
  }
  /**
   * Detects if the projection matrix requires to be recomputed this frame.
   * @returns true if it requires to be recomputed otherwise, false.
   */
  needProjectionMatrixCompute() {
    return this._needProjectionMatrixCompute;
  }
  /**
   * Forces the shadow generator to recompute the projection matrix even if position and direction did not changed.
   */
  forceProjectionMatrixCompute() {
    this._needProjectionMatrixCompute = true;
  }
  /** @internal */
  _initCache() {
    super._initCache();
    this._cache.position = Vector3.Zero();
  }
  /** @internal */
  _isSynchronized() {
    if (!this._cache.position.equals(this.position)) {
      return false;
    }
    return true;
  }
  /**
   * Computes the world matrix of the node
   * @param force defines if the cache version should be invalidated forcing the world matrix to be created from scratch
   * @returns the world matrix
   */
  computeWorldMatrix(force) {
    if (!force && this.isSynchronized()) {
      this._currentRenderId = this.getScene().getRenderId();
      return this._worldMatrix;
    }
    this._updateCache();
    this._cache.position.copyFrom(this.position);
    if (!this._worldMatrix) {
      this._worldMatrix = Matrix.Identity();
    }
    Matrix.TranslationToRef(this.position.x, this.position.y, this.position.z, this._worldMatrix);
    if (this.parent && this.parent.getWorldMatrix) {
      this._worldMatrix.multiplyToRef(this.parent.getWorldMatrix(), this._worldMatrix);
      this._markSyncedWithParent();
    }
    this._worldMatrixDeterminantIsDirty = true;
    return this._worldMatrix;
  }
  /**
   * Gets the minZ used for shadow according to both the scene and the light.
   * @param activeCamera The camera we are returning the min for
   * @returns the depth min z
   */
  getDepthMinZ(activeCamera) {
    return this.shadowMinZ !== void 0 ? this.shadowMinZ : activeCamera.minZ;
  }
  /**
   * Gets the maxZ used for shadow according to both the scene and the light.
   * @param activeCamera The camera we are returning the max for
   * @returns the depth max z
   */
  getDepthMaxZ(activeCamera) {
    return this.shadowMaxZ !== void 0 ? this.shadowMaxZ : activeCamera.maxZ;
  }
  /**
   * Sets the shadow projection matrix in parameter to the generated projection matrix.
   * @param matrix The matrix to updated with the projection information
   * @param viewMatrix The transform matrix of the light
   * @param renderList The list of mesh to render in the map
   * @returns The current light
   */
  setShadowProjectionMatrix(matrix, viewMatrix, renderList) {
    if (this.customProjectionMatrixBuilder) {
      this.customProjectionMatrixBuilder(viewMatrix, renderList, matrix);
    } else {
      this._setDefaultShadowProjectionMatrix(matrix, viewMatrix, renderList);
    }
    return this;
  }
  /** @internal */
  _syncParentEnabledState() {
    super._syncParentEnabledState();
    if (!this.parent || !this.parent.getWorldMatrix) {
      this.transformedPosition = null;
      this.transformedDirection = null;
    }
  }
  /**
   * Returns the view matrix.
   * @param faceIndex The index of the face for which we want to extract the view matrix. Only used for point light types.
   * @returns The view matrix. Can be null, if a view matrix cannot be defined for the type of light considered (as for a hemispherical light, for example).
   */
  getViewMatrix(faceIndex) {
    const lightDirection = TmpVectors.Vector3[0];
    let lightPosition = this.position;
    if (this.computeTransformedInformation()) {
      lightPosition = this.transformedPosition;
    }
    Vector3.NormalizeToRef(this.getShadowDirection(faceIndex), lightDirection);
    if (Math.abs(Vector3.Dot(lightDirection, Vector3.Up())) === 1) {
      lightDirection.z = 1e-13;
    }
    const lightTarget = TmpVectors.Vector3[1];
    lightPosition.addToRef(lightDirection, lightTarget);
    Matrix.LookAtLHToRef(lightPosition, lightTarget, Vector3.Up(), this._viewMatrix);
    return this._viewMatrix;
  }
  /**
   * Returns the projection matrix.
   * Note that viewMatrix and renderList are optional and are only used by lights that calculate the projection matrix from a list of meshes (e.g. directional lights with automatic extents calculation).
   * @param viewMatrix The view transform matrix of the light (optional).
   * @param renderList The list of meshes to take into account when calculating the projection matrix (optional).
   * @returns The projection matrix. Can be null, if a projection matrix cannot be defined for the type of light considered (as for a hemispherical light, for example).
   */
  getProjectionMatrix(viewMatrix, renderList) {
    this.setShadowProjectionMatrix(this._projectionMatrix, viewMatrix ?? this._viewMatrix, renderList ?? []);
    return this._projectionMatrix;
  }
};
__decorate([
  serializeAsVector3()
], ShadowLight.prototype, "position", null);
__decorate([
  serializeAsVector3()
], ShadowLight.prototype, "direction", null);
__decorate([
  serialize()
], ShadowLight.prototype, "shadowMinZ", null);
__decorate([
  serialize()
], ShadowLight.prototype, "shadowMaxZ", null);

// ../../node_modules/@babylonjs/core/Lights/directionalLight.js
Node.AddNodeConstructor("Light_Type_1", (name66, scene) => {
  return () => new DirectionalLight(name66, Vector3.Zero(), scene);
});
var DirectionalLight = class extends ShadowLight {
  /**
   * Fix frustum size for the shadow generation. This is disabled if the value is 0.
   */
  get shadowFrustumSize() {
    return this._shadowFrustumSize;
  }
  /**
   * Specifies a fix frustum size for the shadow generation.
   */
  set shadowFrustumSize(value) {
    this._shadowFrustumSize = value;
    this.forceProjectionMatrixCompute();
  }
  /**
   * Gets the shadow projection scale against the optimal computed one.
   * 0.1 by default which means that the projection window is increase by 10% from the optimal size.
   * This does not impact in fixed frustum size (shadowFrustumSize being set)
   */
  get shadowOrthoScale() {
    return this._shadowOrthoScale;
  }
  /**
   * Sets the shadow projection scale against the optimal computed one.
   * 0.1 by default which means that the projection window is increase by 10% from the optimal size.
   * This does not impact in fixed frustum size (shadowFrustumSize being set)
   */
  set shadowOrthoScale(value) {
    this._shadowOrthoScale = value;
    this.forceProjectionMatrixCompute();
  }
  /**
   * Gets or sets the orthoLeft property used to build the light frustum
   */
  get orthoLeft() {
    return this._orthoLeft;
  }
  set orthoLeft(left) {
    this._orthoLeft = left;
  }
  /**
   * Gets or sets the orthoRight property used to build the light frustum
   */
  get orthoRight() {
    return this._orthoRight;
  }
  set orthoRight(right) {
    this._orthoRight = right;
  }
  /**
   * Gets or sets the orthoTop property used to build the light frustum
   */
  get orthoTop() {
    return this._orthoTop;
  }
  set orthoTop(top) {
    this._orthoTop = top;
  }
  /**
   * Gets or sets the orthoBottom property used to build the light frustum
   */
  get orthoBottom() {
    return this._orthoBottom;
  }
  set orthoBottom(bottom) {
    this._orthoBottom = bottom;
  }
  /**
   * Creates a DirectionalLight object in the scene, oriented towards the passed direction (Vector3).
   * The directional light is emitted from everywhere in the given direction.
   * It can cast shadows.
   * Documentation : https://doc.babylonjs.com/features/featuresDeepDive/lights/lights_introduction
   * @param name The friendly name of the light
   * @param direction The direction of the light
   * @param scene The scene the light belongs to
   */
  constructor(name66, direction, scene) {
    super(name66, scene);
    this._shadowFrustumSize = 0;
    this._shadowOrthoScale = 0.1;
    this.autoUpdateExtends = true;
    this.autoCalcShadowZBounds = false;
    this._orthoLeft = Number.MAX_VALUE;
    this._orthoRight = Number.MIN_VALUE;
    this._orthoTop = Number.MIN_VALUE;
    this._orthoBottom = Number.MAX_VALUE;
    this.position = direction.scale(-1);
    this.direction = direction;
  }
  /**
   * Returns the string "DirectionalLight".
   * @returns The class name
   */
  getClassName() {
    return "DirectionalLight";
  }
  /**
   * Returns the integer 1.
   * @returns The light Type id as a constant defines in Light.LIGHTTYPEID_x
   */
  getTypeID() {
    return Light.LIGHTTYPEID_DIRECTIONALLIGHT;
  }
  /**
   * Sets the passed matrix "matrix" as projection matrix for the shadows cast by the light according to the passed view matrix.
   * Returns the DirectionalLight Shadow projection matrix.
   * @param matrix
   * @param viewMatrix
   * @param renderList
   */
  _setDefaultShadowProjectionMatrix(matrix, viewMatrix, renderList) {
    if (this.shadowFrustumSize > 0) {
      this._setDefaultFixedFrustumShadowProjectionMatrix(matrix);
    } else {
      this._setDefaultAutoExtendShadowProjectionMatrix(matrix, viewMatrix, renderList);
    }
  }
  /**
   * Sets the passed matrix "matrix" as fixed frustum projection matrix for the shadows cast by the light according to the passed view matrix.
   * Returns the DirectionalLight Shadow projection matrix.
   * @param matrix
   */
  _setDefaultFixedFrustumShadowProjectionMatrix(matrix) {
    const activeCamera = this.getScene().activeCamera;
    if (!activeCamera) {
      return;
    }
    Matrix.OrthoLHToRef(this.shadowFrustumSize, this.shadowFrustumSize, this.shadowMinZ !== void 0 ? this.shadowMinZ : activeCamera.minZ, this.shadowMaxZ !== void 0 ? this.shadowMaxZ : activeCamera.maxZ, matrix, this.getScene().getEngine().isNDCHalfZRange);
  }
  /**
   * Sets the passed matrix "matrix" as auto extend projection matrix for the shadows cast by the light according to the passed view matrix.
   * Returns the DirectionalLight Shadow projection matrix.
   * @param matrix
   * @param viewMatrix
   * @param renderList
   */
  _setDefaultAutoExtendShadowProjectionMatrix(matrix, viewMatrix, renderList) {
    const activeCamera = this.getScene().activeCamera;
    if (!activeCamera) {
      return;
    }
    if (this.autoUpdateExtends || this._orthoLeft === Number.MAX_VALUE) {
      const tempVector3 = Vector3.Zero();
      this._orthoLeft = Number.MAX_VALUE;
      this._orthoRight = -Number.MAX_VALUE;
      this._orthoTop = -Number.MAX_VALUE;
      this._orthoBottom = Number.MAX_VALUE;
      let shadowMinZ = Number.MAX_VALUE;
      let shadowMaxZ = -Number.MAX_VALUE;
      for (let meshIndex = 0; meshIndex < renderList.length; meshIndex++) {
        const mesh = renderList[meshIndex];
        if (!mesh) {
          continue;
        }
        const boundingInfo = mesh.getBoundingInfo();
        const boundingBox = boundingInfo.boundingBox;
        for (let index = 0; index < boundingBox.vectorsWorld.length; index++) {
          Vector3.TransformCoordinatesToRef(boundingBox.vectorsWorld[index], viewMatrix, tempVector3);
          if (tempVector3.x < this._orthoLeft) {
            this._orthoLeft = tempVector3.x;
          }
          if (tempVector3.y < this._orthoBottom) {
            this._orthoBottom = tempVector3.y;
          }
          if (tempVector3.x > this._orthoRight) {
            this._orthoRight = tempVector3.x;
          }
          if (tempVector3.y > this._orthoTop) {
            this._orthoTop = tempVector3.y;
          }
          if (this.autoCalcShadowZBounds) {
            if (tempVector3.z < shadowMinZ) {
              shadowMinZ = tempVector3.z;
            }
            if (tempVector3.z > shadowMaxZ) {
              shadowMaxZ = tempVector3.z;
            }
          }
        }
      }
      if (this.autoCalcShadowZBounds) {
        this._shadowMinZ = shadowMinZ;
        this._shadowMaxZ = shadowMaxZ;
      }
    }
    const xOffset = this._orthoRight - this._orthoLeft;
    const yOffset = this._orthoTop - this._orthoBottom;
    const minZ = this.shadowMinZ !== void 0 ? this.shadowMinZ : activeCamera.minZ;
    const maxZ = this.shadowMaxZ !== void 0 ? this.shadowMaxZ : activeCamera.maxZ;
    const useReverseDepthBuffer = this.getScene().getEngine().useReverseDepthBuffer;
    Matrix.OrthoOffCenterLHToRef(this._orthoLeft - xOffset * this.shadowOrthoScale, this._orthoRight + xOffset * this.shadowOrthoScale, this._orthoBottom - yOffset * this.shadowOrthoScale, this._orthoTop + yOffset * this.shadowOrthoScale, useReverseDepthBuffer ? maxZ : minZ, useReverseDepthBuffer ? minZ : maxZ, matrix, this.getScene().getEngine().isNDCHalfZRange);
  }
  _buildUniformLayout() {
    this._uniformBuffer.addUniform("vLightData", 4);
    this._uniformBuffer.addUniform("vLightDiffuse", 4);
    this._uniformBuffer.addUniform("vLightSpecular", 4);
    this._uniformBuffer.addUniform("shadowsInfo", 3);
    this._uniformBuffer.addUniform("depthValues", 2);
    this._uniformBuffer.create();
  }
  /**
   * Sets the passed Effect object with the DirectionalLight transformed position (or position if not parented) and the passed name.
   * @param effect The effect to update
   * @param lightIndex The index of the light in the effect to update
   * @returns The directional light
   */
  transferToEffect(effect, lightIndex) {
    if (this.computeTransformedInformation()) {
      this._uniformBuffer.updateFloat4("vLightData", this.transformedDirection.x, this.transformedDirection.y, this.transformedDirection.z, 1, lightIndex);
      return this;
    }
    this._uniformBuffer.updateFloat4("vLightData", this.direction.x, this.direction.y, this.direction.z, 1, lightIndex);
    return this;
  }
  transferToNodeMaterialEffect(effect, lightDataUniformName) {
    if (this.computeTransformedInformation()) {
      effect.setFloat3(lightDataUniformName, this.transformedDirection.x, this.transformedDirection.y, this.transformedDirection.z);
      return this;
    }
    effect.setFloat3(lightDataUniformName, this.direction.x, this.direction.y, this.direction.z);
    return this;
  }
  /**
   * Gets the minZ used for shadow according to both the scene and the light.
   *
   * Values are fixed on directional lights as it relies on an ortho projection hence the need to convert being
   * -1 and 1 to 0 and 1 doing (depth + min) / (min + max) -> (depth + 1) / (1 + 1) -> (depth * 0.5) + 0.5.
   * (when not using reverse depth buffer / NDC half Z range)
   * @param activeCamera The camera we are returning the min for
   * @returns the depth min z
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  getDepthMinZ(activeCamera) {
    const engine = this._scene.getEngine();
    return !engine.useReverseDepthBuffer && engine.isNDCHalfZRange ? 0 : 1;
  }
  /**
   * Gets the maxZ used for shadow according to both the scene and the light.
   *
   * Values are fixed on directional lights as it relies on an ortho projection hence the need to convert being
   * -1 and 1 to 0 and 1 doing (depth + min) / (min + max) -> (depth + 1) / (1 + 1) -> (depth * 0.5) + 0.5.
   * (when not using reverse depth buffer / NDC half Z range)
   * @param activeCamera The camera we are returning the max for
   * @returns the depth max z
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  getDepthMaxZ(activeCamera) {
    const engine = this._scene.getEngine();
    return engine.useReverseDepthBuffer && engine.isNDCHalfZRange ? 0 : 1;
  }
  /**
   * Prepares the list of defines specific to the light type.
   * @param defines the list of defines
   * @param lightIndex defines the index of the light for the effect
   */
  prepareLightSpecificDefines(defines, lightIndex) {
    defines["DIRLIGHT" + lightIndex] = true;
  }
};
__decorate([
  serialize()
], DirectionalLight.prototype, "shadowFrustumSize", null);
__decorate([
  serialize()
], DirectionalLight.prototype, "shadowOrthoScale", null);
__decorate([
  serialize()
], DirectionalLight.prototype, "autoUpdateExtends", void 0);
__decorate([
  serialize()
], DirectionalLight.prototype, "autoCalcShadowZBounds", void 0);
__decorate([
  serialize("orthoLeft")
], DirectionalLight.prototype, "_orthoLeft", void 0);
__decorate([
  serialize("orthoRight")
], DirectionalLight.prototype, "_orthoRight", void 0);
__decorate([
  serialize("orthoTop")
], DirectionalLight.prototype, "_orthoTop", void 0);
__decorate([
  serialize("orthoBottom")
], DirectionalLight.prototype, "_orthoBottom", void 0);

// ../../node_modules/@babylonjs/core/Materials/prePassConfiguration.js
var PrePassConfiguration = class {
  constructor() {
    this.previousWorldMatrices = {};
    this.previousBones = {};
  }
  /**
   * Add the required uniforms to the current list.
   * @param uniforms defines the current uniform list.
   */
  static AddUniforms(uniforms) {
    uniforms.push("previousWorld", "previousViewProjection", "mPreviousBones");
  }
  /**
   * Add the required samplers to the current list.
   * @param samplers defines the current sampler list.
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  static AddSamplers(samplers) {
  }
  /**
   * Binds the material data.
   * @param effect defines the effect to update
   * @param scene defines the scene the material belongs to.
   * @param mesh The mesh
   * @param world World matrix of this mesh
   * @param isFrozen Is the material frozen
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  bindForSubMesh(effect, scene, mesh, world, isFrozen) {
    if (scene.prePassRenderer && scene.prePassRenderer.enabled && scene.prePassRenderer.currentRTisSceneRT) {
      if (scene.prePassRenderer.getIndex(2) !== -1) {
        if (!this.previousWorldMatrices[mesh.uniqueId]) {
          this.previousWorldMatrices[mesh.uniqueId] = world.clone();
        }
        if (!this.previousViewProjection) {
          this.previousViewProjection = scene.getTransformMatrix().clone();
          this.currentViewProjection = scene.getTransformMatrix().clone();
        }
        const engine = scene.getEngine();
        if (this.currentViewProjection.updateFlag !== scene.getTransformMatrix().updateFlag) {
          this._lastUpdateFrameId = engine.frameId;
          this.previousViewProjection.copyFrom(this.currentViewProjection);
          this.currentViewProjection.copyFrom(scene.getTransformMatrix());
        } else if (this._lastUpdateFrameId !== engine.frameId) {
          this._lastUpdateFrameId = engine.frameId;
          this.previousViewProjection.copyFrom(this.currentViewProjection);
        }
        effect.setMatrix("previousWorld", this.previousWorldMatrices[mesh.uniqueId]);
        effect.setMatrix("previousViewProjection", this.previousViewProjection);
        this.previousWorldMatrices[mesh.uniqueId] = world.clone();
      }
    }
  }
};

// ../../node_modules/@babylonjs/core/Materials/materialDefines.js
var MaterialDefines = class {
  /**
   * Creates a new instance
   * @param externalProperties list of external properties to inject into the object
   */
  constructor(externalProperties) {
    this._keys = [];
    this._isDirty = true;
    this._areLightsDirty = true;
    this._areLightsDisposed = false;
    this._areAttributesDirty = true;
    this._areTexturesDirty = true;
    this._areFresnelDirty = true;
    this._areMiscDirty = true;
    this._arePrePassDirty = true;
    this._areImageProcessingDirty = true;
    this._normals = false;
    this._uvs = false;
    this._needNormals = false;
    this._needUVs = false;
    this._externalProperties = externalProperties;
    if (externalProperties) {
      for (const prop in externalProperties) {
        if (Object.prototype.hasOwnProperty.call(externalProperties, prop)) {
          this._setDefaultValue(prop);
        }
      }
    }
  }
  /**
   * Specifies if the material needs to be re-calculated
   */
  get isDirty() {
    return this._isDirty;
  }
  /**
   * Marks the material to indicate that it has been re-calculated
   */
  markAsProcessed() {
    this._isDirty = false;
    this._areAttributesDirty = false;
    this._areTexturesDirty = false;
    this._areFresnelDirty = false;
    this._areLightsDirty = false;
    this._areLightsDisposed = false;
    this._areMiscDirty = false;
    this._arePrePassDirty = false;
    this._areImageProcessingDirty = false;
  }
  /**
   * Marks the material to indicate that it needs to be re-calculated
   */
  markAsUnprocessed() {
    this._isDirty = true;
  }
  /**
   * Marks the material to indicate all of its defines need to be re-calculated
   */
  markAllAsDirty() {
    this._areTexturesDirty = true;
    this._areAttributesDirty = true;
    this._areLightsDirty = true;
    this._areFresnelDirty = true;
    this._areMiscDirty = true;
    this._arePrePassDirty = false;
    this._areImageProcessingDirty = true;
    this._isDirty = true;
  }
  /**
   * Marks the material to indicate that image processing needs to be re-calculated
   */
  markAsImageProcessingDirty() {
    this._areImageProcessingDirty = true;
    this._isDirty = true;
  }
  /**
   * Marks the material to indicate the lights need to be re-calculated
   * @param disposed Defines whether the light is dirty due to dispose or not
   */
  markAsLightDirty(disposed = false) {
    this._areLightsDirty = true;
    this._areLightsDisposed = this._areLightsDisposed || disposed;
    this._isDirty = true;
  }
  /**
   * Marks the attribute state as changed
   */
  markAsAttributesDirty() {
    this._areAttributesDirty = true;
    this._isDirty = true;
  }
  /**
   * Marks the texture state as changed
   */
  markAsTexturesDirty() {
    this._areTexturesDirty = true;
    this._isDirty = true;
  }
  /**
   * Marks the fresnel state as changed
   */
  markAsFresnelDirty() {
    this._areFresnelDirty = true;
    this._isDirty = true;
  }
  /**
   * Marks the misc state as changed
   */
  markAsMiscDirty() {
    this._areMiscDirty = true;
    this._isDirty = true;
  }
  /**
   * Marks the prepass state as changed
   */
  markAsPrePassDirty() {
    this._arePrePassDirty = true;
    this._isDirty = true;
  }
  /**
   * Rebuilds the material defines
   */
  rebuild() {
    this._keys.length = 0;
    for (const key of Object.keys(this)) {
      if (key[0] === "_") {
        continue;
      }
      this._keys.push(key);
    }
    if (this._externalProperties) {
      for (const name66 in this._externalProperties) {
        if (this._keys.indexOf(name66) === -1) {
          this._keys.push(name66);
        }
      }
    }
  }
  /**
   * Specifies if two material defines are equal
   * @param other - A material define instance to compare to
   * @returns - Boolean indicating if the material defines are equal (true) or not (false)
   */
  isEqual(other) {
    if (this._keys.length !== other._keys.length) {
      return false;
    }
    for (let index = 0; index < this._keys.length; index++) {
      const prop = this._keys[index];
      if (this[prop] !== other[prop]) {
        return false;
      }
    }
    return true;
  }
  /**
   * Clones this instance's defines to another instance
   * @param other - material defines to clone values to
   */
  cloneTo(other) {
    if (this._keys.length !== other._keys.length) {
      other._keys = this._keys.slice(0);
    }
    for (let index = 0; index < this._keys.length; index++) {
      const prop = this._keys[index];
      other[prop] = this[prop];
    }
  }
  /**
   * Resets the material define values
   */
  reset() {
    this._keys.forEach((prop) => this._setDefaultValue(prop));
  }
  _setDefaultValue(prop) {
    const type = this._externalProperties?.[prop]?.type ?? typeof this[prop];
    const defValue = this._externalProperties?.[prop]?.default;
    switch (type) {
      case "number":
        this[prop] = defValue ?? 0;
        break;
      case "string":
        this[prop] = defValue ?? "";
        break;
      default:
        this[prop] = defValue ?? false;
        break;
    }
  }
  /**
   * Converts the material define values to a string
   * @returns - String of material define information
   */
  toString() {
    let result = "";
    for (let index = 0; index < this._keys.length; index++) {
      const prop = this._keys[index];
      const value = this[prop];
      const type = typeof value;
      switch (type) {
        case "number":
        case "string":
          result += "#define " + prop + " " + value + "\n";
          break;
        default:
          if (value) {
            result += "#define " + prop + "\n";
          }
          break;
      }
    }
    return result;
  }
};

// ../../node_modules/@babylonjs/core/Materials/pushMaterial.js
var PushMaterial = class extends Material {
  constructor(name66, scene, storeEffectOnSubMeshes = true) {
    super(name66, scene);
    this._normalMatrix = new Matrix();
    this._storeEffectOnSubMeshes = storeEffectOnSubMeshes;
  }
  getEffect() {
    return this._storeEffectOnSubMeshes ? this._activeEffect : super.getEffect();
  }
  isReady(mesh, useInstances) {
    if (!mesh) {
      return false;
    }
    if (!this._storeEffectOnSubMeshes) {
      return true;
    }
    if (!mesh.subMeshes || mesh.subMeshes.length === 0) {
      return true;
    }
    return this.isReadyForSubMesh(mesh, mesh.subMeshes[0], useInstances);
  }
  _isReadyForSubMesh(subMesh) {
    const defines = subMesh.materialDefines;
    if (!this.checkReadyOnEveryCall && subMesh.effect && defines) {
      if (defines._renderId === this.getScene().getRenderId()) {
        return true;
      }
    }
    return false;
  }
  /**
   * Binds the given world matrix to the active effect
   *
   * @param world the matrix to bind
   */
  bindOnlyWorldMatrix(world) {
    this._activeEffect.setMatrix("world", world);
  }
  /**
   * Binds the given normal matrix to the active effect
   *
   * @param normalMatrix the matrix to bind
   */
  bindOnlyNormalMatrix(normalMatrix) {
    this._activeEffect.setMatrix("normalMatrix", normalMatrix);
  }
  bind(world, mesh) {
    if (!mesh) {
      return;
    }
    this.bindForSubMesh(world, mesh, mesh.subMeshes[0]);
  }
  _afterBind(mesh, effect = null, subMesh) {
    super._afterBind(mesh, effect, subMesh);
    this.getScene()._cachedEffect = effect;
    if (subMesh) {
      subMesh._drawWrapper._forceRebindOnNextCall = false;
    } else {
      this._drawWrapper._forceRebindOnNextCall = false;
    }
  }
  _mustRebind(scene, effect, subMesh, visibility = 1) {
    return subMesh._drawWrapper._forceRebindOnNextCall || scene.isCachedMaterialInvalid(this, effect, visibility);
  }
  dispose(forceDisposeEffect, forceDisposeTextures, notBoundToMesh) {
    this._activeEffect = void 0;
    super.dispose(forceDisposeEffect, forceDisposeTextures, notBoundToMesh);
  }
};

// ../../node_modules/@babylonjs/core/Materials/materialFlags.js
var MaterialFlags = class {
  /**
   * Are diffuse textures enabled in the application.
   */
  static get DiffuseTextureEnabled() {
    return this._DiffuseTextureEnabled;
  }
  static set DiffuseTextureEnabled(value) {
    if (this._DiffuseTextureEnabled === value) {
      return;
    }
    this._DiffuseTextureEnabled = value;
    Engine.MarkAllMaterialsAsDirty(1);
  }
  /**
   * Are detail textures enabled in the application.
   */
  static get DetailTextureEnabled() {
    return this._DetailTextureEnabled;
  }
  static set DetailTextureEnabled(value) {
    if (this._DetailTextureEnabled === value) {
      return;
    }
    this._DetailTextureEnabled = value;
    Engine.MarkAllMaterialsAsDirty(1);
  }
  /**
   * Are decal maps enabled in the application.
   */
  static get DecalMapEnabled() {
    return this._DecalMapEnabled;
  }
  static set DecalMapEnabled(value) {
    if (this._DecalMapEnabled === value) {
      return;
    }
    this._DecalMapEnabled = value;
    Engine.MarkAllMaterialsAsDirty(1);
  }
  /**
   * Are ambient textures enabled in the application.
   */
  static get AmbientTextureEnabled() {
    return this._AmbientTextureEnabled;
  }
  static set AmbientTextureEnabled(value) {
    if (this._AmbientTextureEnabled === value) {
      return;
    }
    this._AmbientTextureEnabled = value;
    Engine.MarkAllMaterialsAsDirty(1);
  }
  /**
   * Are opacity textures enabled in the application.
   */
  static get OpacityTextureEnabled() {
    return this._OpacityTextureEnabled;
  }
  static set OpacityTextureEnabled(value) {
    if (this._OpacityTextureEnabled === value) {
      return;
    }
    this._OpacityTextureEnabled = value;
    Engine.MarkAllMaterialsAsDirty(1);
  }
  /**
   * Are reflection textures enabled in the application.
   */
  static get ReflectionTextureEnabled() {
    return this._ReflectionTextureEnabled;
  }
  static set ReflectionTextureEnabled(value) {
    if (this._ReflectionTextureEnabled === value) {
      return;
    }
    this._ReflectionTextureEnabled = value;
    Engine.MarkAllMaterialsAsDirty(1);
  }
  /**
   * Are emissive textures enabled in the application.
   */
  static get EmissiveTextureEnabled() {
    return this._EmissiveTextureEnabled;
  }
  static set EmissiveTextureEnabled(value) {
    if (this._EmissiveTextureEnabled === value) {
      return;
    }
    this._EmissiveTextureEnabled = value;
    Engine.MarkAllMaterialsAsDirty(1);
  }
  /**
   * Are specular textures enabled in the application.
   */
  static get SpecularTextureEnabled() {
    return this._SpecularTextureEnabled;
  }
  static set SpecularTextureEnabled(value) {
    if (this._SpecularTextureEnabled === value) {
      return;
    }
    this._SpecularTextureEnabled = value;
    Engine.MarkAllMaterialsAsDirty(1);
  }
  /**
   * Are bump textures enabled in the application.
   */
  static get BumpTextureEnabled() {
    return this._BumpTextureEnabled;
  }
  static set BumpTextureEnabled(value) {
    if (this._BumpTextureEnabled === value) {
      return;
    }
    this._BumpTextureEnabled = value;
    Engine.MarkAllMaterialsAsDirty(1);
  }
  /**
   * Are lightmap textures enabled in the application.
   */
  static get LightmapTextureEnabled() {
    return this._LightmapTextureEnabled;
  }
  static set LightmapTextureEnabled(value) {
    if (this._LightmapTextureEnabled === value) {
      return;
    }
    this._LightmapTextureEnabled = value;
    Engine.MarkAllMaterialsAsDirty(1);
  }
  /**
   * Are refraction textures enabled in the application.
   */
  static get RefractionTextureEnabled() {
    return this._RefractionTextureEnabled;
  }
  static set RefractionTextureEnabled(value) {
    if (this._RefractionTextureEnabled === value) {
      return;
    }
    this._RefractionTextureEnabled = value;
    Engine.MarkAllMaterialsAsDirty(1);
  }
  /**
   * Are color grading textures enabled in the application.
   */
  static get ColorGradingTextureEnabled() {
    return this._ColorGradingTextureEnabled;
  }
  static set ColorGradingTextureEnabled(value) {
    if (this._ColorGradingTextureEnabled === value) {
      return;
    }
    this._ColorGradingTextureEnabled = value;
    Engine.MarkAllMaterialsAsDirty(1);
  }
  /**
   * Are fresnels enabled in the application.
   */
  static get FresnelEnabled() {
    return this._FresnelEnabled;
  }
  static set FresnelEnabled(value) {
    if (this._FresnelEnabled === value) {
      return;
    }
    this._FresnelEnabled = value;
    Engine.MarkAllMaterialsAsDirty(4);
  }
  /**
   * Are clear coat textures enabled in the application.
   */
  static get ClearCoatTextureEnabled() {
    return this._ClearCoatTextureEnabled;
  }
  static set ClearCoatTextureEnabled(value) {
    if (this._ClearCoatTextureEnabled === value) {
      return;
    }
    this._ClearCoatTextureEnabled = value;
    Engine.MarkAllMaterialsAsDirty(1);
  }
  /**
   * Are clear coat bump textures enabled in the application.
   */
  static get ClearCoatBumpTextureEnabled() {
    return this._ClearCoatBumpTextureEnabled;
  }
  static set ClearCoatBumpTextureEnabled(value) {
    if (this._ClearCoatBumpTextureEnabled === value) {
      return;
    }
    this._ClearCoatBumpTextureEnabled = value;
    Engine.MarkAllMaterialsAsDirty(1);
  }
  /**
   * Are clear coat tint textures enabled in the application.
   */
  static get ClearCoatTintTextureEnabled() {
    return this._ClearCoatTintTextureEnabled;
  }
  static set ClearCoatTintTextureEnabled(value) {
    if (this._ClearCoatTintTextureEnabled === value) {
      return;
    }
    this._ClearCoatTintTextureEnabled = value;
    Engine.MarkAllMaterialsAsDirty(1);
  }
  /**
   * Are sheen textures enabled in the application.
   */
  static get SheenTextureEnabled() {
    return this._SheenTextureEnabled;
  }
  static set SheenTextureEnabled(value) {
    if (this._SheenTextureEnabled === value) {
      return;
    }
    this._SheenTextureEnabled = value;
    Engine.MarkAllMaterialsAsDirty(1);
  }
  /**
   * Are anisotropic textures enabled in the application.
   */
  static get AnisotropicTextureEnabled() {
    return this._AnisotropicTextureEnabled;
  }
  static set AnisotropicTextureEnabled(value) {
    if (this._AnisotropicTextureEnabled === value) {
      return;
    }
    this._AnisotropicTextureEnabled = value;
    Engine.MarkAllMaterialsAsDirty(1);
  }
  /**
   * Are thickness textures enabled in the application.
   */
  static get ThicknessTextureEnabled() {
    return this._ThicknessTextureEnabled;
  }
  static set ThicknessTextureEnabled(value) {
    if (this._ThicknessTextureEnabled === value) {
      return;
    }
    this._ThicknessTextureEnabled = value;
    Engine.MarkAllMaterialsAsDirty(1);
  }
  /**
   * Are refraction intensity textures enabled in the application.
   */
  static get RefractionIntensityTextureEnabled() {
    return this._ThicknessTextureEnabled;
  }
  static set RefractionIntensityTextureEnabled(value) {
    if (this._RefractionIntensityTextureEnabled === value) {
      return;
    }
    this._RefractionIntensityTextureEnabled = value;
    Engine.MarkAllMaterialsAsDirty(1);
  }
  /**
   * Are translucency intensity textures enabled in the application.
   */
  static get TranslucencyIntensityTextureEnabled() {
    return this._ThicknessTextureEnabled;
  }
  static set TranslucencyIntensityTextureEnabled(value) {
    if (this._TranslucencyIntensityTextureEnabled === value) {
      return;
    }
    this._TranslucencyIntensityTextureEnabled = value;
    Engine.MarkAllMaterialsAsDirty(1);
  }
  /**
   * Are translucency intensity textures enabled in the application.
   */
  static get IridescenceTextureEnabled() {
    return this._IridescenceTextureEnabled;
  }
  static set IridescenceTextureEnabled(value) {
    if (this._IridescenceTextureEnabled === value) {
      return;
    }
    this._IridescenceTextureEnabled = value;
    Engine.MarkAllMaterialsAsDirty(1);
  }
};
MaterialFlags._DiffuseTextureEnabled = true;
MaterialFlags._DetailTextureEnabled = true;
MaterialFlags._DecalMapEnabled = true;
MaterialFlags._AmbientTextureEnabled = true;
MaterialFlags._OpacityTextureEnabled = true;
MaterialFlags._ReflectionTextureEnabled = true;
MaterialFlags._EmissiveTextureEnabled = true;
MaterialFlags._SpecularTextureEnabled = true;
MaterialFlags._BumpTextureEnabled = true;
MaterialFlags._LightmapTextureEnabled = true;
MaterialFlags._RefractionTextureEnabled = true;
MaterialFlags._ColorGradingTextureEnabled = true;
MaterialFlags._FresnelEnabled = true;
MaterialFlags._ClearCoatTextureEnabled = true;
MaterialFlags._ClearCoatBumpTextureEnabled = true;
MaterialFlags._ClearCoatTintTextureEnabled = true;
MaterialFlags._SheenTextureEnabled = true;
MaterialFlags._AnisotropicTextureEnabled = true;
MaterialFlags._ThicknessTextureEnabled = true;
MaterialFlags._RefractionIntensityTextureEnabled = true;
MaterialFlags._TranslucencyIntensityTextureEnabled = true;
MaterialFlags._IridescenceTextureEnabled = true;

// ../../node_modules/@babylonjs/core/Shaders/ShadersInclude/decalFragmentDeclaration.js
var name = "decalFragmentDeclaration";
var shader = `#ifdef DECAL
uniform vec4 vDecalInfos;
#endif
`;
ShaderStore.IncludesShadersStore[name] = shader;

// ../../node_modules/@babylonjs/core/Shaders/ShadersInclude/defaultFragmentDeclaration.js
var name2 = "defaultFragmentDeclaration";
var shader2 = `uniform vec4 vEyePosition;uniform vec4 vDiffuseColor;
#ifdef SPECULARTERM
uniform vec4 vSpecularColor;
#endif
uniform vec3 vEmissiveColor;uniform vec3 vAmbientColor;uniform float visibility;
#ifdef DIFFUSE
uniform vec2 vDiffuseInfos;
#endif
#ifdef AMBIENT
uniform vec2 vAmbientInfos;
#endif
#ifdef OPACITY 
uniform vec2 vOpacityInfos;
#endif
#ifdef EMISSIVE
uniform vec2 vEmissiveInfos;
#endif
#ifdef LIGHTMAP
uniform vec2 vLightmapInfos;
#endif
#ifdef BUMP
uniform vec3 vBumpInfos;uniform vec2 vTangentSpaceParams;
#endif
#ifdef ALPHATEST
uniform float alphaCutOff;
#endif
#if defined(REFLECTIONMAP_SPHERICAL) || defined(REFLECTIONMAP_PROJECTION) || defined(REFRACTION) || defined(PREPASS)
uniform mat4 view;
#endif
#ifdef REFRACTION
uniform vec4 vRefractionInfos;
#ifndef REFRACTIONMAP_3D
uniform mat4 refractionMatrix;
#endif
#ifdef REFRACTIONFRESNEL
uniform vec4 refractionLeftColor;uniform vec4 refractionRightColor;
#endif
#if defined(USE_LOCAL_REFRACTIONMAP_CUBIC) && defined(REFRACTIONMAP_3D)
uniform vec3 vRefractionPosition;uniform vec3 vRefractionSize; 
#endif
#endif
#if defined(SPECULAR) && defined(SPECULARTERM)
uniform vec2 vSpecularInfos;
#endif
#ifdef DIFFUSEFRESNEL
uniform vec4 diffuseLeftColor;uniform vec4 diffuseRightColor;
#endif
#ifdef OPACITYFRESNEL
uniform vec4 opacityParts;
#endif
#ifdef EMISSIVEFRESNEL
uniform vec4 emissiveLeftColor;uniform vec4 emissiveRightColor;
#endif
#ifdef REFLECTION
uniform vec2 vReflectionInfos;
#if defined(REFLECTIONMAP_PLANAR) || defined(REFLECTIONMAP_CUBIC) || defined(REFLECTIONMAP_PROJECTION) || defined(REFLECTIONMAP_EQUIRECTANGULAR) || defined(REFLECTIONMAP_SPHERICAL) || defined(REFLECTIONMAP_SKYBOX)
uniform mat4 reflectionMatrix;
#endif
#ifndef REFLECTIONMAP_SKYBOX
#if defined(USE_LOCAL_REFLECTIONMAP_CUBIC) && defined(REFLECTIONMAP_CUBIC)
uniform vec3 vReflectionPosition;uniform vec3 vReflectionSize; 
#endif
#endif
#ifdef REFLECTIONFRESNEL
uniform vec4 reflectionLeftColor;uniform vec4 reflectionRightColor;
#endif
#endif
#ifdef DETAIL
uniform vec4 vDetailInfos;
#endif
#include<decalFragmentDeclaration>
#define ADDITIONAL_FRAGMENT_DECLARATION
`;
ShaderStore.IncludesShadersStore[name2] = shader2;

// ../../node_modules/@babylonjs/core/Shaders/ShadersInclude/sceneUboDeclaration.js
var name3 = "sceneUboDeclaration";
var shader3 = `layout(std140,column_major) uniform;uniform Scene {mat4 viewProjection;
#ifdef MULTIVIEW
mat4 viewProjectionR;
#endif 
mat4 view;mat4 projection;vec4 vEyePosition;};
`;
ShaderStore.IncludesShadersStore[name3] = shader3;

// ../../node_modules/@babylonjs/core/Shaders/ShadersInclude/meshUboDeclaration.js
var name4 = "meshUboDeclaration";
var shader4 = `#ifdef WEBGL2
uniform mat4 world;uniform float visibility;
#else
layout(std140,column_major) uniform;uniform Mesh
{mat4 world;float visibility;};
#endif
#define WORLD_UBO
`;
ShaderStore.IncludesShadersStore[name4] = shader4;

// ../../node_modules/@babylonjs/core/Shaders/ShadersInclude/defaultUboDeclaration.js
var name5 = "defaultUboDeclaration";
var shader5 = `layout(std140,column_major) uniform;uniform Material
{vec4 diffuseLeftColor;vec4 diffuseRightColor;vec4 opacityParts;vec4 reflectionLeftColor;vec4 reflectionRightColor;vec4 refractionLeftColor;vec4 refractionRightColor;vec4 emissiveLeftColor;vec4 emissiveRightColor;vec2 vDiffuseInfos;vec2 vAmbientInfos;vec2 vOpacityInfos;vec2 vReflectionInfos;vec3 vReflectionPosition;vec3 vReflectionSize;vec2 vEmissiveInfos;vec2 vLightmapInfos;vec2 vSpecularInfos;vec3 vBumpInfos;mat4 diffuseMatrix;mat4 ambientMatrix;mat4 opacityMatrix;mat4 reflectionMatrix;mat4 emissiveMatrix;mat4 lightmapMatrix;mat4 specularMatrix;mat4 bumpMatrix;vec2 vTangentSpaceParams;float pointSize;float alphaCutOff;mat4 refractionMatrix;vec4 vRefractionInfos;vec3 vRefractionPosition;vec3 vRefractionSize;vec4 vSpecularColor;vec3 vEmissiveColor;vec4 vDiffuseColor;vec3 vAmbientColor;
#define ADDITIONAL_UBO_DECLARATION
};
#include<sceneUboDeclaration>
#include<meshUboDeclaration>
`;
ShaderStore.IncludesShadersStore[name5] = shader5;

// ../../node_modules/@babylonjs/core/Shaders/ShadersInclude/prePassDeclaration.js
var name6 = "prePassDeclaration";
var shader6 = `#ifdef PREPASS
#extension GL_EXT_draw_buffers : require
layout(location=0) out highp vec4 glFragData[{X}];highp vec4 gl_FragColor;
#ifdef PREPASS_DEPTH
varying highp vec3 vViewPos;
#endif
#ifdef PREPASS_VELOCITY
varying highp vec4 vCurrentPosition;varying highp vec4 vPreviousPosition;
#endif
#endif
`;
ShaderStore.IncludesShadersStore[name6] = shader6;

// ../../node_modules/@babylonjs/core/Shaders/ShadersInclude/oitDeclaration.js
var name7 = "oitDeclaration";
var shader7 = `#ifdef ORDER_INDEPENDENT_TRANSPARENCY
#extension GL_EXT_draw_buffers : require
layout(location=0) out vec2 depth; 
layout(location=1) out vec4 frontColor;layout(location=2) out vec4 backColor;
#define MAX_DEPTH 99999.0
highp vec4 gl_FragColor;uniform sampler2D oitDepthSampler;uniform sampler2D oitFrontColorSampler;
#endif
`;
ShaderStore.IncludesShadersStore[name7] = shader7;

// ../../node_modules/@babylonjs/core/Shaders/ShadersInclude/mainUVVaryingDeclaration.js
var name8 = "mainUVVaryingDeclaration";
var shader8 = `#ifdef MAINUV{X}
varying vec2 vMainUV{X};
#endif
`;
ShaderStore.IncludesShadersStore[name8] = shader8;

// ../../node_modules/@babylonjs/core/Shaders/ShadersInclude/helperFunctions.js
var name9 = "helperFunctions";
var shader9 = `const float PI=3.1415926535897932384626433832795;const float RECIPROCAL_PI=0.3183098861837907;const float RECIPROCAL_PI2=0.15915494309189535;const float HALF_MIN=5.96046448e-08; 
const float LinearEncodePowerApprox=2.2;const float GammaEncodePowerApprox=1.0/LinearEncodePowerApprox;const vec3 LuminanceEncodeApprox=vec3(0.2126,0.7152,0.0722);const float Epsilon=0.0000001;
#define saturate(x) clamp(x,0.0,1.0)
#define absEps(x) abs(x)+Epsilon
#define maxEps(x) max(x,Epsilon)
#define saturateEps(x) clamp(x,Epsilon,1.0)
mat3 transposeMat3(mat3 inMatrix) {vec3 i0=inMatrix[0];vec3 i1=inMatrix[1];vec3 i2=inMatrix[2];mat3 outMatrix=mat3(
vec3(i0.x,i1.x,i2.x),
vec3(i0.y,i1.y,i2.y),
vec3(i0.z,i1.z,i2.z)
);return outMatrix;}
mat3 inverseMat3(mat3 inMatrix) {float a00=inMatrix[0][0],a01=inMatrix[0][1],a02=inMatrix[0][2];float a10=inMatrix[1][0],a11=inMatrix[1][1],a12=inMatrix[1][2];float a20=inMatrix[2][0],a21=inMatrix[2][1],a22=inMatrix[2][2];float b01=a22*a11-a12*a21;float b11=-a22*a10+a12*a20;float b21=a21*a10-a11*a20;float det=a00*b01+a01*b11+a02*b21;return mat3(b01,(-a22*a01+a02*a21),(a12*a01-a02*a11),
b11,(a22*a00-a02*a20),(-a12*a00+a02*a10),
b21,(-a21*a00+a01*a20),(a11*a00-a01*a10))/det;}
#if USE_EXACT_SRGB_CONVERSIONS
vec3 toLinearSpaceExact(vec3 color)
{vec3 nearZeroSection=0.0773993808*color;vec3 remainingSection=pow(0.947867299*(color+vec3(0.055)),vec3(2.4));
#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)
return mix(remainingSection,nearZeroSection,lessThanEqual(color,vec3(0.04045)));
#else
return
vec3(
color.r<=0.04045 ? nearZeroSection.r : remainingSection.r,
color.g<=0.04045 ? nearZeroSection.g : remainingSection.g,
color.b<=0.04045 ? nearZeroSection.b : remainingSection.b);
#endif
}
vec3 toGammaSpaceExact(vec3 color)
{vec3 nearZeroSection=12.92*color;vec3 remainingSection=1.055*pow(color,vec3(0.41666))-vec3(0.055);
#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)
return mix(remainingSection,nearZeroSection,lessThanEqual(color,vec3(0.0031308)));
#else
return
vec3(
color.r<=0.0031308 ? nearZeroSection.r : remainingSection.r,
color.g<=0.0031308 ? nearZeroSection.g : remainingSection.g,
color.b<=0.0031308 ? nearZeroSection.b : remainingSection.b);
#endif
}
#endif
float toLinearSpace(float color)
{
#if USE_EXACT_SRGB_CONVERSIONS
float nearZeroSection=0.0773993808*color;float remainingSection=pow(0.947867299*(color+0.055),2.4);return color<=0.04045 ? nearZeroSection : remainingSection;
#else
return pow(color,LinearEncodePowerApprox);
#endif
}
vec3 toLinearSpace(vec3 color)
{
#if USE_EXACT_SRGB_CONVERSIONS
return toLinearSpaceExact(color);
#else
return pow(color,vec3(LinearEncodePowerApprox));
#endif
}
vec4 toLinearSpace(vec4 color)
{
#if USE_EXACT_SRGB_CONVERSIONS
return vec4(toLinearSpaceExact(color.rgb),color.a);
#else
return vec4(pow(color.rgb,vec3(LinearEncodePowerApprox)),color.a);
#endif
}
float toGammaSpace(float color)
{
#if USE_EXACT_SRGB_CONVERSIONS
float nearZeroSection=12.92*color;float remainingSection=1.055*pow(color,0.41666)-0.055;return color<=0.0031308 ? nearZeroSection : remainingSection;
#else
return pow(color,GammaEncodePowerApprox);
#endif
}
vec3 toGammaSpace(vec3 color)
{
#if USE_EXACT_SRGB_CONVERSIONS
return toGammaSpaceExact(color);
#else
return pow(color,vec3(GammaEncodePowerApprox));
#endif
}
vec4 toGammaSpace(vec4 color)
{
#if USE_EXACT_SRGB_CONVERSIONS
return vec4(toGammaSpaceExact(color.rgb),color.a);
#else
return vec4(pow(color.rgb,vec3(GammaEncodePowerApprox)),color.a);
#endif
}
float square(float value)
{return value*value;}
vec3 square(vec3 value)
{return value*value;}
float pow5(float value) {float sq=value*value;return sq*sq*value;}
float getLuminance(vec3 color)
{return clamp(dot(color,LuminanceEncodeApprox),0.,1.);}
float getRand(vec2 seed) {return fract(sin(dot(seed.xy ,vec2(12.9898,78.233)))*43758.5453);}
float dither(vec2 seed,float varianceAmount) {float rand=getRand(seed);float normVariance=varianceAmount/255.0;float dither=mix(-normVariance,normVariance,rand);return dither;}
const float rgbdMaxRange=255.0;vec4 toRGBD(vec3 color) {float maxRGB=maxEps(max(color.r,max(color.g,color.b)));float D =max(rgbdMaxRange/maxRGB,1.);D =clamp(floor(D)/255.0,0.,1.);vec3 rgb=color.rgb*D;rgb=toGammaSpace(rgb);return vec4(clamp(rgb,0.,1.),D); }
vec3 fromRGBD(vec4 rgbd) {rgbd.rgb=toLinearSpace(rgbd.rgb);return rgbd.rgb/rgbd.a;}
vec3 parallaxCorrectNormal( vec3 vertexPos,vec3 origVec,vec3 cubeSize,vec3 cubePos ) {vec3 invOrigVec=vec3(1.0,1.0,1.0)/origVec;vec3 halfSize=cubeSize*0.5;vec3 intersecAtMaxPlane=(cubePos+halfSize-vertexPos)*invOrigVec;vec3 intersecAtMinPlane=(cubePos-halfSize-vertexPos)*invOrigVec;vec3 largestIntersec=max(intersecAtMaxPlane,intersecAtMinPlane);float distance=min(min(largestIntersec.x,largestIntersec.y),largestIntersec.z);vec3 intersectPositionWS=vertexPos+origVec*distance;return intersectPositionWS-cubePos;}
`;
ShaderStore.IncludesShadersStore[name9] = shader9;

// ../../node_modules/@babylonjs/core/Shaders/ShadersInclude/lightFragmentDeclaration.js
var name10 = "lightFragmentDeclaration";
var shader10 = `#ifdef LIGHT{X}
uniform vec4 vLightData{X};uniform vec4 vLightDiffuse{X};
#ifdef SPECULARTERM
uniform vec4 vLightSpecular{X};
#else
vec4 vLightSpecular{X}=vec4(0.);
#endif
#ifdef SHADOW{X}
#ifdef SHADOWCSM{X}
uniform mat4 lightMatrix{X}[SHADOWCSMNUM_CASCADES{X}];uniform float viewFrustumZ{X}[SHADOWCSMNUM_CASCADES{X}];uniform float frustumLengths{X}[SHADOWCSMNUM_CASCADES{X}];uniform float cascadeBlendFactor{X};varying vec4 vPositionFromLight{X}[SHADOWCSMNUM_CASCADES{X}];varying float vDepthMetric{X}[SHADOWCSMNUM_CASCADES{X}];varying vec4 vPositionFromCamera{X};
#if defined(SHADOWPCSS{X})
uniform highp sampler2DArrayShadow shadowSampler{X};uniform highp sampler2DArray depthSampler{X};uniform vec2 lightSizeUVCorrection{X}[SHADOWCSMNUM_CASCADES{X}];uniform float depthCorrection{X}[SHADOWCSMNUM_CASCADES{X}];uniform float penumbraDarkness{X};
#elif defined(SHADOWPCF{X})
uniform highp sampler2DArrayShadow shadowSampler{X};
#else
uniform highp sampler2DArray shadowSampler{X};
#endif
#ifdef SHADOWCSMDEBUG{X}
const vec3 vCascadeColorsMultiplier{X}[8]=vec3[8]
(
vec3 ( 1.5,0.0,0.0 ),
vec3 ( 0.0,1.5,0.0 ),
vec3 ( 0.0,0.0,5.5 ),
vec3 ( 1.5,0.0,5.5 ),
vec3 ( 1.5,1.5,0.0 ),
vec3 ( 1.0,1.0,1.0 ),
vec3 ( 0.0,1.0,5.5 ),
vec3 ( 0.5,3.5,0.75 )
);vec3 shadowDebug{X};
#endif
#ifdef SHADOWCSMUSESHADOWMAXZ{X}
int index{X}=-1;
#else
int index{X}=SHADOWCSMNUM_CASCADES{X}-1;
#endif
float diff{X}=0.;
#elif defined(SHADOWCUBE{X})
uniform samplerCube shadowSampler{X};
#else
varying vec4 vPositionFromLight{X};varying float vDepthMetric{X};
#if defined(SHADOWPCSS{X})
uniform highp sampler2DShadow shadowSampler{X};uniform highp sampler2D depthSampler{X};
#elif defined(SHADOWPCF{X})
uniform highp sampler2DShadow shadowSampler{X};
#else
uniform sampler2D shadowSampler{X};
#endif
uniform mat4 lightMatrix{X};
#endif
uniform vec4 shadowsInfo{X};uniform vec2 depthValues{X};
#endif
#ifdef SPOTLIGHT{X}
uniform vec4 vLightDirection{X};uniform vec4 vLightFalloff{X};
#elif defined(POINTLIGHT{X})
uniform vec4 vLightFalloff{X};
#elif defined(HEMILIGHT{X})
uniform vec3 vLightGround{X};
#endif
#ifdef PROJECTEDLIGHTTEXTURE{X}
uniform mat4 textureProjectionMatrix{X};uniform sampler2D projectionLightSampler{X};
#endif
#endif
`;
ShaderStore.IncludesShadersStore[name10] = shader10;

// ../../node_modules/@babylonjs/core/Shaders/ShadersInclude/lightUboDeclaration.js
var name11 = "lightUboDeclaration";
var shader11 = `#ifdef LIGHT{X}
uniform Light{X}
{vec4 vLightData;vec4 vLightDiffuse;vec4 vLightSpecular;
#ifdef SPOTLIGHT{X}
vec4 vLightDirection;vec4 vLightFalloff;
#elif defined(POINTLIGHT{X})
vec4 vLightFalloff;
#elif defined(HEMILIGHT{X})
vec3 vLightGround;
#endif
vec4 shadowsInfo;vec2 depthValues;} light{X};
#ifdef PROJECTEDLIGHTTEXTURE{X}
uniform mat4 textureProjectionMatrix{X};uniform sampler2D projectionLightSampler{X};
#endif
#ifdef SHADOW{X}
#ifdef SHADOWCSM{X}
uniform mat4 lightMatrix{X}[SHADOWCSMNUM_CASCADES{X}];uniform float viewFrustumZ{X}[SHADOWCSMNUM_CASCADES{X}];uniform float frustumLengths{X}[SHADOWCSMNUM_CASCADES{X}];uniform float cascadeBlendFactor{X};varying vec4 vPositionFromLight{X}[SHADOWCSMNUM_CASCADES{X}];varying float vDepthMetric{X}[SHADOWCSMNUM_CASCADES{X}];varying vec4 vPositionFromCamera{X};
#if defined(SHADOWPCSS{X})
uniform highp sampler2DArrayShadow shadowSampler{X};uniform highp sampler2DArray depthSampler{X};uniform vec2 lightSizeUVCorrection{X}[SHADOWCSMNUM_CASCADES{X}];uniform float depthCorrection{X}[SHADOWCSMNUM_CASCADES{X}];uniform float penumbraDarkness{X};
#elif defined(SHADOWPCF{X})
uniform highp sampler2DArrayShadow shadowSampler{X};
#else
uniform highp sampler2DArray shadowSampler{X};
#endif
#ifdef SHADOWCSMDEBUG{X}
const vec3 vCascadeColorsMultiplier{X}[8]=vec3[8]
(
vec3 ( 1.5,0.0,0.0 ),
vec3 ( 0.0,1.5,0.0 ),
vec3 ( 0.0,0.0,5.5 ),
vec3 ( 1.5,0.0,5.5 ),
vec3 ( 1.5,1.5,0.0 ),
vec3 ( 1.0,1.0,1.0 ),
vec3 ( 0.0,1.0,5.5 ),
vec3 ( 0.5,3.5,0.75 )
);vec3 shadowDebug{X};
#endif
#ifdef SHADOWCSMUSESHADOWMAXZ{X}
int index{X}=-1;
#else
int index{X}=SHADOWCSMNUM_CASCADES{X}-1;
#endif
float diff{X}=0.;
#elif defined(SHADOWCUBE{X})
uniform samplerCube shadowSampler{X}; 
#else
varying vec4 vPositionFromLight{X};varying float vDepthMetric{X};
#if defined(SHADOWPCSS{X})
uniform highp sampler2DShadow shadowSampler{X};uniform highp sampler2D depthSampler{X};
#elif defined(SHADOWPCF{X})
uniform highp sampler2DShadow shadowSampler{X};
#else
uniform sampler2D shadowSampler{X};
#endif
uniform mat4 lightMatrix{X};
#endif
#endif
#endif
`;
ShaderStore.IncludesShadersStore[name11] = shader11;

// ../../node_modules/@babylonjs/core/Shaders/ShadersInclude/lightsFragmentFunctions.js
var name12 = "lightsFragmentFunctions";
var shader12 = `struct lightingInfo
{vec3 diffuse;
#ifdef SPECULARTERM
vec3 specular;
#endif
#ifdef NDOTL
float ndl;
#endif
};lightingInfo computeLighting(vec3 viewDirectionW,vec3 vNormal,vec4 lightData,vec3 diffuseColor,vec3 specularColor,float range,float glossiness) {lightingInfo result;vec3 lightVectorW;float attenuation=1.0;if (lightData.w==0.)
{vec3 direction=lightData.xyz-vPositionW;attenuation=max(0.,1.0-length(direction)/range);lightVectorW=normalize(direction);}
else
{lightVectorW=normalize(-lightData.xyz);}
float ndl=max(0.,dot(vNormal,lightVectorW));
#ifdef NDOTL
result.ndl=ndl;
#endif
result.diffuse=ndl*diffuseColor*attenuation;
#ifdef SPECULARTERM
vec3 angleW=normalize(viewDirectionW+lightVectorW);float specComp=max(0.,dot(vNormal,angleW));specComp=pow(specComp,max(1.,glossiness));result.specular=specComp*specularColor*attenuation;
#endif
return result;}
lightingInfo computeSpotLighting(vec3 viewDirectionW,vec3 vNormal,vec4 lightData,vec4 lightDirection,vec3 diffuseColor,vec3 specularColor,float range,float glossiness) {lightingInfo result;vec3 direction=lightData.xyz-vPositionW;vec3 lightVectorW=normalize(direction);float attenuation=max(0.,1.0-length(direction)/range);float cosAngle=max(0.,dot(lightDirection.xyz,-lightVectorW));if (cosAngle>=lightDirection.w)
{cosAngle=max(0.,pow(cosAngle,lightData.w));attenuation*=cosAngle;float ndl=max(0.,dot(vNormal,lightVectorW));
#ifdef NDOTL
result.ndl=ndl;
#endif
result.diffuse=ndl*diffuseColor*attenuation;
#ifdef SPECULARTERM
vec3 angleW=normalize(viewDirectionW+lightVectorW);float specComp=max(0.,dot(vNormal,angleW));specComp=pow(specComp,max(1.,glossiness));result.specular=specComp*specularColor*attenuation;
#endif
return result;}
result.diffuse=vec3(0.);
#ifdef SPECULARTERM
result.specular=vec3(0.);
#endif
#ifdef NDOTL
result.ndl=0.;
#endif
return result;}
lightingInfo computeHemisphericLighting(vec3 viewDirectionW,vec3 vNormal,vec4 lightData,vec3 diffuseColor,vec3 specularColor,vec3 groundColor,float glossiness) {lightingInfo result;float ndl=dot(vNormal,lightData.xyz)*0.5+0.5;
#ifdef NDOTL
result.ndl=ndl;
#endif
result.diffuse=mix(groundColor,diffuseColor,ndl);
#ifdef SPECULARTERM
vec3 angleW=normalize(viewDirectionW+lightData.xyz);float specComp=max(0.,dot(vNormal,angleW));specComp=pow(specComp,max(1.,glossiness));result.specular=specComp*specularColor;
#endif
return result;}
#define inline
vec3 computeProjectionTextureDiffuseLighting(sampler2D projectionLightSampler,mat4 textureProjectionMatrix){vec4 strq=textureProjectionMatrix*vec4(vPositionW,1.0);strq/=strq.w;vec3 textureColor=texture2D(projectionLightSampler,strq.xy).rgb;return textureColor;}`;
ShaderStore.IncludesShadersStore[name12] = shader12;

// ../../node_modules/@babylonjs/core/Shaders/ShadersInclude/shadowsFragmentFunctions.js
var name13 = "shadowsFragmentFunctions";
var shader13 = `#ifdef SHADOWS
#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)
#define TEXTUREFUNC(s,c,l) texture2DLodEXT(s,c,l)
#else
#define TEXTUREFUNC(s,c,b) texture2D(s,c,b)
#endif
#ifndef SHADOWFLOAT
float unpack(vec4 color)
{const vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(color,bit_shift);}
#endif
float computeFallOff(float value,vec2 clipSpace,float frustumEdgeFalloff)
{float mask=smoothstep(1.0-frustumEdgeFalloff,1.00000012,clamp(dot(clipSpace,clipSpace),0.,1.));return mix(value,1.0,mask);}
#define inline
float computeShadowCube(vec3 worldPos,vec3 lightPosition,samplerCube shadowSampler,float darkness,vec2 depthValues)
{vec3 directionToLight=worldPos-lightPosition;float depth=length(directionToLight);depth=(depth+depthValues.x)/(depthValues.y);depth=clamp(depth,0.,1.0);directionToLight=normalize(directionToLight);directionToLight.y=-directionToLight.y;
#ifndef SHADOWFLOAT
float shadow=unpack(textureCube(shadowSampler,directionToLight));
#else
float shadow=textureCube(shadowSampler,directionToLight).x;
#endif
return depth>shadow ? darkness : 1.0;}
#define inline
float computeShadowWithPoissonSamplingCube(vec3 worldPos,vec3 lightPosition,samplerCube shadowSampler,float mapSize,float darkness,vec2 depthValues)
{vec3 directionToLight=worldPos-lightPosition;float depth=length(directionToLight);depth=(depth+depthValues.x)/(depthValues.y);depth=clamp(depth,0.,1.0);directionToLight=normalize(directionToLight);directionToLight.y=-directionToLight.y;float visibility=1.;vec3 poissonDisk[4];poissonDisk[0]=vec3(-1.0,1.0,-1.0);poissonDisk[1]=vec3(1.0,-1.0,-1.0);poissonDisk[2]=vec3(-1.0,-1.0,-1.0);poissonDisk[3]=vec3(1.0,-1.0,1.0);
#ifndef SHADOWFLOAT
if (unpack(textureCube(shadowSampler,directionToLight+poissonDisk[0]*mapSize))<depth) visibility-=0.25;if (unpack(textureCube(shadowSampler,directionToLight+poissonDisk[1]*mapSize))<depth) visibility-=0.25;if (unpack(textureCube(shadowSampler,directionToLight+poissonDisk[2]*mapSize))<depth) visibility-=0.25;if (unpack(textureCube(shadowSampler,directionToLight+poissonDisk[3]*mapSize))<depth) visibility-=0.25;
#else
if (textureCube(shadowSampler,directionToLight+poissonDisk[0]*mapSize).x<depth) visibility-=0.25;if (textureCube(shadowSampler,directionToLight+poissonDisk[1]*mapSize).x<depth) visibility-=0.25;if (textureCube(shadowSampler,directionToLight+poissonDisk[2]*mapSize).x<depth) visibility-=0.25;if (textureCube(shadowSampler,directionToLight+poissonDisk[3]*mapSize).x<depth) visibility-=0.25;
#endif
return min(1.0,visibility+darkness);}
#define inline
float computeShadowWithESMCube(vec3 worldPos,vec3 lightPosition,samplerCube shadowSampler,float darkness,float depthScale,vec2 depthValues)
{vec3 directionToLight=worldPos-lightPosition;float depth=length(directionToLight);depth=(depth+depthValues.x)/(depthValues.y);float shadowPixelDepth=clamp(depth,0.,1.0);directionToLight=normalize(directionToLight);directionToLight.y=-directionToLight.y;
#ifndef SHADOWFLOAT
float shadowMapSample=unpack(textureCube(shadowSampler,directionToLight));
#else
float shadowMapSample=textureCube(shadowSampler,directionToLight).x;
#endif
float esm=1.0-clamp(exp(min(87.,depthScale*shadowPixelDepth))*shadowMapSample,0.,1.-darkness);return esm;}
#define inline
float computeShadowWithCloseESMCube(vec3 worldPos,vec3 lightPosition,samplerCube shadowSampler,float darkness,float depthScale,vec2 depthValues)
{vec3 directionToLight=worldPos-lightPosition;float depth=length(directionToLight);depth=(depth+depthValues.x)/(depthValues.y);float shadowPixelDepth=clamp(depth,0.,1.0);directionToLight=normalize(directionToLight);directionToLight.y=-directionToLight.y;
#ifndef SHADOWFLOAT
float shadowMapSample=unpack(textureCube(shadowSampler,directionToLight));
#else
float shadowMapSample=textureCube(shadowSampler,directionToLight).x;
#endif
float esm=clamp(exp(min(87.,-depthScale*(shadowPixelDepth-shadowMapSample))),darkness,1.);return esm;}
#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)
#define inline
float computeShadowCSM(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray shadowSampler,float darkness,float frustumEdgeFalloff)
{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec2 uv=0.5*clipSpace.xy+vec2(0.5);vec3 uvLayer=vec3(uv.x,uv.y,layer);float shadowPixelDepth=clamp(depthMetric,0.,1.0);
#ifndef SHADOWFLOAT
float shadow=unpack(texture2D(shadowSampler,uvLayer));
#else
float shadow=texture2D(shadowSampler,uvLayer).x;
#endif
return shadowPixelDepth>shadow ? computeFallOff(darkness,clipSpace.xy,frustumEdgeFalloff) : 1.;}
#endif
#define inline
float computeShadow(vec4 vPositionFromLight,float depthMetric,sampler2D shadowSampler,float darkness,float frustumEdgeFalloff)
{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec2 uv=0.5*clipSpace.xy+vec2(0.5);if (uv.x<0. || uv.x>1.0 || uv.y<0. || uv.y>1.0)
{return 1.0;}
else
{float shadowPixelDepth=clamp(depthMetric,0.,1.0);
#ifndef SHADOWFLOAT
float shadow=unpack(TEXTUREFUNC(shadowSampler,uv,0.));
#else
float shadow=TEXTUREFUNC(shadowSampler,uv,0.).x;
#endif
return shadowPixelDepth>shadow ? computeFallOff(darkness,clipSpace.xy,frustumEdgeFalloff) : 1.;}}
#define inline
float computeShadowWithPoissonSampling(vec4 vPositionFromLight,float depthMetric,sampler2D shadowSampler,float mapSize,float darkness,float frustumEdgeFalloff)
{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec2 uv=0.5*clipSpace.xy+vec2(0.5);if (uv.x<0. || uv.x>1.0 || uv.y<0. || uv.y>1.0)
{return 1.0;}
else
{float shadowPixelDepth=clamp(depthMetric,0.,1.0);float visibility=1.;vec2 poissonDisk[4];poissonDisk[0]=vec2(-0.94201624,-0.39906216);poissonDisk[1]=vec2(0.94558609,-0.76890725);poissonDisk[2]=vec2(-0.094184101,-0.92938870);poissonDisk[3]=vec2(0.34495938,0.29387760);
#ifndef SHADOWFLOAT
if (unpack(TEXTUREFUNC(shadowSampler,uv+poissonDisk[0]*mapSize,0.))<shadowPixelDepth) visibility-=0.25;if (unpack(TEXTUREFUNC(shadowSampler,uv+poissonDisk[1]*mapSize,0.))<shadowPixelDepth) visibility-=0.25;if (unpack(TEXTUREFUNC(shadowSampler,uv+poissonDisk[2]*mapSize,0.))<shadowPixelDepth) visibility-=0.25;if (unpack(TEXTUREFUNC(shadowSampler,uv+poissonDisk[3]*mapSize,0.))<shadowPixelDepth) visibility-=0.25;
#else
if (TEXTUREFUNC(shadowSampler,uv+poissonDisk[0]*mapSize,0.).x<shadowPixelDepth) visibility-=0.25;if (TEXTUREFUNC(shadowSampler,uv+poissonDisk[1]*mapSize,0.).x<shadowPixelDepth) visibility-=0.25;if (TEXTUREFUNC(shadowSampler,uv+poissonDisk[2]*mapSize,0.).x<shadowPixelDepth) visibility-=0.25;if (TEXTUREFUNC(shadowSampler,uv+poissonDisk[3]*mapSize,0.).x<shadowPixelDepth) visibility-=0.25;
#endif
return computeFallOff(min(1.0,visibility+darkness),clipSpace.xy,frustumEdgeFalloff);}}
#define inline
float computeShadowWithESM(vec4 vPositionFromLight,float depthMetric,sampler2D shadowSampler,float darkness,float depthScale,float frustumEdgeFalloff)
{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec2 uv=0.5*clipSpace.xy+vec2(0.5);if (uv.x<0. || uv.x>1.0 || uv.y<0. || uv.y>1.0)
{return 1.0;}
else
{float shadowPixelDepth=clamp(depthMetric,0.,1.0);
#ifndef SHADOWFLOAT
float shadowMapSample=unpack(TEXTUREFUNC(shadowSampler,uv,0.));
#else
float shadowMapSample=TEXTUREFUNC(shadowSampler,uv,0.).x;
#endif
float esm=1.0-clamp(exp(min(87.,depthScale*shadowPixelDepth))*shadowMapSample,0.,1.-darkness);return computeFallOff(esm,clipSpace.xy,frustumEdgeFalloff);}}
#define inline
float computeShadowWithCloseESM(vec4 vPositionFromLight,float depthMetric,sampler2D shadowSampler,float darkness,float depthScale,float frustumEdgeFalloff)
{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec2 uv=0.5*clipSpace.xy+vec2(0.5);if (uv.x<0. || uv.x>1.0 || uv.y<0. || uv.y>1.0)
{return 1.0;}
else
{float shadowPixelDepth=clamp(depthMetric,0.,1.0); 
#ifndef SHADOWFLOAT
float shadowMapSample=unpack(TEXTUREFUNC(shadowSampler,uv,0.));
#else
float shadowMapSample=TEXTUREFUNC(shadowSampler,uv,0.).x;
#endif
float esm=clamp(exp(min(87.,-depthScale*(shadowPixelDepth-shadowMapSample))),darkness,1.);return computeFallOff(esm,clipSpace.xy,frustumEdgeFalloff);}}
#ifdef IS_NDC_HALF_ZRANGE
#define ZINCLIP clipSpace.z
#else
#define ZINCLIP uvDepth.z
#endif
#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)
#define GREATEST_LESS_THAN_ONE 0.99999994
/* disable_uniformity_analysis */
#define inline
float computeShadowWithCSMPCF1(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArrayShadow shadowSampler,float darkness,float frustumEdgeFalloff)
{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));uvDepth.z=clamp(ZINCLIP,0.,GREATEST_LESS_THAN_ONE);vec4 uvDepthLayer=vec4(uvDepth.x,uvDepth.y,layer,uvDepth.z);float shadow=texture2D(shadowSampler,uvDepthLayer);shadow=mix(darkness,1.,shadow);return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);}
#define inline
float computeShadowWithCSMPCF3(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArrayShadow shadowSampler,vec2 shadowMapSizeAndInverse,float darkness,float frustumEdgeFalloff)
{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));uvDepth.z=clamp(ZINCLIP,0.,GREATEST_LESS_THAN_ONE);vec2 uv=uvDepth.xy*shadowMapSizeAndInverse.x; 
uv+=0.5; 
vec2 st=fract(uv); 
vec2 base_uv=floor(uv)-0.5; 
base_uv*=shadowMapSizeAndInverse.y; 
vec2 uvw0=3.-2.*st;vec2 uvw1=1.+2.*st;vec2 u=vec2((2.-st.x)/uvw0.x-1.,st.x/uvw1.x+1.)*shadowMapSizeAndInverse.y;vec2 v=vec2((2.-st.y)/uvw0.y-1.,st.y/uvw1.y+1.)*shadowMapSizeAndInverse.y;float shadow=0.;shadow+=uvw0.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[0]),layer,uvDepth.z));shadow+=uvw1.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[0]),layer,uvDepth.z));shadow+=uvw0.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[1]),layer,uvDepth.z));shadow+=uvw1.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[1]),layer,uvDepth.z));shadow=shadow/16.;shadow=mix(darkness,1.,shadow);return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);}
#define inline
float computeShadowWithCSMPCF5(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArrayShadow shadowSampler,vec2 shadowMapSizeAndInverse,float darkness,float frustumEdgeFalloff)
{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));uvDepth.z=clamp(ZINCLIP,0.,GREATEST_LESS_THAN_ONE);vec2 uv=uvDepth.xy*shadowMapSizeAndInverse.x; 
uv+=0.5; 
vec2 st=fract(uv); 
vec2 base_uv=floor(uv)-0.5; 
base_uv*=shadowMapSizeAndInverse.y; 
vec2 uvw0=4.-3.*st;vec2 uvw1=vec2(7.);vec2 uvw2=1.+3.*st;vec3 u=vec3((3.-2.*st.x)/uvw0.x-2.,(3.+st.x)/uvw1.x,st.x/uvw2.x+2.)*shadowMapSizeAndInverse.y;vec3 v=vec3((3.-2.*st.y)/uvw0.y-2.,(3.+st.y)/uvw1.y,st.y/uvw2.y+2.)*shadowMapSizeAndInverse.y;float shadow=0.;shadow+=uvw0.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[0]),layer,uvDepth.z));shadow+=uvw1.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[0]),layer,uvDepth.z));shadow+=uvw2.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[2],v[0]),layer,uvDepth.z));shadow+=uvw0.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[1]),layer,uvDepth.z));shadow+=uvw1.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[1]),layer,uvDepth.z));shadow+=uvw2.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[2],v[1]),layer,uvDepth.z));shadow+=uvw0.x*uvw2.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[2]),layer,uvDepth.z));shadow+=uvw1.x*uvw2.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[2]),layer,uvDepth.z));shadow+=uvw2.x*uvw2.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[2],v[2]),layer,uvDepth.z));shadow=shadow/144.;shadow=mix(darkness,1.,shadow);return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);}
#define inline
float computeShadowWithPCF1(vec4 vPositionFromLight,float depthMetric,highp sampler2DShadow shadowSampler,float darkness,float frustumEdgeFalloff)
{if (depthMetric>1.0 || depthMetric<0.0) {return 1.0;}
else
{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));uvDepth.z=ZINCLIP;float shadow=TEXTUREFUNC(shadowSampler,uvDepth,0.);shadow=mix(darkness,1.,shadow);return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);}}
#define inline
float computeShadowWithPCF3(vec4 vPositionFromLight,float depthMetric,highp sampler2DShadow shadowSampler,vec2 shadowMapSizeAndInverse,float darkness,float frustumEdgeFalloff)
{if (depthMetric>1.0 || depthMetric<0.0) {return 1.0;}
else
{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));uvDepth.z=ZINCLIP;vec2 uv=uvDepth.xy*shadowMapSizeAndInverse.x; 
uv+=0.5; 
vec2 st=fract(uv); 
vec2 base_uv=floor(uv)-0.5; 
base_uv*=shadowMapSizeAndInverse.y; 
vec2 uvw0=3.-2.*st;vec2 uvw1=1.+2.*st;vec2 u=vec2((2.-st.x)/uvw0.x-1.,st.x/uvw1.x+1.)*shadowMapSizeAndInverse.y;vec2 v=vec2((2.-st.y)/uvw0.y-1.,st.y/uvw1.y+1.)*shadowMapSizeAndInverse.y;float shadow=0.;shadow+=uvw0.x*uvw0.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[0]),uvDepth.z),0.);shadow+=uvw1.x*uvw0.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[0]),uvDepth.z),0.);shadow+=uvw0.x*uvw1.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[1]),uvDepth.z),0.);shadow+=uvw1.x*uvw1.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[1]),uvDepth.z),0.);shadow=shadow/16.;shadow=mix(darkness,1.,shadow);return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);}}
#define inline
float computeShadowWithPCF5(vec4 vPositionFromLight,float depthMetric,highp sampler2DShadow shadowSampler,vec2 shadowMapSizeAndInverse,float darkness,float frustumEdgeFalloff)
{if (depthMetric>1.0 || depthMetric<0.0) {return 1.0;}
else
{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));uvDepth.z=ZINCLIP;vec2 uv=uvDepth.xy*shadowMapSizeAndInverse.x; 
uv+=0.5; 
vec2 st=fract(uv); 
vec2 base_uv=floor(uv)-0.5; 
base_uv*=shadowMapSizeAndInverse.y; 
vec2 uvw0=4.-3.*st;vec2 uvw1=vec2(7.);vec2 uvw2=1.+3.*st;vec3 u=vec3((3.-2.*st.x)/uvw0.x-2.,(3.+st.x)/uvw1.x,st.x/uvw2.x+2.)*shadowMapSizeAndInverse.y;vec3 v=vec3((3.-2.*st.y)/uvw0.y-2.,(3.+st.y)/uvw1.y,st.y/uvw2.y+2.)*shadowMapSizeAndInverse.y;float shadow=0.;shadow+=uvw0.x*uvw0.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[0]),uvDepth.z),0.);shadow+=uvw1.x*uvw0.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[0]),uvDepth.z),0.);shadow+=uvw2.x*uvw0.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[2],v[0]),uvDepth.z),0.);shadow+=uvw0.x*uvw1.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[1]),uvDepth.z),0.);shadow+=uvw1.x*uvw1.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[1]),uvDepth.z),0.);shadow+=uvw2.x*uvw1.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[2],v[1]),uvDepth.z),0.);shadow+=uvw0.x*uvw2.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[2]),uvDepth.z),0.);shadow+=uvw1.x*uvw2.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[2]),uvDepth.z),0.);shadow+=uvw2.x*uvw2.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[2],v[2]),uvDepth.z),0.);shadow=shadow/144.;shadow=mix(darkness,1.,shadow);return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);}}
const vec3 PoissonSamplers32[64]=vec3[64](
vec3(0.06407013,0.05409927,0.),
vec3(0.7366577,0.5789394,0.),
vec3(-0.6270542,-0.5320278,0.),
vec3(-0.4096107,0.8411095,0.),
vec3(0.6849564,-0.4990818,0.),
vec3(-0.874181,-0.04579735,0.),
vec3(0.9989998,0.0009880066,0.),
vec3(-0.004920578,-0.9151649,0.),
vec3(0.1805763,0.9747483,0.),
vec3(-0.2138451,0.2635818,0.),
vec3(0.109845,0.3884785,0.),
vec3(0.06876755,-0.3581074,0.),
vec3(0.374073,-0.7661266,0.),
vec3(0.3079132,-0.1216763,0.),
vec3(-0.3794335,-0.8271583,0.),
vec3(-0.203878,-0.07715034,0.),
vec3(0.5912697,0.1469799,0.),
vec3(-0.88069,0.3031784,0.),
vec3(0.5040108,0.8283722,0.),
vec3(-0.5844124,0.5494877,0.),
vec3(0.6017799,-0.1726654,0.),
vec3(-0.5554981,0.1559997,0.),
vec3(-0.3016369,-0.3900928,0.),
vec3(-0.5550632,-0.1723762,0.),
vec3(0.925029,0.2995041,0.),
vec3(-0.2473137,0.5538505,0.),
vec3(0.9183037,-0.2862392,0.),
vec3(0.2469421,0.6718712,0.),
vec3(0.3916397,-0.4328209,0.),
vec3(-0.03576927,-0.6220032,0.),
vec3(-0.04661255,0.7995201,0.),
vec3(0.4402924,0.3640312,0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.)
);const vec3 PoissonSamplers64[64]=vec3[64](
vec3(-0.613392,0.617481,0.),
vec3(0.170019,-0.040254,0.),
vec3(-0.299417,0.791925,0.),
vec3(0.645680,0.493210,0.),
vec3(-0.651784,0.717887,0.),
vec3(0.421003,0.027070,0.),
vec3(-0.817194,-0.271096,0.),
vec3(-0.705374,-0.668203,0.),
vec3(0.977050,-0.108615,0.),
vec3(0.063326,0.142369,0.),
vec3(0.203528,0.214331,0.),
vec3(-0.667531,0.326090,0.),
vec3(-0.098422,-0.295755,0.),
vec3(-0.885922,0.215369,0.),
vec3(0.566637,0.605213,0.),
vec3(0.039766,-0.396100,0.),
vec3(0.751946,0.453352,0.),
vec3(0.078707,-0.715323,0.),
vec3(-0.075838,-0.529344,0.),
vec3(0.724479,-0.580798,0.),
vec3(0.222999,-0.215125,0.),
vec3(-0.467574,-0.405438,0.),
vec3(-0.248268,-0.814753,0.),
vec3(0.354411,-0.887570,0.),
vec3(0.175817,0.382366,0.),
vec3(0.487472,-0.063082,0.),
vec3(-0.084078,0.898312,0.),
vec3(0.488876,-0.783441,0.),
vec3(0.470016,0.217933,0.),
vec3(-0.696890,-0.549791,0.),
vec3(-0.149693,0.605762,0.),
vec3(0.034211,0.979980,0.),
vec3(0.503098,-0.308878,0.),
vec3(-0.016205,-0.872921,0.),
vec3(0.385784,-0.393902,0.),
vec3(-0.146886,-0.859249,0.),
vec3(0.643361,0.164098,0.),
vec3(0.634388,-0.049471,0.),
vec3(-0.688894,0.007843,0.),
vec3(0.464034,-0.188818,0.),
vec3(-0.440840,0.137486,0.),
vec3(0.364483,0.511704,0.),
vec3(0.034028,0.325968,0.),
vec3(0.099094,-0.308023,0.),
vec3(0.693960,-0.366253,0.),
vec3(0.678884,-0.204688,0.),
vec3(0.001801,0.780328,0.),
vec3(0.145177,-0.898984,0.),
vec3(0.062655,-0.611866,0.),
vec3(0.315226,-0.604297,0.),
vec3(-0.780145,0.486251,0.),
vec3(-0.371868,0.882138,0.),
vec3(0.200476,0.494430,0.),
vec3(-0.494552,-0.711051,0.),
vec3(0.612476,0.705252,0.),
vec3(-0.578845,-0.768792,0.),
vec3(-0.772454,-0.090976,0.),
vec3(0.504440,0.372295,0.),
vec3(0.155736,0.065157,0.),
vec3(0.391522,0.849605,0.),
vec3(-0.620106,-0.328104,0.),
vec3(0.789239,-0.419965,0.),
vec3(-0.545396,0.538133,0.),
vec3(-0.178564,-0.596057,0.)
);
#define inline
float computeShadowWithCSMPCSS(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray depthSampler,highp sampler2DArrayShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,int searchTapCount,int pcfTapCount,vec3[64] poissonSamplers,vec2 lightSizeUVCorrection,float depthCorrection,float penumbraDarkness)
{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));uvDepth.z=clamp(ZINCLIP,0.,GREATEST_LESS_THAN_ONE);vec4 uvDepthLayer=vec4(uvDepth.x,uvDepth.y,layer,uvDepth.z);float blockerDepth=0.0;float sumBlockerDepth=0.0;float numBlocker=0.0;for (int i=0; i<searchTapCount; i ++) {blockerDepth=texture2D(depthSampler,vec3(uvDepth.xy+(lightSizeUV*lightSizeUVCorrection*shadowMapSizeInverse*PoissonSamplers32[i].xy),layer)).r;if (blockerDepth<depthMetric) {sumBlockerDepth+=blockerDepth;numBlocker++;}}
float avgBlockerDepth=sumBlockerDepth/numBlocker;float AAOffset=shadowMapSizeInverse*10.;float penumbraRatio=((depthMetric-avgBlockerDepth)*depthCorrection+AAOffset);vec4 filterRadius=vec4(penumbraRatio*lightSizeUV*lightSizeUVCorrection*shadowMapSizeInverse,0.,0.);float random=getRand(vPositionFromLight.xy);float rotationAngle=random*3.1415926;vec2 rotationVector=vec2(cos(rotationAngle),sin(rotationAngle));float shadow=0.;for (int i=0; i<pcfTapCount; i++) {vec4 offset=vec4(poissonSamplers[i],0.);offset=vec4(offset.x*rotationVector.x-offset.y*rotationVector.y,offset.y*rotationVector.x+offset.x*rotationVector.y,0.,0.);shadow+=texture2D(shadowSampler,uvDepthLayer+offset*filterRadius);}
shadow/=float(pcfTapCount);shadow=mix(shadow,1.,min((depthMetric-avgBlockerDepth)*depthCorrection*penumbraDarkness,1.));shadow=mix(darkness,1.,shadow);if (numBlocker<1.0) {return 1.0;}
else
{return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);}}
#define inline
float computeShadowWithPCSS(vec4 vPositionFromLight,float depthMetric,sampler2D depthSampler,highp sampler2DShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,int searchTapCount,int pcfTapCount,vec3[64] poissonSamplers)
{if (depthMetric>1.0 || depthMetric<0.0) {return 1.0;}
else
{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));uvDepth.z=ZINCLIP;float blockerDepth=0.0;float sumBlockerDepth=0.0;float numBlocker=0.0;for (int i=0; i<searchTapCount; i ++) {blockerDepth=TEXTUREFUNC(depthSampler,uvDepth.xy+(lightSizeUV*shadowMapSizeInverse*PoissonSamplers32[i].xy),0.).r;if (blockerDepth<depthMetric) {sumBlockerDepth+=blockerDepth;numBlocker++;}}
if (numBlocker<1.0) {return 1.0;}
else
{float avgBlockerDepth=sumBlockerDepth/numBlocker;float AAOffset=shadowMapSizeInverse*10.;float penumbraRatio=((depthMetric-avgBlockerDepth)+AAOffset);float filterRadius=penumbraRatio*lightSizeUV*shadowMapSizeInverse;float random=getRand(vPositionFromLight.xy);float rotationAngle=random*3.1415926;vec2 rotationVector=vec2(cos(rotationAngle),sin(rotationAngle));float shadow=0.;for (int i=0; i<pcfTapCount; i++) {vec3 offset=poissonSamplers[i];offset=vec3(offset.x*rotationVector.x-offset.y*rotationVector.y,offset.y*rotationVector.x+offset.x*rotationVector.y,0.);shadow+=TEXTUREFUNC(shadowSampler,uvDepth+offset*filterRadius,0.);}
shadow/=float(pcfTapCount);shadow=mix(shadow,1.,depthMetric-avgBlockerDepth);shadow=mix(darkness,1.,shadow);return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);}}}
#define inline
float computeShadowWithPCSS16(vec4 vPositionFromLight,float depthMetric,sampler2D depthSampler,highp sampler2DShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff)
{return computeShadowWithPCSS(vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,16,16,PoissonSamplers32);}
#define inline
float computeShadowWithPCSS32(vec4 vPositionFromLight,float depthMetric,sampler2D depthSampler,highp sampler2DShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff)
{return computeShadowWithPCSS(vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,16,32,PoissonSamplers32);}
#define inline
float computeShadowWithPCSS64(vec4 vPositionFromLight,float depthMetric,sampler2D depthSampler,highp sampler2DShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff)
{return computeShadowWithPCSS(vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,32,64,PoissonSamplers64);}
#define inline
float computeShadowWithCSMPCSS16(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray depthSampler,highp sampler2DArrayShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,vec2 lightSizeUVCorrection,float depthCorrection,float penumbraDarkness)
{return computeShadowWithCSMPCSS(layer,vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,16,16,PoissonSamplers32,lightSizeUVCorrection,depthCorrection,penumbraDarkness);}
#define inline
float computeShadowWithCSMPCSS32(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray depthSampler,highp sampler2DArrayShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,vec2 lightSizeUVCorrection,float depthCorrection,float penumbraDarkness)
{return computeShadowWithCSMPCSS(layer,vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,16,32,PoissonSamplers32,lightSizeUVCorrection,depthCorrection,penumbraDarkness);}
#define inline
float computeShadowWithCSMPCSS64(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray depthSampler,highp sampler2DArrayShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,vec2 lightSizeUVCorrection,float depthCorrection,float penumbraDarkness)
{return computeShadowWithCSMPCSS(layer,vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,32,64,PoissonSamplers64,lightSizeUVCorrection,depthCorrection,penumbraDarkness);}
#endif
#endif
`;
ShaderStore.IncludesShadersStore[name13] = shader13;

// ../../node_modules/@babylonjs/core/Shaders/ShadersInclude/samplerFragmentDeclaration.js
var name14 = "samplerFragmentDeclaration";
var shader14 = `#ifdef _DEFINENAME_
#if _DEFINENAME_DIRECTUV==1
#define v_VARYINGNAME_UV vMainUV1
#elif _DEFINENAME_DIRECTUV==2
#define v_VARYINGNAME_UV vMainUV2
#elif _DEFINENAME_DIRECTUV==3
#define v_VARYINGNAME_UV vMainUV3
#elif _DEFINENAME_DIRECTUV==4
#define v_VARYINGNAME_UV vMainUV4
#elif _DEFINENAME_DIRECTUV==5
#define v_VARYINGNAME_UV vMainUV5
#elif _DEFINENAME_DIRECTUV==6
#define v_VARYINGNAME_UV vMainUV6
#else
varying vec2 v_VARYINGNAME_UV;
#endif
uniform sampler2D _SAMPLERNAME_Sampler;
#endif
`;
ShaderStore.IncludesShadersStore[name14] = shader14;

// ../../node_modules/@babylonjs/core/Shaders/ShadersInclude/fresnelFunction.js
var name15 = "fresnelFunction";
var shader15 = `#ifdef FRESNEL
float computeFresnelTerm(vec3 viewDirection,vec3 worldNormal,float bias,float power)
{float fresnelTerm=pow(bias+abs(dot(viewDirection,worldNormal)),power);return clamp(fresnelTerm,0.,1.);}
#endif
`;
ShaderStore.IncludesShadersStore[name15] = shader15;

// ../../node_modules/@babylonjs/core/Shaders/ShadersInclude/reflectionFunction.js
var name16 = "reflectionFunction";
var shader16 = `vec3 computeFixedEquirectangularCoords(vec4 worldPos,vec3 worldNormal,vec3 direction)
{float lon=atan(direction.z,direction.x);float lat=acos(direction.y);vec2 sphereCoords=vec2(lon,lat)*RECIPROCAL_PI2*2.0;float s=sphereCoords.x*0.5+0.5;float t=sphereCoords.y;return vec3(s,t,0); }
vec3 computeMirroredFixedEquirectangularCoords(vec4 worldPos,vec3 worldNormal,vec3 direction)
{float lon=atan(direction.z,direction.x);float lat=acos(direction.y);vec2 sphereCoords=vec2(lon,lat)*RECIPROCAL_PI2*2.0;float s=sphereCoords.x*0.5+0.5;float t=sphereCoords.y;return vec3(1.0-s,t,0); }
vec3 computeEquirectangularCoords(vec4 worldPos,vec3 worldNormal,vec3 eyePosition,mat4 reflectionMatrix)
{vec3 cameraToVertex=normalize(worldPos.xyz-eyePosition);vec3 r=normalize(reflect(cameraToVertex,worldNormal));r=vec3(reflectionMatrix*vec4(r,0));float lon=atan(r.z,r.x);float lat=acos(r.y);vec2 sphereCoords=vec2(lon,lat)*RECIPROCAL_PI2*2.0;float s=sphereCoords.x*0.5+0.5;float t=sphereCoords.y;return vec3(s,t,0);}
vec3 computeSphericalCoords(vec4 worldPos,vec3 worldNormal,mat4 view,mat4 reflectionMatrix)
{vec3 viewDir=normalize(vec3(view*worldPos));vec3 viewNormal=normalize(vec3(view*vec4(worldNormal,0.0)));vec3 r=reflect(viewDir,viewNormal);r=vec3(reflectionMatrix*vec4(r,0));r.z=r.z-1.0;float m=2.0*length(r);return vec3(r.x/m+0.5,1.0-r.y/m-0.5,0);}
vec3 computePlanarCoords(vec4 worldPos,vec3 worldNormal,vec3 eyePosition,mat4 reflectionMatrix)
{vec3 viewDir=worldPos.xyz-eyePosition;vec3 coords=normalize(reflect(viewDir,worldNormal));return vec3(reflectionMatrix*vec4(coords,1));}
vec3 computeCubicCoords(vec4 worldPos,vec3 worldNormal,vec3 eyePosition,mat4 reflectionMatrix)
{vec3 viewDir=normalize(worldPos.xyz-eyePosition);vec3 coords=reflect(viewDir,worldNormal);coords=vec3(reflectionMatrix*vec4(coords,0));
#ifdef INVERTCUBICMAP
coords.y*=-1.0;
#endif
return coords;}
vec3 computeCubicLocalCoords(vec4 worldPos,vec3 worldNormal,vec3 eyePosition,mat4 reflectionMatrix,vec3 reflectionSize,vec3 reflectionPosition)
{vec3 viewDir=normalize(worldPos.xyz-eyePosition);vec3 coords=reflect(viewDir,worldNormal);coords=parallaxCorrectNormal(worldPos.xyz,coords,reflectionSize,reflectionPosition);coords=vec3(reflectionMatrix*vec4(coords,0));
#ifdef INVERTCUBICMAP
coords.y*=-1.0;
#endif
return coords;}
vec3 computeProjectionCoords(vec4 worldPos,mat4 view,mat4 reflectionMatrix)
{return vec3(reflectionMatrix*(view*worldPos));}
vec3 computeSkyBoxCoords(vec3 positionW,mat4 reflectionMatrix)
{return vec3(reflectionMatrix*vec4(positionW,1.));}
#ifdef REFLECTION
vec3 computeReflectionCoords(vec4 worldPos,vec3 worldNormal)
{
#ifdef REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED
vec3 direction=normalize(vDirectionW);return computeMirroredFixedEquirectangularCoords(worldPos,worldNormal,direction);
#endif
#ifdef REFLECTIONMAP_EQUIRECTANGULAR_FIXED
vec3 direction=normalize(vDirectionW);return computeFixedEquirectangularCoords(worldPos,worldNormal,direction);
#endif
#ifdef REFLECTIONMAP_EQUIRECTANGULAR
return computeEquirectangularCoords(worldPos,worldNormal,vEyePosition.xyz,reflectionMatrix);
#endif
#ifdef REFLECTIONMAP_SPHERICAL
return computeSphericalCoords(worldPos,worldNormal,view,reflectionMatrix);
#endif
#ifdef REFLECTIONMAP_PLANAR
return computePlanarCoords(worldPos,worldNormal,vEyePosition.xyz,reflectionMatrix);
#endif
#ifdef REFLECTIONMAP_CUBIC
#ifdef USE_LOCAL_REFLECTIONMAP_CUBIC
return computeCubicLocalCoords(worldPos,worldNormal,vEyePosition.xyz,reflectionMatrix,vReflectionSize,vReflectionPosition);
#else
return computeCubicCoords(worldPos,worldNormal,vEyePosition.xyz,reflectionMatrix);
#endif
#endif
#ifdef REFLECTIONMAP_PROJECTION
return computeProjectionCoords(worldPos,view,reflectionMatrix);
#endif
#ifdef REFLECTIONMAP_SKYBOX
return computeSkyBoxCoords(vPositionUVW,reflectionMatrix);
#endif
#ifdef REFLECTIONMAP_EXPLICIT
return vec3(0,0,0);
#endif
}
#endif
`;
ShaderStore.IncludesShadersStore[name16] = shader16;

// ../../node_modules/@babylonjs/core/Shaders/ShadersInclude/imageProcessingDeclaration.js
var name17 = "imageProcessingDeclaration";
var shader17 = `#ifdef EXPOSURE
uniform float exposureLinear;
#endif
#ifdef CONTRAST
uniform float contrast;
#endif
#if defined(VIGNETTE) || defined(DITHER)
uniform vec2 vInverseScreenSize;
#endif
#ifdef VIGNETTE
uniform vec4 vignetteSettings1;uniform vec4 vignetteSettings2;
#endif
#ifdef COLORCURVES
uniform vec4 vCameraColorCurveNegative;uniform vec4 vCameraColorCurveNeutral;uniform vec4 vCameraColorCurvePositive;
#endif
#ifdef COLORGRADING
#ifdef COLORGRADING3D
uniform highp sampler3D txColorTransform;
#else
uniform sampler2D txColorTransform;
#endif
uniform vec4 colorTransformSettings;
#endif
#ifdef DITHER
uniform float ditherIntensity;
#endif
`;
ShaderStore.IncludesShadersStore[name17] = shader17;

// ../../node_modules/@babylonjs/core/Shaders/ShadersInclude/imageProcessingFunctions.js
var name18 = "imageProcessingFunctions";
var shader18 = `#if defined(COLORGRADING) && !defined(COLORGRADING3D)
/** 
* Polyfill for SAMPLE_TEXTURE_3D,which is unsupported in WebGL.
* sampler3dSetting.x=textureOffset (0.5/textureSize).
* sampler3dSetting.y=textureSize.
*/
#define inline
vec3 sampleTexture3D(sampler2D colorTransform,vec3 color,vec2 sampler3dSetting)
{float sliceSize=2.0*sampler3dSetting.x; 
#ifdef SAMPLER3DGREENDEPTH
float sliceContinuous=(color.g-sampler3dSetting.x)*sampler3dSetting.y;
#else
float sliceContinuous=(color.b-sampler3dSetting.x)*sampler3dSetting.y;
#endif
float sliceInteger=floor(sliceContinuous);float sliceFraction=sliceContinuous-sliceInteger;
#ifdef SAMPLER3DGREENDEPTH
vec2 sliceUV=color.rb;
#else
vec2 sliceUV=color.rg;
#endif
sliceUV.x*=sliceSize;sliceUV.x+=sliceInteger*sliceSize;sliceUV=saturate(sliceUV);vec4 slice0Color=texture2D(colorTransform,sliceUV);sliceUV.x+=sliceSize;sliceUV=saturate(sliceUV);vec4 slice1Color=texture2D(colorTransform,sliceUV);vec3 result=mix(slice0Color.rgb,slice1Color.rgb,sliceFraction);
#ifdef SAMPLER3DBGRMAP
color.rgb=result.rgb;
#else
color.rgb=result.bgr;
#endif
return color;}
#endif
#ifdef TONEMAPPING_ACES
const mat3 ACESInputMat=mat3(
vec3(0.59719,0.07600,0.02840),
vec3(0.35458,0.90834,0.13383),
vec3(0.04823,0.01566,0.83777)
);const mat3 ACESOutputMat=mat3(
vec3( 1.60475,-0.10208,-0.00327),
vec3(-0.53108, 1.10813,-0.07276),
vec3(-0.07367,-0.00605, 1.07602)
);vec3 RRTAndODTFit(vec3 v)
{vec3 a=v*(v+0.0245786)-0.000090537;vec3 b=v*(0.983729*v+0.4329510)+0.238081;return a/b;}
vec3 ACESFitted(vec3 color)
{color=ACESInputMat*color;color=RRTAndODTFit(color);color=ACESOutputMat*color;color=saturate(color);return color;}
#endif
#define CUSTOM_IMAGEPROCESSINGFUNCTIONS_DEFINITIONS
vec4 applyImageProcessing(vec4 result) {
#define CUSTOM_IMAGEPROCESSINGFUNCTIONS_UPDATERESULT_ATSTART
#ifdef EXPOSURE
result.rgb*=exposureLinear;
#endif
#ifdef VIGNETTE
vec2 viewportXY=gl_FragCoord.xy*vInverseScreenSize;viewportXY=viewportXY*2.0-1.0;vec3 vignetteXY1=vec3(viewportXY*vignetteSettings1.xy+vignetteSettings1.zw,1.0);float vignetteTerm=dot(vignetteXY1,vignetteXY1);float vignette=pow(vignetteTerm,vignetteSettings2.w);vec3 vignetteColor=vignetteSettings2.rgb;
#ifdef VIGNETTEBLENDMODEMULTIPLY
vec3 vignetteColorMultiplier=mix(vignetteColor,vec3(1,1,1),vignette);result.rgb*=vignetteColorMultiplier;
#endif
#ifdef VIGNETTEBLENDMODEOPAQUE
result.rgb=mix(vignetteColor,result.rgb,vignette);
#endif
#endif
#ifdef TONEMAPPING
#ifdef TONEMAPPING_ACES
result.rgb=ACESFitted(result.rgb);
#else
const float tonemappingCalibration=1.590579;result.rgb=1.0-exp2(-tonemappingCalibration*result.rgb);
#endif
#endif
result.rgb=toGammaSpace(result.rgb);result.rgb=saturate(result.rgb);
#ifdef CONTRAST
vec3 resultHighContrast=result.rgb*result.rgb*(3.0-2.0*result.rgb);if (contrast<1.0) {result.rgb=mix(vec3(0.5,0.5,0.5),result.rgb,contrast);} else {result.rgb=mix(result.rgb,resultHighContrast,contrast-1.0);}
#endif
#ifdef COLORGRADING
vec3 colorTransformInput=result.rgb*colorTransformSettings.xxx+colorTransformSettings.yyy;
#ifdef COLORGRADING3D
vec3 colorTransformOutput=texture(txColorTransform,colorTransformInput).rgb;
#else
vec3 colorTransformOutput=sampleTexture3D(txColorTransform,colorTransformInput,colorTransformSettings.yz).rgb;
#endif
result.rgb=mix(result.rgb,colorTransformOutput,colorTransformSettings.www);
#endif
#ifdef COLORCURVES
float luma=getLuminance(result.rgb);vec2 curveMix=clamp(vec2(luma*3.0-1.5,luma*-3.0+1.5),vec2(0.0),vec2(1.0));vec4 colorCurve=vCameraColorCurveNeutral+curveMix.x*vCameraColorCurvePositive-curveMix.y*vCameraColorCurveNegative;result.rgb*=colorCurve.rgb;result.rgb=mix(vec3(luma),result.rgb,colorCurve.a);
#endif
#ifdef DITHER
float rand=getRand(gl_FragCoord.xy*vInverseScreenSize);float dither=mix(-ditherIntensity,ditherIntensity,rand);result.rgb=saturate(result.rgb+vec3(dither));
#endif
#define CUSTOM_IMAGEPROCESSINGFUNCTIONS_UPDATERESULT_ATEND
return result;}`;
ShaderStore.IncludesShadersStore[name18] = shader18;

// ../../node_modules/@babylonjs/core/Shaders/ShadersInclude/bumpFragmentMainFunctions.js
var name19 = "bumpFragmentMainFunctions";
var shader19 = `#if defined(BUMP) || defined(CLEARCOAT_BUMP) || defined(ANISOTROPIC) || defined(DETAIL)
#if defined(TANGENT) && defined(NORMAL) 
varying mat3 vTBN;
#endif
#ifdef OBJECTSPACE_NORMALMAP
uniform mat4 normalMatrix;
#if defined(WEBGL2) || defined(WEBGPU)
mat4 toNormalMatrix(mat4 wMatrix)
{mat4 ret=inverse(wMatrix);ret=transpose(ret);ret[0][3]=0.;ret[1][3]=0.;ret[2][3]=0.;ret[3]=vec4(0.,0.,0.,1.);return ret;}
#else
mat4 toNormalMatrix(mat4 m)
{float
a00=m[0][0],a01=m[0][1],a02=m[0][2],a03=m[0][3],
a10=m[1][0],a11=m[1][1],a12=m[1][2],a13=m[1][3],
a20=m[2][0],a21=m[2][1],a22=m[2][2],a23=m[2][3],
a30=m[3][0],a31=m[3][1],a32=m[3][2],a33=m[3][3],
b00=a00*a11-a01*a10,
b01=a00*a12-a02*a10,
b02=a00*a13-a03*a10,
b03=a01*a12-a02*a11,
b04=a01*a13-a03*a11,
b05=a02*a13-a03*a12,
b06=a20*a31-a21*a30,
b07=a20*a32-a22*a30,
b08=a20*a33-a23*a30,
b09=a21*a32-a22*a31,
b10=a21*a33-a23*a31,
b11=a22*a33-a23*a32,
det=b00*b11-b01*b10+b02*b09+b03*b08-b04*b07+b05*b06;mat4 mi=mat4(
a11*b11-a12*b10+a13*b09,
a02*b10-a01*b11-a03*b09,
a31*b05-a32*b04+a33*b03,
a22*b04-a21*b05-a23*b03,
a12*b08-a10*b11-a13*b07,
a00*b11-a02*b08+a03*b07,
a32*b02-a30*b05-a33*b01,
a20*b05-a22*b02+a23*b01,
a10*b10-a11*b08+a13*b06,
a01*b08-a00*b10-a03*b06,
a30*b04-a31*b02+a33*b00,
a21*b02-a20*b04-a23*b00,
a11*b07-a10*b09-a12*b06,
a00*b09-a01*b07+a02*b06,
a31*b01-a30*b03-a32*b00,
a20*b03-a21*b01+a22*b00)/det;return mat4(mi[0][0],mi[1][0],mi[2][0],mi[3][0],
mi[0][1],mi[1][1],mi[2][1],mi[3][1],
mi[0][2],mi[1][2],mi[2][2],mi[3][2],
mi[0][3],mi[1][3],mi[2][3],mi[3][3]);}
#endif
#endif
vec3 perturbNormalBase(mat3 cotangentFrame,vec3 normal,float scale)
{
#ifdef NORMALXYSCALE
normal=normalize(normal*vec3(scale,scale,1.0));
#endif
return normalize(cotangentFrame*normal);}
vec3 perturbNormal(mat3 cotangentFrame,vec3 textureSample,float scale)
{return perturbNormalBase(cotangentFrame,textureSample*2.0-1.0,scale);}
mat3 cotangent_frame(vec3 normal,vec3 p,vec2 uv,vec2 tangentSpaceParams)
{vec3 dp1=dFdx(p);vec3 dp2=dFdy(p);vec2 duv1=dFdx(uv);vec2 duv2=dFdy(uv);vec3 dp2perp=cross(dp2,normal);vec3 dp1perp=cross(normal,dp1);vec3 tangent=dp2perp*duv1.x+dp1perp*duv2.x;vec3 bitangent=dp2perp*duv1.y+dp1perp*duv2.y;tangent*=tangentSpaceParams.x;bitangent*=tangentSpaceParams.y;float det=max(dot(tangent,tangent),dot(bitangent,bitangent));float invmax=det==0.0 ? 0.0 : inversesqrt(det);return mat3(tangent*invmax,bitangent*invmax,normal);}
#endif
`;
ShaderStore.IncludesShadersStore[name19] = shader19;

// ../../node_modules/@babylonjs/core/Shaders/ShadersInclude/bumpFragmentFunctions.js
var name20 = "bumpFragmentFunctions";
var shader20 = `#if defined(BUMP)
#include<samplerFragmentDeclaration>(_DEFINENAME_,BUMP,_VARYINGNAME_,Bump,_SAMPLERNAME_,bump)
#endif
#if defined(DETAIL)
#include<samplerFragmentDeclaration>(_DEFINENAME_,DETAIL,_VARYINGNAME_,Detail,_SAMPLERNAME_,detail)
#endif
#if defined(BUMP) && defined(PARALLAX)
const float minSamples=4.;const float maxSamples=15.;const int iMaxSamples=15;vec2 parallaxOcclusion(vec3 vViewDirCoT,vec3 vNormalCoT,vec2 texCoord,float parallaxScale) {float parallaxLimit=length(vViewDirCoT.xy)/vViewDirCoT.z;parallaxLimit*=parallaxScale;vec2 vOffsetDir=normalize(vViewDirCoT.xy);vec2 vMaxOffset=vOffsetDir*parallaxLimit;float numSamples=maxSamples+(dot(vViewDirCoT,vNormalCoT)*(minSamples-maxSamples));float stepSize=1.0/numSamples;float currRayHeight=1.0;vec2 vCurrOffset=vec2(0,0);vec2 vLastOffset=vec2(0,0);float lastSampledHeight=1.0;float currSampledHeight=1.0;bool keepWorking=true;for (int i=0; i<iMaxSamples; i++)
{currSampledHeight=texture2D(bumpSampler,texCoord+vCurrOffset).w;if (!keepWorking)
{}
else if (currSampledHeight>currRayHeight)
{float delta1=currSampledHeight-currRayHeight;float delta2=(currRayHeight+stepSize)-lastSampledHeight;float ratio=delta1/(delta1+delta2);vCurrOffset=(ratio)* vLastOffset+(1.0-ratio)*vCurrOffset;keepWorking=false;}
else
{currRayHeight-=stepSize;vLastOffset=vCurrOffset;
#ifdef PARALLAX_RHS
vCurrOffset-=stepSize*vMaxOffset;
#else
vCurrOffset+=stepSize*vMaxOffset;
#endif
lastSampledHeight=currSampledHeight;}}
return vCurrOffset;}
vec2 parallaxOffset(vec3 viewDir,float heightScale)
{float height=texture2D(bumpSampler,vBumpUV).w;vec2 texCoordOffset=heightScale*viewDir.xy*height;
#ifdef PARALLAX_RHS
return texCoordOffset;
#else
return -texCoordOffset;
#endif
}
#endif
`;
ShaderStore.IncludesShadersStore[name20] = shader20;

// ../../node_modules/@babylonjs/core/Shaders/ShadersInclude/clipPlaneFragmentDeclaration.js
var name21 = "clipPlaneFragmentDeclaration";
var shader21 = `#ifdef CLIPPLANE
varying float fClipDistance;
#endif
#ifdef CLIPPLANE2
varying float fClipDistance2;
#endif
#ifdef CLIPPLANE3
varying float fClipDistance3;
#endif
#ifdef CLIPPLANE4
varying float fClipDistance4;
#endif
#ifdef CLIPPLANE5
varying float fClipDistance5;
#endif
#ifdef CLIPPLANE6
varying float fClipDistance6;
#endif
`;
ShaderStore.IncludesShadersStore[name21] = shader21;

// ../../node_modules/@babylonjs/core/Shaders/ShadersInclude/logDepthDeclaration.js
var name22 = "logDepthDeclaration";
var shader22 = `#ifdef LOGARITHMICDEPTH
uniform float logarithmicDepthConstant;varying float vFragmentDepth;
#endif
`;
ShaderStore.IncludesShadersStore[name22] = shader22;

// ../../node_modules/@babylonjs/core/Shaders/ShadersInclude/fogFragmentDeclaration.js
var name23 = "fogFragmentDeclaration";
var shader23 = `#ifdef FOG
#define FOGMODE_NONE 0.
#define FOGMODE_EXP 1.
#define FOGMODE_EXP2 2.
#define FOGMODE_LINEAR 3.
#define E 2.71828
uniform vec4 vFogInfos;uniform vec3 vFogColor;varying vec3 vFogDistance;float CalcFogFactor()
{float fogCoeff=1.0;float fogStart=vFogInfos.y;float fogEnd=vFogInfos.z;float fogDensity=vFogInfos.w;float fogDistance=length(vFogDistance);if (FOGMODE_LINEAR==vFogInfos.x)
{fogCoeff=(fogEnd-fogDistance)/(fogEnd-fogStart);}
else if (FOGMODE_EXP==vFogInfos.x)
{fogCoeff=1.0/pow(E,fogDistance*fogDensity);}
else if (FOGMODE_EXP2==vFogInfos.x)
{fogCoeff=1.0/pow(E,fogDistance*fogDistance*fogDensity*fogDensity);}
return clamp(fogCoeff,0.0,1.0);}
#endif
`;
ShaderStore.IncludesShadersStore[name23] = shader23;

// ../../node_modules/@babylonjs/core/Shaders/ShadersInclude/clipPlaneFragment.js
var name24 = "clipPlaneFragment";
var shader24 = `#if defined(CLIPPLANE) || defined(CLIPPLANE2) || defined(CLIPPLANE3) || defined(CLIPPLANE4) || defined(CLIPPLANE5) || defined(CLIPPLANE6)
if (false) {}
#endif
#ifdef CLIPPLANE
else if (fClipDistance>0.0)
{discard;}
#endif
#ifdef CLIPPLANE2
else if (fClipDistance2>0.0)
{discard;}
#endif
#ifdef CLIPPLANE3
else if (fClipDistance3>0.0)
{discard;}
#endif
#ifdef CLIPPLANE4
else if (fClipDistance4>0.0)
{discard;}
#endif
#ifdef CLIPPLANE5
else if (fClipDistance5>0.0)
{discard;}
#endif
#ifdef CLIPPLANE6
else if (fClipDistance6>0.0)
{discard;}
#endif
`;
ShaderStore.IncludesShadersStore[name24] = shader24;

// ../../node_modules/@babylonjs/core/Shaders/ShadersInclude/bumpFragment.js
var name25 = "bumpFragment";
var shader25 = `vec2 uvOffset=vec2(0.0,0.0);
#if defined(BUMP) || defined(PARALLAX) || defined(DETAIL)
#ifdef NORMALXYSCALE
float normalScale=1.0;
#elif defined(BUMP)
float normalScale=vBumpInfos.y;
#else
float normalScale=1.0;
#endif
#if defined(TANGENT) && defined(NORMAL)
mat3 TBN=vTBN;
#elif defined(BUMP)
vec2 TBNUV=gl_FrontFacing ? vBumpUV : -vBumpUV;mat3 TBN=cotangent_frame(normalW*normalScale,vPositionW,TBNUV,vTangentSpaceParams);
#else
vec2 TBNUV=gl_FrontFacing ? vDetailUV : -vDetailUV;mat3 TBN=cotangent_frame(normalW*normalScale,vPositionW,TBNUV,vec2(1.,1.));
#endif
#elif defined(ANISOTROPIC)
#if defined(TANGENT) && defined(NORMAL)
mat3 TBN=vTBN;
#else
vec2 TBNUV=gl_FrontFacing ? vMainUV1 : -vMainUV1;mat3 TBN=cotangent_frame(normalW,vPositionW,TBNUV,vec2(1.,1.));
#endif
#endif
#ifdef PARALLAX
mat3 invTBN=transposeMat3(TBN);
#ifdef PARALLAXOCCLUSION
uvOffset=parallaxOcclusion(invTBN*-viewDirectionW,invTBN*normalW,vBumpUV,vBumpInfos.z);
#else
uvOffset=parallaxOffset(invTBN*viewDirectionW,vBumpInfos.z);
#endif
#endif
#ifdef DETAIL
vec4 detailColor=texture2D(detailSampler,vDetailUV+uvOffset);vec2 detailNormalRG=detailColor.wy*2.0-1.0;float detailNormalB=sqrt(1.-saturate(dot(detailNormalRG,detailNormalRG)));vec3 detailNormal=vec3(detailNormalRG,detailNormalB);
#endif
#ifdef BUMP
#ifdef OBJECTSPACE_NORMALMAP
#define CUSTOM_FRAGMENT_BUMP_FRAGMENT
normalW=normalize(texture2D(bumpSampler,vBumpUV).xyz *2.0-1.0);normalW=normalize(mat3(normalMatrix)*normalW);
#elif !defined(DETAIL)
normalW=perturbNormal(TBN,texture2D(bumpSampler,vBumpUV+uvOffset).xyz,vBumpInfos.y);
#else
vec3 bumpNormal=texture2D(bumpSampler,vBumpUV+uvOffset).xyz*2.0-1.0;
#if DETAIL_NORMALBLENDMETHOD==0 
detailNormal.xy*=vDetailInfos.z;vec3 blendedNormal=normalize(vec3(bumpNormal.xy+detailNormal.xy,bumpNormal.z*detailNormal.z));
#elif DETAIL_NORMALBLENDMETHOD==1 
detailNormal.xy*=vDetailInfos.z;bumpNormal+=vec3(0.0,0.0,1.0);detailNormal*=vec3(-1.0,-1.0,1.0);vec3 blendedNormal=bumpNormal*dot(bumpNormal,detailNormal)/bumpNormal.z-detailNormal;
#endif
normalW=perturbNormalBase(TBN,blendedNormal,vBumpInfos.y);
#endif
#elif defined(DETAIL)
detailNormal.xy*=vDetailInfos.z;normalW=perturbNormalBase(TBN,detailNormal,vDetailInfos.z);
#endif
`;
ShaderStore.IncludesShadersStore[name25] = shader25;

// ../../node_modules/@babylonjs/core/Shaders/ShadersInclude/decalFragment.js
var name26 = "decalFragment";
var shader26 = `#ifdef DECAL
#ifdef GAMMADECAL
decalColor.rgb=toLinearSpace(decalColor.rgb);
#endif
#ifdef DECAL_SMOOTHALPHA
decalColor.a*=decalColor.a;
#endif
surfaceAlbedo.rgb=mix(surfaceAlbedo.rgb,decalColor.rgb,decalColor.a);
#endif
`;
ShaderStore.IncludesShadersStore[name26] = shader26;

// ../../node_modules/@babylonjs/core/Shaders/ShadersInclude/depthPrePass.js
var name27 = "depthPrePass";
var shader27 = `#ifdef DEPTHPREPASS
gl_FragColor=vec4(0.,0.,0.,1.0);return;
#endif
`;
ShaderStore.IncludesShadersStore[name27] = shader27;

// ../../node_modules/@babylonjs/core/Shaders/ShadersInclude/lightFragment.js
var name28 = "lightFragment";
var shader28 = `#ifdef LIGHT{X}
#if defined(SHADOWONLY) || defined(LIGHTMAP) && defined(LIGHTMAPEXCLUDED{X}) && defined(LIGHTMAPNOSPECULAR{X})
#else
#ifdef PBR
#ifdef SPOTLIGHT{X}
preInfo=computePointAndSpotPreLightingInfo(light{X}.vLightData,viewDirectionW,normalW);
#elif defined(POINTLIGHT{X})
preInfo=computePointAndSpotPreLightingInfo(light{X}.vLightData,viewDirectionW,normalW);
#elif defined(HEMILIGHT{X})
preInfo=computeHemisphericPreLightingInfo(light{X}.vLightData,viewDirectionW,normalW);
#elif defined(DIRLIGHT{X})
preInfo=computeDirectionalPreLightingInfo(light{X}.vLightData,viewDirectionW,normalW);
#endif
preInfo.NdotV=NdotV;
#ifdef SPOTLIGHT{X}
#ifdef LIGHT_FALLOFF_GLTF{X}
preInfo.attenuation=computeDistanceLightFalloff_GLTF(preInfo.lightDistanceSquared,light{X}.vLightFalloff.y);preInfo.attenuation*=computeDirectionalLightFalloff_GLTF(light{X}.vLightDirection.xyz,preInfo.L,light{X}.vLightFalloff.z,light{X}.vLightFalloff.w);
#elif defined(LIGHT_FALLOFF_PHYSICAL{X})
preInfo.attenuation=computeDistanceLightFalloff_Physical(preInfo.lightDistanceSquared);preInfo.attenuation*=computeDirectionalLightFalloff_Physical(light{X}.vLightDirection.xyz,preInfo.L,light{X}.vLightDirection.w);
#elif defined(LIGHT_FALLOFF_STANDARD{X})
preInfo.attenuation=computeDistanceLightFalloff_Standard(preInfo.lightOffset,light{X}.vLightFalloff.x);preInfo.attenuation*=computeDirectionalLightFalloff_Standard(light{X}.vLightDirection.xyz,preInfo.L,light{X}.vLightDirection.w,light{X}.vLightData.w);
#else
preInfo.attenuation=computeDistanceLightFalloff(preInfo.lightOffset,preInfo.lightDistanceSquared,light{X}.vLightFalloff.x,light{X}.vLightFalloff.y);preInfo.attenuation*=computeDirectionalLightFalloff(light{X}.vLightDirection.xyz,preInfo.L,light{X}.vLightDirection.w,light{X}.vLightData.w,light{X}.vLightFalloff.z,light{X}.vLightFalloff.w);
#endif
#elif defined(POINTLIGHT{X})
#ifdef LIGHT_FALLOFF_GLTF{X}
preInfo.attenuation=computeDistanceLightFalloff_GLTF(preInfo.lightDistanceSquared,light{X}.vLightFalloff.y);
#elif defined(LIGHT_FALLOFF_PHYSICAL{X})
preInfo.attenuation=computeDistanceLightFalloff_Physical(preInfo.lightDistanceSquared);
#elif defined(LIGHT_FALLOFF_STANDARD{X})
preInfo.attenuation=computeDistanceLightFalloff_Standard(preInfo.lightOffset,light{X}.vLightFalloff.x);
#else
preInfo.attenuation=computeDistanceLightFalloff(preInfo.lightOffset,preInfo.lightDistanceSquared,light{X}.vLightFalloff.x,light{X}.vLightFalloff.y);
#endif
#else
preInfo.attenuation=1.0;
#endif
#ifdef HEMILIGHT{X}
preInfo.roughness=roughness;
#else
preInfo.roughness=adjustRoughnessFromLightProperties(roughness,light{X}.vLightSpecular.a,preInfo.lightDistance);
#endif
#ifdef IRIDESCENCE
preInfo.iridescenceIntensity=iridescenceIntensity;
#endif
#ifdef HEMILIGHT{X}
info.diffuse=computeHemisphericDiffuseLighting(preInfo,light{X}.vLightDiffuse.rgb,light{X}.vLightGround);
#elif defined(SS_TRANSLUCENCY)
info.diffuse=computeDiffuseAndTransmittedLighting(preInfo,light{X}.vLightDiffuse.rgb,subSurfaceOut.transmittance);
#else
info.diffuse=computeDiffuseLighting(preInfo,light{X}.vLightDiffuse.rgb);
#endif
#ifdef SPECULARTERM
#ifdef ANISOTROPIC
info.specular=computeAnisotropicSpecularLighting(preInfo,viewDirectionW,normalW,anisotropicOut.anisotropicTangent,anisotropicOut.anisotropicBitangent,anisotropicOut.anisotropy,clearcoatOut.specularEnvironmentR0,specularEnvironmentR90,AARoughnessFactors.x,light{X}.vLightDiffuse.rgb);
#else
info.specular=computeSpecularLighting(preInfo,normalW,clearcoatOut.specularEnvironmentR0,specularEnvironmentR90,AARoughnessFactors.x,light{X}.vLightDiffuse.rgb);
#endif
#endif
#ifdef SHEEN
#ifdef SHEEN_LINKWITHALBEDO
preInfo.roughness=sheenOut.sheenIntensity;
#else
#ifdef HEMILIGHT{X}
preInfo.roughness=sheenOut.sheenRoughness;
#else
preInfo.roughness=adjustRoughnessFromLightProperties(sheenOut.sheenRoughness,light{X}.vLightSpecular.a,preInfo.lightDistance);
#endif
#endif
info.sheen=computeSheenLighting(preInfo,normalW,sheenOut.sheenColor,specularEnvironmentR90,AARoughnessFactors.x,light{X}.vLightDiffuse.rgb);
#endif
#ifdef CLEARCOAT
#ifdef HEMILIGHT{X}
preInfo.roughness=clearcoatOut.clearCoatRoughness;
#else
preInfo.roughness=adjustRoughnessFromLightProperties(clearcoatOut.clearCoatRoughness,light{X}.vLightSpecular.a,preInfo.lightDistance);
#endif
info.clearCoat=computeClearCoatLighting(preInfo,clearcoatOut.clearCoatNormalW,clearcoatOut.clearCoatAARoughnessFactors.x,clearcoatOut.clearCoatIntensity,light{X}.vLightDiffuse.rgb);
#ifdef CLEARCOAT_TINT
absorption=computeClearCoatLightingAbsorption(clearcoatOut.clearCoatNdotVRefract,preInfo.L,clearcoatOut.clearCoatNormalW,clearcoatOut.clearCoatColor,clearcoatOut.clearCoatThickness,clearcoatOut.clearCoatIntensity);info.diffuse*=absorption;
#ifdef SPECULARTERM
info.specular*=absorption;
#endif
#endif
info.diffuse*=info.clearCoat.w;
#ifdef SPECULARTERM
info.specular*=info.clearCoat.w;
#endif
#ifdef SHEEN
info.sheen*=info.clearCoat.w;
#endif
#endif
#else
#ifdef SPOTLIGHT{X}
info=computeSpotLighting(viewDirectionW,normalW,light{X}.vLightData,light{X}.vLightDirection,light{X}.vLightDiffuse.rgb,light{X}.vLightSpecular.rgb,light{X}.vLightDiffuse.a,glossiness);
#elif defined(HEMILIGHT{X})
info=computeHemisphericLighting(viewDirectionW,normalW,light{X}.vLightData,light{X}.vLightDiffuse.rgb,light{X}.vLightSpecular.rgb,light{X}.vLightGround,glossiness);
#elif defined(POINTLIGHT{X}) || defined(DIRLIGHT{X})
info=computeLighting(viewDirectionW,normalW,light{X}.vLightData,light{X}.vLightDiffuse.rgb,light{X}.vLightSpecular.rgb,light{X}.vLightDiffuse.a,glossiness);
#endif
#endif
#ifdef PROJECTEDLIGHTTEXTURE{X}
info.diffuse*=computeProjectionTextureDiffuseLighting(projectionLightSampler{X},textureProjectionMatrix{X});
#endif
#endif
#ifdef SHADOW{X}
#ifdef SHADOWCSM{X}
for (int i=0; i<SHADOWCSMNUM_CASCADES{X}; i++) 
{
#ifdef SHADOWCSM_RIGHTHANDED{X}
diff{X}=viewFrustumZ{X}[i]+vPositionFromCamera{X}.z;
#else
diff{X}=viewFrustumZ{X}[i]-vPositionFromCamera{X}.z;
#endif
if (diff{X}>=0.) {index{X}=i;break;}}
#ifdef SHADOWCSMUSESHADOWMAXZ{X}
if (index{X}>=0)
#endif
{
#if defined(SHADOWPCF{X})
#if defined(SHADOWLOWQUALITY{X})
shadow=computeShadowWithCSMPCF1(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#elif defined(SHADOWMEDIUMQUALITY{X})
shadow=computeShadowWithCSMPCF3(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#else
shadow=computeShadowWithCSMPCF5(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#endif
#elif defined(SHADOWPCSS{X})
#if defined(SHADOWLOWQUALITY{X})
shadow=computeShadowWithCSMPCSS16(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});
#elif defined(SHADOWMEDIUMQUALITY{X})
shadow=computeShadowWithCSMPCSS32(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});
#else
shadow=computeShadowWithCSMPCSS64(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});
#endif
#else
shadow=computeShadowCSM(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#endif
#ifdef SHADOWCSMDEBUG{X}
shadowDebug{X}=vec3(shadow)*vCascadeColorsMultiplier{X}[index{X}];
#endif
#ifndef SHADOWCSMNOBLEND{X}
float frustumLength=frustumLengths{X}[index{X}];float diffRatio=clamp(diff{X}/frustumLength,0.,1.)*cascadeBlendFactor{X};if (index{X}<(SHADOWCSMNUM_CASCADES{X}-1) && diffRatio<1.)
{index{X}+=1;float nextShadow=0.;
#if defined(SHADOWPCF{X})
#if defined(SHADOWLOWQUALITY{X})
nextShadow=computeShadowWithCSMPCF1(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#elif defined(SHADOWMEDIUMQUALITY{X})
nextShadow=computeShadowWithCSMPCF3(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#else
nextShadow=computeShadowWithCSMPCF5(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#endif
#elif defined(SHADOWPCSS{X})
#if defined(SHADOWLOWQUALITY{X})
nextShadow=computeShadowWithCSMPCSS16(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});
#elif defined(SHADOWMEDIUMQUALITY{X})
nextShadow=computeShadowWithCSMPCSS32(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});
#else
nextShadow=computeShadowWithCSMPCSS64(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});
#endif
#else
nextShadow=computeShadowCSM(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#endif
shadow=mix(nextShadow,shadow,diffRatio);
#ifdef SHADOWCSMDEBUG{X}
shadowDebug{X}=mix(vec3(nextShadow)*vCascadeColorsMultiplier{X}[index{X}],shadowDebug{X},diffRatio);
#endif
}
#endif
}
#elif defined(SHADOWCLOSEESM{X})
#if defined(SHADOWCUBE{X})
shadow=computeShadowWithCloseESMCube(vPositionW,light{X}.vLightData.xyz,shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.z,light{X}.depthValues);
#else
shadow=computeShadowWithCloseESM(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.z,light{X}.shadowsInfo.w);
#endif
#elif defined(SHADOWESM{X})
#if defined(SHADOWCUBE{X})
shadow=computeShadowWithESMCube(vPositionW,light{X}.vLightData.xyz,shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.z,light{X}.depthValues);
#else
shadow=computeShadowWithESM(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.z,light{X}.shadowsInfo.w);
#endif
#elif defined(SHADOWPOISSON{X})
#if defined(SHADOWCUBE{X})
shadow=computeShadowWithPoissonSamplingCube(vPositionW,light{X}.vLightData.xyz,shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.x,light{X}.depthValues);
#else
shadow=computeShadowWithPoissonSampling(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#endif
#elif defined(SHADOWPCF{X})
#if defined(SHADOWLOWQUALITY{X})
shadow=computeShadowWithPCF1(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#elif defined(SHADOWMEDIUMQUALITY{X})
shadow=computeShadowWithPCF3(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#else
shadow=computeShadowWithPCF5(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#endif
#elif defined(SHADOWPCSS{X})
#if defined(SHADOWLOWQUALITY{X})
shadow=computeShadowWithPCSS16(vPositionFromLight{X},vDepthMetric{X},depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#elif defined(SHADOWMEDIUMQUALITY{X})
shadow=computeShadowWithPCSS32(vPositionFromLight{X},vDepthMetric{X},depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#else
shadow=computeShadowWithPCSS64(vPositionFromLight{X},vDepthMetric{X},depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#endif
#else
#if defined(SHADOWCUBE{X})
shadow=computeShadowCube(vPositionW,light{X}.vLightData.xyz,shadowSampler{X},light{X}.shadowsInfo.x,light{X}.depthValues);
#else
shadow=computeShadow(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#endif
#endif
#ifdef SHADOWONLY
#ifndef SHADOWINUSE
#define SHADOWINUSE
#endif
globalShadow+=shadow;shadowLightCount+=1.0;
#endif
#else
shadow=1.;
#endif
aggShadow+=shadow;numLights+=1.0;
#ifndef SHADOWONLY
#ifdef CUSTOMUSERLIGHTING
diffuseBase+=computeCustomDiffuseLighting(info,diffuseBase,shadow);
#ifdef SPECULARTERM
specularBase+=computeCustomSpecularLighting(info,specularBase,shadow);
#endif
#elif defined(LIGHTMAP) && defined(LIGHTMAPEXCLUDED{X})
diffuseBase+=lightmapColor.rgb*shadow;
#ifdef SPECULARTERM
#ifndef LIGHTMAPNOSPECULAR{X}
specularBase+=info.specular*shadow*lightmapColor.rgb;
#endif
#endif
#ifdef CLEARCOAT
#ifndef LIGHTMAPNOSPECULAR{X}
clearCoatBase+=info.clearCoat.rgb*shadow*lightmapColor.rgb;
#endif
#endif
#ifdef SHEEN
#ifndef LIGHTMAPNOSPECULAR{X}
sheenBase+=info.sheen.rgb*shadow;
#endif
#endif
#else
#ifdef SHADOWCSMDEBUG{X}
diffuseBase+=info.diffuse*shadowDebug{X};
#else 
diffuseBase+=info.diffuse*shadow;
#endif
#ifdef SPECULARTERM
specularBase+=info.specular*shadow;
#endif
#ifdef CLEARCOAT
clearCoatBase+=info.clearCoat.rgb*shadow;
#endif
#ifdef SHEEN
sheenBase+=info.sheen.rgb*shadow;
#endif
#endif
#endif
#endif
`;
ShaderStore.IncludesShadersStore[name28] = shader28;

// ../../node_modules/@babylonjs/core/Shaders/ShadersInclude/logDepthFragment.js
var name29 = "logDepthFragment";
var shader29 = `#ifdef LOGARITHMICDEPTH
gl_FragDepthEXT=log2(vFragmentDepth)*logarithmicDepthConstant*0.5;
#endif
`;
ShaderStore.IncludesShadersStore[name29] = shader29;

// ../../node_modules/@babylonjs/core/Shaders/ShadersInclude/fogFragment.js
var name30 = "fogFragment";
var shader30 = `#ifdef FOG
float fog=CalcFogFactor();
#ifdef PBR
fog=toLinearSpace(fog);
#endif
color.rgb=mix(vFogColor,color.rgb,fog);
#endif
`;
ShaderStore.IncludesShadersStore[name30] = shader30;

// ../../node_modules/@babylonjs/core/Shaders/ShadersInclude/oitFragment.js
var name31 = "oitFragment";
var shader31 = `#ifdef ORDER_INDEPENDENT_TRANSPARENCY
float fragDepth=gl_FragCoord.z; 
#ifdef ORDER_INDEPENDENT_TRANSPARENCY_16BITS
uint halfFloat=packHalf2x16(vec2(fragDepth));vec2 full=unpackHalf2x16(halfFloat);fragDepth=full.x;
#endif
ivec2 fragCoord=ivec2(gl_FragCoord.xy);vec2 lastDepth=texelFetch(oitDepthSampler,fragCoord,0).rg;vec4 lastFrontColor=texelFetch(oitFrontColorSampler,fragCoord,0);depth.rg=vec2(-MAX_DEPTH);frontColor=lastFrontColor;backColor=vec4(0.0);
#ifdef USE_REVERSE_DEPTHBUFFER
float furthestDepth=-lastDepth.x;float nearestDepth=lastDepth.y;
#else
float nearestDepth=-lastDepth.x;float furthestDepth=lastDepth.y;
#endif
float alphaMultiplier=1.0-lastFrontColor.a;
#ifdef USE_REVERSE_DEPTHBUFFER
if (fragDepth>nearestDepth || fragDepth<furthestDepth) {
#else
if (fragDepth<nearestDepth || fragDepth>furthestDepth) {
#endif
return;}
#ifdef USE_REVERSE_DEPTHBUFFER
if (fragDepth<nearestDepth && fragDepth>furthestDepth) {
#else
if (fragDepth>nearestDepth && fragDepth<furthestDepth) {
#endif
depth.rg=vec2(-fragDepth,fragDepth);return;}
#endif
`;
ShaderStore.IncludesShadersStore[name31] = shader31;

// ../../node_modules/@babylonjs/core/Shaders/default.fragment.js
var name32 = "defaultPixelShader";
var shader32 = `#include<__decl__defaultFragment>
#if defined(BUMP) || !defined(NORMAL)
#extension GL_OES_standard_derivatives : enable
#endif
#include<prePassDeclaration>[SCENE_MRT_COUNT]
#include<oitDeclaration>
#define CUSTOM_FRAGMENT_BEGIN
#ifdef LOGARITHMICDEPTH
#extension GL_EXT_frag_depth : enable
#endif
varying vec3 vPositionW;
#ifdef NORMAL
varying vec3 vNormalW;
#endif
#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)
varying vec4 vColor;
#endif
#include<mainUVVaryingDeclaration>[1..7]
#include<helperFunctions>
#include<__decl__lightFragment>[0..maxSimultaneousLights]
#include<lightsFragmentFunctions>
#include<shadowsFragmentFunctions>
#include<samplerFragmentDeclaration>(_DEFINENAME_,DIFFUSE,_VARYINGNAME_,Diffuse,_SAMPLERNAME_,diffuse)
#include<samplerFragmentDeclaration>(_DEFINENAME_,AMBIENT,_VARYINGNAME_,Ambient,_SAMPLERNAME_,ambient)
#include<samplerFragmentDeclaration>(_DEFINENAME_,OPACITY,_VARYINGNAME_,Opacity,_SAMPLERNAME_,opacity)
#include<samplerFragmentDeclaration>(_DEFINENAME_,EMISSIVE,_VARYINGNAME_,Emissive,_SAMPLERNAME_,emissive)
#include<samplerFragmentDeclaration>(_DEFINENAME_,LIGHTMAP,_VARYINGNAME_,Lightmap,_SAMPLERNAME_,lightmap)
#include<samplerFragmentDeclaration>(_DEFINENAME_,DECAL,_VARYINGNAME_,Decal,_SAMPLERNAME_,decal)
#ifdef REFRACTION
#ifdef REFRACTIONMAP_3D
uniform samplerCube refractionCubeSampler;
#else
uniform sampler2D refraction2DSampler;
#endif
#endif
#if defined(SPECULARTERM)
#include<samplerFragmentDeclaration>(_DEFINENAME_,SPECULAR,_VARYINGNAME_,Specular,_SAMPLERNAME_,specular)
#endif
#include<fresnelFunction>
#ifdef REFLECTION
#ifdef REFLECTIONMAP_3D
uniform samplerCube reflectionCubeSampler;
#else
uniform sampler2D reflection2DSampler;
#endif
#ifdef REFLECTIONMAP_SKYBOX
varying vec3 vPositionUVW;
#else
#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)
varying vec3 vDirectionW;
#endif
#endif
#include<reflectionFunction>
#endif
#include<imageProcessingDeclaration>
#include<imageProcessingFunctions>
#include<bumpFragmentMainFunctions>
#include<bumpFragmentFunctions>
#include<clipPlaneFragmentDeclaration>
#include<logDepthDeclaration>
#include<fogFragmentDeclaration>
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void) {
#define CUSTOM_FRAGMENT_MAIN_BEGIN
#include<clipPlaneFragment>
vec3 viewDirectionW=normalize(vEyePosition.xyz-vPositionW);vec4 baseColor=vec4(1.,1.,1.,1.);vec3 diffuseColor=vDiffuseColor.rgb;float alpha=vDiffuseColor.a;
#ifdef NORMAL
vec3 normalW=normalize(vNormalW);
#else
vec3 normalW=normalize(-cross(dFdx(vPositionW),dFdy(vPositionW)));
#endif
#include<bumpFragment>
#ifdef TWOSIDEDLIGHTING
normalW=gl_FrontFacing ? normalW : -normalW;
#endif
#ifdef DIFFUSE
baseColor=texture2D(diffuseSampler,vDiffuseUV+uvOffset);
#if defined(ALPHATEST) && !defined(ALPHATEST_AFTERALLALPHACOMPUTATIONS)
if (baseColor.a<alphaCutOff)
discard;
#endif
#ifdef ALPHAFROMDIFFUSE
alpha*=baseColor.a;
#endif
#define CUSTOM_FRAGMENT_UPDATE_ALPHA
baseColor.rgb*=vDiffuseInfos.y;
#endif
#if defined(DECAL) && !defined(DECAL_AFTER_DETAIL)
vec4 decalColor=texture2D(decalSampler,vDecalUV+uvOffset);
#include<decalFragment>(surfaceAlbedo,baseColor,GAMMADECAL,_GAMMADECAL_NOTUSED_)
#endif
#include<depthPrePass>
#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)
baseColor.rgb*=vColor.rgb;
#endif
#ifdef DETAIL
baseColor.rgb=baseColor.rgb*2.0*mix(0.5,detailColor.r,vDetailInfos.y);
#endif
#if defined(DECAL) && defined(DECAL_AFTER_DETAIL)
vec4 decalColor=texture2D(decalSampler,vDecalUV+uvOffset);
#include<decalFragment>(surfaceAlbedo,baseColor,GAMMADECAL,_GAMMADECAL_NOTUSED_)
#endif
#define CUSTOM_FRAGMENT_UPDATE_DIFFUSE
vec3 baseAmbientColor=vec3(1.,1.,1.);
#ifdef AMBIENT
baseAmbientColor=texture2D(ambientSampler,vAmbientUV+uvOffset).rgb*vAmbientInfos.y;
#endif
#define CUSTOM_FRAGMENT_BEFORE_LIGHTS
#ifdef SPECULARTERM
float glossiness=vSpecularColor.a;vec3 specularColor=vSpecularColor.rgb;
#ifdef SPECULAR
vec4 specularMapColor=texture2D(specularSampler,vSpecularUV+uvOffset);specularColor=specularMapColor.rgb;
#ifdef GLOSSINESS
glossiness=glossiness*specularMapColor.a;
#endif
#endif
#else
float glossiness=0.;
#endif
vec3 diffuseBase=vec3(0.,0.,0.);lightingInfo info;
#ifdef SPECULARTERM
vec3 specularBase=vec3(0.,0.,0.);
#endif
float shadow=1.;float aggShadow=0.;float numLights=0.;
#ifdef LIGHTMAP
vec4 lightmapColor=texture2D(lightmapSampler,vLightmapUV+uvOffset);
#ifdef RGBDLIGHTMAP
lightmapColor.rgb=fromRGBD(lightmapColor);
#endif
lightmapColor.rgb*=vLightmapInfos.y;
#endif
#include<lightFragment>[0..maxSimultaneousLights]
aggShadow=aggShadow/numLights;vec4 refractionColor=vec4(0.,0.,0.,1.);
#ifdef REFRACTION
vec3 refractionVector=normalize(refract(-viewDirectionW,normalW,vRefractionInfos.y));
#ifdef REFRACTIONMAP_3D
#ifdef USE_LOCAL_REFRACTIONMAP_CUBIC
refractionVector=parallaxCorrectNormal(vPositionW,refractionVector,vRefractionSize,vRefractionPosition);
#endif
refractionVector.y=refractionVector.y*vRefractionInfos.w;vec4 refractionLookup=textureCube(refractionCubeSampler,refractionVector);if (dot(refractionVector,viewDirectionW)<1.0) {refractionColor=refractionLookup;}
#else
vec3 vRefractionUVW=vec3(refractionMatrix*(view*vec4(vPositionW+refractionVector*vRefractionInfos.z,1.0)));vec2 refractionCoords=vRefractionUVW.xy/vRefractionUVW.z;refractionCoords.y=1.0-refractionCoords.y;refractionColor=texture2D(refraction2DSampler,refractionCoords);
#endif
#ifdef RGBDREFRACTION
refractionColor.rgb=fromRGBD(refractionColor);
#endif
#ifdef IS_REFRACTION_LINEAR
refractionColor.rgb=toGammaSpace(refractionColor.rgb);
#endif
refractionColor.rgb*=vRefractionInfos.x;
#endif
vec4 reflectionColor=vec4(0.,0.,0.,1.);
#ifdef REFLECTION
vec3 vReflectionUVW=computeReflectionCoords(vec4(vPositionW,1.0),normalW);
#ifdef REFLECTIONMAP_OPPOSITEZ
vReflectionUVW.z*=-1.0;
#endif
#ifdef REFLECTIONMAP_3D
#ifdef ROUGHNESS
float bias=vReflectionInfos.y;
#ifdef SPECULARTERM
#ifdef SPECULAR
#ifdef GLOSSINESS
bias*=(1.0-specularMapColor.a);
#endif
#endif
#endif
reflectionColor=textureCube(reflectionCubeSampler,vReflectionUVW,bias);
#else
reflectionColor=textureCube(reflectionCubeSampler,vReflectionUVW);
#endif
#else
vec2 coords=vReflectionUVW.xy;
#ifdef REFLECTIONMAP_PROJECTION
coords/=vReflectionUVW.z;
#endif
coords.y=1.0-coords.y;reflectionColor=texture2D(reflection2DSampler,coords);
#endif
#ifdef RGBDREFLECTION
reflectionColor.rgb=fromRGBD(reflectionColor);
#endif
#ifdef IS_REFLECTION_LINEAR
reflectionColor.rgb=toGammaSpace(reflectionColor.rgb);
#endif
reflectionColor.rgb*=vReflectionInfos.x;
#ifdef REFLECTIONFRESNEL
float reflectionFresnelTerm=computeFresnelTerm(viewDirectionW,normalW,reflectionRightColor.a,reflectionLeftColor.a);
#ifdef REFLECTIONFRESNELFROMSPECULAR
#ifdef SPECULARTERM
reflectionColor.rgb*=specularColor.rgb*(1.0-reflectionFresnelTerm)+reflectionFresnelTerm*reflectionRightColor.rgb;
#else
reflectionColor.rgb*=reflectionLeftColor.rgb*(1.0-reflectionFresnelTerm)+reflectionFresnelTerm*reflectionRightColor.rgb;
#endif
#else
reflectionColor.rgb*=reflectionLeftColor.rgb*(1.0-reflectionFresnelTerm)+reflectionFresnelTerm*reflectionRightColor.rgb;
#endif
#endif
#endif
#ifdef REFRACTIONFRESNEL
float refractionFresnelTerm=computeFresnelTerm(viewDirectionW,normalW,refractionRightColor.a,refractionLeftColor.a);refractionColor.rgb*=refractionLeftColor.rgb*(1.0-refractionFresnelTerm)+refractionFresnelTerm*refractionRightColor.rgb;
#endif
#ifdef OPACITY
vec4 opacityMap=texture2D(opacitySampler,vOpacityUV+uvOffset);
#ifdef OPACITYRGB
opacityMap.rgb=opacityMap.rgb*vec3(0.3,0.59,0.11);alpha*=(opacityMap.x+opacityMap.y+opacityMap.z)* vOpacityInfos.y;
#else
alpha*=opacityMap.a*vOpacityInfos.y;
#endif
#endif
#if defined(VERTEXALPHA) || defined(INSTANCESCOLOR) && defined(INSTANCES)
alpha*=vColor.a;
#endif
#ifdef OPACITYFRESNEL
float opacityFresnelTerm=computeFresnelTerm(viewDirectionW,normalW,opacityParts.z,opacityParts.w);alpha+=opacityParts.x*(1.0-opacityFresnelTerm)+opacityFresnelTerm*opacityParts.y;
#endif
#ifdef ALPHATEST
#ifdef ALPHATEST_AFTERALLALPHACOMPUTATIONS
if (alpha<alphaCutOff)
discard;
#endif
#ifndef ALPHABLEND
alpha=1.0;
#endif
#endif
vec3 emissiveColor=vEmissiveColor;
#ifdef EMISSIVE
emissiveColor+=texture2D(emissiveSampler,vEmissiveUV+uvOffset).rgb*vEmissiveInfos.y;
#endif
#ifdef EMISSIVEFRESNEL
float emissiveFresnelTerm=computeFresnelTerm(viewDirectionW,normalW,emissiveRightColor.a,emissiveLeftColor.a);emissiveColor*=emissiveLeftColor.rgb*(1.0-emissiveFresnelTerm)+emissiveFresnelTerm*emissiveRightColor.rgb;
#endif
#ifdef DIFFUSEFRESNEL
float diffuseFresnelTerm=computeFresnelTerm(viewDirectionW,normalW,diffuseRightColor.a,diffuseLeftColor.a);diffuseBase*=diffuseLeftColor.rgb*(1.0-diffuseFresnelTerm)+diffuseFresnelTerm*diffuseRightColor.rgb;
#endif
#ifdef EMISSIVEASILLUMINATION
vec3 finalDiffuse=clamp(diffuseBase*diffuseColor+vAmbientColor,0.0,1.0)*baseColor.rgb;
#else
#ifdef LINKEMISSIVEWITHDIFFUSE
vec3 finalDiffuse=clamp((diffuseBase+emissiveColor)*diffuseColor+vAmbientColor,0.0,1.0)*baseColor.rgb;
#else
vec3 finalDiffuse=clamp(diffuseBase*diffuseColor+emissiveColor+vAmbientColor,0.0,1.0)*baseColor.rgb;
#endif
#endif
#ifdef SPECULARTERM
vec3 finalSpecular=specularBase*specularColor;
#ifdef SPECULAROVERALPHA
alpha=clamp(alpha+dot(finalSpecular,vec3(0.3,0.59,0.11)),0.,1.);
#endif
#else
vec3 finalSpecular=vec3(0.0);
#endif
#ifdef REFLECTIONOVERALPHA
alpha=clamp(alpha+dot(reflectionColor.rgb,vec3(0.3,0.59,0.11)),0.,1.);
#endif
#ifdef EMISSIVEASILLUMINATION
vec4 color=vec4(clamp(finalDiffuse*baseAmbientColor+finalSpecular+reflectionColor.rgb+emissiveColor+refractionColor.rgb,0.0,1.0),alpha);
#else
vec4 color=vec4(finalDiffuse*baseAmbientColor+finalSpecular+reflectionColor.rgb+refractionColor.rgb,alpha);
#endif
#ifdef LIGHTMAP
#ifndef LIGHTMAPEXCLUDED
#ifdef USELIGHTMAPASSHADOWMAP
color.rgb*=lightmapColor.rgb;
#else
color.rgb+=lightmapColor.rgb;
#endif
#endif
#endif
#define CUSTOM_FRAGMENT_BEFORE_FOG
color.rgb=max(color.rgb,0.);
#include<logDepthFragment>
#include<fogFragment>
#ifdef IMAGEPROCESSINGPOSTPROCESS
color.rgb=toLinearSpace(color.rgb);
#else
#ifdef IMAGEPROCESSING
color.rgb=toLinearSpace(color.rgb);color=applyImageProcessing(color);
#endif
#endif
color.a*=visibility;
#ifdef PREMULTIPLYALPHA
color.rgb*=color.a;
#endif
#define CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR
#ifdef PREPASS
float writeGeometryInfo=color.a>0.4 ? 1.0 : 0.0;gl_FragData[0]=color; 
#ifdef PREPASS_POSITION
gl_FragData[PREPASS_POSITION_INDEX]=vec4(vPositionW,writeGeometryInfo);
#endif
#ifdef PREPASS_VELOCITY
vec2 a=(vCurrentPosition.xy/vCurrentPosition.w)*0.5+0.5;vec2 b=(vPreviousPosition.xy/vPreviousPosition.w)*0.5+0.5;vec2 velocity=abs(a-b);velocity=vec2(pow(velocity.x,1.0/3.0),pow(velocity.y,1.0/3.0))*sign(a-b)*0.5+0.5;gl_FragData[PREPASS_VELOCITY_INDEX]=vec4(velocity,0.0,writeGeometryInfo);
#endif
#ifdef PREPASS_IRRADIANCE
gl_FragData[PREPASS_IRRADIANCE_INDEX]=vec4(0.0,0.0,0.0,writeGeometryInfo); 
#endif
#ifdef PREPASS_DEPTH
gl_FragData[PREPASS_DEPTH_INDEX]=vec4(vViewPos.z,0.0,0.0,writeGeometryInfo); 
#endif
#ifdef PREPASS_NORMAL
#ifdef PREPASS_NORMAL_WORLDSPACE
gl_FragData[PREPASS_NORMAL_INDEX]=vec4(normalW,writeGeometryInfo); 
#else
gl_FragData[PREPASS_NORMAL_INDEX]=vec4(normalize((view*vec4(normalW,0.0)).rgb),writeGeometryInfo); 
#endif
#endif
#ifdef PREPASS_ALBEDO_SQRT
gl_FragData[PREPASS_ALBEDO_SQRT_INDEX]=vec4(0.0,0.0,0.0,writeGeometryInfo); 
#endif
#ifdef PREPASS_REFLECTIVITY
#if defined(SPECULARTERM)
#if defined(SPECULAR)
gl_FragData[PREPASS_REFLECTIVITY_INDEX]=vec4(toLinearSpace(specularMapColor))*writeGeometryInfo; 
#else
gl_FragData[PREPASS_REFLECTIVITY_INDEX]=vec4(toLinearSpace(specularColor),1.0)*writeGeometryInfo;
#endif
#else
gl_FragData[PREPASS_REFLECTIVITY_INDEX]=vec4(0.0,0.0,0.0,1.0)*writeGeometryInfo;
#endif
#endif
#endif
#if !defined(PREPASS) || defined(WEBGL2)
gl_FragColor=color;
#endif
#include<oitFragment>
#if ORDER_INDEPENDENT_TRANSPARENCY
if (fragDepth==nearestDepth) {frontColor.rgb+=color.rgb*color.a*alphaMultiplier;frontColor.a=1.0-alphaMultiplier*(1.0-color.a);} else {backColor+=color;}
#endif
#define CUSTOM_FRAGMENT_MAIN_END
}
`;
ShaderStore.ShadersStore[name32] = shader32;

// ../../node_modules/@babylonjs/core/Shaders/ShadersInclude/decalVertexDeclaration.js
var name33 = "decalVertexDeclaration";
var shader33 = `#ifdef DECAL
uniform vec4 vDecalInfos;uniform mat4 decalMatrix;
#endif
`;
ShaderStore.IncludesShadersStore[name33] = shader33;

// ../../node_modules/@babylonjs/core/Shaders/ShadersInclude/defaultVertexDeclaration.js
var name34 = "defaultVertexDeclaration";
var shader34 = `uniform mat4 viewProjection;uniform mat4 view;
#ifdef DIFFUSE
uniform mat4 diffuseMatrix;uniform vec2 vDiffuseInfos;
#endif
#ifdef AMBIENT
uniform mat4 ambientMatrix;uniform vec2 vAmbientInfos;
#endif
#ifdef OPACITY
uniform mat4 opacityMatrix;uniform vec2 vOpacityInfos;
#endif
#ifdef EMISSIVE
uniform vec2 vEmissiveInfos;uniform mat4 emissiveMatrix;
#endif
#ifdef LIGHTMAP
uniform vec2 vLightmapInfos;uniform mat4 lightmapMatrix;
#endif
#if defined(SPECULAR) && defined(SPECULARTERM)
uniform vec2 vSpecularInfos;uniform mat4 specularMatrix;
#endif
#ifdef BUMP
uniform vec3 vBumpInfos;uniform mat4 bumpMatrix;
#endif
#ifdef REFLECTION
uniform mat4 reflectionMatrix;
#endif
#ifdef POINTSIZE
uniform float pointSize;
#endif
#ifdef DETAIL
uniform vec4 vDetailInfos;uniform mat4 detailMatrix;
#endif
#include<decalVertexDeclaration>
#define ADDITIONAL_VERTEX_DECLARATION
`;
ShaderStore.IncludesShadersStore[name34] = shader34;

// ../../node_modules/@babylonjs/core/Shaders/ShadersInclude/uvAttributeDeclaration.js
var name35 = "uvAttributeDeclaration";
var shader35 = `#ifdef UV{X}
attribute vec2 uv{X};
#endif
`;
ShaderStore.IncludesShadersStore[name35] = shader35;

// ../../node_modules/@babylonjs/core/Shaders/ShadersInclude/bonesDeclaration.js
var name36 = "bonesDeclaration";
var shader36 = `#if NUM_BONE_INFLUENCERS>0
attribute vec4 matricesIndices;attribute vec4 matricesWeights;
#if NUM_BONE_INFLUENCERS>4
attribute vec4 matricesIndicesExtra;attribute vec4 matricesWeightsExtra;
#endif
#ifndef BAKED_VERTEX_ANIMATION_TEXTURE
#ifdef BONETEXTURE
uniform highp sampler2D boneSampler;uniform float boneTextureWidth;
#else
uniform mat4 mBones[BonesPerMesh];
#endif
#ifdef BONES_VELOCITY_ENABLED
uniform mat4 mPreviousBones[BonesPerMesh];
#endif
#ifdef BONETEXTURE
#define inline
mat4 readMatrixFromRawSampler(sampler2D smp,float index)
{float offset=index *4.0;float dx=1.0/boneTextureWidth;vec4 m0=texture2D(smp,vec2(dx*(offset+0.5),0.));vec4 m1=texture2D(smp,vec2(dx*(offset+1.5),0.));vec4 m2=texture2D(smp,vec2(dx*(offset+2.5),0.));vec4 m3=texture2D(smp,vec2(dx*(offset+3.5),0.));return mat4(m0,m1,m2,m3);}
#endif
#endif
#endif
`;
ShaderStore.IncludesShadersStore[name36] = shader36;

// ../../node_modules/@babylonjs/core/Shaders/ShadersInclude/bakedVertexAnimationDeclaration.js
var name37 = "bakedVertexAnimationDeclaration";
var shader37 = `#ifdef BAKED_VERTEX_ANIMATION_TEXTURE
uniform float bakedVertexAnimationTime;uniform vec2 bakedVertexAnimationTextureSizeInverted;uniform vec4 bakedVertexAnimationSettings;uniform sampler2D bakedVertexAnimationTexture;
#ifdef INSTANCES
attribute vec4 bakedVertexAnimationSettingsInstanced;
#endif
#define inline
mat4 readMatrixFromRawSamplerVAT(sampler2D smp,float index,float frame)
{float offset=index*4.0;float frameUV=(frame+0.5)*bakedVertexAnimationTextureSizeInverted.y;float dx=bakedVertexAnimationTextureSizeInverted.x;vec4 m0=texture2D(smp,vec2(dx*(offset+0.5),frameUV));vec4 m1=texture2D(smp,vec2(dx*(offset+1.5),frameUV));vec4 m2=texture2D(smp,vec2(dx*(offset+2.5),frameUV));vec4 m3=texture2D(smp,vec2(dx*(offset+3.5),frameUV));return mat4(m0,m1,m2,m3);}
#endif
`;
ShaderStore.IncludesShadersStore[name37] = shader37;

// ../../node_modules/@babylonjs/core/Shaders/ShadersInclude/instancesDeclaration.js
var name38 = "instancesDeclaration";
var shader38 = `#ifdef INSTANCES
attribute vec4 world0;attribute vec4 world1;attribute vec4 world2;attribute vec4 world3;
#ifdef INSTANCESCOLOR
attribute vec4 instanceColor;
#endif
#if defined(THIN_INSTANCES) && !defined(WORLD_UBO)
uniform mat4 world;
#endif
#if defined(VELOCITY) || defined(PREPASS_VELOCITY)
attribute vec4 previousWorld0;attribute vec4 previousWorld1;attribute vec4 previousWorld2;attribute vec4 previousWorld3;
#ifdef THIN_INSTANCES
uniform mat4 previousWorld;
#endif
#endif
#else
#if !defined(WORLD_UBO)
uniform mat4 world;
#endif
#if defined(VELOCITY) || defined(PREPASS_VELOCITY)
uniform mat4 previousWorld;
#endif
#endif
`;
ShaderStore.IncludesShadersStore[name38] = shader38;

// ../../node_modules/@babylonjs/core/Shaders/ShadersInclude/prePassVertexDeclaration.js
var name39 = "prePassVertexDeclaration";
var shader39 = `#ifdef PREPASS
#ifdef PREPASS_DEPTH
varying vec3 vViewPos;
#endif
#ifdef PREPASS_VELOCITY
uniform mat4 previousViewProjection;varying vec4 vCurrentPosition;varying vec4 vPreviousPosition;
#endif
#endif
`;
ShaderStore.IncludesShadersStore[name39] = shader39;

// ../../node_modules/@babylonjs/core/Shaders/ShadersInclude/samplerVertexDeclaration.js
var name40 = "samplerVertexDeclaration";
var shader40 = `#if defined(_DEFINENAME_) && _DEFINENAME_DIRECTUV==0
varying vec2 v_VARYINGNAME_UV;
#endif
`;
ShaderStore.IncludesShadersStore[name40] = shader40;

// ../../node_modules/@babylonjs/core/Shaders/ShadersInclude/bumpVertexDeclaration.js
var name41 = "bumpVertexDeclaration";
var shader41 = `#if defined(BUMP) || defined(PARALLAX) || defined(CLEARCOAT_BUMP) || defined(ANISOTROPIC)
#if defined(TANGENT) && defined(NORMAL) 
varying mat3 vTBN;
#endif
#endif
`;
ShaderStore.IncludesShadersStore[name41] = shader41;

// ../../node_modules/@babylonjs/core/Shaders/ShadersInclude/clipPlaneVertexDeclaration.js
var name42 = "clipPlaneVertexDeclaration";
var shader42 = `#ifdef CLIPPLANE
uniform vec4 vClipPlane;varying float fClipDistance;
#endif
#ifdef CLIPPLANE2
uniform vec4 vClipPlane2;varying float fClipDistance2;
#endif
#ifdef CLIPPLANE3
uniform vec4 vClipPlane3;varying float fClipDistance3;
#endif
#ifdef CLIPPLANE4
uniform vec4 vClipPlane4;varying float fClipDistance4;
#endif
#ifdef CLIPPLANE5
uniform vec4 vClipPlane5;varying float fClipDistance5;
#endif
#ifdef CLIPPLANE6
uniform vec4 vClipPlane6;varying float fClipDistance6;
#endif
`;
ShaderStore.IncludesShadersStore[name42] = shader42;

// ../../node_modules/@babylonjs/core/Shaders/ShadersInclude/fogVertexDeclaration.js
var name43 = "fogVertexDeclaration";
var shader43 = `#ifdef FOG
varying vec3 vFogDistance;
#endif
`;
ShaderStore.IncludesShadersStore[name43] = shader43;

// ../../node_modules/@babylonjs/core/Shaders/ShadersInclude/lightVxFragmentDeclaration.js
var name44 = "lightVxFragmentDeclaration";
var shader44 = `#ifdef LIGHT{X}
uniform vec4 vLightData{X};uniform vec4 vLightDiffuse{X};
#ifdef SPECULARTERM
uniform vec4 vLightSpecular{X};
#else
vec4 vLightSpecular{X}=vec4(0.);
#endif
#ifdef SHADOW{X}
#ifdef SHADOWCSM{X}
uniform mat4 lightMatrix{X}[SHADOWCSMNUM_CASCADES{X}];varying vec4 vPositionFromLight{X}[SHADOWCSMNUM_CASCADES{X}];varying float vDepthMetric{X}[SHADOWCSMNUM_CASCADES{X}];varying vec4 vPositionFromCamera{X};
#elif defined(SHADOWCUBE{X})
#else
varying vec4 vPositionFromLight{X};varying float vDepthMetric{X};uniform mat4 lightMatrix{X};
#endif
uniform vec4 shadowsInfo{X};uniform vec2 depthValues{X};
#endif
#ifdef SPOTLIGHT{X}
uniform vec4 vLightDirection{X};uniform vec4 vLightFalloff{X};
#elif defined(POINTLIGHT{X})
uniform vec4 vLightFalloff{X};
#elif defined(HEMILIGHT{X})
uniform vec3 vLightGround{X};
#endif
#endif
`;
ShaderStore.IncludesShadersStore[name44] = shader44;

// ../../node_modules/@babylonjs/core/Shaders/ShadersInclude/lightVxUboDeclaration.js
var name45 = "lightVxUboDeclaration";
var shader45 = `#ifdef LIGHT{X}
uniform Light{X}
{vec4 vLightData;vec4 vLightDiffuse;vec4 vLightSpecular;
#ifdef SPOTLIGHT{X}
vec4 vLightDirection;vec4 vLightFalloff;
#elif defined(POINTLIGHT{X})
vec4 vLightFalloff;
#elif defined(HEMILIGHT{X})
vec3 vLightGround;
#endif
vec4 shadowsInfo;vec2 depthValues;} light{X};
#ifdef SHADOW{X}
#ifdef SHADOWCSM{X}
uniform mat4 lightMatrix{X}[SHADOWCSMNUM_CASCADES{X}];varying vec4 vPositionFromLight{X}[SHADOWCSMNUM_CASCADES{X}];varying float vDepthMetric{X}[SHADOWCSMNUM_CASCADES{X}];varying vec4 vPositionFromCamera{X};
#elif defined(SHADOWCUBE{X})
#else
varying vec4 vPositionFromLight{X};varying float vDepthMetric{X};uniform mat4 lightMatrix{X};
#endif
#endif
#endif
`;
ShaderStore.IncludesShadersStore[name45] = shader45;

// ../../node_modules/@babylonjs/core/Shaders/ShadersInclude/morphTargetsVertexGlobalDeclaration.js
var name46 = "morphTargetsVertexGlobalDeclaration";
var shader46 = `#ifdef MORPHTARGETS
uniform float morphTargetInfluences[NUM_MORPH_INFLUENCERS];
#ifdef MORPHTARGETS_TEXTURE 
uniform float morphTargetTextureIndices[NUM_MORPH_INFLUENCERS];uniform vec3 morphTargetTextureInfo;uniform highp sampler2DArray morphTargets;vec3 readVector3FromRawSampler(int targetIndex,float vertexIndex)
{ 
float y=floor(vertexIndex/morphTargetTextureInfo.y);float x=vertexIndex-y*morphTargetTextureInfo.y;vec3 textureUV=vec3((x+0.5)/morphTargetTextureInfo.y,(y+0.5)/morphTargetTextureInfo.z,morphTargetTextureIndices[targetIndex]);return texture(morphTargets,textureUV).xyz;}
#endif
#endif
`;
ShaderStore.IncludesShadersStore[name46] = shader46;

// ../../node_modules/@babylonjs/core/Shaders/ShadersInclude/morphTargetsVertexDeclaration.js
var name47 = "morphTargetsVertexDeclaration";
var shader47 = `#ifdef MORPHTARGETS
#ifndef MORPHTARGETS_TEXTURE
attribute vec3 position{X};
#ifdef MORPHTARGETS_NORMAL
attribute vec3 normal{X};
#endif
#ifdef MORPHTARGETS_TANGENT
attribute vec3 tangent{X};
#endif
#ifdef MORPHTARGETS_UV
attribute vec2 uv_{X};
#endif
#elif {X}==0
uniform int morphTargetCount;
#endif
#endif
`;
ShaderStore.IncludesShadersStore[name47] = shader47;

// ../../node_modules/@babylonjs/core/Shaders/ShadersInclude/morphTargetsVertexGlobal.js
var name48 = "morphTargetsVertexGlobal";
var shader48 = `#ifdef MORPHTARGETS
#ifdef MORPHTARGETS_TEXTURE
float vertexID;
#endif
#endif
`;
ShaderStore.IncludesShadersStore[name48] = shader48;

// ../../node_modules/@babylonjs/core/Shaders/ShadersInclude/morphTargetsVertex.js
var name49 = "morphTargetsVertex";
var shader49 = `#ifdef MORPHTARGETS
#ifdef MORPHTARGETS_TEXTURE
#if {X}==0
for (int i=0; i<NUM_MORPH_INFLUENCERS; i++) {if (i>=morphTargetCount) break;vertexID=float(gl_VertexID)*morphTargetTextureInfo.x;positionUpdated+=(readVector3FromRawSampler(i,vertexID)-position)*morphTargetInfluences[i];vertexID+=1.0;
#ifdef MORPHTARGETS_NORMAL
normalUpdated+=(readVector3FromRawSampler(i,vertexID) -normal)*morphTargetInfluences[i];vertexID+=1.0;
#endif
#ifdef MORPHTARGETS_UV
uvUpdated+=(readVector3FromRawSampler(i,vertexID).xy-uv)*morphTargetInfluences[i];vertexID+=1.0;
#endif
#ifdef MORPHTARGETS_TANGENT
tangentUpdated.xyz+=(readVector3FromRawSampler(i,vertexID) -tangent.xyz)*morphTargetInfluences[i];
#endif
}
#endif
#else
positionUpdated+=(position{X}-position)*morphTargetInfluences[{X}];
#ifdef MORPHTARGETS_NORMAL
normalUpdated+=(normal{X}-normal)*morphTargetInfluences[{X}];
#endif
#ifdef MORPHTARGETS_TANGENT
tangentUpdated.xyz+=(tangent{X}-tangent.xyz)*morphTargetInfluences[{X}];
#endif
#ifdef MORPHTARGETS_UV
uvUpdated+=(uv_{X}-uv)*morphTargetInfluences[{X}];
#endif
#endif
#endif
`;
ShaderStore.IncludesShadersStore[name49] = shader49;

// ../../node_modules/@babylonjs/core/Shaders/ShadersInclude/instancesVertex.js
var name50 = "instancesVertex";
var shader50 = `#ifdef INSTANCES
mat4 finalWorld=mat4(world0,world1,world2,world3);
#if defined(PREPASS_VELOCITY) || defined(VELOCITY)
mat4 finalPreviousWorld=mat4(previousWorld0,previousWorld1,previousWorld2,previousWorld3);
#endif
#ifdef THIN_INSTANCES
finalWorld=world*finalWorld;
#if defined(PREPASS_VELOCITY) || defined(VELOCITY)
finalPreviousWorld=previousWorld*finalPreviousWorld;
#endif
#endif
#else
mat4 finalWorld=world;
#if defined(PREPASS_VELOCITY) || defined(VELOCITY)
mat4 finalPreviousWorld=previousWorld;
#endif
#endif
`;
ShaderStore.IncludesShadersStore[name50] = shader50;

// ../../node_modules/@babylonjs/core/Shaders/ShadersInclude/bonesVertex.js
var name51 = "bonesVertex";
var shader51 = `#ifndef BAKED_VERTEX_ANIMATION_TEXTURE
#if NUM_BONE_INFLUENCERS>0
mat4 influence;
#ifdef BONETEXTURE
influence=readMatrixFromRawSampler(boneSampler,matricesIndices[0])*matricesWeights[0];
#if NUM_BONE_INFLUENCERS>1
influence+=readMatrixFromRawSampler(boneSampler,matricesIndices[1])*matricesWeights[1];
#endif
#if NUM_BONE_INFLUENCERS>2
influence+=readMatrixFromRawSampler(boneSampler,matricesIndices[2])*matricesWeights[2];
#endif
#if NUM_BONE_INFLUENCERS>3
influence+=readMatrixFromRawSampler(boneSampler,matricesIndices[3])*matricesWeights[3];
#endif
#if NUM_BONE_INFLUENCERS>4
influence+=readMatrixFromRawSampler(boneSampler,matricesIndicesExtra[0])*matricesWeightsExtra[0];
#endif
#if NUM_BONE_INFLUENCERS>5
influence+=readMatrixFromRawSampler(boneSampler,matricesIndicesExtra[1])*matricesWeightsExtra[1];
#endif
#if NUM_BONE_INFLUENCERS>6
influence+=readMatrixFromRawSampler(boneSampler,matricesIndicesExtra[2])*matricesWeightsExtra[2];
#endif
#if NUM_BONE_INFLUENCERS>7
influence+=readMatrixFromRawSampler(boneSampler,matricesIndicesExtra[3])*matricesWeightsExtra[3];
#endif
#else
influence=mBones[int(matricesIndices[0])]*matricesWeights[0];
#if NUM_BONE_INFLUENCERS>1
influence+=mBones[int(matricesIndices[1])]*matricesWeights[1];
#endif
#if NUM_BONE_INFLUENCERS>2
influence+=mBones[int(matricesIndices[2])]*matricesWeights[2];
#endif
#if NUM_BONE_INFLUENCERS>3
influence+=mBones[int(matricesIndices[3])]*matricesWeights[3];
#endif
#if NUM_BONE_INFLUENCERS>4
influence+=mBones[int(matricesIndicesExtra[0])]*matricesWeightsExtra[0];
#endif
#if NUM_BONE_INFLUENCERS>5
influence+=mBones[int(matricesIndicesExtra[1])]*matricesWeightsExtra[1];
#endif
#if NUM_BONE_INFLUENCERS>6
influence+=mBones[int(matricesIndicesExtra[2])]*matricesWeightsExtra[2];
#endif
#if NUM_BONE_INFLUENCERS>7
influence+=mBones[int(matricesIndicesExtra[3])]*matricesWeightsExtra[3];
#endif
#endif
finalWorld=finalWorld*influence;
#endif
#endif
`;
ShaderStore.IncludesShadersStore[name51] = shader51;

// ../../node_modules/@babylonjs/core/Shaders/ShadersInclude/bakedVertexAnimation.js
var name52 = "bakedVertexAnimation";
var shader52 = `#ifdef BAKED_VERTEX_ANIMATION_TEXTURE
{
#ifdef INSTANCES
#define BVASNAME bakedVertexAnimationSettingsInstanced
#else
#define BVASNAME bakedVertexAnimationSettings
#endif
float VATStartFrame=BVASNAME.x;float VATEndFrame=BVASNAME.y;float VATOffsetFrame=BVASNAME.z;float VATSpeed=BVASNAME.w;float totalFrames=VATEndFrame-VATStartFrame+1.0;float time=bakedVertexAnimationTime*VATSpeed/totalFrames;float frameCorrection=time<1.0 ? 0.0 : 1.0;float numOfFrames=totalFrames-frameCorrection;float VATFrameNum=fract(time)*numOfFrames;VATFrameNum=mod(VATFrameNum+VATOffsetFrame,numOfFrames);VATFrameNum=floor(VATFrameNum);VATFrameNum+=VATStartFrame+frameCorrection;mat4 VATInfluence;VATInfluence=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndices[0],VATFrameNum)*matricesWeights[0];
#if NUM_BONE_INFLUENCERS>1
VATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndices[1],VATFrameNum)*matricesWeights[1];
#endif
#if NUM_BONE_INFLUENCERS>2
VATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndices[2],VATFrameNum)*matricesWeights[2];
#endif
#if NUM_BONE_INFLUENCERS>3
VATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndices[3],VATFrameNum)*matricesWeights[3];
#endif
#if NUM_BONE_INFLUENCERS>4
VATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndicesExtra[0],VATFrameNum)*matricesWeightsExtra[0];
#endif
#if NUM_BONE_INFLUENCERS>5
VATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndicesExtra[1],VATFrameNum)*matricesWeightsExtra[1];
#endif
#if NUM_BONE_INFLUENCERS>6
VATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndicesExtra[2],VATFrameNum)*matricesWeightsExtra[2];
#endif
#if NUM_BONE_INFLUENCERS>7
VATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndicesExtra[3],VATFrameNum)*matricesWeightsExtra[3];
#endif
finalWorld=finalWorld*VATInfluence;}
#endif
`;
ShaderStore.IncludesShadersStore[name52] = shader52;

// ../../node_modules/@babylonjs/core/Shaders/ShadersInclude/prePassVertex.js
var name53 = "prePassVertex";
var shader53 = `#ifdef PREPASS_DEPTH
vViewPos=(view*worldPos).rgb;
#endif
#if defined(PREPASS_VELOCITY) && defined(BONES_VELOCITY_ENABLED)
vCurrentPosition=viewProjection*worldPos;
#if NUM_BONE_INFLUENCERS>0
mat4 previousInfluence;previousInfluence=mPreviousBones[int(matricesIndices[0])]*matricesWeights[0];
#if NUM_BONE_INFLUENCERS>1
previousInfluence+=mPreviousBones[int(matricesIndices[1])]*matricesWeights[1];
#endif 
#if NUM_BONE_INFLUENCERS>2
previousInfluence+=mPreviousBones[int(matricesIndices[2])]*matricesWeights[2];
#endif 
#if NUM_BONE_INFLUENCERS>3
previousInfluence+=mPreviousBones[int(matricesIndices[3])]*matricesWeights[3];
#endif
#if NUM_BONE_INFLUENCERS>4
previousInfluence+=mPreviousBones[int(matricesIndicesExtra[0])]*matricesWeightsExtra[0];
#endif 
#if NUM_BONE_INFLUENCERS>5
previousInfluence+=mPreviousBones[int(matricesIndicesExtra[1])]*matricesWeightsExtra[1];
#endif 
#if NUM_BONE_INFLUENCERS>6
previousInfluence+=mPreviousBones[int(matricesIndicesExtra[2])]*matricesWeightsExtra[2];
#endif 
#if NUM_BONE_INFLUENCERS>7
previousInfluence+=mPreviousBones[int(matricesIndicesExtra[3])]*matricesWeightsExtra[3];
#endif
vPreviousPosition=previousViewProjection*finalPreviousWorld*previousInfluence*vec4(positionUpdated,1.0);
#else
vPreviousPosition=previousViewProjection*finalPreviousWorld*vec4(positionUpdated,1.0);
#endif
#endif
`;
ShaderStore.IncludesShadersStore[name53] = shader53;

// ../../node_modules/@babylonjs/core/Shaders/ShadersInclude/uvVariableDeclaration.js
var name54 = "uvVariableDeclaration";
var shader54 = `#if !defined(UV{X}) && defined(MAINUV{X})
vec2 uv{X}=vec2(0.,0.);
#endif
#ifdef MAINUV{X}
vMainUV{X}=uv{X};
#endif
`;
ShaderStore.IncludesShadersStore[name54] = shader54;

// ../../node_modules/@babylonjs/core/Shaders/ShadersInclude/samplerVertexImplementation.js
var name55 = "samplerVertexImplementation";
var shader55 = `#if defined(_DEFINENAME_) && _DEFINENAME_DIRECTUV==0
if (v_INFONAME_==0.)
{v_VARYINGNAME_UV=vec2(_MATRIXNAME_Matrix*vec4(uvUpdated,1.0,0.0));}
#ifdef UV2
else if (v_INFONAME_==1.)
{v_VARYINGNAME_UV=vec2(_MATRIXNAME_Matrix*vec4(uv2,1.0,0.0));}
#endif
#ifdef UV3
else if (v_INFONAME_==2.)
{v_VARYINGNAME_UV=vec2(_MATRIXNAME_Matrix*vec4(uv3,1.0,0.0));}
#endif
#ifdef UV4
else if (v_INFONAME_==3.)
{v_VARYINGNAME_UV=vec2(_MATRIXNAME_Matrix*vec4(uv4,1.0,0.0));}
#endif
#ifdef UV5
else if (v_INFONAME_==4.)
{v_VARYINGNAME_UV=vec2(_MATRIXNAME_Matrix*vec4(uv5,1.0,0.0));}
#endif
#ifdef UV6
else if (v_INFONAME_==5.)
{v_VARYINGNAME_UV=vec2(_MATRIXNAME_Matrix*vec4(uv6,1.0,0.0));}
#endif
#endif
`;
ShaderStore.IncludesShadersStore[name55] = shader55;

// ../../node_modules/@babylonjs/core/Shaders/ShadersInclude/bumpVertex.js
var name56 = "bumpVertex";
var shader56 = `#if defined(BUMP) || defined(PARALLAX) || defined(CLEARCOAT_BUMP) || defined(ANISOTROPIC)
#if defined(TANGENT) && defined(NORMAL)
vec3 tbnNormal=normalize(normalUpdated);vec3 tbnTangent=normalize(tangentUpdated.xyz);vec3 tbnBitangent=cross(tbnNormal,tbnTangent)*tangentUpdated.w;vTBN=mat3(finalWorld)*mat3(tbnTangent,tbnBitangent,tbnNormal);
#endif
#endif
`;
ShaderStore.IncludesShadersStore[name56] = shader56;

// ../../node_modules/@babylonjs/core/Shaders/ShadersInclude/clipPlaneVertex.js
var name57 = "clipPlaneVertex";
var shader57 = `#ifdef CLIPPLANE
fClipDistance=dot(worldPos,vClipPlane);
#endif
#ifdef CLIPPLANE2
fClipDistance2=dot(worldPos,vClipPlane2);
#endif
#ifdef CLIPPLANE3
fClipDistance3=dot(worldPos,vClipPlane3);
#endif
#ifdef CLIPPLANE4
fClipDistance4=dot(worldPos,vClipPlane4);
#endif
#ifdef CLIPPLANE5
fClipDistance5=dot(worldPos,vClipPlane5);
#endif
#ifdef CLIPPLANE6
fClipDistance6=dot(worldPos,vClipPlane6);
#endif
`;
ShaderStore.IncludesShadersStore[name57] = shader57;

// ../../node_modules/@babylonjs/core/Shaders/ShadersInclude/fogVertex.js
var name58 = "fogVertex";
var shader58 = `#ifdef FOG
vFogDistance=(view*worldPos).xyz;
#endif
`;
ShaderStore.IncludesShadersStore[name58] = shader58;

// ../../node_modules/@babylonjs/core/Shaders/ShadersInclude/shadowsVertex.js
var name59 = "shadowsVertex";
var shader59 = `#ifdef SHADOWS
#if defined(SHADOWCSM{X})
vPositionFromCamera{X}=view*worldPos;for (int i=0; i<SHADOWCSMNUM_CASCADES{X}; i++) {vPositionFromLight{X}[i]=lightMatrix{X}[i]*worldPos;
#ifdef USE_REVERSE_DEPTHBUFFER
vDepthMetric{X}[i]=(-vPositionFromLight{X}[i].z+light{X}.depthValues.x)/light{X}.depthValues.y;
#else
vDepthMetric{X}[i]=(vPositionFromLight{X}[i].z+light{X}.depthValues.x)/light{X}.depthValues.y;
#endif
}
#elif defined(SHADOW{X}) && !defined(SHADOWCUBE{X})
vPositionFromLight{X}=lightMatrix{X}*worldPos;
#ifdef USE_REVERSE_DEPTHBUFFER
vDepthMetric{X}=(-vPositionFromLight{X}.z+light{X}.depthValues.x)/light{X}.depthValues.y;
#else
vDepthMetric{X}=(vPositionFromLight{X}.z+light{X}.depthValues.x)/light{X}.depthValues.y;
#endif
#endif
#endif
`;
ShaderStore.IncludesShadersStore[name59] = shader59;

// ../../node_modules/@babylonjs/core/Shaders/ShadersInclude/vertexColorMixing.js
var name60 = "vertexColorMixing";
var shader60 = `#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)
vColor=vec4(1.0);
#ifdef VERTEXCOLOR
#ifdef VERTEXALPHA
vColor*=color;
#else
vColor.rgb*=color.rgb;
#endif
#endif
#ifdef INSTANCESCOLOR
vColor*=instanceColor;
#endif
#endif
`;
ShaderStore.IncludesShadersStore[name60] = shader60;

// ../../node_modules/@babylonjs/core/Shaders/ShadersInclude/pointCloudVertex.js
var name61 = "pointCloudVertex";
var shader61 = `#if defined(POINTSIZE) && !defined(WEBGPU)
gl_PointSize=pointSize;
#endif
`;
ShaderStore.IncludesShadersStore[name61] = shader61;

// ../../node_modules/@babylonjs/core/Shaders/ShadersInclude/logDepthVertex.js
var name62 = "logDepthVertex";
var shader62 = `#ifdef LOGARITHMICDEPTH
vFragmentDepth=1.0+gl_Position.w;gl_Position.z=log2(max(0.000001,vFragmentDepth))*logarithmicDepthConstant;
#endif
`;
ShaderStore.IncludesShadersStore[name62] = shader62;

// ../../node_modules/@babylonjs/core/Shaders/default.vertex.js
var name63 = "defaultVertexShader";
var shader63 = `#include<__decl__defaultVertex>
#define CUSTOM_VERTEX_BEGIN
attribute vec3 position;
#ifdef NORMAL
attribute vec3 normal;
#endif
#ifdef TANGENT
attribute vec4 tangent;
#endif
#ifdef UV1
attribute vec2 uv;
#endif
#include<uvAttributeDeclaration>[2..7]
#ifdef VERTEXCOLOR
attribute vec4 color;
#endif
#include<helperFunctions>
#include<bonesDeclaration>
#include<bakedVertexAnimationDeclaration>
#include<instancesDeclaration>
#include<prePassVertexDeclaration>
#include<mainUVVaryingDeclaration>[1..7]
#include<samplerVertexDeclaration>(_DEFINENAME_,DIFFUSE,_VARYINGNAME_,Diffuse)
#include<samplerVertexDeclaration>(_DEFINENAME_,DETAIL,_VARYINGNAME_,Detail)
#include<samplerVertexDeclaration>(_DEFINENAME_,AMBIENT,_VARYINGNAME_,Ambient)
#include<samplerVertexDeclaration>(_DEFINENAME_,OPACITY,_VARYINGNAME_,Opacity)
#include<samplerVertexDeclaration>(_DEFINENAME_,EMISSIVE,_VARYINGNAME_,Emissive)
#include<samplerVertexDeclaration>(_DEFINENAME_,LIGHTMAP,_VARYINGNAME_,Lightmap)
#if defined(SPECULARTERM)
#include<samplerVertexDeclaration>(_DEFINENAME_,SPECULAR,_VARYINGNAME_,Specular)
#endif
#include<samplerVertexDeclaration>(_DEFINENAME_,BUMP,_VARYINGNAME_,Bump)
#include<samplerVertexDeclaration>(_DEFINENAME_,DECAL,_VARYINGNAME_,Decal)
varying vec3 vPositionW;
#ifdef NORMAL
varying vec3 vNormalW;
#endif
#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)
varying vec4 vColor;
#endif
#include<bumpVertexDeclaration>
#include<clipPlaneVertexDeclaration>
#include<fogVertexDeclaration>
#include<__decl__lightVxFragment>[0..maxSimultaneousLights]
#include<morphTargetsVertexGlobalDeclaration>
#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]
#ifdef REFLECTIONMAP_SKYBOX
varying vec3 vPositionUVW;
#endif
#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)
varying vec3 vDirectionW;
#endif
#include<logDepthDeclaration>
#define CUSTOM_VERTEX_DEFINITIONS
void main(void) {
#define CUSTOM_VERTEX_MAIN_BEGIN
vec3 positionUpdated=position;
#ifdef NORMAL
vec3 normalUpdated=normal;
#endif
#ifdef TANGENT
vec4 tangentUpdated=tangent;
#endif
#ifdef UV1
vec2 uvUpdated=uv;
#endif
#include<morphTargetsVertexGlobal>
#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]
#ifdef REFLECTIONMAP_SKYBOX
vPositionUVW=positionUpdated;
#endif
#define CUSTOM_VERTEX_UPDATE_POSITION
#define CUSTOM_VERTEX_UPDATE_NORMAL
#include<instancesVertex>
#if defined(PREPASS) && defined(PREPASS_VELOCITY) && !defined(BONES_VELOCITY_ENABLED)
vCurrentPosition=viewProjection*finalWorld*vec4(positionUpdated,1.0);vPreviousPosition=previousViewProjection*finalPreviousWorld*vec4(positionUpdated,1.0);
#endif
#include<bonesVertex>
#include<bakedVertexAnimation>
vec4 worldPos=finalWorld*vec4(positionUpdated,1.0);
#ifdef NORMAL
mat3 normalWorld=mat3(finalWorld);
#if defined(INSTANCES) && defined(THIN_INSTANCES)
vNormalW=normalUpdated/vec3(dot(normalWorld[0],normalWorld[0]),dot(normalWorld[1],normalWorld[1]),dot(normalWorld[2],normalWorld[2]));vNormalW=normalize(normalWorld*vNormalW);
#else
#ifdef NONUNIFORMSCALING
normalWorld=transposeMat3(inverseMat3(normalWorld));
#endif
vNormalW=normalize(normalWorld*normalUpdated);
#endif
#endif
#define CUSTOM_VERTEX_UPDATE_WORLDPOS
#ifdef MULTIVIEW
if (gl_ViewID_OVR==0u) {gl_Position=viewProjection*worldPos;} else {gl_Position=viewProjectionR*worldPos;}
#else
gl_Position=viewProjection*worldPos;
#endif
vPositionW=vec3(worldPos);
#include<prePassVertex>
#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)
vDirectionW=normalize(vec3(finalWorld*vec4(positionUpdated,0.0)));
#endif
#ifndef UV1
vec2 uvUpdated=vec2(0.,0.);
#endif
#ifdef MAINUV1
vMainUV1=uvUpdated;
#endif
#include<uvVariableDeclaration>[2..7]
#include<samplerVertexImplementation>(_DEFINENAME_,DIFFUSE,_VARYINGNAME_,Diffuse,_MATRIXNAME_,diffuse,_INFONAME_,DiffuseInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,DETAIL,_VARYINGNAME_,Detail,_MATRIXNAME_,detail,_INFONAME_,DetailInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,AMBIENT,_VARYINGNAME_,Ambient,_MATRIXNAME_,ambient,_INFONAME_,AmbientInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,OPACITY,_VARYINGNAME_,Opacity,_MATRIXNAME_,opacity,_INFONAME_,OpacityInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,EMISSIVE,_VARYINGNAME_,Emissive,_MATRIXNAME_,emissive,_INFONAME_,EmissiveInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,LIGHTMAP,_VARYINGNAME_,Lightmap,_MATRIXNAME_,lightmap,_INFONAME_,LightmapInfos.x)
#if defined(SPECULARTERM)
#include<samplerVertexImplementation>(_DEFINENAME_,SPECULAR,_VARYINGNAME_,Specular,_MATRIXNAME_,specular,_INFONAME_,SpecularInfos.x)
#endif
#include<samplerVertexImplementation>(_DEFINENAME_,BUMP,_VARYINGNAME_,Bump,_MATRIXNAME_,bump,_INFONAME_,BumpInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,DECAL,_VARYINGNAME_,Decal,_MATRIXNAME_,decal,_INFONAME_,DecalInfos.x)
#include<bumpVertex>
#include<clipPlaneVertex>
#include<fogVertex>
#include<shadowsVertex>[0..maxSimultaneousLights]
#include<vertexColorMixing>
#include<pointCloudVertex>
#include<logDepthVertex>
#define CUSTOM_VERTEX_MAIN_END
}
`;
ShaderStore.ShadersStore[name63] = shader63;

// ../../node_modules/@babylonjs/core/Materials/effectFallbacks.js
var EffectFallbacks = class {
  constructor() {
    this._defines = {};
    this._currentRank = 32;
    this._maxRank = -1;
    this._mesh = null;
  }
  /**
   * Removes the fallback from the bound mesh.
   */
  unBindMesh() {
    this._mesh = null;
  }
  /**
   * Adds a fallback on the specified property.
   * @param rank The rank of the fallback (Lower ranks will be fallbacked to first)
   * @param define The name of the define in the shader
   */
  addFallback(rank, define) {
    if (!this._defines[rank]) {
      if (rank < this._currentRank) {
        this._currentRank = rank;
      }
      if (rank > this._maxRank) {
        this._maxRank = rank;
      }
      this._defines[rank] = new Array();
    }
    this._defines[rank].push(define);
  }
  /**
   * Sets the mesh to use CPU skinning when needing to fallback.
   * @param rank The rank of the fallback (Lower ranks will be fallbacked to first)
   * @param mesh The mesh to use the fallbacks.
   */
  addCPUSkinningFallback(rank, mesh) {
    this._mesh = mesh;
    if (rank < this._currentRank) {
      this._currentRank = rank;
    }
    if (rank > this._maxRank) {
      this._maxRank = rank;
    }
  }
  /**
   * Checks to see if more fallbacks are still available.
   */
  get hasMoreFallbacks() {
    return this._currentRank <= this._maxRank;
  }
  /**
   * Removes the defines that should be removed when falling back.
   * @param currentDefines defines the current define statements for the shader.
   * @param effect defines the current effect we try to compile
   * @returns The resulting defines with defines of the current rank removed.
   */
  reduce(currentDefines, effect) {
    if (this._mesh && this._mesh.computeBonesUsingShaders && this._mesh.numBoneInfluencers > 0) {
      this._mesh.computeBonesUsingShaders = false;
      currentDefines = currentDefines.replace("#define NUM_BONE_INFLUENCERS " + this._mesh.numBoneInfluencers, "#define NUM_BONE_INFLUENCERS 0");
      effect._bonesComputationForcedToCPU = true;
      const scene = this._mesh.getScene();
      for (let index = 0; index < scene.meshes.length; index++) {
        const otherMesh = scene.meshes[index];
        if (!otherMesh.material) {
          if (!this._mesh.material && otherMesh.computeBonesUsingShaders && otherMesh.numBoneInfluencers > 0) {
            otherMesh.computeBonesUsingShaders = false;
          }
          continue;
        }
        if (!otherMesh.computeBonesUsingShaders || otherMesh.numBoneInfluencers === 0) {
          continue;
        }
        if (otherMesh.material.getEffect() === effect) {
          otherMesh.computeBonesUsingShaders = false;
        } else if (otherMesh.subMeshes) {
          for (const subMesh of otherMesh.subMeshes) {
            const subMeshEffect = subMesh.effect;
            if (subMeshEffect === effect) {
              otherMesh.computeBonesUsingShaders = false;
              break;
            }
          }
        }
      }
    } else {
      const currentFallbacks = this._defines[this._currentRank];
      if (currentFallbacks) {
        for (let index = 0; index < currentFallbacks.length; index++) {
          currentDefines = currentDefines.replace("#define " + currentFallbacks[index], "");
        }
      }
      this._currentRank++;
    }
    return currentDefines;
  }
};

// ../../node_modules/@babylonjs/core/Materials/material.detailMapConfiguration.js
var MaterialDetailMapDefines = class extends MaterialDefines {
  constructor() {
    super(...arguments);
    this.DETAIL = false;
    this.DETAILDIRECTUV = 0;
    this.DETAIL_NORMALBLENDMETHOD = 0;
  }
};
var DetailMapConfiguration = class extends MaterialPluginBase {
  /** @internal */
  _markAllSubMeshesAsTexturesDirty() {
    this._enable(this._isEnabled);
    this._internalMarkAllSubMeshesAsTexturesDirty();
  }
  constructor(material, addToPluginList = true) {
    super(material, "DetailMap", 140, new MaterialDetailMapDefines(), addToPluginList);
    this._texture = null;
    this.diffuseBlendLevel = 1;
    this.roughnessBlendLevel = 1;
    this.bumpLevel = 1;
    this._normalBlendMethod = Material.MATERIAL_NORMALBLENDMETHOD_WHITEOUT;
    this._isEnabled = false;
    this.isEnabled = false;
    this._internalMarkAllSubMeshesAsTexturesDirty = material._dirtyCallbacks[1];
  }
  isReadyForSubMesh(defines, scene, engine) {
    if (!this._isEnabled) {
      return true;
    }
    if (defines._areTexturesDirty && scene.texturesEnabled) {
      if (engine.getCaps().standardDerivatives && this._texture && MaterialFlags.DetailTextureEnabled) {
        if (!this._texture.isReady()) {
          return false;
        }
      }
    }
    return true;
  }
  prepareDefines(defines, scene) {
    if (this._isEnabled) {
      defines.DETAIL_NORMALBLENDMETHOD = this._normalBlendMethod;
      const engine = scene.getEngine();
      if (defines._areTexturesDirty) {
        if (engine.getCaps().standardDerivatives && this._texture && MaterialFlags.DetailTextureEnabled && this._isEnabled) {
          PrepareDefinesForMergedUV(this._texture, defines, "DETAIL");
          defines.DETAIL_NORMALBLENDMETHOD = this._normalBlendMethod;
        } else {
          defines.DETAIL = false;
        }
      }
    } else {
      defines.DETAIL = false;
    }
  }
  bindForSubMesh(uniformBuffer, scene) {
    if (!this._isEnabled) {
      return;
    }
    const isFrozen = this._material.isFrozen;
    if (!uniformBuffer.useUbo || !isFrozen || !uniformBuffer.isSync) {
      if (this._texture && MaterialFlags.DetailTextureEnabled) {
        uniformBuffer.updateFloat4("vDetailInfos", this._texture.coordinatesIndex, this.diffuseBlendLevel, this.bumpLevel, this.roughnessBlendLevel);
        BindTextureMatrix(this._texture, uniformBuffer, "detail");
      }
    }
    if (scene.texturesEnabled) {
      if (this._texture && MaterialFlags.DetailTextureEnabled) {
        uniformBuffer.setTexture("detailSampler", this._texture);
      }
    }
  }
  hasTexture(texture) {
    if (this._texture === texture) {
      return true;
    }
    return false;
  }
  getActiveTextures(activeTextures) {
    if (this._texture) {
      activeTextures.push(this._texture);
    }
  }
  getAnimatables(animatables) {
    if (this._texture && this._texture.animations && this._texture.animations.length > 0) {
      animatables.push(this._texture);
    }
  }
  dispose(forceDisposeTextures) {
    if (forceDisposeTextures) {
      this._texture?.dispose();
    }
  }
  getClassName() {
    return "DetailMapConfiguration";
  }
  getSamplers(samplers) {
    samplers.push("detailSampler");
  }
  getUniforms() {
    return {
      ubo: [
        { name: "vDetailInfos", size: 4, type: "vec4" },
        { name: "detailMatrix", size: 16, type: "mat4" }
      ]
    };
  }
};
__decorate([
  serializeAsTexture("detailTexture"),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], DetailMapConfiguration.prototype, "texture", void 0);
__decorate([
  serialize()
], DetailMapConfiguration.prototype, "diffuseBlendLevel", void 0);
__decorate([
  serialize()
], DetailMapConfiguration.prototype, "roughnessBlendLevel", void 0);
__decorate([
  serialize()
], DetailMapConfiguration.prototype, "bumpLevel", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], DetailMapConfiguration.prototype, "normalBlendMethod", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], DetailMapConfiguration.prototype, "isEnabled", void 0);

// ../../node_modules/@babylonjs/core/Materials/standardMaterial.js
var onCreatedEffectParameters = { effect: null, subMesh: null };
var StandardMaterialDefines = class extends MaterialDefines {
  /**
   * Initializes the Standard Material defines.
   * @param externalProperties The external properties
   */
  constructor(externalProperties) {
    super(externalProperties);
    this.MAINUV1 = false;
    this.MAINUV2 = false;
    this.MAINUV3 = false;
    this.MAINUV4 = false;
    this.MAINUV5 = false;
    this.MAINUV6 = false;
    this.DIFFUSE = false;
    this.DIFFUSEDIRECTUV = 0;
    this.BAKED_VERTEX_ANIMATION_TEXTURE = false;
    this.AMBIENT = false;
    this.AMBIENTDIRECTUV = 0;
    this.OPACITY = false;
    this.OPACITYDIRECTUV = 0;
    this.OPACITYRGB = false;
    this.REFLECTION = false;
    this.EMISSIVE = false;
    this.EMISSIVEDIRECTUV = 0;
    this.SPECULAR = false;
    this.SPECULARDIRECTUV = 0;
    this.BUMP = false;
    this.BUMPDIRECTUV = 0;
    this.PARALLAX = false;
    this.PARALLAX_RHS = false;
    this.PARALLAXOCCLUSION = false;
    this.SPECULAROVERALPHA = false;
    this.CLIPPLANE = false;
    this.CLIPPLANE2 = false;
    this.CLIPPLANE3 = false;
    this.CLIPPLANE4 = false;
    this.CLIPPLANE5 = false;
    this.CLIPPLANE6 = false;
    this.ALPHATEST = false;
    this.DEPTHPREPASS = false;
    this.ALPHAFROMDIFFUSE = false;
    this.POINTSIZE = false;
    this.FOG = false;
    this.SPECULARTERM = false;
    this.DIFFUSEFRESNEL = false;
    this.OPACITYFRESNEL = false;
    this.REFLECTIONFRESNEL = false;
    this.REFRACTIONFRESNEL = false;
    this.EMISSIVEFRESNEL = false;
    this.FRESNEL = false;
    this.NORMAL = false;
    this.TANGENT = false;
    this.UV1 = false;
    this.UV2 = false;
    this.UV3 = false;
    this.UV4 = false;
    this.UV5 = false;
    this.UV6 = false;
    this.VERTEXCOLOR = false;
    this.VERTEXALPHA = false;
    this.NUM_BONE_INFLUENCERS = 0;
    this.BonesPerMesh = 0;
    this.BONETEXTURE = false;
    this.BONES_VELOCITY_ENABLED = false;
    this.INSTANCES = false;
    this.THIN_INSTANCES = false;
    this.INSTANCESCOLOR = false;
    this.GLOSSINESS = false;
    this.ROUGHNESS = false;
    this.EMISSIVEASILLUMINATION = false;
    this.LINKEMISSIVEWITHDIFFUSE = false;
    this.REFLECTIONFRESNELFROMSPECULAR = false;
    this.LIGHTMAP = false;
    this.LIGHTMAPDIRECTUV = 0;
    this.OBJECTSPACE_NORMALMAP = false;
    this.USELIGHTMAPASSHADOWMAP = false;
    this.REFLECTIONMAP_3D = false;
    this.REFLECTIONMAP_SPHERICAL = false;
    this.REFLECTIONMAP_PLANAR = false;
    this.REFLECTIONMAP_CUBIC = false;
    this.USE_LOCAL_REFLECTIONMAP_CUBIC = false;
    this.USE_LOCAL_REFRACTIONMAP_CUBIC = false;
    this.REFLECTIONMAP_PROJECTION = false;
    this.REFLECTIONMAP_SKYBOX = false;
    this.REFLECTIONMAP_EXPLICIT = false;
    this.REFLECTIONMAP_EQUIRECTANGULAR = false;
    this.REFLECTIONMAP_EQUIRECTANGULAR_FIXED = false;
    this.REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED = false;
    this.REFLECTIONMAP_OPPOSITEZ = false;
    this.INVERTCUBICMAP = false;
    this.LOGARITHMICDEPTH = false;
    this.REFRACTION = false;
    this.REFRACTIONMAP_3D = false;
    this.REFLECTIONOVERALPHA = false;
    this.TWOSIDEDLIGHTING = false;
    this.SHADOWFLOAT = false;
    this.MORPHTARGETS = false;
    this.MORPHTARGETS_NORMAL = false;
    this.MORPHTARGETS_TANGENT = false;
    this.MORPHTARGETS_UV = false;
    this.NUM_MORPH_INFLUENCERS = 0;
    this.MORPHTARGETS_TEXTURE = false;
    this.NONUNIFORMSCALING = false;
    this.PREMULTIPLYALPHA = false;
    this.ALPHATEST_AFTERALLALPHACOMPUTATIONS = false;
    this.ALPHABLEND = true;
    this.PREPASS = false;
    this.PREPASS_IRRADIANCE = false;
    this.PREPASS_IRRADIANCE_INDEX = -1;
    this.PREPASS_ALBEDO_SQRT = false;
    this.PREPASS_ALBEDO_SQRT_INDEX = -1;
    this.PREPASS_DEPTH = false;
    this.PREPASS_DEPTH_INDEX = -1;
    this.PREPASS_NORMAL = false;
    this.PREPASS_NORMAL_INDEX = -1;
    this.PREPASS_NORMAL_WORLDSPACE = false;
    this.PREPASS_POSITION = false;
    this.PREPASS_POSITION_INDEX = -1;
    this.PREPASS_VELOCITY = false;
    this.PREPASS_VELOCITY_INDEX = -1;
    this.PREPASS_REFLECTIVITY = false;
    this.PREPASS_REFLECTIVITY_INDEX = -1;
    this.SCENE_MRT_COUNT = 0;
    this.RGBDLIGHTMAP = false;
    this.RGBDREFLECTION = false;
    this.RGBDREFRACTION = false;
    this.IMAGEPROCESSING = false;
    this.VIGNETTE = false;
    this.VIGNETTEBLENDMODEMULTIPLY = false;
    this.VIGNETTEBLENDMODEOPAQUE = false;
    this.TONEMAPPING = false;
    this.TONEMAPPING_ACES = false;
    this.CONTRAST = false;
    this.COLORCURVES = false;
    this.COLORGRADING = false;
    this.COLORGRADING3D = false;
    this.SAMPLER3DGREENDEPTH = false;
    this.SAMPLER3DBGRMAP = false;
    this.DITHER = false;
    this.IMAGEPROCESSINGPOSTPROCESS = false;
    this.SKIPFINALCOLORCLAMP = false;
    this.MULTIVIEW = false;
    this.ORDER_INDEPENDENT_TRANSPARENCY = false;
    this.ORDER_INDEPENDENT_TRANSPARENCY_16BITS = false;
    this.CAMERA_ORTHOGRAPHIC = false;
    this.CAMERA_PERSPECTIVE = false;
    this.IS_REFLECTION_LINEAR = false;
    this.IS_REFRACTION_LINEAR = false;
    this.EXPOSURE = false;
    this.DECAL_AFTER_DETAIL = false;
    this.rebuild();
  }
  setReflectionMode(modeToEnable) {
    const modes = [
      "REFLECTIONMAP_CUBIC",
      "REFLECTIONMAP_EXPLICIT",
      "REFLECTIONMAP_PLANAR",
      "REFLECTIONMAP_PROJECTION",
      "REFLECTIONMAP_PROJECTION",
      "REFLECTIONMAP_SKYBOX",
      "REFLECTIONMAP_SPHERICAL",
      "REFLECTIONMAP_EQUIRECTANGULAR",
      "REFLECTIONMAP_EQUIRECTANGULAR_FIXED",
      "REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED"
    ];
    for (const mode of modes) {
      this[mode] = mode === modeToEnable;
    }
  }
};
var StandardMaterial = class _StandardMaterial extends PushMaterial {
  /**
   * Gets the image processing configuration used either in this material.
   */
  get imageProcessingConfiguration() {
    return this._imageProcessingConfiguration;
  }
  /**
   * Sets the Default image processing configuration used either in the this material.
   *
   * If sets to null, the scene one is in use.
   */
  set imageProcessingConfiguration(value) {
    this._attachImageProcessingConfiguration(value);
    this._markAllSubMeshesAsTexturesDirty();
  }
  /**
   * Attaches a new image processing configuration to the Standard Material.
   * @param configuration
   */
  _attachImageProcessingConfiguration(configuration) {
    if (configuration === this._imageProcessingConfiguration) {
      return;
    }
    if (this._imageProcessingConfiguration && this._imageProcessingObserver) {
      this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver);
    }
    if (!configuration) {
      this._imageProcessingConfiguration = this.getScene().imageProcessingConfiguration;
    } else {
      this._imageProcessingConfiguration = configuration;
    }
    if (this._imageProcessingConfiguration) {
      this._imageProcessingObserver = this._imageProcessingConfiguration.onUpdateParameters.add(() => {
        this._markAllSubMeshesAsImageProcessingDirty();
      });
    }
  }
  /**
   * Can this material render to prepass
   */
  get isPrePassCapable() {
    return !this.disableDepthWrite;
  }
  /**
   * Gets whether the color curves effect is enabled.
   */
  get cameraColorCurvesEnabled() {
    return this.imageProcessingConfiguration.colorCurvesEnabled;
  }
  /**
   * Sets whether the color curves effect is enabled.
   */
  set cameraColorCurvesEnabled(value) {
    this.imageProcessingConfiguration.colorCurvesEnabled = value;
  }
  /**
   * Gets whether the color grading effect is enabled.
   */
  get cameraColorGradingEnabled() {
    return this.imageProcessingConfiguration.colorGradingEnabled;
  }
  /**
   * Gets whether the color grading effect is enabled.
   */
  set cameraColorGradingEnabled(value) {
    this.imageProcessingConfiguration.colorGradingEnabled = value;
  }
  /**
   * Gets whether tonemapping is enabled or not.
   */
  get cameraToneMappingEnabled() {
    return this._imageProcessingConfiguration.toneMappingEnabled;
  }
  /**
   * Sets whether tonemapping is enabled or not
   */
  set cameraToneMappingEnabled(value) {
    this._imageProcessingConfiguration.toneMappingEnabled = value;
  }
  /**
   * The camera exposure used on this material.
   * This property is here and not in the camera to allow controlling exposure without full screen post process.
   * This corresponds to a photographic exposure.
   */
  get cameraExposure() {
    return this._imageProcessingConfiguration.exposure;
  }
  /**
   * The camera exposure used on this material.
   * This property is here and not in the camera to allow controlling exposure without full screen post process.
   * This corresponds to a photographic exposure.
   */
  set cameraExposure(value) {
    this._imageProcessingConfiguration.exposure = value;
  }
  /**
   * Gets The camera contrast used on this material.
   */
  get cameraContrast() {
    return this._imageProcessingConfiguration.contrast;
  }
  /**
   * Sets The camera contrast used on this material.
   */
  set cameraContrast(value) {
    this._imageProcessingConfiguration.contrast = value;
  }
  /**
   * Gets the Color Grading 2D Lookup Texture.
   */
  get cameraColorGradingTexture() {
    return this._imageProcessingConfiguration.colorGradingTexture;
  }
  /**
   * Sets the Color Grading 2D Lookup Texture.
   */
  set cameraColorGradingTexture(value) {
    this._imageProcessingConfiguration.colorGradingTexture = value;
  }
  /**
   * The color grading curves provide additional color adjustmnent that is applied after any color grading transform (3D LUT).
   * They allow basic adjustment of saturation and small exposure adjustments, along with color filter tinting to provide white balance adjustment or more stylistic effects.
   * These are similar to controls found in many professional imaging or colorist software. The global controls are applied to the entire image. For advanced tuning, extra controls are provided to adjust the shadow, midtone and highlight areas of the image;
   * corresponding to low luminance, medium luminance, and high luminance areas respectively.
   */
  get cameraColorCurves() {
    return this._imageProcessingConfiguration.colorCurves;
  }
  /**
   * The color grading curves provide additional color adjustment that is applied after any color grading transform (3D LUT).
   * They allow basic adjustment of saturation and small exposure adjustments, along with color filter tinting to provide white balance adjustment or more stylistic effects.
   * These are similar to controls found in many professional imaging or colorist software. The global controls are applied to the entire image. For advanced tuning, extra controls are provided to adjust the shadow, midtone and highlight areas of the image;
   * corresponding to low luminance, medium luminance, and high luminance areas respectively.
   */
  set cameraColorCurves(value) {
    this._imageProcessingConfiguration.colorCurves = value;
  }
  /**
   * Can this material render to several textures at once
   */
  get canRenderToMRT() {
    return true;
  }
  /**
   * Instantiates a new standard material.
   * This is the default material used in Babylon. It is the best trade off between quality
   * and performances.
   * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/materials_introduction
   * @param name Define the name of the material in the scene
   * @param scene Define the scene the material belong to
   */
  constructor(name66, scene) {
    super(name66, scene);
    this._diffuseTexture = null;
    this._ambientTexture = null;
    this._opacityTexture = null;
    this._reflectionTexture = null;
    this._emissiveTexture = null;
    this._specularTexture = null;
    this._bumpTexture = null;
    this._lightmapTexture = null;
    this._refractionTexture = null;
    this.ambientColor = new Color3(0, 0, 0);
    this.diffuseColor = new Color3(1, 1, 1);
    this.specularColor = new Color3(1, 1, 1);
    this.emissiveColor = new Color3(0, 0, 0);
    this.specularPower = 64;
    this._useAlphaFromDiffuseTexture = false;
    this._useEmissiveAsIllumination = false;
    this._linkEmissiveWithDiffuse = false;
    this._useSpecularOverAlpha = false;
    this._useReflectionOverAlpha = false;
    this._disableLighting = false;
    this._useObjectSpaceNormalMap = false;
    this._useParallax = false;
    this._useParallaxOcclusion = false;
    this.parallaxScaleBias = 0.05;
    this._roughness = 0;
    this.indexOfRefraction = 0.98;
    this.invertRefractionY = true;
    this.alphaCutOff = 0.4;
    this._useLightmapAsShadowmap = false;
    this._useReflectionFresnelFromSpecular = false;
    this._useGlossinessFromSpecularMapAlpha = false;
    this._maxSimultaneousLights = 4;
    this._invertNormalMapX = false;
    this._invertNormalMapY = false;
    this._twoSidedLighting = false;
    this._applyDecalMapAfterDetailMap = false;
    this._renderTargets = new SmartArray(16);
    this._worldViewProjectionMatrix = Matrix.Zero();
    this._globalAmbientColor = new Color3(0, 0, 0);
    this._cacheHasRenderTargetTextures = false;
    this.detailMap = new DetailMapConfiguration(this);
    this._attachImageProcessingConfiguration(null);
    this.prePassConfiguration = new PrePassConfiguration();
    this.getRenderTargetTextures = () => {
      this._renderTargets.reset();
      if (_StandardMaterial.ReflectionTextureEnabled && this._reflectionTexture && this._reflectionTexture.isRenderTarget) {
        this._renderTargets.push(this._reflectionTexture);
      }
      if (_StandardMaterial.RefractionTextureEnabled && this._refractionTexture && this._refractionTexture.isRenderTarget) {
        this._renderTargets.push(this._refractionTexture);
      }
      this._eventInfo.renderTargets = this._renderTargets;
      this._callbackPluginEventFillRenderTargetTextures(this._eventInfo);
      return this._renderTargets;
    };
  }
  /**
   * Gets a boolean indicating that current material needs to register RTT
   */
  get hasRenderTargetTextures() {
    if (_StandardMaterial.ReflectionTextureEnabled && this._reflectionTexture && this._reflectionTexture.isRenderTarget) {
      return true;
    }
    if (_StandardMaterial.RefractionTextureEnabled && this._refractionTexture && this._refractionTexture.isRenderTarget) {
      return true;
    }
    return this._cacheHasRenderTargetTextures;
  }
  /**
   * Gets the current class name of the material e.g. "StandardMaterial"
   * Mainly use in serialization.
   * @returns the class name
   */
  getClassName() {
    return "StandardMaterial";
  }
  /**
   * Specifies if the material will require alpha blending
   * @returns a boolean specifying if alpha blending is needed
   */
  needAlphaBlending() {
    if (this._disableAlphaBlending) {
      return false;
    }
    return this.alpha < 1 || this._opacityTexture != null || this._shouldUseAlphaFromDiffuseTexture() || this._opacityFresnelParameters && this._opacityFresnelParameters.isEnabled;
  }
  /**
   * Specifies if this material should be rendered in alpha test mode
   * @returns a boolean specifying if an alpha test is needed.
   */
  needAlphaTesting() {
    if (this._forceAlphaTest) {
      return true;
    }
    return this._hasAlphaChannel() && (this._transparencyMode == null || this._transparencyMode === Material.MATERIAL_ALPHATEST);
  }
  /**
   * @returns whether or not the alpha value of the diffuse texture should be used for alpha blending.
   */
  _shouldUseAlphaFromDiffuseTexture() {
    return this._diffuseTexture != null && this._diffuseTexture.hasAlpha && this._useAlphaFromDiffuseTexture && this._transparencyMode !== Material.MATERIAL_OPAQUE;
  }
  /**
   * @returns whether or not there is a usable alpha channel for transparency.
   */
  _hasAlphaChannel() {
    return this._diffuseTexture != null && this._diffuseTexture.hasAlpha || this._opacityTexture != null;
  }
  /**
   * Get the texture used for alpha test purpose.
   * @returns the diffuse texture in case of the standard material.
   */
  getAlphaTestTexture() {
    return this._diffuseTexture;
  }
  /**
   * Get if the submesh is ready to be used and all its information available.
   * Child classes can use it to update shaders
   * @param mesh defines the mesh to check
   * @param subMesh defines which submesh to check
   * @param useInstances specifies that instances should be used
   * @returns a boolean indicating that the submesh is ready or not
   */
  isReadyForSubMesh(mesh, subMesh, useInstances = false) {
    if (!this._uniformBufferLayoutBuilt) {
      this.buildUniformLayout();
    }
    const drawWrapper = subMesh._drawWrapper;
    if (drawWrapper.effect && this.isFrozen) {
      if (drawWrapper._wasPreviouslyReady && drawWrapper._wasPreviouslyUsingInstances === useInstances) {
        return true;
      }
    }
    if (!subMesh.materialDefines) {
      this._callbackPluginEventGeneric(MaterialPluginEvent.GetDefineNames, this._eventInfo);
      subMesh.materialDefines = new StandardMaterialDefines(this._eventInfo.defineNames);
    }
    const scene = this.getScene();
    const defines = subMesh.materialDefines;
    if (this._isReadyForSubMesh(subMesh)) {
      return true;
    }
    const engine = scene.getEngine();
    defines._needNormals = PrepareDefinesForLights(scene, mesh, defines, true, this._maxSimultaneousLights, this._disableLighting);
    PrepareDefinesForMultiview(scene, defines);
    const oit = this.needAlphaBlendingForMesh(mesh) && this.getScene().useOrderIndependentTransparency;
    PrepareDefinesForPrePass(scene, defines, this.canRenderToMRT && !oit);
    PrepareDefinesForOIT(scene, defines, oit);
    if (defines._areTexturesDirty) {
      this._eventInfo.hasRenderTargetTextures = false;
      this._callbackPluginEventHasRenderTargetTextures(this._eventInfo);
      this._cacheHasRenderTargetTextures = this._eventInfo.hasRenderTargetTextures;
      defines._needUVs = false;
      for (let i = 1; i <= 6; ++i) {
        defines["MAINUV" + i] = false;
      }
      if (scene.texturesEnabled) {
        defines.DIFFUSEDIRECTUV = 0;
        defines.BUMPDIRECTUV = 0;
        defines.AMBIENTDIRECTUV = 0;
        defines.OPACITYDIRECTUV = 0;
        defines.EMISSIVEDIRECTUV = 0;
        defines.SPECULARDIRECTUV = 0;
        defines.LIGHTMAPDIRECTUV = 0;
        if (this._diffuseTexture && _StandardMaterial.DiffuseTextureEnabled) {
          if (!this._diffuseTexture.isReadyOrNotBlocking()) {
            return false;
          } else {
            PrepareDefinesForMergedUV(this._diffuseTexture, defines, "DIFFUSE");
          }
        } else {
          defines.DIFFUSE = false;
        }
        if (this._ambientTexture && _StandardMaterial.AmbientTextureEnabled) {
          if (!this._ambientTexture.isReadyOrNotBlocking()) {
            return false;
          } else {
            PrepareDefinesForMergedUV(this._ambientTexture, defines, "AMBIENT");
          }
        } else {
          defines.AMBIENT = false;
        }
        if (this._opacityTexture && _StandardMaterial.OpacityTextureEnabled) {
          if (!this._opacityTexture.isReadyOrNotBlocking()) {
            return false;
          } else {
            PrepareDefinesForMergedUV(this._opacityTexture, defines, "OPACITY");
            defines.OPACITYRGB = this._opacityTexture.getAlphaFromRGB;
          }
        } else {
          defines.OPACITY = false;
        }
        if (this._reflectionTexture && _StandardMaterial.ReflectionTextureEnabled) {
          if (!this._reflectionTexture.isReadyOrNotBlocking()) {
            return false;
          } else {
            defines._needNormals = true;
            defines.REFLECTION = true;
            defines.ROUGHNESS = this._roughness > 0;
            defines.REFLECTIONOVERALPHA = this._useReflectionOverAlpha;
            defines.INVERTCUBICMAP = this._reflectionTexture.coordinatesMode === Texture.INVCUBIC_MODE;
            defines.REFLECTIONMAP_3D = this._reflectionTexture.isCube;
            defines.REFLECTIONMAP_OPPOSITEZ = defines.REFLECTIONMAP_3D && this.getScene().useRightHandedSystem ? !this._reflectionTexture.invertZ : this._reflectionTexture.invertZ;
            defines.RGBDREFLECTION = this._reflectionTexture.isRGBD;
            switch (this._reflectionTexture.coordinatesMode) {
              case Texture.EXPLICIT_MODE:
                defines.setReflectionMode("REFLECTIONMAP_EXPLICIT");
                break;
              case Texture.PLANAR_MODE:
                defines.setReflectionMode("REFLECTIONMAP_PLANAR");
                break;
              case Texture.PROJECTION_MODE:
                defines.setReflectionMode("REFLECTIONMAP_PROJECTION");
                break;
              case Texture.SKYBOX_MODE:
                defines.setReflectionMode("REFLECTIONMAP_SKYBOX");
                break;
              case Texture.SPHERICAL_MODE:
                defines.setReflectionMode("REFLECTIONMAP_SPHERICAL");
                break;
              case Texture.EQUIRECTANGULAR_MODE:
                defines.setReflectionMode("REFLECTIONMAP_EQUIRECTANGULAR");
                break;
              case Texture.FIXED_EQUIRECTANGULAR_MODE:
                defines.setReflectionMode("REFLECTIONMAP_EQUIRECTANGULAR_FIXED");
                break;
              case Texture.FIXED_EQUIRECTANGULAR_MIRRORED_MODE:
                defines.setReflectionMode("REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED");
                break;
              case Texture.CUBIC_MODE:
              case Texture.INVCUBIC_MODE:
              default:
                defines.setReflectionMode("REFLECTIONMAP_CUBIC");
                break;
            }
            defines.USE_LOCAL_REFLECTIONMAP_CUBIC = this._reflectionTexture.boundingBoxSize ? true : false;
          }
        } else {
          defines.REFLECTION = false;
          defines.REFLECTIONMAP_OPPOSITEZ = false;
        }
        if (this._emissiveTexture && _StandardMaterial.EmissiveTextureEnabled) {
          if (!this._emissiveTexture.isReadyOrNotBlocking()) {
            return false;
          } else {
            PrepareDefinesForMergedUV(this._emissiveTexture, defines, "EMISSIVE");
          }
        } else {
          defines.EMISSIVE = false;
        }
        if (this._lightmapTexture && _StandardMaterial.LightmapTextureEnabled) {
          if (!this._lightmapTexture.isReadyOrNotBlocking()) {
            return false;
          } else {
            PrepareDefinesForMergedUV(this._lightmapTexture, defines, "LIGHTMAP");
            defines.USELIGHTMAPASSHADOWMAP = this._useLightmapAsShadowmap;
            defines.RGBDLIGHTMAP = this._lightmapTexture.isRGBD;
          }
        } else {
          defines.LIGHTMAP = false;
        }
        if (this._specularTexture && _StandardMaterial.SpecularTextureEnabled) {
          if (!this._specularTexture.isReadyOrNotBlocking()) {
            return false;
          } else {
            PrepareDefinesForMergedUV(this._specularTexture, defines, "SPECULAR");
            defines.GLOSSINESS = this._useGlossinessFromSpecularMapAlpha;
          }
        } else {
          defines.SPECULAR = false;
        }
        if (scene.getEngine().getCaps().standardDerivatives && this._bumpTexture && _StandardMaterial.BumpTextureEnabled) {
          if (!this._bumpTexture.isReady()) {
            return false;
          } else {
            PrepareDefinesForMergedUV(this._bumpTexture, defines, "BUMP");
            defines.PARALLAX = this._useParallax;
            defines.PARALLAX_RHS = scene.useRightHandedSystem;
            defines.PARALLAXOCCLUSION = this._useParallaxOcclusion;
          }
          defines.OBJECTSPACE_NORMALMAP = this._useObjectSpaceNormalMap;
        } else {
          defines.BUMP = false;
          defines.PARALLAX = false;
          defines.PARALLAX_RHS = false;
          defines.PARALLAXOCCLUSION = false;
        }
        if (this._refractionTexture && _StandardMaterial.RefractionTextureEnabled) {
          if (!this._refractionTexture.isReadyOrNotBlocking()) {
            return false;
          } else {
            defines._needUVs = true;
            defines.REFRACTION = true;
            defines.REFRACTIONMAP_3D = this._refractionTexture.isCube;
            defines.RGBDREFRACTION = this._refractionTexture.isRGBD;
            defines.USE_LOCAL_REFRACTIONMAP_CUBIC = this._refractionTexture.boundingBoxSize ? true : false;
          }
        } else {
          defines.REFRACTION = false;
        }
        defines.TWOSIDEDLIGHTING = !this._backFaceCulling && this._twoSidedLighting;
      } else {
        defines.DIFFUSE = false;
        defines.AMBIENT = false;
        defines.OPACITY = false;
        defines.REFLECTION = false;
        defines.EMISSIVE = false;
        defines.LIGHTMAP = false;
        defines.BUMP = false;
        defines.REFRACTION = false;
      }
      defines.ALPHAFROMDIFFUSE = this._shouldUseAlphaFromDiffuseTexture();
      defines.EMISSIVEASILLUMINATION = this._useEmissiveAsIllumination;
      defines.LINKEMISSIVEWITHDIFFUSE = this._linkEmissiveWithDiffuse;
      defines.SPECULAROVERALPHA = this._useSpecularOverAlpha;
      defines.PREMULTIPLYALPHA = this.alphaMode === 7 || this.alphaMode === 8;
      defines.ALPHATEST_AFTERALLALPHACOMPUTATIONS = this.transparencyMode !== null;
      defines.ALPHABLEND = this.transparencyMode === null || this.needAlphaBlendingForMesh(mesh);
    }
    this._eventInfo.isReadyForSubMesh = true;
    this._eventInfo.defines = defines;
    this._eventInfo.subMesh = subMesh;
    this._callbackPluginEventIsReadyForSubMesh(this._eventInfo);
    if (!this._eventInfo.isReadyForSubMesh) {
      return false;
    }
    if (defines._areImageProcessingDirty && this._imageProcessingConfiguration) {
      if (!this._imageProcessingConfiguration.isReady()) {
        return false;
      }
      this._imageProcessingConfiguration.prepareDefines(defines);
      defines.IS_REFLECTION_LINEAR = this.reflectionTexture != null && !this.reflectionTexture.gammaSpace;
      defines.IS_REFRACTION_LINEAR = this.refractionTexture != null && !this.refractionTexture.gammaSpace;
    }
    if (defines._areFresnelDirty) {
      if (_StandardMaterial.FresnelEnabled) {
        if (this._diffuseFresnelParameters || this._opacityFresnelParameters || this._emissiveFresnelParameters || this._refractionFresnelParameters || this._reflectionFresnelParameters) {
          defines.DIFFUSEFRESNEL = this._diffuseFresnelParameters && this._diffuseFresnelParameters.isEnabled;
          defines.OPACITYFRESNEL = this._opacityFresnelParameters && this._opacityFresnelParameters.isEnabled;
          defines.REFLECTIONFRESNEL = this._reflectionFresnelParameters && this._reflectionFresnelParameters.isEnabled;
          defines.REFLECTIONFRESNELFROMSPECULAR = this._useReflectionFresnelFromSpecular;
          defines.REFRACTIONFRESNEL = this._refractionFresnelParameters && this._refractionFresnelParameters.isEnabled;
          defines.EMISSIVEFRESNEL = this._emissiveFresnelParameters && this._emissiveFresnelParameters.isEnabled;
          defines._needNormals = true;
          defines.FRESNEL = true;
        }
      } else {
        defines.FRESNEL = false;
      }
    }
    PrepareDefinesForMisc(mesh, scene, this._useLogarithmicDepth, this.pointsCloud, this.fogEnabled, this._shouldTurnAlphaTestOn(mesh) || this._forceAlphaTest, defines, this._applyDecalMapAfterDetailMap);
    PrepareDefinesForFrameBoundValues(scene, engine, this, defines, useInstances, null, subMesh.getRenderingMesh().hasThinInstances);
    this._eventInfo.defines = defines;
    this._eventInfo.mesh = mesh;
    this._callbackPluginEventPrepareDefinesBeforeAttributes(this._eventInfo);
    PrepareDefinesForAttributes(mesh, defines, true, true, true);
    this._callbackPluginEventPrepareDefines(this._eventInfo);
    let forceWasNotReadyPreviously = false;
    if (defines.isDirty) {
      const lightDisposed = defines._areLightsDisposed;
      defines.markAsProcessed();
      const fallbacks = new EffectFallbacks();
      if (defines.REFLECTION) {
        fallbacks.addFallback(0, "REFLECTION");
      }
      if (defines.SPECULAR) {
        fallbacks.addFallback(0, "SPECULAR");
      }
      if (defines.BUMP) {
        fallbacks.addFallback(0, "BUMP");
      }
      if (defines.PARALLAX) {
        fallbacks.addFallback(1, "PARALLAX");
      }
      if (defines.PARALLAX_RHS) {
        fallbacks.addFallback(1, "PARALLAX_RHS");
      }
      if (defines.PARALLAXOCCLUSION) {
        fallbacks.addFallback(0, "PARALLAXOCCLUSION");
      }
      if (defines.SPECULAROVERALPHA) {
        fallbacks.addFallback(0, "SPECULAROVERALPHA");
      }
      if (defines.FOG) {
        fallbacks.addFallback(1, "FOG");
      }
      if (defines.POINTSIZE) {
        fallbacks.addFallback(0, "POINTSIZE");
      }
      if (defines.LOGARITHMICDEPTH) {
        fallbacks.addFallback(0, "LOGARITHMICDEPTH");
      }
      HandleFallbacksForShadows(defines, fallbacks, this._maxSimultaneousLights);
      if (defines.SPECULARTERM) {
        fallbacks.addFallback(0, "SPECULARTERM");
      }
      if (defines.DIFFUSEFRESNEL) {
        fallbacks.addFallback(1, "DIFFUSEFRESNEL");
      }
      if (defines.OPACITYFRESNEL) {
        fallbacks.addFallback(2, "OPACITYFRESNEL");
      }
      if (defines.REFLECTIONFRESNEL) {
        fallbacks.addFallback(3, "REFLECTIONFRESNEL");
      }
      if (defines.EMISSIVEFRESNEL) {
        fallbacks.addFallback(4, "EMISSIVEFRESNEL");
      }
      if (defines.FRESNEL) {
        fallbacks.addFallback(4, "FRESNEL");
      }
      if (defines.MULTIVIEW) {
        fallbacks.addFallback(0, "MULTIVIEW");
      }
      const attribs = [VertexBuffer.PositionKind];
      if (defines.NORMAL) {
        attribs.push(VertexBuffer.NormalKind);
      }
      if (defines.TANGENT) {
        attribs.push(VertexBuffer.TangentKind);
      }
      for (let i = 1; i <= 6; ++i) {
        if (defines["UV" + i]) {
          attribs.push(`uv${i === 1 ? "" : i}`);
        }
      }
      if (defines.VERTEXCOLOR) {
        attribs.push(VertexBuffer.ColorKind);
      }
      PrepareAttributesForBones(attribs, mesh, defines, fallbacks);
      PrepareAttributesForInstances(attribs, defines);
      PrepareAttributesForMorphTargets(attribs, mesh, defines);
      PrepareAttributesForBakedVertexAnimation(attribs, mesh, defines);
      let shaderName = "default";
      const uniforms = [
        "world",
        "view",
        "viewProjection",
        "vEyePosition",
        "vLightsType",
        "vAmbientColor",
        "vDiffuseColor",
        "vSpecularColor",
        "vEmissiveColor",
        "visibility",
        "vFogInfos",
        "vFogColor",
        "pointSize",
        "vDiffuseInfos",
        "vAmbientInfos",
        "vOpacityInfos",
        "vReflectionInfos",
        "vEmissiveInfos",
        "vSpecularInfos",
        "vBumpInfos",
        "vLightmapInfos",
        "vRefractionInfos",
        "mBones",
        "diffuseMatrix",
        "ambientMatrix",
        "opacityMatrix",
        "reflectionMatrix",
        "emissiveMatrix",
        "specularMatrix",
        "bumpMatrix",
        "normalMatrix",
        "lightmapMatrix",
        "refractionMatrix",
        "diffuseLeftColor",
        "diffuseRightColor",
        "opacityParts",
        "reflectionLeftColor",
        "reflectionRightColor",
        "emissiveLeftColor",
        "emissiveRightColor",
        "refractionLeftColor",
        "refractionRightColor",
        "vReflectionPosition",
        "vReflectionSize",
        "vRefractionPosition",
        "vRefractionSize",
        "logarithmicDepthConstant",
        "vTangentSpaceParams",
        "alphaCutOff",
        "boneTextureWidth",
        "morphTargetTextureInfo",
        "morphTargetTextureIndices"
      ];
      const samplers = [
        "diffuseSampler",
        "ambientSampler",
        "opacitySampler",
        "reflectionCubeSampler",
        "reflection2DSampler",
        "emissiveSampler",
        "specularSampler",
        "bumpSampler",
        "lightmapSampler",
        "refractionCubeSampler",
        "refraction2DSampler",
        "boneSampler",
        "morphTargets",
        "oitDepthSampler",
        "oitFrontColorSampler"
      ];
      const uniformBuffers = ["Material", "Scene", "Mesh"];
      const indexParameters = { maxSimultaneousLights: this._maxSimultaneousLights, maxSimultaneousMorphTargets: defines.NUM_MORPH_INFLUENCERS };
      this._eventInfo.fallbacks = fallbacks;
      this._eventInfo.fallbackRank = 0;
      this._eventInfo.defines = defines;
      this._eventInfo.uniforms = uniforms;
      this._eventInfo.attributes = attribs;
      this._eventInfo.samplers = samplers;
      this._eventInfo.uniformBuffersNames = uniformBuffers;
      this._eventInfo.customCode = void 0;
      this._eventInfo.mesh = mesh;
      this._eventInfo.indexParameters = indexParameters;
      this._callbackPluginEventGeneric(MaterialPluginEvent.PrepareEffect, this._eventInfo);
      PrePassConfiguration.AddUniforms(uniforms);
      PrePassConfiguration.AddSamplers(samplers);
      if (ImageProcessingConfiguration) {
        ImageProcessingConfiguration.PrepareUniforms(uniforms, defines);
        ImageProcessingConfiguration.PrepareSamplers(samplers, defines);
      }
      PrepareUniformsAndSamplersList({
        uniformsNames: uniforms,
        uniformBuffersNames: uniformBuffers,
        samplers,
        defines,
        maxSimultaneousLights: this._maxSimultaneousLights
      });
      addClipPlaneUniforms(uniforms);
      const csnrOptions = {};
      if (this.customShaderNameResolve) {
        shaderName = this.customShaderNameResolve(shaderName, uniforms, uniformBuffers, samplers, defines, attribs, csnrOptions);
      }
      const join = defines.toString();
      const previousEffect = subMesh.effect;
      let effect = scene.getEngine().createEffect(shaderName, {
        attributes: attribs,
        uniformsNames: uniforms,
        uniformBuffersNames: uniformBuffers,
        samplers,
        defines: join,
        fallbacks,
        onCompiled: this.onCompiled,
        onError: this.onError,
        indexParameters,
        processFinalCode: csnrOptions.processFinalCode,
        processCodeAfterIncludes: this._eventInfo.customCode,
        multiTarget: defines.PREPASS
      }, engine);
      this._eventInfo.customCode = void 0;
      if (effect) {
        if (this._onEffectCreatedObservable) {
          onCreatedEffectParameters.effect = effect;
          onCreatedEffectParameters.subMesh = subMesh;
          this._onEffectCreatedObservable.notifyObservers(onCreatedEffectParameters);
        }
        if (this.allowShaderHotSwapping && previousEffect && !effect.isReady()) {
          effect = previousEffect;
          defines.markAsUnprocessed();
          forceWasNotReadyPreviously = this.isFrozen;
          if (lightDisposed) {
            defines._areLightsDisposed = true;
            return false;
          }
        } else {
          scene.resetCachedMaterial();
          subMesh.setEffect(effect, defines, this._materialContext);
        }
      }
    }
    if (!subMesh.effect || !subMesh.effect.isReady()) {
      return false;
    }
    defines._renderId = scene.getRenderId();
    drawWrapper._wasPreviouslyReady = forceWasNotReadyPreviously ? false : true;
    drawWrapper._wasPreviouslyUsingInstances = useInstances;
    this._checkScenePerformancePriority();
    return true;
  }
  /**
   * Builds the material UBO layouts.
   * Used internally during the effect preparation.
   */
  buildUniformLayout() {
    const ubo = this._uniformBuffer;
    ubo.addUniform("diffuseLeftColor", 4);
    ubo.addUniform("diffuseRightColor", 4);
    ubo.addUniform("opacityParts", 4);
    ubo.addUniform("reflectionLeftColor", 4);
    ubo.addUniform("reflectionRightColor", 4);
    ubo.addUniform("refractionLeftColor", 4);
    ubo.addUniform("refractionRightColor", 4);
    ubo.addUniform("emissiveLeftColor", 4);
    ubo.addUniform("emissiveRightColor", 4);
    ubo.addUniform("vDiffuseInfos", 2);
    ubo.addUniform("vAmbientInfos", 2);
    ubo.addUniform("vOpacityInfos", 2);
    ubo.addUniform("vReflectionInfos", 2);
    ubo.addUniform("vReflectionPosition", 3);
    ubo.addUniform("vReflectionSize", 3);
    ubo.addUniform("vEmissiveInfos", 2);
    ubo.addUniform("vLightmapInfos", 2);
    ubo.addUniform("vSpecularInfos", 2);
    ubo.addUniform("vBumpInfos", 3);
    ubo.addUniform("diffuseMatrix", 16);
    ubo.addUniform("ambientMatrix", 16);
    ubo.addUniform("opacityMatrix", 16);
    ubo.addUniform("reflectionMatrix", 16);
    ubo.addUniform("emissiveMatrix", 16);
    ubo.addUniform("lightmapMatrix", 16);
    ubo.addUniform("specularMatrix", 16);
    ubo.addUniform("bumpMatrix", 16);
    ubo.addUniform("vTangentSpaceParams", 2);
    ubo.addUniform("pointSize", 1);
    ubo.addUniform("alphaCutOff", 1);
    ubo.addUniform("refractionMatrix", 16);
    ubo.addUniform("vRefractionInfos", 4);
    ubo.addUniform("vRefractionPosition", 3);
    ubo.addUniform("vRefractionSize", 3);
    ubo.addUniform("vSpecularColor", 4);
    ubo.addUniform("vEmissiveColor", 3);
    ubo.addUniform("vDiffuseColor", 4);
    ubo.addUniform("vAmbientColor", 3);
    super.buildUniformLayout();
  }
  /**
   * Binds the submesh to this material by preparing the effect and shader to draw
   * @param world defines the world transformation matrix
   * @param mesh defines the mesh containing the submesh
   * @param subMesh defines the submesh to bind the material to
   */
  bindForSubMesh(world, mesh, subMesh) {
    const scene = this.getScene();
    const defines = subMesh.materialDefines;
    if (!defines) {
      return;
    }
    const effect = subMesh.effect;
    if (!effect) {
      return;
    }
    this._activeEffect = effect;
    mesh.getMeshUniformBuffer().bindToEffect(effect, "Mesh");
    mesh.transferToEffect(world);
    this._uniformBuffer.bindToEffect(effect, "Material");
    this.prePassConfiguration.bindForSubMesh(this._activeEffect, scene, mesh, world, this.isFrozen);
    this._eventInfo.subMesh = subMesh;
    this._callbackPluginEventHardBindForSubMesh(this._eventInfo);
    if (defines.OBJECTSPACE_NORMALMAP) {
      world.toNormalMatrix(this._normalMatrix);
      this.bindOnlyNormalMatrix(this._normalMatrix);
    }
    const mustRebind = this._mustRebind(scene, effect, subMesh, mesh.visibility);
    BindBonesParameters(mesh, effect);
    const ubo = this._uniformBuffer;
    if (mustRebind) {
      this.bindViewProjection(effect);
      if (!ubo.useUbo || !this.isFrozen || !ubo.isSync || subMesh._drawWrapper._forceRebindOnNextCall) {
        if (_StandardMaterial.FresnelEnabled && defines.FRESNEL) {
          if (this.diffuseFresnelParameters && this.diffuseFresnelParameters.isEnabled) {
            ubo.updateColor4("diffuseLeftColor", this.diffuseFresnelParameters.leftColor, this.diffuseFresnelParameters.power);
            ubo.updateColor4("diffuseRightColor", this.diffuseFresnelParameters.rightColor, this.diffuseFresnelParameters.bias);
          }
          if (this.opacityFresnelParameters && this.opacityFresnelParameters.isEnabled) {
            ubo.updateColor4("opacityParts", new Color3(this.opacityFresnelParameters.leftColor.toLuminance(), this.opacityFresnelParameters.rightColor.toLuminance(), this.opacityFresnelParameters.bias), this.opacityFresnelParameters.power);
          }
          if (this.reflectionFresnelParameters && this.reflectionFresnelParameters.isEnabled) {
            ubo.updateColor4("reflectionLeftColor", this.reflectionFresnelParameters.leftColor, this.reflectionFresnelParameters.power);
            ubo.updateColor4("reflectionRightColor", this.reflectionFresnelParameters.rightColor, this.reflectionFresnelParameters.bias);
          }
          if (this.refractionFresnelParameters && this.refractionFresnelParameters.isEnabled) {
            ubo.updateColor4("refractionLeftColor", this.refractionFresnelParameters.leftColor, this.refractionFresnelParameters.power);
            ubo.updateColor4("refractionRightColor", this.refractionFresnelParameters.rightColor, this.refractionFresnelParameters.bias);
          }
          if (this.emissiveFresnelParameters && this.emissiveFresnelParameters.isEnabled) {
            ubo.updateColor4("emissiveLeftColor", this.emissiveFresnelParameters.leftColor, this.emissiveFresnelParameters.power);
            ubo.updateColor4("emissiveRightColor", this.emissiveFresnelParameters.rightColor, this.emissiveFresnelParameters.bias);
          }
        }
        if (scene.texturesEnabled) {
          if (this._diffuseTexture && _StandardMaterial.DiffuseTextureEnabled) {
            ubo.updateFloat2("vDiffuseInfos", this._diffuseTexture.coordinatesIndex, this._diffuseTexture.level);
            BindTextureMatrix(this._diffuseTexture, ubo, "diffuse");
          }
          if (this._ambientTexture && _StandardMaterial.AmbientTextureEnabled) {
            ubo.updateFloat2("vAmbientInfos", this._ambientTexture.coordinatesIndex, this._ambientTexture.level);
            BindTextureMatrix(this._ambientTexture, ubo, "ambient");
          }
          if (this._opacityTexture && _StandardMaterial.OpacityTextureEnabled) {
            ubo.updateFloat2("vOpacityInfos", this._opacityTexture.coordinatesIndex, this._opacityTexture.level);
            BindTextureMatrix(this._opacityTexture, ubo, "opacity");
          }
          if (this._hasAlphaChannel()) {
            ubo.updateFloat("alphaCutOff", this.alphaCutOff);
          }
          if (this._reflectionTexture && _StandardMaterial.ReflectionTextureEnabled) {
            ubo.updateFloat2("vReflectionInfos", this._reflectionTexture.level, this.roughness);
            ubo.updateMatrix("reflectionMatrix", this._reflectionTexture.getReflectionTextureMatrix());
            if (this._reflectionTexture.boundingBoxSize) {
              const cubeTexture = this._reflectionTexture;
              ubo.updateVector3("vReflectionPosition", cubeTexture.boundingBoxPosition);
              ubo.updateVector3("vReflectionSize", cubeTexture.boundingBoxSize);
            }
          }
          if (this._emissiveTexture && _StandardMaterial.EmissiveTextureEnabled) {
            ubo.updateFloat2("vEmissiveInfos", this._emissiveTexture.coordinatesIndex, this._emissiveTexture.level);
            BindTextureMatrix(this._emissiveTexture, ubo, "emissive");
          }
          if (this._lightmapTexture && _StandardMaterial.LightmapTextureEnabled) {
            ubo.updateFloat2("vLightmapInfos", this._lightmapTexture.coordinatesIndex, this._lightmapTexture.level);
            BindTextureMatrix(this._lightmapTexture, ubo, "lightmap");
          }
          if (this._specularTexture && _StandardMaterial.SpecularTextureEnabled) {
            ubo.updateFloat2("vSpecularInfos", this._specularTexture.coordinatesIndex, this._specularTexture.level);
            BindTextureMatrix(this._specularTexture, ubo, "specular");
          }
          if (this._bumpTexture && scene.getEngine().getCaps().standardDerivatives && _StandardMaterial.BumpTextureEnabled) {
            ubo.updateFloat3("vBumpInfos", this._bumpTexture.coordinatesIndex, 1 / this._bumpTexture.level, this.parallaxScaleBias);
            BindTextureMatrix(this._bumpTexture, ubo, "bump");
            if (scene._mirroredCameraPosition) {
              ubo.updateFloat2("vTangentSpaceParams", this._invertNormalMapX ? 1 : -1, this._invertNormalMapY ? 1 : -1);
            } else {
              ubo.updateFloat2("vTangentSpaceParams", this._invertNormalMapX ? -1 : 1, this._invertNormalMapY ? -1 : 1);
            }
          }
          if (this._refractionTexture && _StandardMaterial.RefractionTextureEnabled) {
            let depth = 1;
            if (!this._refractionTexture.isCube) {
              ubo.updateMatrix("refractionMatrix", this._refractionTexture.getReflectionTextureMatrix());
              if (this._refractionTexture.depth) {
                depth = this._refractionTexture.depth;
              }
            }
            ubo.updateFloat4("vRefractionInfos", this._refractionTexture.level, this.indexOfRefraction, depth, this.invertRefractionY ? -1 : 1);
            if (this._refractionTexture.boundingBoxSize) {
              const cubeTexture = this._refractionTexture;
              ubo.updateVector3("vRefractionPosition", cubeTexture.boundingBoxPosition);
              ubo.updateVector3("vRefractionSize", cubeTexture.boundingBoxSize);
            }
          }
        }
        if (this.pointsCloud) {
          ubo.updateFloat("pointSize", this.pointSize);
        }
        if (defines.SPECULARTERM) {
          ubo.updateColor4("vSpecularColor", this.specularColor, this.specularPower);
        }
        ubo.updateColor3("vEmissiveColor", _StandardMaterial.EmissiveTextureEnabled ? this.emissiveColor : Color3.BlackReadOnly);
        ubo.updateColor4("vDiffuseColor", this.diffuseColor, this.alpha);
        scene.ambientColor.multiplyToRef(this.ambientColor, this._globalAmbientColor);
        ubo.updateColor3("vAmbientColor", this._globalAmbientColor);
      }
      if (scene.texturesEnabled) {
        if (this._diffuseTexture && _StandardMaterial.DiffuseTextureEnabled) {
          effect.setTexture("diffuseSampler", this._diffuseTexture);
        }
        if (this._ambientTexture && _StandardMaterial.AmbientTextureEnabled) {
          effect.setTexture("ambientSampler", this._ambientTexture);
        }
        if (this._opacityTexture && _StandardMaterial.OpacityTextureEnabled) {
          effect.setTexture("opacitySampler", this._opacityTexture);
        }
        if (this._reflectionTexture && _StandardMaterial.ReflectionTextureEnabled) {
          if (this._reflectionTexture.isCube) {
            effect.setTexture("reflectionCubeSampler", this._reflectionTexture);
          } else {
            effect.setTexture("reflection2DSampler", this._reflectionTexture);
          }
        }
        if (this._emissiveTexture && _StandardMaterial.EmissiveTextureEnabled) {
          effect.setTexture("emissiveSampler", this._emissiveTexture);
        }
        if (this._lightmapTexture && _StandardMaterial.LightmapTextureEnabled) {
          effect.setTexture("lightmapSampler", this._lightmapTexture);
        }
        if (this._specularTexture && _StandardMaterial.SpecularTextureEnabled) {
          effect.setTexture("specularSampler", this._specularTexture);
        }
        if (this._bumpTexture && scene.getEngine().getCaps().standardDerivatives && _StandardMaterial.BumpTextureEnabled) {
          effect.setTexture("bumpSampler", this._bumpTexture);
        }
        if (this._refractionTexture && _StandardMaterial.RefractionTextureEnabled) {
          if (this._refractionTexture.isCube) {
            effect.setTexture("refractionCubeSampler", this._refractionTexture);
          } else {
            effect.setTexture("refraction2DSampler", this._refractionTexture);
          }
        }
      }
      if (this.getScene().useOrderIndependentTransparency && this.needAlphaBlendingForMesh(mesh)) {
        this.getScene().depthPeelingRenderer.bind(effect);
      }
      this._eventInfo.subMesh = subMesh;
      this._callbackPluginEventBindForSubMesh(this._eventInfo);
      bindClipPlane(effect, this, scene);
      this.bindEyePosition(effect);
    } else if (scene.getEngine()._features.needToAlwaysBindUniformBuffers) {
      this._needToBindSceneUbo = true;
    }
    if (mustRebind || !this.isFrozen) {
      if (scene.lightsEnabled && !this._disableLighting) {
        BindLights(scene, mesh, effect, defines, this._maxSimultaneousLights);
      }
      if (scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE || this._reflectionTexture || this._refractionTexture || mesh.receiveShadows || defines.PREPASS) {
        this.bindView(effect);
      }
      BindFogParameters(scene, mesh, effect);
      if (defines.NUM_MORPH_INFLUENCERS) {
        BindMorphTargetParameters(mesh, effect);
      }
      if (defines.BAKED_VERTEX_ANIMATION_TEXTURE) {
        mesh.bakedVertexAnimationManager?.bind(effect, defines.INSTANCES);
      }
      if (this.useLogarithmicDepth) {
        BindLogDepth(defines, effect, scene);
      }
      if (this._imageProcessingConfiguration && !this._imageProcessingConfiguration.applyByPostProcess) {
        this._imageProcessingConfiguration.bind(this._activeEffect);
      }
    }
    this._afterBind(mesh, this._activeEffect, subMesh);
    ubo.update();
  }
  /**
   * Get the list of animatables in the material.
   * @returns the list of animatables object used in the material
   */
  getAnimatables() {
    const results = super.getAnimatables();
    if (this._diffuseTexture && this._diffuseTexture.animations && this._diffuseTexture.animations.length > 0) {
      results.push(this._diffuseTexture);
    }
    if (this._ambientTexture && this._ambientTexture.animations && this._ambientTexture.animations.length > 0) {
      results.push(this._ambientTexture);
    }
    if (this._opacityTexture && this._opacityTexture.animations && this._opacityTexture.animations.length > 0) {
      results.push(this._opacityTexture);
    }
    if (this._reflectionTexture && this._reflectionTexture.animations && this._reflectionTexture.animations.length > 0) {
      results.push(this._reflectionTexture);
    }
    if (this._emissiveTexture && this._emissiveTexture.animations && this._emissiveTexture.animations.length > 0) {
      results.push(this._emissiveTexture);
    }
    if (this._specularTexture && this._specularTexture.animations && this._specularTexture.animations.length > 0) {
      results.push(this._specularTexture);
    }
    if (this._bumpTexture && this._bumpTexture.animations && this._bumpTexture.animations.length > 0) {
      results.push(this._bumpTexture);
    }
    if (this._lightmapTexture && this._lightmapTexture.animations && this._lightmapTexture.animations.length > 0) {
      results.push(this._lightmapTexture);
    }
    if (this._refractionTexture && this._refractionTexture.animations && this._refractionTexture.animations.length > 0) {
      results.push(this._refractionTexture);
    }
    return results;
  }
  /**
   * Gets the active textures from the material
   * @returns an array of textures
   */
  getActiveTextures() {
    const activeTextures = super.getActiveTextures();
    if (this._diffuseTexture) {
      activeTextures.push(this._diffuseTexture);
    }
    if (this._ambientTexture) {
      activeTextures.push(this._ambientTexture);
    }
    if (this._opacityTexture) {
      activeTextures.push(this._opacityTexture);
    }
    if (this._reflectionTexture) {
      activeTextures.push(this._reflectionTexture);
    }
    if (this._emissiveTexture) {
      activeTextures.push(this._emissiveTexture);
    }
    if (this._specularTexture) {
      activeTextures.push(this._specularTexture);
    }
    if (this._bumpTexture) {
      activeTextures.push(this._bumpTexture);
    }
    if (this._lightmapTexture) {
      activeTextures.push(this._lightmapTexture);
    }
    if (this._refractionTexture) {
      activeTextures.push(this._refractionTexture);
    }
    return activeTextures;
  }
  /**
   * Specifies if the material uses a texture
   * @param texture defines the texture to check against the material
   * @returns a boolean specifying if the material uses the texture
   */
  hasTexture(texture) {
    if (super.hasTexture(texture)) {
      return true;
    }
    if (this._diffuseTexture === texture) {
      return true;
    }
    if (this._ambientTexture === texture) {
      return true;
    }
    if (this._opacityTexture === texture) {
      return true;
    }
    if (this._reflectionTexture === texture) {
      return true;
    }
    if (this._emissiveTexture === texture) {
      return true;
    }
    if (this._specularTexture === texture) {
      return true;
    }
    if (this._bumpTexture === texture) {
      return true;
    }
    if (this._lightmapTexture === texture) {
      return true;
    }
    if (this._refractionTexture === texture) {
      return true;
    }
    return false;
  }
  /**
   * Disposes the material
   * @param forceDisposeEffect specifies if effects should be forcefully disposed
   * @param forceDisposeTextures specifies if textures should be forcefully disposed
   */
  dispose(forceDisposeEffect, forceDisposeTextures) {
    if (forceDisposeTextures) {
      this._diffuseTexture?.dispose();
      this._ambientTexture?.dispose();
      this._opacityTexture?.dispose();
      this._reflectionTexture?.dispose();
      this._emissiveTexture?.dispose();
      this._specularTexture?.dispose();
      this._bumpTexture?.dispose();
      this._lightmapTexture?.dispose();
      this._refractionTexture?.dispose();
    }
    if (this._imageProcessingConfiguration && this._imageProcessingObserver) {
      this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver);
    }
    super.dispose(forceDisposeEffect, forceDisposeTextures);
  }
  /**
   * Makes a duplicate of the material, and gives it a new name
   * @param name defines the new name for the duplicated material
   * @param cloneTexturesOnlyOnce - if a texture is used in more than one channel (e.g diffuse and opacity), only clone it once and reuse it on the other channels. Default false.
   * @param rootUrl defines the root URL to use to load textures
   * @returns the cloned material
   */
  clone(name66, cloneTexturesOnlyOnce = true, rootUrl = "") {
    const result = SerializationHelper.Clone(() => new _StandardMaterial(name66, this.getScene()), this, { cloneTexturesOnlyOnce });
    result.name = name66;
    result.id = name66;
    this.stencil.copyTo(result.stencil);
    this._clonePlugins(result, rootUrl);
    return result;
  }
  /**
   * Creates a standard material from parsed material data
   * @param source defines the JSON representation of the material
   * @param scene defines the hosting scene
   * @param rootUrl defines the root URL to use to load textures and relative dependencies
   * @returns a new standard material
   */
  static Parse(source, scene, rootUrl) {
    const material = SerializationHelper.Parse(() => new _StandardMaterial(source.name, scene), source, scene, rootUrl);
    if (source.stencil) {
      material.stencil.parse(source.stencil, scene, rootUrl);
    }
    Material._ParsePlugins(source, material, scene, rootUrl);
    return material;
  }
  // Flags used to enable or disable a type of texture for all Standard Materials
  /**
   * Are diffuse textures enabled in the application.
   */
  static get DiffuseTextureEnabled() {
    return MaterialFlags.DiffuseTextureEnabled;
  }
  static set DiffuseTextureEnabled(value) {
    MaterialFlags.DiffuseTextureEnabled = value;
  }
  /**
   * Are detail textures enabled in the application.
   */
  static get DetailTextureEnabled() {
    return MaterialFlags.DetailTextureEnabled;
  }
  static set DetailTextureEnabled(value) {
    MaterialFlags.DetailTextureEnabled = value;
  }
  /**
   * Are ambient textures enabled in the application.
   */
  static get AmbientTextureEnabled() {
    return MaterialFlags.AmbientTextureEnabled;
  }
  static set AmbientTextureEnabled(value) {
    MaterialFlags.AmbientTextureEnabled = value;
  }
  /**
   * Are opacity textures enabled in the application.
   */
  static get OpacityTextureEnabled() {
    return MaterialFlags.OpacityTextureEnabled;
  }
  static set OpacityTextureEnabled(value) {
    MaterialFlags.OpacityTextureEnabled = value;
  }
  /**
   * Are reflection textures enabled in the application.
   */
  static get ReflectionTextureEnabled() {
    return MaterialFlags.ReflectionTextureEnabled;
  }
  static set ReflectionTextureEnabled(value) {
    MaterialFlags.ReflectionTextureEnabled = value;
  }
  /**
   * Are emissive textures enabled in the application.
   */
  static get EmissiveTextureEnabled() {
    return MaterialFlags.EmissiveTextureEnabled;
  }
  static set EmissiveTextureEnabled(value) {
    MaterialFlags.EmissiveTextureEnabled = value;
  }
  /**
   * Are specular textures enabled in the application.
   */
  static get SpecularTextureEnabled() {
    return MaterialFlags.SpecularTextureEnabled;
  }
  static set SpecularTextureEnabled(value) {
    MaterialFlags.SpecularTextureEnabled = value;
  }
  /**
   * Are bump textures enabled in the application.
   */
  static get BumpTextureEnabled() {
    return MaterialFlags.BumpTextureEnabled;
  }
  static set BumpTextureEnabled(value) {
    MaterialFlags.BumpTextureEnabled = value;
  }
  /**
   * Are lightmap textures enabled in the application.
   */
  static get LightmapTextureEnabled() {
    return MaterialFlags.LightmapTextureEnabled;
  }
  static set LightmapTextureEnabled(value) {
    MaterialFlags.LightmapTextureEnabled = value;
  }
  /**
   * Are refraction textures enabled in the application.
   */
  static get RefractionTextureEnabled() {
    return MaterialFlags.RefractionTextureEnabled;
  }
  static set RefractionTextureEnabled(value) {
    MaterialFlags.RefractionTextureEnabled = value;
  }
  /**
   * Are color grading textures enabled in the application.
   */
  static get ColorGradingTextureEnabled() {
    return MaterialFlags.ColorGradingTextureEnabled;
  }
  static set ColorGradingTextureEnabled(value) {
    MaterialFlags.ColorGradingTextureEnabled = value;
  }
  /**
   * Are fresnels enabled in the application.
   */
  static get FresnelEnabled() {
    return MaterialFlags.FresnelEnabled;
  }
  static set FresnelEnabled(value) {
    MaterialFlags.FresnelEnabled = value;
  }
};
__decorate([
  serializeAsTexture("diffuseTexture")
], StandardMaterial.prototype, "_diffuseTexture", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsTexturesAndMiscDirty")
], StandardMaterial.prototype, "diffuseTexture", void 0);
__decorate([
  serializeAsTexture("ambientTexture")
], StandardMaterial.prototype, "_ambientTexture", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], StandardMaterial.prototype, "ambientTexture", void 0);
__decorate([
  serializeAsTexture("opacityTexture")
], StandardMaterial.prototype, "_opacityTexture", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsTexturesAndMiscDirty")
], StandardMaterial.prototype, "opacityTexture", void 0);
__decorate([
  serializeAsTexture("reflectionTexture")
], StandardMaterial.prototype, "_reflectionTexture", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], StandardMaterial.prototype, "reflectionTexture", void 0);
__decorate([
  serializeAsTexture("emissiveTexture")
], StandardMaterial.prototype, "_emissiveTexture", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], StandardMaterial.prototype, "emissiveTexture", void 0);
__decorate([
  serializeAsTexture("specularTexture")
], StandardMaterial.prototype, "_specularTexture", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], StandardMaterial.prototype, "specularTexture", void 0);
__decorate([
  serializeAsTexture("bumpTexture")
], StandardMaterial.prototype, "_bumpTexture", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], StandardMaterial.prototype, "bumpTexture", void 0);
__decorate([
  serializeAsTexture("lightmapTexture")
], StandardMaterial.prototype, "_lightmapTexture", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], StandardMaterial.prototype, "lightmapTexture", void 0);
__decorate([
  serializeAsTexture("refractionTexture")
], StandardMaterial.prototype, "_refractionTexture", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], StandardMaterial.prototype, "refractionTexture", void 0);
__decorate([
  serializeAsColor3("ambient")
], StandardMaterial.prototype, "ambientColor", void 0);
__decorate([
  serializeAsColor3("diffuse")
], StandardMaterial.prototype, "diffuseColor", void 0);
__decorate([
  serializeAsColor3("specular")
], StandardMaterial.prototype, "specularColor", void 0);
__decorate([
  serializeAsColor3("emissive")
], StandardMaterial.prototype, "emissiveColor", void 0);
__decorate([
  serialize()
], StandardMaterial.prototype, "specularPower", void 0);
__decorate([
  serialize("useAlphaFromDiffuseTexture")
], StandardMaterial.prototype, "_useAlphaFromDiffuseTexture", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsTexturesAndMiscDirty")
], StandardMaterial.prototype, "useAlphaFromDiffuseTexture", void 0);
__decorate([
  serialize("useEmissiveAsIllumination")
], StandardMaterial.prototype, "_useEmissiveAsIllumination", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], StandardMaterial.prototype, "useEmissiveAsIllumination", void 0);
__decorate([
  serialize("linkEmissiveWithDiffuse")
], StandardMaterial.prototype, "_linkEmissiveWithDiffuse", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], StandardMaterial.prototype, "linkEmissiveWithDiffuse", void 0);
__decorate([
  serialize("useSpecularOverAlpha")
], StandardMaterial.prototype, "_useSpecularOverAlpha", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], StandardMaterial.prototype, "useSpecularOverAlpha", void 0);
__decorate([
  serialize("useReflectionOverAlpha")
], StandardMaterial.prototype, "_useReflectionOverAlpha", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], StandardMaterial.prototype, "useReflectionOverAlpha", void 0);
__decorate([
  serialize("disableLighting")
], StandardMaterial.prototype, "_disableLighting", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsLightsDirty")
], StandardMaterial.prototype, "disableLighting", void 0);
__decorate([
  serialize("useObjectSpaceNormalMap")
], StandardMaterial.prototype, "_useObjectSpaceNormalMap", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], StandardMaterial.prototype, "useObjectSpaceNormalMap", void 0);
__decorate([
  serialize("useParallax")
], StandardMaterial.prototype, "_useParallax", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], StandardMaterial.prototype, "useParallax", void 0);
__decorate([
  serialize("useParallaxOcclusion")
], StandardMaterial.prototype, "_useParallaxOcclusion", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], StandardMaterial.prototype, "useParallaxOcclusion", void 0);
__decorate([
  serialize()
], StandardMaterial.prototype, "parallaxScaleBias", void 0);
__decorate([
  serialize("roughness")
], StandardMaterial.prototype, "_roughness", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], StandardMaterial.prototype, "roughness", void 0);
__decorate([
  serialize()
], StandardMaterial.prototype, "indexOfRefraction", void 0);
__decorate([
  serialize()
], StandardMaterial.prototype, "invertRefractionY", void 0);
__decorate([
  serialize()
], StandardMaterial.prototype, "alphaCutOff", void 0);
__decorate([
  serialize("useLightmapAsShadowmap")
], StandardMaterial.prototype, "_useLightmapAsShadowmap", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], StandardMaterial.prototype, "useLightmapAsShadowmap", void 0);
__decorate([
  serializeAsFresnelParameters("diffuseFresnelParameters")
], StandardMaterial.prototype, "_diffuseFresnelParameters", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsFresnelDirty")
], StandardMaterial.prototype, "diffuseFresnelParameters", void 0);
__decorate([
  serializeAsFresnelParameters("opacityFresnelParameters")
], StandardMaterial.prototype, "_opacityFresnelParameters", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsFresnelAndMiscDirty")
], StandardMaterial.prototype, "opacityFresnelParameters", void 0);
__decorate([
  serializeAsFresnelParameters("reflectionFresnelParameters")
], StandardMaterial.prototype, "_reflectionFresnelParameters", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsFresnelDirty")
], StandardMaterial.prototype, "reflectionFresnelParameters", void 0);
__decorate([
  serializeAsFresnelParameters("refractionFresnelParameters")
], StandardMaterial.prototype, "_refractionFresnelParameters", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsFresnelDirty")
], StandardMaterial.prototype, "refractionFresnelParameters", void 0);
__decorate([
  serializeAsFresnelParameters("emissiveFresnelParameters")
], StandardMaterial.prototype, "_emissiveFresnelParameters", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsFresnelDirty")
], StandardMaterial.prototype, "emissiveFresnelParameters", void 0);
__decorate([
  serialize("useReflectionFresnelFromSpecular")
], StandardMaterial.prototype, "_useReflectionFresnelFromSpecular", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsFresnelDirty")
], StandardMaterial.prototype, "useReflectionFresnelFromSpecular", void 0);
__decorate([
  serialize("useGlossinessFromSpecularMapAlpha")
], StandardMaterial.prototype, "_useGlossinessFromSpecularMapAlpha", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], StandardMaterial.prototype, "useGlossinessFromSpecularMapAlpha", void 0);
__decorate([
  serialize("maxSimultaneousLights")
], StandardMaterial.prototype, "_maxSimultaneousLights", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsLightsDirty")
], StandardMaterial.prototype, "maxSimultaneousLights", void 0);
__decorate([
  serialize("invertNormalMapX")
], StandardMaterial.prototype, "_invertNormalMapX", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], StandardMaterial.prototype, "invertNormalMapX", void 0);
__decorate([
  serialize("invertNormalMapY")
], StandardMaterial.prototype, "_invertNormalMapY", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], StandardMaterial.prototype, "invertNormalMapY", void 0);
__decorate([
  serialize("twoSidedLighting")
], StandardMaterial.prototype, "_twoSidedLighting", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], StandardMaterial.prototype, "twoSidedLighting", void 0);
__decorate([
  serialize("applyDecalMapAfterDetailMap")
], StandardMaterial.prototype, "_applyDecalMapAfterDetailMap", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsMiscDirty")
], StandardMaterial.prototype, "applyDecalMapAfterDetailMap", void 0);
RegisterClass("BABYLON.StandardMaterial", StandardMaterial);
Scene.DefaultMaterialFactory = (scene) => {
  return new StandardMaterial("default material", scene);
};

// ../../node_modules/@babylonjs/core/Materials/shaderMaterial.js
var onCreatedEffectParameters2 = { effect: null, subMesh: null };
var ShaderMaterial = class _ShaderMaterial extends PushMaterial {
  /**
   * Instantiate a new shader material.
   * The ShaderMaterial object has the necessary methods to pass data from your scene to the Vertex and Fragment Shaders and returns a material that can be applied to any mesh.
   * This returned material effects how the mesh will look based on the code in the shaders.
   * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/shaders/shaderMaterial
   * @param name Define the name of the material in the scene
   * @param scene Define the scene the material belongs to
   * @param shaderPath Defines  the route to the shader code in one of three ways:
   *  * object: \{ vertex: "custom", fragment: "custom" \}, used with Effect.ShadersStore["customVertexShader"] and Effect.ShadersStore["customFragmentShader"]
   *  * object: \{ vertexElement: "vertexShaderCode", fragmentElement: "fragmentShaderCode" \}, used with shader code in script tags
   *  * object: \{ vertexSource: "vertex shader code string", fragmentSource: "fragment shader code string" \} using with strings containing the shaders code
   *  * string: "./COMMON_NAME", used with external files COMMON_NAME.vertex.fx and COMMON_NAME.fragment.fx in index.html folder.
   * @param options Define the options used to create the shader
   * @param storeEffectOnSubMeshes true to store effect on submeshes, false to store the effect directly in the material class.
   */
  constructor(name66, scene, shaderPath, options = {}, storeEffectOnSubMeshes = true) {
    super(name66, scene, storeEffectOnSubMeshes);
    this._textures = {};
    this._textureArrays = {};
    this._externalTextures = {};
    this._floats = {};
    this._ints = {};
    this._uints = {};
    this._floatsArrays = {};
    this._colors3 = {};
    this._colors3Arrays = {};
    this._colors4 = {};
    this._colors4Arrays = {};
    this._vectors2 = {};
    this._vectors3 = {};
    this._vectors4 = {};
    this._quaternions = {};
    this._quaternionsArrays = {};
    this._matrices = {};
    this._matrixArrays = {};
    this._matrices3x3 = {};
    this._matrices2x2 = {};
    this._vectors2Arrays = {};
    this._vectors3Arrays = {};
    this._vectors4Arrays = {};
    this._uniformBuffers = {};
    this._textureSamplers = {};
    this._storageBuffers = {};
    this._cachedWorldViewMatrix = new Matrix();
    this._cachedWorldViewProjectionMatrix = new Matrix();
    this._multiview = false;
    this._materialHelperNeedsPreviousMatrices = false;
    this._shaderPath = shaderPath;
    this._options = {
      needAlphaBlending: false,
      needAlphaTesting: false,
      attributes: ["position", "normal", "uv"],
      uniforms: ["worldViewProjection"],
      uniformBuffers: [],
      samplers: [],
      externalTextures: [],
      samplerObjects: [],
      storageBuffers: [],
      defines: [],
      useClipPlane: false,
      ...options
    };
  }
  /**
   * Gets the shader path used to define the shader code
   * It can be modified to trigger a new compilation
   */
  get shaderPath() {
    return this._shaderPath;
  }
  /**
   * Sets the shader path used to define the shader code
   * It can be modified to trigger a new compilation
   */
  set shaderPath(shaderPath) {
    this._shaderPath = shaderPath;
  }
  /**
   * Gets the options used to compile the shader.
   * They can be modified to trigger a new compilation
   */
  get options() {
    return this._options;
  }
  /**
   * is multiview set to true?
   */
  get isMultiview() {
    return this._multiview;
  }
  /**
   * Gets the current class name of the material e.g. "ShaderMaterial"
   * Mainly use in serialization.
   * @returns the class name
   */
  getClassName() {
    return "ShaderMaterial";
  }
  /**
   * Specifies if the material will require alpha blending
   * @returns a boolean specifying if alpha blending is needed
   */
  needAlphaBlending() {
    return this.alpha < 1 || this._options.needAlphaBlending;
  }
  /**
   * Specifies if this material should be rendered in alpha test mode
   * @returns a boolean specifying if an alpha test is needed.
   */
  needAlphaTesting() {
    return this._options.needAlphaTesting;
  }
  _checkUniform(uniformName) {
    if (this._options.uniforms.indexOf(uniformName) === -1) {
      this._options.uniforms.push(uniformName);
    }
  }
  /**
   * Set a texture in the shader.
   * @param name Define the name of the uniform samplers as defined in the shader
   * @param texture Define the texture to bind to this sampler
   * @returns the material itself allowing "fluent" like uniform updates
   */
  setTexture(name66, texture) {
    if (this._options.samplers.indexOf(name66) === -1) {
      this._options.samplers.push(name66);
    }
    this._textures[name66] = texture;
    return this;
  }
  /**
   * Set a texture array in the shader.
   * @param name Define the name of the uniform sampler array as defined in the shader
   * @param textures Define the list of textures to bind to this sampler
   * @returns the material itself allowing "fluent" like uniform updates
   */
  setTextureArray(name66, textures) {
    if (this._options.samplers.indexOf(name66) === -1) {
      this._options.samplers.push(name66);
    }
    this._checkUniform(name66);
    this._textureArrays[name66] = textures;
    return this;
  }
  /**
   * Set an internal texture in the shader.
   * @param name Define the name of the uniform samplers as defined in the shader
   * @param texture Define the texture to bind to this sampler
   * @returns the material itself allowing "fluent" like uniform updates
   */
  setExternalTexture(name66, texture) {
    if (this._options.externalTextures.indexOf(name66) === -1) {
      this._options.externalTextures.push(name66);
    }
    this._externalTextures[name66] = texture;
    return this;
  }
  /**
   * Set a float in the shader.
   * @param name Define the name of the uniform as defined in the shader
   * @param value Define the value to give to the uniform
   * @returns the material itself allowing "fluent" like uniform updates
   */
  setFloat(name66, value) {
    this._checkUniform(name66);
    this._floats[name66] = value;
    return this;
  }
  /**
   * Set a int in the shader.
   * @param name Define the name of the uniform as defined in the shader
   * @param value Define the value to give to the uniform
   * @returns the material itself allowing "fluent" like uniform updates
   */
  setInt(name66, value) {
    this._checkUniform(name66);
    this._ints[name66] = value;
    return this;
  }
  /**
   * Set a unsigned int in the shader.
   * @param name Define the name of the uniform as defined in the shader
   * @param value Define the value to give to the uniform
   * @returns the material itself allowing "fluent" like uniform updates
   */
  setUInt(name66, value) {
    this._checkUniform(name66);
    this._uints[name66] = value;
    return this;
  }
  /**
   * Set an array of floats in the shader.
   * @param name Define the name of the uniform as defined in the shader
   * @param value Define the value to give to the uniform
   * @returns the material itself allowing "fluent" like uniform updates
   */
  setFloats(name66, value) {
    this._checkUniform(name66);
    this._floatsArrays[name66] = value;
    return this;
  }
  /**
   * Set a vec3 in the shader from a Color3.
   * @param name Define the name of the uniform as defined in the shader
   * @param value Define the value to give to the uniform
   * @returns the material itself allowing "fluent" like uniform updates
   */
  setColor3(name66, value) {
    this._checkUniform(name66);
    this._colors3[name66] = value;
    return this;
  }
  /**
   * Set a vec3 array in the shader from a Color3 array.
   * @param name Define the name of the uniform as defined in the shader
   * @param value Define the value to give to the uniform
   * @returns the material itself allowing "fluent" like uniform updates
   */
  setColor3Array(name66, value) {
    this._checkUniform(name66);
    this._colors3Arrays[name66] = value.reduce((arr, color) => {
      color.toArray(arr, arr.length);
      return arr;
    }, []);
    return this;
  }
  /**
   * Set a vec4 in the shader from a Color4.
   * @param name Define the name of the uniform as defined in the shader
   * @param value Define the value to give to the uniform
   * @returns the material itself allowing "fluent" like uniform updates
   */
  setColor4(name66, value) {
    this._checkUniform(name66);
    this._colors4[name66] = value;
    return this;
  }
  /**
   * Set a vec4 array in the shader from a Color4 array.
   * @param name Define the name of the uniform as defined in the shader
   * @param value Define the value to give to the uniform
   * @returns the material itself allowing "fluent" like uniform updates
   */
  setColor4Array(name66, value) {
    this._checkUniform(name66);
    this._colors4Arrays[name66] = value.reduce((arr, color) => {
      color.toArray(arr, arr.length);
      return arr;
    }, []);
    return this;
  }
  /**
   * Set a vec2 in the shader from a Vector2.
   * @param name Define the name of the uniform as defined in the shader
   * @param value Define the value to give to the uniform
   * @returns the material itself allowing "fluent" like uniform updates
   */
  setVector2(name66, value) {
    this._checkUniform(name66);
    this._vectors2[name66] = value;
    return this;
  }
  /**
   * Set a vec3 in the shader from a Vector3.
   * @param name Define the name of the uniform as defined in the shader
   * @param value Define the value to give to the uniform
   * @returns the material itself allowing "fluent" like uniform updates
   */
  setVector3(name66, value) {
    this._checkUniform(name66);
    this._vectors3[name66] = value;
    return this;
  }
  /**
   * Set a vec4 in the shader from a Vector4.
   * @param name Define the name of the uniform as defined in the shader
   * @param value Define the value to give to the uniform
   * @returns the material itself allowing "fluent" like uniform updates
   */
  setVector4(name66, value) {
    this._checkUniform(name66);
    this._vectors4[name66] = value;
    return this;
  }
  /**
   * Set a vec4 in the shader from a Quaternion.
   * @param name Define the name of the uniform as defined in the shader
   * @param value Define the value to give to the uniform
   * @returns the material itself allowing "fluent" like uniform updates
   */
  setQuaternion(name66, value) {
    this._checkUniform(name66);
    this._quaternions[name66] = value;
    return this;
  }
  /**
   * Set a vec4 array in the shader from a Quaternion array.
   * @param name Define the name of the uniform as defined in the shader
   * @param value Define the value to give to the uniform
   * @returns the material itself allowing "fluent" like uniform updates
   */
  setQuaternionArray(name66, value) {
    this._checkUniform(name66);
    this._quaternionsArrays[name66] = value.reduce((arr, quaternion) => {
      quaternion.toArray(arr, arr.length);
      return arr;
    }, []);
    return this;
  }
  /**
   * Set a mat4 in the shader from a Matrix.
   * @param name Define the name of the uniform as defined in the shader
   * @param value Define the value to give to the uniform
   * @returns the material itself allowing "fluent" like uniform updates
   */
  setMatrix(name66, value) {
    this._checkUniform(name66);
    this._matrices[name66] = value;
    return this;
  }
  /**
   * Set a float32Array in the shader from a matrix array.
   * @param name Define the name of the uniform as defined in the shader
   * @param value Define the value to give to the uniform
   * @returns the material itself allowing "fluent" like uniform updates
   */
  setMatrices(name66, value) {
    this._checkUniform(name66);
    const float32Array = new Float32Array(value.length * 16);
    for (let index = 0; index < value.length; index++) {
      const matrix = value[index];
      matrix.copyToArray(float32Array, index * 16);
    }
    this._matrixArrays[name66] = float32Array;
    return this;
  }
  /**
   * Set a mat3 in the shader from a Float32Array.
   * @param name Define the name of the uniform as defined in the shader
   * @param value Define the value to give to the uniform
   * @returns the material itself allowing "fluent" like uniform updates
   */
  setMatrix3x3(name66, value) {
    this._checkUniform(name66);
    this._matrices3x3[name66] = value;
    return this;
  }
  /**
   * Set a mat2 in the shader from a Float32Array.
   * @param name Define the name of the uniform as defined in the shader
   * @param value Define the value to give to the uniform
   * @returns the material itself allowing "fluent" like uniform updates
   */
  setMatrix2x2(name66, value) {
    this._checkUniform(name66);
    this._matrices2x2[name66] = value;
    return this;
  }
  /**
   * Set a vec2 array in the shader from a number array.
   * @param name Define the name of the uniform as defined in the shader
   * @param value Define the value to give to the uniform
   * @returns the material itself allowing "fluent" like uniform updates
   */
  setArray2(name66, value) {
    this._checkUniform(name66);
    this._vectors2Arrays[name66] = value;
    return this;
  }
  /**
   * Set a vec3 array in the shader from a number array.
   * @param name Define the name of the uniform as defined in the shader
   * @param value Define the value to give to the uniform
   * @returns the material itself allowing "fluent" like uniform updates
   */
  setArray3(name66, value) {
    this._checkUniform(name66);
    this._vectors3Arrays[name66] = value;
    return this;
  }
  /**
   * Set a vec4 array in the shader from a number array.
   * @param name Define the name of the uniform as defined in the shader
   * @param value Define the value to give to the uniform
   * @returns the material itself allowing "fluent" like uniform updates
   */
  setArray4(name66, value) {
    this._checkUniform(name66);
    this._vectors4Arrays[name66] = value;
    return this;
  }
  /**
   * Set a uniform buffer in the shader
   * @param name Define the name of the uniform as defined in the shader
   * @param buffer Define the value to give to the uniform
   * @returns the material itself allowing "fluent" like uniform updates
   */
  setUniformBuffer(name66, buffer) {
    if (this._options.uniformBuffers.indexOf(name66) === -1) {
      this._options.uniformBuffers.push(name66);
    }
    this._uniformBuffers[name66] = buffer;
    return this;
  }
  /**
   * Set a texture sampler in the shader
   * @param name Define the name of the uniform as defined in the shader
   * @param sampler Define the value to give to the uniform
   * @returns the material itself allowing "fluent" like uniform updates
   */
  setTextureSampler(name66, sampler) {
    if (this._options.samplerObjects.indexOf(name66) === -1) {
      this._options.samplerObjects.push(name66);
    }
    this._textureSamplers[name66] = sampler;
    return this;
  }
  /**
   * Set a storage buffer in the shader
   * @param name Define the name of the storage buffer as defined in the shader
   * @param buffer Define the value to give to the uniform
   * @returns the material itself allowing "fluent" like uniform updates
   */
  setStorageBuffer(name66, buffer) {
    if (this._options.storageBuffers.indexOf(name66) === -1) {
      this._options.storageBuffers.push(name66);
    }
    this._storageBuffers[name66] = buffer;
    return this;
  }
  /**
   * Adds, removes, or replaces the specified shader define and value.
   * * setDefine("MY_DEFINE", true); // enables a boolean define
   * * setDefine("MY_DEFINE", "0.5"); // adds "#define MY_DEFINE 0.5" to the shader (or sets and replaces the value of any existing define with that name)
   * * setDefine("MY_DEFINE", false); // disables and removes the define
   * Note if the active defines do change, the shader will be recompiled and this can be expensive.
   * @param define the define name e.g., "OUTPUT_TO_SRGB" or "#define OUTPUT_TO_SRGB". If the define was passed into the constructor already, the version used should match that, and in either case, it should not include any appended value.
   * @param value either the value of the define (e.g. a numerical value) or for booleans, true if the define should be enabled or false if it should be disabled
   * @returns the material itself allowing "fluent" like uniform updates
   */
  setDefine(define, value) {
    const defineName = define.trimEnd() + " ";
    const existingDefineIdx = this.options.defines.findIndex((x) => x === define || x.startsWith(defineName));
    if (existingDefineIdx >= 0) {
      this.options.defines.splice(existingDefineIdx, 1);
    }
    if (typeof value !== "boolean" || value) {
      this.options.defines.push(defineName + value);
    }
    return this;
  }
  /**
   * Specifies that the submesh is ready to be used
   * @param mesh defines the mesh to check
   * @param subMesh defines which submesh to check
   * @param useInstances specifies that instances should be used
   * @returns a boolean indicating that the submesh is ready or not
   */
  isReadyForSubMesh(mesh, subMesh, useInstances) {
    return this.isReady(mesh, useInstances, subMesh);
  }
  /**
   * Checks if the material is ready to render the requested mesh
   * @param mesh Define the mesh to render
   * @param useInstances Define whether or not the material is used with instances
   * @param subMesh defines which submesh to render
   * @returns true if ready, otherwise false
   */
  isReady(mesh, useInstances, subMesh) {
    const storeEffectOnSubMeshes = subMesh && this._storeEffectOnSubMeshes;
    if (this.isFrozen) {
      const drawWrapper2 = storeEffectOnSubMeshes ? subMesh._drawWrapper : this._drawWrapper;
      if (drawWrapper2.effect && drawWrapper2._wasPreviouslyReady && drawWrapper2._wasPreviouslyUsingInstances === useInstances) {
        return true;
      }
    }
    const scene = this.getScene();
    const engine = scene.getEngine();
    const defines = [];
    const attribs = [];
    const fallbacks = new EffectFallbacks();
    let shaderName = this._shaderPath, uniforms = this._options.uniforms, uniformBuffers = this._options.uniformBuffers, samplers = this._options.samplers;
    if (engine.getCaps().multiview && scene.activeCamera && scene.activeCamera.outputRenderTarget && scene.activeCamera.outputRenderTarget.getViewCount() > 1) {
      this._multiview = true;
      defines.push("#define MULTIVIEW");
      if (uniforms.indexOf("viewProjection") !== -1 && uniforms.indexOf("viewProjectionR") === -1) {
        uniforms.push("viewProjectionR");
      }
    }
    for (let index = 0; index < this._options.defines.length; index++) {
      const defineToAdd = this._options.defines[index].indexOf("#define") === 0 ? this._options.defines[index] : `#define ${this._options.defines[index]}`;
      defines.push(defineToAdd);
    }
    for (let index = 0; index < this._options.attributes.length; index++) {
      attribs.push(this._options.attributes[index]);
    }
    if (mesh && mesh.isVerticesDataPresent(VertexBuffer.ColorKind)) {
      if (attribs.indexOf(VertexBuffer.ColorKind) === -1) {
        attribs.push(VertexBuffer.ColorKind);
      }
      defines.push("#define VERTEXCOLOR");
    }
    if (useInstances) {
      defines.push("#define INSTANCES");
      PushAttributesForInstances(attribs, this._materialHelperNeedsPreviousMatrices);
      if (mesh?.hasThinInstances) {
        defines.push("#define THIN_INSTANCES");
        if (mesh && mesh.isVerticesDataPresent(VertexBuffer.ColorInstanceKind)) {
          attribs.push(VertexBuffer.ColorInstanceKind);
          defines.push("#define INSTANCESCOLOR");
        }
      }
    }
    if (mesh && mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton) {
      attribs.push(VertexBuffer.MatricesIndicesKind);
      attribs.push(VertexBuffer.MatricesWeightsKind);
      if (mesh.numBoneInfluencers > 4) {
        attribs.push(VertexBuffer.MatricesIndicesExtraKind);
        attribs.push(VertexBuffer.MatricesWeightsExtraKind);
      }
      const skeleton = mesh.skeleton;
      defines.push("#define NUM_BONE_INFLUENCERS " + mesh.numBoneInfluencers);
      fallbacks.addCPUSkinningFallback(0, mesh);
      if (skeleton.isUsingTextureForMatrices) {
        defines.push("#define BONETEXTURE");
        if (uniforms.indexOf("boneTextureWidth") === -1) {
          uniforms.push("boneTextureWidth");
        }
        if (this._options.samplers.indexOf("boneSampler") === -1) {
          this._options.samplers.push("boneSampler");
        }
      } else {
        defines.push("#define BonesPerMesh " + (skeleton.bones.length + 1));
        if (uniforms.indexOf("mBones") === -1) {
          uniforms.push("mBones");
        }
      }
    } else {
      defines.push("#define NUM_BONE_INFLUENCERS 0");
    }
    let numInfluencers = 0;
    const manager = mesh ? mesh.morphTargetManager : null;
    if (manager) {
      const uv = manager.supportsUVs && defines.indexOf("#define UV1") !== -1;
      const tangent = manager.supportsTangents && defines.indexOf("#define TANGENT") !== -1;
      const normal = manager.supportsNormals && defines.indexOf("#define NORMAL") !== -1;
      numInfluencers = manager.numMaxInfluencers || manager.numInfluencers;
      if (uv) {
        defines.push("#define MORPHTARGETS_UV");
      }
      if (tangent) {
        defines.push("#define MORPHTARGETS_TANGENT");
      }
      if (normal) {
        defines.push("#define MORPHTARGETS_NORMAL");
      }
      if (numInfluencers > 0) {
        defines.push("#define MORPHTARGETS");
      }
      if (manager.isUsingTextureForTargets) {
        defines.push("#define MORPHTARGETS_TEXTURE");
        if (uniforms.indexOf("morphTargetTextureIndices") === -1) {
          uniforms.push("morphTargetTextureIndices");
        }
        if (this._options.samplers.indexOf("morphTargets") === -1) {
          this._options.samplers.push("morphTargets");
        }
      }
      defines.push("#define NUM_MORPH_INFLUENCERS " + numInfluencers);
      for (let index = 0; index < numInfluencers; index++) {
        attribs.push(VertexBuffer.PositionKind + index);
        if (normal) {
          attribs.push(VertexBuffer.NormalKind + index);
        }
        if (tangent) {
          attribs.push(VertexBuffer.TangentKind + index);
        }
        if (uv) {
          attribs.push(VertexBuffer.UVKind + "_" + index);
        }
      }
      if (numInfluencers > 0) {
        uniforms = uniforms.slice();
        uniforms.push("morphTargetInfluences");
        uniforms.push("morphTargetCount");
        uniforms.push("morphTargetTextureInfo");
        uniforms.push("morphTargetTextureIndices");
      }
    } else {
      defines.push("#define NUM_MORPH_INFLUENCERS 0");
    }
    if (mesh) {
      const bvaManager = mesh.bakedVertexAnimationManager;
      if (bvaManager && bvaManager.isEnabled) {
        defines.push("#define BAKED_VERTEX_ANIMATION_TEXTURE");
        if (uniforms.indexOf("bakedVertexAnimationSettings") === -1) {
          uniforms.push("bakedVertexAnimationSettings");
        }
        if (uniforms.indexOf("bakedVertexAnimationTextureSizeInverted") === -1) {
          uniforms.push("bakedVertexAnimationTextureSizeInverted");
        }
        if (uniforms.indexOf("bakedVertexAnimationTime") === -1) {
          uniforms.push("bakedVertexAnimationTime");
        }
        if (this._options.samplers.indexOf("bakedVertexAnimationTexture") === -1) {
          this._options.samplers.push("bakedVertexAnimationTexture");
        }
      }
      PrepareAttributesForBakedVertexAnimation(attribs, mesh, defines);
    }
    for (const name66 in this._textures) {
      if (!this._textures[name66].isReady()) {
        return false;
      }
    }
    if (mesh && this._shouldTurnAlphaTestOn(mesh)) {
      defines.push("#define ALPHATEST");
    }
    if (this._options.useClipPlane !== false) {
      addClipPlaneUniforms(uniforms);
      prepareStringDefinesForClipPlanes(this, scene, defines);
    }
    if (scene.fogEnabled && mesh?.applyFog && scene.fogMode !== Scene.FOGMODE_NONE) {
      defines.push("#define FOG");
      if (uniforms.indexOf("view") === -1) {
        uniforms.push("view");
      }
      if (uniforms.indexOf("vFogInfos") === -1) {
        uniforms.push("vFogInfos");
      }
      if (uniforms.indexOf("vFogColor") === -1) {
        uniforms.push("vFogColor");
      }
    }
    if (this._useLogarithmicDepth) {
      defines.push("#define LOGARITHMICDEPTH");
      if (uniforms.indexOf("logarithmicDepthConstant") === -1) {
        uniforms.push("logarithmicDepthConstant");
      }
    }
    if (this.customShaderNameResolve) {
      uniforms = uniforms.slice();
      uniformBuffers = uniformBuffers.slice();
      samplers = samplers.slice();
      shaderName = this.customShaderNameResolve(shaderName, uniforms, uniformBuffers, samplers, defines, attribs);
    }
    const drawWrapper = storeEffectOnSubMeshes ? subMesh._getDrawWrapper(void 0, true) : this._drawWrapper;
    const previousEffect = drawWrapper?.effect ?? null;
    const previousDefines = drawWrapper?.defines ?? null;
    const join = defines.join("\n");
    let effect = previousEffect;
    if (previousDefines !== join) {
      effect = engine.createEffect(shaderName, {
        attributes: attribs,
        uniformsNames: uniforms,
        uniformBuffersNames: uniformBuffers,
        samplers,
        defines: join,
        fallbacks,
        onCompiled: this.onCompiled,
        onError: this.onError,
        indexParameters: { maxSimultaneousMorphTargets: numInfluencers },
        shaderLanguage: this._options.shaderLanguage
      }, engine);
      if (storeEffectOnSubMeshes) {
        subMesh.setEffect(effect, join, this._materialContext);
      } else if (drawWrapper) {
        drawWrapper.setEffect(effect, join);
      }
      if (this._onEffectCreatedObservable) {
        onCreatedEffectParameters2.effect = effect;
        onCreatedEffectParameters2.subMesh = subMesh ?? mesh?.subMeshes[0] ?? null;
        this._onEffectCreatedObservable.notifyObservers(onCreatedEffectParameters2);
      }
    }
    drawWrapper._wasPreviouslyUsingInstances = !!useInstances;
    if (!effect?.isReady()) {
      return false;
    }
    if (previousEffect !== effect) {
      scene.resetCachedMaterial();
    }
    drawWrapper._wasPreviouslyReady = true;
    return true;
  }
  /**
   * Binds the world matrix to the material
   * @param world defines the world transformation matrix
   * @param effectOverride - If provided, use this effect instead of internal effect
   */
  bindOnlyWorldMatrix(world, effectOverride) {
    const scene = this.getScene();
    const effect = effectOverride ?? this.getEffect();
    if (!effect) {
      return;
    }
    if (this._options.uniforms.indexOf("world") !== -1) {
      effect.setMatrix("world", world);
    }
    if (this._options.uniforms.indexOf("worldView") !== -1) {
      world.multiplyToRef(scene.getViewMatrix(), this._cachedWorldViewMatrix);
      effect.setMatrix("worldView", this._cachedWorldViewMatrix);
    }
    if (this._options.uniforms.indexOf("worldViewProjection") !== -1) {
      world.multiplyToRef(scene.getTransformMatrix(), this._cachedWorldViewProjectionMatrix);
      effect.setMatrix("worldViewProjection", this._cachedWorldViewProjectionMatrix);
    }
    if (this._options.uniforms.indexOf("view") !== -1) {
      effect.setMatrix("view", scene.getViewMatrix());
    }
  }
  /**
   * Binds the submesh to this material by preparing the effect and shader to draw
   * @param world defines the world transformation matrix
   * @param mesh defines the mesh containing the submesh
   * @param subMesh defines the submesh to bind the material to
   */
  bindForSubMesh(world, mesh, subMesh) {
    this.bind(world, mesh, subMesh._drawWrapperOverride?.effect, subMesh);
  }
  /**
   * Binds the material to the mesh
   * @param world defines the world transformation matrix
   * @param mesh defines the mesh to bind the material to
   * @param effectOverride - If provided, use this effect instead of internal effect
   * @param subMesh defines the submesh to bind the material to
   */
  bind(world, mesh, effectOverride, subMesh) {
    const storeEffectOnSubMeshes = subMesh && this._storeEffectOnSubMeshes;
    const effect = effectOverride ?? (storeEffectOnSubMeshes ? subMesh.effect : this.getEffect());
    if (!effect) {
      return;
    }
    const scene = this.getScene();
    this._activeEffect = effect;
    this.bindOnlyWorldMatrix(world, effectOverride);
    const uniformBuffers = this._options.uniformBuffers;
    let useSceneUBO = false;
    if (effect && uniformBuffers && uniformBuffers.length > 0 && scene.getEngine().supportsUniformBuffers) {
      for (let i = 0; i < uniformBuffers.length; ++i) {
        const bufferName = uniformBuffers[i];
        switch (bufferName) {
          case "Mesh":
            if (mesh) {
              mesh.getMeshUniformBuffer().bindToEffect(effect, "Mesh");
              mesh.transferToEffect(world);
            }
            break;
          case "Scene":
            BindSceneUniformBuffer(effect, scene.getSceneUniformBuffer());
            scene.finalizeSceneUbo();
            useSceneUBO = true;
            break;
        }
      }
    }
    const mustRebind = mesh && storeEffectOnSubMeshes ? this._mustRebind(scene, effect, subMesh, mesh.visibility) : scene.getCachedMaterial() !== this;
    if (effect && mustRebind) {
      if (!useSceneUBO && this._options.uniforms.indexOf("view") !== -1) {
        effect.setMatrix("view", scene.getViewMatrix());
      }
      if (!useSceneUBO && this._options.uniforms.indexOf("projection") !== -1) {
        effect.setMatrix("projection", scene.getProjectionMatrix());
      }
      if (!useSceneUBO && this._options.uniforms.indexOf("viewProjection") !== -1) {
        effect.setMatrix("viewProjection", scene.getTransformMatrix());
        if (this._multiview) {
          effect.setMatrix("viewProjectionR", scene._transformMatrixR);
        }
      }
      if (scene.activeCamera && this._options.uniforms.indexOf("cameraPosition") !== -1) {
        effect.setVector3("cameraPosition", scene.activeCamera.globalPosition);
      }
      BindBonesParameters(mesh, effect);
      bindClipPlane(effect, this, scene);
      if (this._useLogarithmicDepth) {
        BindLogDepth(storeEffectOnSubMeshes ? subMesh.materialDefines : effect.defines, effect, scene);
      }
      if (mesh) {
        BindFogParameters(scene, mesh, effect);
      }
      let name66;
      for (name66 in this._textures) {
        effect.setTexture(name66, this._textures[name66]);
      }
      for (name66 in this._textureArrays) {
        effect.setTextureArray(name66, this._textureArrays[name66]);
      }
      for (name66 in this._externalTextures) {
        effect.setExternalTexture(name66, this._externalTextures[name66]);
      }
      for (name66 in this._ints) {
        effect.setInt(name66, this._ints[name66]);
      }
      for (name66 in this._uints) {
        effect.setUInt(name66, this._uints[name66]);
      }
      for (name66 in this._floats) {
        effect.setFloat(name66, this._floats[name66]);
      }
      for (name66 in this._floatsArrays) {
        effect.setArray(name66, this._floatsArrays[name66]);
      }
      for (name66 in this._colors3) {
        effect.setColor3(name66, this._colors3[name66]);
      }
      for (name66 in this._colors3Arrays) {
        effect.setArray3(name66, this._colors3Arrays[name66]);
      }
      for (name66 in this._colors4) {
        const color = this._colors4[name66];
        effect.setFloat4(name66, color.r, color.g, color.b, color.a);
      }
      for (name66 in this._colors4Arrays) {
        effect.setArray4(name66, this._colors4Arrays[name66]);
      }
      for (name66 in this._vectors2) {
        effect.setVector2(name66, this._vectors2[name66]);
      }
      for (name66 in this._vectors3) {
        effect.setVector3(name66, this._vectors3[name66]);
      }
      for (name66 in this._vectors4) {
        effect.setVector4(name66, this._vectors4[name66]);
      }
      for (name66 in this._quaternions) {
        effect.setQuaternion(name66, this._quaternions[name66]);
      }
      for (name66 in this._matrices) {
        effect.setMatrix(name66, this._matrices[name66]);
      }
      for (name66 in this._matrixArrays) {
        effect.setMatrices(name66, this._matrixArrays[name66]);
      }
      for (name66 in this._matrices3x3) {
        effect.setMatrix3x3(name66, this._matrices3x3[name66]);
      }
      for (name66 in this._matrices2x2) {
        effect.setMatrix2x2(name66, this._matrices2x2[name66]);
      }
      for (name66 in this._vectors2Arrays) {
        effect.setArray2(name66, this._vectors2Arrays[name66]);
      }
      for (name66 in this._vectors3Arrays) {
        effect.setArray3(name66, this._vectors3Arrays[name66]);
      }
      for (name66 in this._vectors4Arrays) {
        effect.setArray4(name66, this._vectors4Arrays[name66]);
      }
      for (name66 in this._quaternionsArrays) {
        effect.setArray4(name66, this._quaternionsArrays[name66]);
      }
      for (name66 in this._uniformBuffers) {
        const buffer = this._uniformBuffers[name66].getBuffer();
        if (buffer) {
          effect.bindUniformBuffer(buffer, name66);
        }
      }
      for (name66 in this._textureSamplers) {
        effect.setTextureSampler(name66, this._textureSamplers[name66]);
      }
      for (name66 in this._storageBuffers) {
        effect.setStorageBuffer(name66, this._storageBuffers[name66]);
      }
    }
    if (effect && mesh && (mustRebind || !this.isFrozen)) {
      const manager = mesh.morphTargetManager;
      if (manager && manager.numInfluencers > 0) {
        BindMorphTargetParameters(mesh, effect);
      }
      const bvaManager = mesh.bakedVertexAnimationManager;
      if (bvaManager && bvaManager.isEnabled) {
        const drawWrapper = storeEffectOnSubMeshes ? subMesh._drawWrapper : this._drawWrapper;
        mesh.bakedVertexAnimationManager?.bind(effect, !!drawWrapper._wasPreviouslyUsingInstances);
      }
    }
    this._afterBind(mesh, effect, subMesh);
  }
  /**
   * Gets the active textures from the material
   * @returns an array of textures
   */
  getActiveTextures() {
    const activeTextures = super.getActiveTextures();
    for (const name66 in this._textures) {
      activeTextures.push(this._textures[name66]);
    }
    for (const name66 in this._textureArrays) {
      const array = this._textureArrays[name66];
      for (let index = 0; index < array.length; index++) {
        activeTextures.push(array[index]);
      }
    }
    return activeTextures;
  }
  /**
   * Specifies if the material uses a texture
   * @param texture defines the texture to check against the material
   * @returns a boolean specifying if the material uses the texture
   */
  hasTexture(texture) {
    if (super.hasTexture(texture)) {
      return true;
    }
    for (const name66 in this._textures) {
      if (this._textures[name66] === texture) {
        return true;
      }
    }
    for (const name66 in this._textureArrays) {
      const array = this._textureArrays[name66];
      for (let index = 0; index < array.length; index++) {
        if (array[index] === texture) {
          return true;
        }
      }
    }
    return false;
  }
  /**
   * Makes a duplicate of the material, and gives it a new name
   * @param name defines the new name for the duplicated material
   * @returns the cloned material
   */
  clone(name66) {
    const result = SerializationHelper.Clone(() => new _ShaderMaterial(name66, this.getScene(), this._shaderPath, this._options, this._storeEffectOnSubMeshes), this);
    result.name = name66;
    result.id = name66;
    if (typeof result._shaderPath === "object") {
      result._shaderPath = { ...result._shaderPath };
    }
    this._options = { ...this._options };
    Object.keys(this._options).forEach((propName) => {
      const propValue = this._options[propName];
      if (Array.isArray(propValue)) {
        this._options[propName] = propValue.slice(0);
      }
    });
    this.stencil.copyTo(result.stencil);
    for (const key in this._textures) {
      result.setTexture(key, this._textures[key]);
    }
    for (const key in this._textureArrays) {
      result.setTextureArray(key, this._textureArrays[key]);
    }
    for (const key in this._externalTextures) {
      result.setExternalTexture(key, this._externalTextures[key]);
    }
    for (const key in this._ints) {
      result.setInt(key, this._ints[key]);
    }
    for (const key in this._uints) {
      result.setUInt(key, this._uints[key]);
    }
    for (const key in this._floats) {
      result.setFloat(key, this._floats[key]);
    }
    for (const key in this._floatsArrays) {
      result.setFloats(key, this._floatsArrays[key]);
    }
    for (const key in this._colors3) {
      result.setColor3(key, this._colors3[key]);
    }
    for (const key in this._colors3Arrays) {
      result._colors3Arrays[key] = this._colors3Arrays[key];
    }
    for (const key in this._colors4) {
      result.setColor4(key, this._colors4[key]);
    }
    for (const key in this._colors4Arrays) {
      result._colors4Arrays[key] = this._colors4Arrays[key];
    }
    for (const key in this._vectors2) {
      result.setVector2(key, this._vectors2[key]);
    }
    for (const key in this._vectors3) {
      result.setVector3(key, this._vectors3[key]);
    }
    for (const key in this._vectors4) {
      result.setVector4(key, this._vectors4[key]);
    }
    for (const key in this._quaternions) {
      result.setQuaternion(key, this._quaternions[key]);
    }
    for (const key in this._quaternionsArrays) {
      result._quaternionsArrays[key] = this._quaternionsArrays[key];
    }
    for (const key in this._matrices) {
      result.setMatrix(key, this._matrices[key]);
    }
    for (const key in this._matrixArrays) {
      result._matrixArrays[key] = this._matrixArrays[key].slice();
    }
    for (const key in this._matrices3x3) {
      result.setMatrix3x3(key, this._matrices3x3[key]);
    }
    for (const key in this._matrices2x2) {
      result.setMatrix2x2(key, this._matrices2x2[key]);
    }
    for (const key in this._vectors2Arrays) {
      result.setArray2(key, this._vectors2Arrays[key]);
    }
    for (const key in this._vectors3Arrays) {
      result.setArray3(key, this._vectors3Arrays[key]);
    }
    for (const key in this._vectors4Arrays) {
      result.setArray4(key, this._vectors4Arrays[key]);
    }
    for (const key in this._uniformBuffers) {
      result.setUniformBuffer(key, this._uniformBuffers[key]);
    }
    for (const key in this._textureSamplers) {
      result.setTextureSampler(key, this._textureSamplers[key]);
    }
    for (const key in this._storageBuffers) {
      result.setStorageBuffer(key, this._storageBuffers[key]);
    }
    return result;
  }
  /**
   * Disposes the material
   * @param forceDisposeEffect specifies if effects should be forcefully disposed
   * @param forceDisposeTextures specifies if textures should be forcefully disposed
   * @param notBoundToMesh specifies if the material that is being disposed is known to be not bound to any mesh
   */
  dispose(forceDisposeEffect, forceDisposeTextures, notBoundToMesh) {
    if (forceDisposeTextures) {
      let name66;
      for (name66 in this._textures) {
        this._textures[name66].dispose();
      }
      for (name66 in this._textureArrays) {
        const array = this._textureArrays[name66];
        for (let index = 0; index < array.length; index++) {
          array[index].dispose();
        }
      }
    }
    this._textures = {};
    super.dispose(forceDisposeEffect, forceDisposeTextures, notBoundToMesh);
  }
  /**
   * Serializes this material in a JSON representation
   * @returns the serialized material object
   */
  serialize() {
    const serializationObject = SerializationHelper.Serialize(this);
    serializationObject.customType = "BABYLON.ShaderMaterial";
    serializationObject.uniqueId = this.uniqueId;
    serializationObject.options = this._options;
    serializationObject.shaderPath = this._shaderPath;
    serializationObject.storeEffectOnSubMeshes = this._storeEffectOnSubMeshes;
    let name66;
    serializationObject.stencil = this.stencil.serialize();
    serializationObject.textures = {};
    for (name66 in this._textures) {
      serializationObject.textures[name66] = this._textures[name66].serialize();
    }
    serializationObject.textureArrays = {};
    for (name66 in this._textureArrays) {
      serializationObject.textureArrays[name66] = [];
      const array = this._textureArrays[name66];
      for (let index = 0; index < array.length; index++) {
        serializationObject.textureArrays[name66].push(array[index].serialize());
      }
    }
    serializationObject.ints = {};
    for (name66 in this._ints) {
      serializationObject.ints[name66] = this._ints[name66];
    }
    serializationObject.uints = {};
    for (name66 in this._uints) {
      serializationObject.uints[name66] = this._uints[name66];
    }
    serializationObject.floats = {};
    for (name66 in this._floats) {
      serializationObject.floats[name66] = this._floats[name66];
    }
    serializationObject.floatsArrays = {};
    for (name66 in this._floatsArrays) {
      serializationObject.floatsArrays[name66] = this._floatsArrays[name66];
    }
    serializationObject.colors3 = {};
    for (name66 in this._colors3) {
      serializationObject.colors3[name66] = this._colors3[name66].asArray();
    }
    serializationObject.colors3Arrays = {};
    for (name66 in this._colors3Arrays) {
      serializationObject.colors3Arrays[name66] = this._colors3Arrays[name66];
    }
    serializationObject.colors4 = {};
    for (name66 in this._colors4) {
      serializationObject.colors4[name66] = this._colors4[name66].asArray();
    }
    serializationObject.colors4Arrays = {};
    for (name66 in this._colors4Arrays) {
      serializationObject.colors4Arrays[name66] = this._colors4Arrays[name66];
    }
    serializationObject.vectors2 = {};
    for (name66 in this._vectors2) {
      serializationObject.vectors2[name66] = this._vectors2[name66].asArray();
    }
    serializationObject.vectors3 = {};
    for (name66 in this._vectors3) {
      serializationObject.vectors3[name66] = this._vectors3[name66].asArray();
    }
    serializationObject.vectors4 = {};
    for (name66 in this._vectors4) {
      serializationObject.vectors4[name66] = this._vectors4[name66].asArray();
    }
    serializationObject.quaternions = {};
    for (name66 in this._quaternions) {
      serializationObject.quaternions[name66] = this._quaternions[name66].asArray();
    }
    serializationObject.matrices = {};
    for (name66 in this._matrices) {
      serializationObject.matrices[name66] = this._matrices[name66].asArray();
    }
    serializationObject.matrixArray = {};
    for (name66 in this._matrixArrays) {
      serializationObject.matrixArray[name66] = this._matrixArrays[name66];
    }
    serializationObject.matrices3x3 = {};
    for (name66 in this._matrices3x3) {
      serializationObject.matrices3x3[name66] = this._matrices3x3[name66];
    }
    serializationObject.matrices2x2 = {};
    for (name66 in this._matrices2x2) {
      serializationObject.matrices2x2[name66] = this._matrices2x2[name66];
    }
    serializationObject.vectors2Arrays = {};
    for (name66 in this._vectors2Arrays) {
      serializationObject.vectors2Arrays[name66] = this._vectors2Arrays[name66];
    }
    serializationObject.vectors3Arrays = {};
    for (name66 in this._vectors3Arrays) {
      serializationObject.vectors3Arrays[name66] = this._vectors3Arrays[name66];
    }
    serializationObject.vectors4Arrays = {};
    for (name66 in this._vectors4Arrays) {
      serializationObject.vectors4Arrays[name66] = this._vectors4Arrays[name66];
    }
    serializationObject.quaternionsArrays = {};
    for (name66 in this._quaternionsArrays) {
      serializationObject.quaternionsArrays[name66] = this._quaternionsArrays[name66];
    }
    return serializationObject;
  }
  /**
   * Creates a shader material from parsed shader material data
   * @param source defines the JSON representation of the material
   * @param scene defines the hosting scene
   * @param rootUrl defines the root URL to use to load textures and relative dependencies
   * @returns a new material
   */
  static Parse(source, scene, rootUrl) {
    const material = SerializationHelper.Parse(() => new _ShaderMaterial(source.name, scene, source.shaderPath, source.options, source.storeEffectOnSubMeshes), source, scene, rootUrl);
    let name66;
    if (source.stencil) {
      material.stencil.parse(source.stencil, scene, rootUrl);
    }
    for (name66 in source.textures) {
      material.setTexture(name66, Texture.Parse(source.textures[name66], scene, rootUrl));
    }
    for (name66 in source.textureArrays) {
      const array = source.textureArrays[name66];
      const textureArray = [];
      for (let index = 0; index < array.length; index++) {
        textureArray.push(Texture.Parse(array[index], scene, rootUrl));
      }
      material.setTextureArray(name66, textureArray);
    }
    for (name66 in source.ints) {
      material.setInt(name66, source.ints[name66]);
    }
    for (name66 in source.uints) {
      material.setUInt(name66, source.uints[name66]);
    }
    for (name66 in source.floats) {
      material.setFloat(name66, source.floats[name66]);
    }
    for (name66 in source.floatsArrays) {
      material.setFloats(name66, source.floatsArrays[name66]);
    }
    for (name66 in source.colors3) {
      material.setColor3(name66, Color3.FromArray(source.colors3[name66]));
    }
    for (name66 in source.colors3Arrays) {
      const colors = source.colors3Arrays[name66].reduce((arr, num, i) => {
        if (i % 3 === 0) {
          arr.push([num]);
        } else {
          arr[arr.length - 1].push(num);
        }
        return arr;
      }, []).map((color) => Color3.FromArray(color));
      material.setColor3Array(name66, colors);
    }
    for (name66 in source.colors4) {
      material.setColor4(name66, Color4.FromArray(source.colors4[name66]));
    }
    for (name66 in source.colors4Arrays) {
      const colors = source.colors4Arrays[name66].reduce((arr, num, i) => {
        if (i % 4 === 0) {
          arr.push([num]);
        } else {
          arr[arr.length - 1].push(num);
        }
        return arr;
      }, []).map((color) => Color4.FromArray(color));
      material.setColor4Array(name66, colors);
    }
    for (name66 in source.vectors2) {
      material.setVector2(name66, Vector2.FromArray(source.vectors2[name66]));
    }
    for (name66 in source.vectors3) {
      material.setVector3(name66, Vector3.FromArray(source.vectors3[name66]));
    }
    for (name66 in source.vectors4) {
      material.setVector4(name66, Vector4.FromArray(source.vectors4[name66]));
    }
    for (name66 in source.quaternions) {
      material.setQuaternion(name66, Quaternion.FromArray(source.quaternions[name66]));
    }
    for (name66 in source.matrices) {
      material.setMatrix(name66, Matrix.FromArray(source.matrices[name66]));
    }
    for (name66 in source.matrixArray) {
      material._matrixArrays[name66] = new Float32Array(source.matrixArray[name66]);
    }
    for (name66 in source.matrices3x3) {
      material.setMatrix3x3(name66, source.matrices3x3[name66]);
    }
    for (name66 in source.matrices2x2) {
      material.setMatrix2x2(name66, source.matrices2x2[name66]);
    }
    for (name66 in source.vectors2Arrays) {
      material.setArray2(name66, source.vectors2Arrays[name66]);
    }
    for (name66 in source.vectors3Arrays) {
      material.setArray3(name66, source.vectors3Arrays[name66]);
    }
    for (name66 in source.vectors4Arrays) {
      material.setArray4(name66, source.vectors4Arrays[name66]);
    }
    for (name66 in source.quaternionsArrays) {
      material.setArray4(name66, source.quaternionsArrays[name66]);
    }
    return material;
  }
  /**
   * Creates a new ShaderMaterial from a snippet saved in a remote file
   * @param name defines the name of the ShaderMaterial to create (can be null or empty to use the one from the json data)
   * @param url defines the url to load from
   * @param scene defines the hosting scene
   * @param rootUrl defines the root URL to use to load textures and relative dependencies
   * @returns a promise that will resolve to the new ShaderMaterial
   */
  static ParseFromFileAsync(name66, url, scene, rootUrl = "") {
    return new Promise((resolve, reject) => {
      const request = new WebRequest();
      request.addEventListener("readystatechange", () => {
        if (request.readyState == 4) {
          if (request.status == 200) {
            const serializationObject = JSON.parse(request.responseText);
            const output = this.Parse(serializationObject, scene || EngineStore.LastCreatedScene, rootUrl);
            if (name66) {
              output.name = name66;
            }
            resolve(output);
          } else {
            reject("Unable to load the ShaderMaterial");
          }
        }
      });
      request.open("GET", url);
      request.send();
    });
  }
  /**
   * Creates a ShaderMaterial from a snippet saved by the Inspector
   * @param snippetId defines the snippet to load
   * @param scene defines the hosting scene
   * @param rootUrl defines the root URL to use to load textures and relative dependencies
   * @returns a promise that will resolve to the new ShaderMaterial
   */
  static ParseFromSnippetAsync(snippetId, scene, rootUrl = "") {
    return new Promise((resolve, reject) => {
      const request = new WebRequest();
      request.addEventListener("readystatechange", () => {
        if (request.readyState == 4) {
          if (request.status == 200) {
            const snippet = JSON.parse(JSON.parse(request.responseText).jsonPayload);
            const serializationObject = JSON.parse(snippet.shaderMaterial);
            const output = this.Parse(serializationObject, scene || EngineStore.LastCreatedScene, rootUrl);
            output.snippetId = snippetId;
            resolve(output);
          } else {
            reject("Unable to load the snippet " + snippetId);
          }
        }
      });
      request.open("GET", this.SnippetUrl + "/" + snippetId.replace(/#/g, "/"));
      request.send();
    });
  }
};
ShaderMaterial.SnippetUrl = `https://snippet.babylonjs.com`;
ShaderMaterial.CreateFromSnippetAsync = ShaderMaterial.ParseFromSnippetAsync;
RegisterClass("BABYLON.ShaderMaterial", ShaderMaterial);

// ../../node_modules/@babylonjs/core/Shaders/color.fragment.js
var name64 = "colorPixelShader";
var shader64 = `#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)
#define VERTEXCOLOR
varying vec4 vColor;
#else
uniform vec4 color;
#endif
#include<clipPlaneFragmentDeclaration>
#include<fogFragmentDeclaration>
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void) {
#define CUSTOM_FRAGMENT_MAIN_BEGIN
#include<clipPlaneFragment>
#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)
gl_FragColor=vColor;
#else
gl_FragColor=color;
#endif
#include<fogFragment>(color,gl_FragColor)
#define CUSTOM_FRAGMENT_MAIN_END
}`;
ShaderStore.ShadersStore[name64] = shader64;

// ../../node_modules/@babylonjs/core/Shaders/color.vertex.js
var name65 = "colorVertexShader";
var shader65 = `attribute vec3 position;
#ifdef VERTEXCOLOR
attribute vec4 color;
#endif
#include<bonesDeclaration>
#include<bakedVertexAnimationDeclaration>
#include<clipPlaneVertexDeclaration>
#include<fogVertexDeclaration>
#ifdef FOG
uniform mat4 view;
#endif
#include<instancesDeclaration>
uniform mat4 viewProjection;
#ifdef MULTIVIEW
uniform mat4 viewProjectionR;
#endif
#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)
varying vec4 vColor;
#endif
#define CUSTOM_VERTEX_DEFINITIONS
void main(void) {
#define CUSTOM_VERTEX_MAIN_BEGIN
#include<instancesVertex>
#include<bonesVertex>
#include<bakedVertexAnimation>
vec4 worldPos=finalWorld*vec4(position,1.0);
#ifdef MULTIVIEW
if (gl_ViewID_OVR==0u) {gl_Position=viewProjection*worldPos;} else {gl_Position=viewProjectionR*worldPos;}
#else
gl_Position=viewProjection*worldPos;
#endif
#include<clipPlaneVertex>
#include<fogVertex>
#include<vertexColorMixing>
#define CUSTOM_VERTEX_MAIN_END
}`;
ShaderStore.ShadersStore[name65] = shader65;

// ../../node_modules/@babylonjs/core/Meshes/linesMesh.js
Mesh._LinesMeshParser = (parsedMesh, scene) => {
  return LinesMesh.Parse(parsedMesh, scene);
};
var LinesMesh = class _LinesMesh extends Mesh {
  _isShaderMaterial(shader66) {
    return shader66.getClassName() === "ShaderMaterial";
  }
  /**
   * Creates a new LinesMesh
   * @param name defines the name
   * @param scene defines the hosting scene
   * @param parent defines the parent mesh if any
   * @param source defines the optional source LinesMesh used to clone data from
   * @param doNotCloneChildren When cloning, skip cloning child meshes of source, default False.
   * When false, achieved by calling a clone(), also passing False.
   * This will make creation of children, recursive.
   * @param useVertexColor defines if this LinesMesh supports vertex color
   * @param useVertexAlpha defines if this LinesMesh supports vertex alpha
   * @param material material to use to draw the line. If not provided, will create a new one
   */
  constructor(name66, scene = null, parent = null, source = null, doNotCloneChildren, useVertexColor, useVertexAlpha, material) {
    super(name66, scene, parent, source, doNotCloneChildren);
    this.useVertexColor = useVertexColor;
    this.useVertexAlpha = useVertexAlpha;
    this.color = new Color3(1, 1, 1);
    this.alpha = 1;
    if (source) {
      this.color = source.color.clone();
      this.alpha = source.alpha;
      this.useVertexColor = source.useVertexColor;
      this.useVertexAlpha = source.useVertexAlpha;
    }
    this.intersectionThreshold = 0.1;
    const defines = [];
    const options = {
      attributes: [VertexBuffer.PositionKind],
      uniforms: ["world", "viewProjection"],
      needAlphaBlending: true,
      defines,
      useClipPlane: null
    };
    if (useVertexAlpha === false) {
      options.needAlphaBlending = false;
    } else {
      options.defines.push("#define VERTEXALPHA");
    }
    if (!useVertexColor) {
      options.uniforms.push("color");
      this._color4 = new Color4();
    } else {
      options.defines.push("#define VERTEXCOLOR");
      options.attributes.push(VertexBuffer.ColorKind);
    }
    if (material) {
      this.material = material;
    } else {
      this.material = new ShaderMaterial("colorShader", this.getScene(), "color", options, false);
      this.material.doNotSerialize = true;
    }
  }
  isReady() {
    if (!this._lineMaterial.isReady(this, !!this._userInstancedBuffersStorage || this.hasThinInstances)) {
      return false;
    }
    return super.isReady();
  }
  /**
   * @returns the string "LineMesh"
   */
  getClassName() {
    return "LinesMesh";
  }
  /**
   * @internal
   */
  get material() {
    return this._lineMaterial;
  }
  /**
   * @internal
   */
  set material(value) {
    this._lineMaterial = value;
    this._lineMaterial.fillMode = Material.LineListDrawMode;
  }
  /**
   * @internal
   */
  get checkCollisions() {
    return false;
  }
  set checkCollisions(value) {
  }
  /**
   * @internal
   */
  _bind(_subMesh, colorEffect) {
    if (!this._geometry) {
      return this;
    }
    const indexToBind = this.isUnIndexed ? null : this._geometry.getIndexBuffer();
    if (!this._userInstancedBuffersStorage || this.hasThinInstances) {
      this._geometry._bind(colorEffect, indexToBind);
    } else {
      this._geometry._bind(colorEffect, indexToBind, this._userInstancedBuffersStorage.vertexBuffers, this._userInstancedBuffersStorage.vertexArrayObjects);
    }
    if (!this.useVertexColor && this._isShaderMaterial(this._lineMaterial)) {
      const { r, g, b } = this.color;
      this._color4.set(r, g, b, this.alpha);
      this._lineMaterial.setColor4("color", this._color4);
    }
    return this;
  }
  /**
   * @internal
   */
  _draw(subMesh, fillMode, instancesCount) {
    if (!this._geometry || !this._geometry.getVertexBuffers() || !this._unIndexed && !this._geometry.getIndexBuffer()) {
      return this;
    }
    const engine = this.getScene().getEngine();
    if (this._unIndexed) {
      engine.drawArraysType(Material.LineListDrawMode, subMesh.verticesStart, subMesh.verticesCount, instancesCount);
    } else {
      engine.drawElementsType(Material.LineListDrawMode, subMesh.indexStart, subMesh.indexCount, instancesCount);
    }
    return this;
  }
  /**
   * Disposes of the line mesh
   * @param doNotRecurse If children should be disposed
   * @param disposeMaterialAndTextures This parameter is not used by the LineMesh class
   * @param doNotDisposeMaterial If the material should not be disposed (default: false, meaning the material is disposed)
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  dispose(doNotRecurse, disposeMaterialAndTextures = false, doNotDisposeMaterial) {
    if (!doNotDisposeMaterial) {
      this._lineMaterial.dispose(false, false, true);
    }
    super.dispose(doNotRecurse);
  }
  /**
   * Returns a new LineMesh object cloned from the current one.
   * @param name defines the cloned mesh name
   * @param newParent defines the new mesh parent
   * @param doNotCloneChildren if set to true, none of the mesh children are cloned (false by default)
   * @returns the new mesh
   */
  clone(name66, newParent = null, doNotCloneChildren) {
    return new _LinesMesh(name66, this.getScene(), newParent, this, doNotCloneChildren);
  }
  /**
   * Creates a new InstancedLinesMesh object from the mesh model.
   * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/copies/instances
   * @param name defines the name of the new instance
   * @returns a new InstancedLinesMesh
   */
  createInstance(name66) {
    const instance = new InstancedLinesMesh(name66, this);
    if (this.instancedBuffers) {
      instance.instancedBuffers = {};
      for (const key in this.instancedBuffers) {
        instance.instancedBuffers[key] = this.instancedBuffers[key];
      }
    }
    return instance;
  }
  /**
   * Serializes this ground mesh
   * @param serializationObject object to write serialization to
   */
  serialize(serializationObject) {
    super.serialize(serializationObject);
    serializationObject.color = this.color.asArray();
    serializationObject.alpha = this.alpha;
  }
  /**
   * Parses a serialized ground mesh
   * @param parsedMesh the serialized mesh
   * @param scene the scene to create the ground mesh in
   * @returns the created ground mesh
   */
  static Parse(parsedMesh, scene) {
    const result = new _LinesMesh(parsedMesh.name, scene);
    result.color = Color3.FromArray(parsedMesh.color);
    result.alpha = parsedMesh.alpha;
    return result;
  }
};
var InstancedLinesMesh = class extends InstancedMesh {
  constructor(name66, source) {
    super(name66, source);
    this.intersectionThreshold = source.intersectionThreshold;
  }
  /**
   * @returns the string "InstancedLinesMesh".
   */
  getClassName() {
    return "InstancedLinesMesh";
  }
};

// ../../node_modules/@babylonjs/core/Meshes/Builders/linesBuilder.js
function CreateLineSystemVertexData(options) {
  const indices = [];
  const positions = [];
  const lines = options.lines;
  const colors = options.colors;
  const vertexColors = [];
  let idx = 0;
  for (let l = 0; l < lines.length; l++) {
    const points = lines[l];
    for (let index = 0; index < points.length; index++) {
      const { x, y, z } = points[index];
      positions.push(x, y, z);
      if (colors) {
        const color = colors[l];
        const { r, g, b, a: a2 } = color[index];
        vertexColors.push(r, g, b, a2);
      }
      if (index > 0) {
        indices.push(idx - 1);
        indices.push(idx);
      }
      idx++;
    }
  }
  const vertexData = new VertexData();
  vertexData.indices = indices;
  vertexData.positions = positions;
  if (colors) {
    vertexData.colors = vertexColors;
  }
  return vertexData;
}
function CreateDashedLinesVertexData(options) {
  const dashSize = options.dashSize || 3;
  const gapSize = options.gapSize || 1;
  const dashNb = options.dashNb || 200;
  const points = options.points;
  const positions = [];
  const indices = [];
  const curvect = Vector3.Zero();
  let lg = 0;
  let nb = 0;
  let shft = 0;
  let dashshft = 0;
  let curshft = 0;
  let idx = 0;
  let i = 0;
  for (i = 0; i < points.length - 1; i++) {
    points[i + 1].subtractToRef(points[i], curvect);
    lg += curvect.length();
  }
  shft = lg / dashNb;
  dashshft = dashSize * shft / (dashSize + gapSize);
  for (i = 0; i < points.length - 1; i++) {
    points[i + 1].subtractToRef(points[i], curvect);
    nb = Math.floor(curvect.length() / shft);
    curvect.normalize();
    for (let j = 0; j < nb; j++) {
      curshft = shft * j;
      positions.push(points[i].x + curshft * curvect.x, points[i].y + curshft * curvect.y, points[i].z + curshft * curvect.z);
      positions.push(points[i].x + (curshft + dashshft) * curvect.x, points[i].y + (curshft + dashshft) * curvect.y, points[i].z + (curshft + dashshft) * curvect.z);
      indices.push(idx, idx + 1);
      idx += 2;
    }
  }
  const vertexData = new VertexData();
  vertexData.positions = positions;
  vertexData.indices = indices;
  return vertexData;
}
function CreateLineSystem(name66, options, scene = null) {
  const instance = options.instance;
  const lines = options.lines;
  const colors = options.colors;
  if (instance) {
    const positions = instance.getVerticesData(VertexBuffer.PositionKind);
    let vertexColor;
    let lineColors;
    if (colors) {
      vertexColor = instance.getVerticesData(VertexBuffer.ColorKind);
    }
    let i = 0;
    let c = 0;
    for (let l = 0; l < lines.length; l++) {
      const points = lines[l];
      for (let p = 0; p < points.length; p++) {
        positions[i] = points[p].x;
        positions[i + 1] = points[p].y;
        positions[i + 2] = points[p].z;
        if (colors && vertexColor) {
          lineColors = colors[l];
          vertexColor[c] = lineColors[p].r;
          vertexColor[c + 1] = lineColors[p].g;
          vertexColor[c + 2] = lineColors[p].b;
          vertexColor[c + 3] = lineColors[p].a;
          c += 4;
        }
        i += 3;
      }
    }
    instance.updateVerticesData(VertexBuffer.PositionKind, positions, false, false);
    if (colors && vertexColor) {
      instance.updateVerticesData(VertexBuffer.ColorKind, vertexColor, false, false);
    }
    return instance;
  }
  const useVertexColor = colors ? true : false;
  const lineSystem = new LinesMesh(name66, scene, null, void 0, void 0, useVertexColor, options.useVertexAlpha, options.material);
  const vertexData = CreateLineSystemVertexData(options);
  vertexData.applyToMesh(lineSystem, options.updatable);
  return lineSystem;
}
function CreateLines(name66, options, scene = null) {
  const colors = options.colors ? [options.colors] : null;
  const lines = CreateLineSystem(name66, { lines: [options.points], updatable: options.updatable, instance: options.instance, colors, useVertexAlpha: options.useVertexAlpha, material: options.material }, scene);
  return lines;
}
function CreateDashedLines(name66, options, scene = null) {
  const points = options.points;
  const instance = options.instance;
  const gapSize = options.gapSize || 1;
  const dashSize = options.dashSize || 3;
  if (instance) {
    const positionFunction = (positions) => {
      const curvect = Vector3.Zero();
      const nbSeg = positions.length / 6;
      let lg = 0;
      let nb = 0;
      let shft = 0;
      let dashshft = 0;
      let curshft = 0;
      let p = 0;
      let i = 0;
      let j = 0;
      for (i = 0; i < points.length - 1; i++) {
        points[i + 1].subtractToRef(points[i], curvect);
        lg += curvect.length();
      }
      shft = lg / nbSeg;
      const dashSize2 = instance._creationDataStorage.dashSize;
      const gapSize2 = instance._creationDataStorage.gapSize;
      dashshft = dashSize2 * shft / (dashSize2 + gapSize2);
      for (i = 0; i < points.length - 1; i++) {
        points[i + 1].subtractToRef(points[i], curvect);
        nb = Math.floor(curvect.length() / shft);
        curvect.normalize();
        j = 0;
        while (j < nb && p < positions.length) {
          curshft = shft * j;
          positions[p] = points[i].x + curshft * curvect.x;
          positions[p + 1] = points[i].y + curshft * curvect.y;
          positions[p + 2] = points[i].z + curshft * curvect.z;
          positions[p + 3] = points[i].x + (curshft + dashshft) * curvect.x;
          positions[p + 4] = points[i].y + (curshft + dashshft) * curvect.y;
          positions[p + 5] = points[i].z + (curshft + dashshft) * curvect.z;
          p += 6;
          j++;
        }
      }
      while (p < positions.length) {
        positions[p] = points[i].x;
        positions[p + 1] = points[i].y;
        positions[p + 2] = points[i].z;
        p += 3;
      }
    };
    if (options.dashNb || options.dashSize || options.gapSize || options.useVertexAlpha || options.material) {
      Logger.Warn("You have used an option other than points with the instance option. Please be aware that these other options will be ignored.");
    }
    instance.updateMeshPositions(positionFunction, false);
    return instance;
  }
  const dashedLines = new LinesMesh(name66, scene, null, void 0, void 0, void 0, options.useVertexAlpha, options.material);
  const vertexData = CreateDashedLinesVertexData(options);
  vertexData.applyToMesh(dashedLines, options.updatable);
  dashedLines._creationDataStorage = new _CreationDataStorage();
  dashedLines._creationDataStorage.dashSize = dashSize;
  dashedLines._creationDataStorage.gapSize = gapSize;
  return dashedLines;
}
VertexData.CreateLineSystem = CreateLineSystemVertexData;
VertexData.CreateDashedLines = CreateDashedLinesVertexData;
Mesh.CreateLines = (name66, points, scene = null, updatable = false, instance = null) => {
  const options = {
    points,
    updatable,
    instance
  };
  return CreateLines(name66, options, scene);
};
Mesh.CreateDashedLines = (name66, points, dashSize, gapSize, dashNb, scene = null, updatable, instance) => {
  const options = {
    points,
    dashSize,
    gapSize,
    dashNb,
    updatable,
    instance
  };
  return CreateDashedLines(name66, options, scene);
};

// ../../node_modules/@babylonjs/core/Meshes/Builders/planeBuilder.js
function CreatePlaneVertexData(options) {
  const indices = [];
  const positions = [];
  const normals = [];
  const uvs = [];
  const width = options.width || options.size || 1;
  const height = options.height || options.size || 1;
  const sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;
  const halfWidth = width / 2;
  const halfHeight = height / 2;
  positions.push(-halfWidth, -halfHeight, 0);
  normals.push(0, 0, -1);
  uvs.push(0, CompatibilityOptions.UseOpenGLOrientationForUV ? 1 : 0);
  positions.push(halfWidth, -halfHeight, 0);
  normals.push(0, 0, -1);
  uvs.push(1, CompatibilityOptions.UseOpenGLOrientationForUV ? 1 : 0);
  positions.push(halfWidth, halfHeight, 0);
  normals.push(0, 0, -1);
  uvs.push(1, CompatibilityOptions.UseOpenGLOrientationForUV ? 0 : 1);
  positions.push(-halfWidth, halfHeight, 0);
  normals.push(0, 0, -1);
  uvs.push(0, CompatibilityOptions.UseOpenGLOrientationForUV ? 0 : 1);
  indices.push(0);
  indices.push(1);
  indices.push(2);
  indices.push(0);
  indices.push(2);
  indices.push(3);
  VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);
  const vertexData = new VertexData();
  vertexData.indices = indices;
  vertexData.positions = positions;
  vertexData.normals = normals;
  vertexData.uvs = uvs;
  return vertexData;
}
function CreatePlane(name66, options = {}, scene = null) {
  const plane = new Mesh(name66, scene);
  options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);
  plane._originalBuilderSideOrientation = options.sideOrientation;
  const vertexData = CreatePlaneVertexData(options);
  vertexData.applyToMesh(plane, options.updatable);
  if (options.sourcePlane) {
    plane.translate(options.sourcePlane.normal, -options.sourcePlane.d);
    plane.setDirection(options.sourcePlane.normal.scale(-1));
  }
  return plane;
}
VertexData.CreatePlane = CreatePlaneVertexData;
Mesh.CreatePlane = (name66, size, scene, updatable, sideOrientation) => {
  const options = {
    size,
    width: size,
    height: size,
    sideOrientation,
    updatable
  };
  return CreatePlane(name66, options, scene);
};

// ../../node_modules/noa-engine/src/lib/rendering.js
var PROFILE2 = 0;
var defaults2 = {
  showFPS: false,
  antiAlias: true,
  clearColor: [0.8, 0.9, 1],
  ambientColor: [0.5, 0.5, 0.5],
  lightDiffuse: [1, 1, 1],
  lightSpecular: [1, 1, 1],
  lightVector: [1, -1, 0.5],
  useAO: true,
  AOmultipliers: [0.93, 0.8, 0.5],
  reverseAOmultiplier: 1,
  preserveDrawingBuffer: true,
  octreeBlockSize: 2,
  renderOnResize: true
};
var Rendering = class {
  /** 
   * @internal 
   * @param {import('../index').Engine} noa  
  */
  constructor(noa, opts, canvas) {
    opts = Object.assign({}, defaults2, opts);
    this.noa = noa;
    this.renderOnResize = !!opts.renderOnResize;
    this.useAO = !!opts.useAO;
    this.aoVals = opts.AOmultipliers;
    this.revAoVal = opts.reverseAOmultiplier;
    this.meshingCutoffTime = 6;
    this.engine = null;
    this.scene = null;
    this.light = null;
    this.camera = null;
    this._initScene(canvas, opts);
    if (opts.showFPS) setUpFPS();
  }
  /**
   * Constructor helper - set up the Babylon.js scene and basic components
   * @internal
   */
  _initScene(canvas, opts) {
    this.engine = new Engine(canvas, opts.antiAlias, {
      preserveDrawingBuffer: opts.preserveDrawingBuffer
    });
    var scene = new Scene(this.engine);
    this.scene = scene;
    scene.detachControl();
    scene.performancePriority = ScenePerformancePriority.Intermediate;
    scene.autoClear = true;
    var blockSize = Math.round(opts.octreeBlockSize);
    this._octreeManager = new SceneOctreeManager(this, blockSize);
    this._cameraHolder = new TransformNode("camHolder", scene);
    this.camera = new FreeCamera("camera", new Vector3(0, 0, 0), scene);
    this.camera.parent = this._cameraHolder;
    this.camera.minZ = 0.01;
    this._camScreen = CreatePlane("camScreen", { size: 10 }, scene);
    this.addMeshToScene(this._camScreen);
    this._camScreen.position.z = 0.1;
    this._camScreen.parent = this.camera;
    this._camScreenMat = this.makeStandardMaterial("camera_screen_mat");
    this._camScreen.material = this._camScreenMat;
    this._camScreen.setEnabled(false);
    this._camScreenMat.freeze();
    this._camLocBlock = 0;
    scene.clearColor = Color4.FromArray(opts.clearColor);
    scene.ambientColor = Color3.FromArray(opts.ambientColor);
    var lightVec = Vector3.FromArray(opts.lightVector);
    this.light = new DirectionalLight("light", lightVec, scene);
    this.light.diffuse = Color3.FromArray(opts.lightDiffuse);
    this.light.specular = Color3.FromArray(opts.lightSpecular);
    scene.skipPointerMovePicking = true;
  }
};
Rendering.prototype.getScene = function() {
  return this.scene;
};
Rendering.prototype.tick = function(dt) {
};
Rendering.prototype.render = function() {
  profile_hook3("start");
  updateCameraForRender(this);
  profile_hook3("updateCamera");
  this.engine.beginFrame();
  profile_hook3("beginFrame");
  this.scene.render();
  profile_hook3("render");
  fps_hook();
  this.engine.endFrame();
  profile_hook3("endFrame");
  profile_hook3("end");
};
Rendering.prototype.postRender = function() {
};
Rendering.prototype.resize = function() {
  this.engine.resize();
  if (this.noa._paused && this.renderOnResize) {
    this.scene.render();
  }
};
Rendering.prototype.highlightBlockFace = function(show, posArr, normArr) {
  var m = getHighlightMesh(this);
  if (show) {
    this.noa.globalToLocal(posArr, null, hlpos);
    var dist2 = import_gl_vec39.default.dist(this.noa.camera._localGetPosition(), hlpos);
    var slop = 1e-3 + 1e-3 * dist2;
    for (var i = 0; i < 3; i++) {
      if (normArr[i] === 0) {
        hlpos[i] += 0.5;
      } else {
        hlpos[i] += normArr[i] > 0 ? 1 + slop : -slop;
      }
    }
    m.position.copyFromFloats(hlpos[0], hlpos[1], hlpos[2]);
    m.rotation.x = normArr[1] ? Math.PI / 2 : 0;
    m.rotation.y = normArr[0] ? Math.PI / 2 : 0;
  }
  m.setEnabled(show);
};
var hlpos = [];
Rendering.prototype.addMeshToScene = function(mesh, isStatic = false, pos = null, containingChunk = null) {
  if (!mesh.metadata) mesh.metadata = {};
  if (mesh.metadata[addedToSceneFlag]) {
    this._octreeManager.setMeshVisibility(mesh, true);
    return;
  }
  mesh.metadata[addedToSceneFlag] = true;
  if (!mesh.parent) {
    if (!pos) pos = mesh.position.asArray();
    var lpos = this.noa.globalToLocal(pos, null, []);
    mesh.position.fromArray(lpos);
  }
  this._octreeManager.addMesh(mesh, isStatic, pos, containingChunk);
  mesh.onDisposeObservable.add(() => {
    this._octreeManager.removeMesh(mesh);
    mesh.metadata[addedToSceneFlag] = false;
  });
};
var addedToSceneFlag = "noa_added_to_scene";
Rendering.prototype.setMeshVisibility = function(mesh, visible = false) {
  if (!mesh.metadata) mesh.metadata = {};
  if (mesh.metadata[addedToSceneFlag]) {
    this._octreeManager.setMeshVisibility(mesh, visible);
  } else {
    if (visible) this.addMeshToScene(mesh);
  }
};
Rendering.prototype.makeStandardMaterial = function(name66) {
  var mat = new StandardMaterial(name66, this.scene);
  mat.specularColor.copyFromFloats(0, 0, 0);
  mat.ambientColor.copyFromFloats(1, 1, 1);
  mat.diffuseColor.copyFromFloats(1, 1, 1);
  return mat;
};
Rendering.prototype.prepareChunkForRendering = function(chunk) {
};
Rendering.prototype.disposeChunkForRendering = function(chunk) {
};
Rendering.prototype._rebaseOrigin = function(delta) {
  var dvec = new Vector3(delta[0], delta[1], delta[2]);
  this.scene.meshes.forEach((mesh) => {
    if (mesh.parent) return;
    mesh.position.subtractInPlace(dvec);
    if (mesh.isWorldMatrixFrozen) {
      mesh.freezeWorldMatrix();
    }
  });
  this._octreeManager.rebase(dvec);
};
function updateCameraForRender(self) {
  var cam = self.noa.camera;
  var tgtLoc = cam._localGetTargetPosition();
  self._cameraHolder.position.copyFromFloats(tgtLoc[0], tgtLoc[1], tgtLoc[2]);
  self._cameraHolder.rotation.x = cam.pitch;
  self._cameraHolder.rotation.y = cam.heading;
  self.camera.position.z = -cam.currentZoom;
  var cloc = cam._localGetPosition();
  var off = self.noa.worldOriginOffset;
  var cx = Math.floor(cloc[0] + off[0]);
  var cy = Math.floor(cloc[1] + off[1]);
  var cz = Math.floor(cloc[2] + off[2]);
  var id = self.noa.getBlock(cx, cy, cz);
  checkCameraEffect(self, id);
}
function checkCameraEffect(self, id) {
  if (id === self._camLocBlock) return;
  if (id === 0) {
    self._camScreen.setEnabled(false);
  } else {
    var matId = self.noa.registry.getBlockFaceMaterial(id, 0);
    if (matId) {
      var matData = self.noa.registry.getMaterialData(matId);
      var col = matData.color;
      var alpha = matData.alpha;
      if (col && alpha && alpha < 1) {
        self._camScreenMat.diffuseColor.set(0, 0, 0);
        self._camScreenMat.ambientColor.set(col[0], col[1], col[2]);
        self._camScreenMat.alpha = alpha;
        self._camScreen.setEnabled(true);
      }
    }
  }
  self._camLocBlock = id;
}
function getHighlightMesh(rendering) {
  var mesh = rendering._highlightMesh;
  if (!mesh) {
    mesh = CreatePlane("highlight", { size: 1 }, rendering.scene);
    var hlm = rendering.makeStandardMaterial("block_highlight_mat");
    hlm.backFaceCulling = false;
    hlm.emissiveColor = new Color3(1, 1, 1);
    hlm.alpha = 0.2;
    hlm.freeze();
    mesh.material = hlm;
    var s = 0.5;
    var lines = CreateLines("hightlightLines", {
      points: [
        new Vector3(s, s, 0),
        new Vector3(s, -s, 0),
        new Vector3(-s, -s, 0),
        new Vector3(-s, s, 0),
        new Vector3(s, s, 0)
      ]
    }, rendering.scene);
    lines.color = new Color3(1, 1, 1);
    lines.parent = mesh;
    rendering.addMeshToScene(mesh);
    rendering.addMeshToScene(lines);
    rendering._highlightMesh = mesh;
  }
  return mesh;
}
Rendering.prototype.debug_SceneCheck = function() {
  var meshes = this.scene.meshes;
  var octree = this.scene._selectionOctree;
  var dyns = octree.dynamicContent;
  var octs = [];
  var numOcts = 0;
  var numSubs = 0;
  var mats = this.scene.materials;
  var allmats = [];
  mats.forEach((mat) => {
    if (mat.subMaterials) mat.subMaterials.forEach((mat2) => allmats.push(mat2));
    else allmats.push(mat);
  });
  octree.blocks.forEach(function(block) {
    numOcts++;
    block.entries.forEach((m) => octs.push(m));
  });
  meshes.forEach(function(m) {
    if (m.isDisposed()) warn(m, "disposed mesh in scene");
    if (empty(m)) return;
    if (missing(m, dyns, octs)) warn(m, "non-empty mesh missing from octree");
    if (!m.material) {
      warn(m, "non-empty scene mesh with no material");
      return;
    }
    numSubs += m.subMeshes ? m.subMeshes.length : 1;
    var mats2 = m.material.subMaterials || [m.material];
    mats2.forEach(function(mat) {
      if (missing(mat, mats2)) warn(mat, "mesh material not in scene");
    });
  });
  var unusedMats = [];
  allmats.forEach((mat) => {
    var used = false;
    meshes.forEach((mesh) => {
      if (mesh.material === mat) used = true;
      if (!mesh.material) return;
      var mats2 = mesh.material.subMaterials || [mesh.material];
      if (mats2.includes(mat)) used = true;
    });
    if (!used) unusedMats.push(mat.name);
  });
  if (unusedMats.length) {
    console.warn("Materials unused by any mesh: ", unusedMats.join(", "));
  }
  dyns.forEach(function(m) {
    if (missing(m, meshes)) warn(m, "octree/dynamic mesh not in scene");
  });
  octs.forEach(function(m) {
    if (missing(m, meshes)) warn(m, "octree block mesh not in scene");
  });
  var avgPerOct = Math.round(10 * octs.length / numOcts) / 10;
  console.log(
    "meshes - octree:",
    octs.length,
    "  dynamic:",
    dyns.length,
    "   subMeshes:",
    numSubs,
    "   avg meshes/octreeBlock:",
    avgPerOct
  );
  function warn(obj, msg) {
    console.warn(obj.name + " --- " + msg);
  }
  function empty(mesh) {
    return mesh.getIndices().length === 0;
  }
  function missing(obj, list1, list2) {
    if (!obj) return false;
    if (list1.includes(obj)) return false;
    if (list2 && list2.includes(obj)) return false;
    return true;
  }
  return "done.";
};
Rendering.prototype.debug_MeshCount = function() {
  var ct = {};
  this.scene.meshes.forEach((m) => {
    var n = m.name || "";
    n = n.replace(/-\d+.*/, "#");
    n = n.replace(/\d+.*/, "#");
    n = n.replace(/(rotHolder|camHolder|camScreen)/, "rendering use");
    n = n.replace(/atlas sprite .*/, "atlas sprites");
    ct[n] = ct[n] || 0;
    ct[n]++;
  });
  for (var s in ct) console.log("   " + (ct[s] + "       ").substr(0, 7) + s);
};
var profile_hook3 = PROFILE2 ? makeProfileHook(200, "render internals") : () => {
};
var fps_hook = function() {
};
function setUpFPS() {
  var div2 = document.createElement("div");
  div2.id = "noa_fps";
  div2.style.position = "absolute";
  div2.style.top = "0";
  div2.style.right = "0";
  div2.style.zIndex = "0";
  div2.style.color = "white";
  div2.style.backgroundColor = "rgba(0,0,0,0.5)";
  div2.style.font = "14px monospace";
  div2.style.textAlign = "center";
  div2.style.minWidth = "2em";
  div2.style.margin = "4px";
  document.body.appendChild(div2);
  var every = 1e3;
  var ct = 0;
  var longest = 0;
  var start = performance.now();
  var last = start;
  fps_hook = function() {
    ct++;
    var nt = performance.now();
    if (nt - last > longest) longest = nt - last;
    last = nt;
    if (nt - start < every) return;
    var fps = Math.round(ct / (nt - start) * 1e3);
    var min2 = Math.round(1 / longest * 1e3);
    div2.innerHTML = fps + "<br>" + min2;
    ct = 0;
    longest = 0;
    start = nt;
  };
}

// ../../node_modules/voxel-physics-engine/src/index.js
var import_gl_vec311 = __toESM(require_gl_vec3());
var import_voxel_aabb_sweep2 = __toESM(require_voxel_aabb_sweep());

// ../../node_modules/voxel-physics-engine/src/rigidBody.js
var import_gl_vec310 = __toESM(require_gl_vec3());
var DEBUG = 0;
var RigidBody = class {
  constructor(_aabb, mass, friction, restitution, gravMult, onCollide, autoStep) {
    this.aabb = new AABB(_aabb.base, _aabb.vec);
    this.mass = mass;
    this.friction = friction;
    this.restitution = restitution;
    this.gravityMultiplier = gravMult;
    this.onCollide = onCollide;
    this.autoStep = !!autoStep;
    this.airDrag = -1;
    this.fluidDrag = -1;
    this.onStep = null;
    this.velocity = import_gl_vec310.default.create();
    this.resting = [0, 0, 0];
    this.inFluid = false;
    this._ratioInFluid = 0;
    this._forces = import_gl_vec310.default.create();
    this._impulses = import_gl_vec310.default.create();
    this._sleepFrameCount = 10 | 0;
  }
  setPosition(p) {
    sanityCheck(p);
    import_gl_vec310.default.subtract(p, p, this.aabb.base);
    this.aabb.translate(p);
    this._markActive();
  }
  getPosition() {
    return import_gl_vec310.default.clone(this.aabb.base);
  }
  applyForce(f) {
    sanityCheck(f);
    import_gl_vec310.default.add(this._forces, this._forces, f);
    this._markActive();
  }
  applyImpulse(i) {
    sanityCheck(i);
    import_gl_vec310.default.add(this._impulses, this._impulses, i);
    this._markActive();
  }
  /** @internal */
  _markActive() {
    this._sleepFrameCount = 10 | 0;
  }
  // temp
  atRestX() {
    return this.resting[0];
  }
  atRestY() {
    return this.resting[1];
  }
  atRestZ() {
    return this.resting[2];
  }
};
var sanityCheck = (v) => {
};
if (DEBUG) sanityCheck = (v) => {
  if (isNaN(import_gl_vec310.default.length(v))) throw "Vector with NAN: " + v;
};

// ../../node_modules/voxel-physics-engine/src/index.js
var DEBUG2 = 0;
function DefaultOptions2() {
  this.airDrag = 0.1;
  this.fluidDrag = 0.4;
  this.fluidDensity = 2;
  this.gravity = [0, -10, 0];
  this.minBounceImpulse = 0.5;
}
function Physics(opts, testSolid, testFluid) {
  opts = Object.assign(new DefaultOptions2(), opts);
  this.gravity = opts.gravity || [0, -10, 0];
  this.airDrag = opts.airDrag || 0.1;
  this.fluidDensity = opts.fluidDensity || 2;
  this.fluidDrag = opts.fluidDrag || 0.4;
  this.minBounceImpulse = opts.minBounceImpulse;
  this.bodies = [];
  this.testSolid = testSolid;
  this.testFluid = testFluid;
}
Physics.prototype.addBody = function(_aabb, mass, friction, restitution, gravMult, onCollide) {
  _aabb = _aabb || new AABB([0, 0, 0], [1, 1, 1]);
  if (typeof mass == "undefined") mass = 1;
  if (typeof friction == "undefined") friction = 1;
  if (typeof restitution == "undefined") restitution = 0;
  if (typeof gravMult == "undefined") gravMult = 1;
  var b = new RigidBody(_aabb, mass, friction, restitution, gravMult, onCollide);
  this.bodies.push(b);
  return b;
};
Physics.prototype.removeBody = function(b) {
  var i = this.bodies.indexOf(b);
  if (i < 0) return void 0;
  this.bodies.splice(i, 1);
  b.aabb = b.onCollide = null;
};
var a = import_gl_vec311.default.create();
var dv = import_gl_vec311.default.create();
var dx = import_gl_vec311.default.create();
var impacts = import_gl_vec311.default.create();
var oldResting = import_gl_vec311.default.create();
Physics.prototype.tick = function(dt) {
  dt = dt / 1e3;
  var noGravity = equals2(0, import_gl_vec311.default.squaredLength(this.gravity));
  this.bodies.forEach((b) => iterateBody(this, b, dt, noGravity));
};
function iterateBody(self, b, dt, noGravity) {
  import_gl_vec311.default.copy(oldResting, b.resting);
  if (b.mass <= 0) {
    import_gl_vec311.default.set(b.velocity, 0, 0, 0);
    import_gl_vec311.default.set(b._forces, 0, 0, 0);
    import_gl_vec311.default.set(b._impulses, 0, 0, 0);
    return;
  }
  var localNoGrav = noGravity || b.gravityMultiplier === 0;
  if (bodyAsleep(self, b, dt, localNoGrav)) return;
  b._sleepFrameCount--;
  applyFluidForces(self, b);
  sanityCheck2(b._forces);
  sanityCheck2(b._impulses);
  sanityCheck2(b.velocity);
  sanityCheck2(b.resting);
  import_gl_vec311.default.scale(a, b._forces, 1 / b.mass);
  import_gl_vec311.default.scaleAndAdd(a, a, self.gravity, b.gravityMultiplier);
  import_gl_vec311.default.scale(dv, b._impulses, 1 / b.mass);
  import_gl_vec311.default.scaleAndAdd(dv, dv, a, dt);
  import_gl_vec311.default.add(b.velocity, b.velocity, dv);
  if (b.friction) {
    applyFrictionByAxis(0, b, dv);
    applyFrictionByAxis(1, b, dv);
    applyFrictionByAxis(2, b, dv);
  }
  var drag = b.airDrag >= 0 ? b.airDrag : self.airDrag;
  if (b.inFluid) {
    drag = b.fluidDrag >= 0 ? b.fluidDrag : self.fluidDrag;
    drag *= 1 - (1 - b.ratioInFluid) ** 2;
  }
  var mult = Math.max(1 - drag * dt / b.mass, 0);
  import_gl_vec311.default.scale(b.velocity, b.velocity, mult);
  import_gl_vec311.default.scale(dx, b.velocity, dt);
  import_gl_vec311.default.set(b._forces, 0, 0, 0);
  import_gl_vec311.default.set(b._impulses, 0, 0, 0);
  if (b.autoStep) {
    cloneAABB(tmpBox, b.aabb);
  }
  processCollisions(self, b.aabb, dx, b.resting);
  if (b.autoStep) {
    tryAutoStepping(self, b, tmpBox, dx);
  }
  for (var i = 0; i < 3; ++i) {
    impacts[i] = 0;
    if (b.resting[i]) {
      if (!oldResting[i]) impacts[i] = -b.velocity[i];
      b.velocity[i] = 0;
    }
  }
  var mag = import_gl_vec311.default.length(impacts);
  if (mag > 1e-3) {
    import_gl_vec311.default.scale(impacts, impacts, b.mass);
    if (b.onCollide) b.onCollide(impacts);
    if (b.restitution > 0 && mag > self.minBounceImpulse) {
      import_gl_vec311.default.scale(impacts, impacts, b.restitution);
      b.applyImpulse(impacts);
    }
  }
  var vsq = import_gl_vec311.default.squaredLength(b.velocity);
  if (vsq > 1e-5) b._markActive();
}
function applyFluidForces(self, body) {
  var box = body.aabb;
  var cx = Math.floor(box.base[0]);
  var cz = Math.floor(box.base[2]);
  var y0 = Math.floor(box.base[1]);
  var y1 = Math.floor(box.max[1]);
  if (!self.testFluid(cx, y0, cz)) {
    body.inFluid = false;
    body.ratioInFluid = 0;
    return;
  }
  var submerged = 1;
  var cy = y0 + 1;
  while (cy <= y1 && self.testFluid(cx, cy, cz)) {
    submerged++;
    cy++;
  }
  var fluidLevel = y0 + submerged;
  var heightInFluid = fluidLevel - box.base[1];
  var ratioInFluid = heightInFluid / box.vec[1];
  if (ratioInFluid > 1) ratioInFluid = 1;
  var vol = box.vec[0] * box.vec[1] * box.vec[2];
  var displaced = vol * ratioInFluid;
  var f = _fluidVec;
  import_gl_vec311.default.scale(f, self.gravity, -self.fluidDensity * displaced);
  body.applyForce(f);
  body.inFluid = true;
  body.ratioInFluid = ratioInFluid;
}
var _fluidVec = import_gl_vec311.default.create();
function applyFrictionByAxis(axis, body, dvel) {
  var restDir = body.resting[axis];
  var vNormal = dvel[axis];
  if (restDir === 0) return;
  if (restDir * vNormal <= 0) return;
  import_gl_vec311.default.copy(lateralVel, body.velocity);
  lateralVel[axis] = 0;
  var vCurr = import_gl_vec311.default.length(lateralVel);
  if (equals2(vCurr, 0)) return;
  var dvMax = Math.abs(body.friction * vNormal);
  var scaler = vCurr > dvMax ? (vCurr - dvMax) / vCurr : 0;
  body.velocity[(axis + 1) % 3] *= scaler;
  body.velocity[(axis + 2) % 3] *= scaler;
}
var lateralVel = import_gl_vec311.default.create();
function processCollisions(self, box, velocity, resting) {
  import_gl_vec311.default.set(resting, 0, 0, 0);
  return (0, import_voxel_aabb_sweep2.default)(self.testSolid, box, velocity, function(dist2, axis, dir, vec) {
    resting[axis] = dir;
    vec[axis] = 0;
  });
}
var tmpBox = new AABB([], []);
var tmpResting = import_gl_vec311.default.create();
var targetPos = import_gl_vec311.default.create();
var upvec = import_gl_vec311.default.create();
var leftover = import_gl_vec311.default.create();
function tryAutoStepping(self, b, oldBox, dx2) {
  if (b.resting[1] >= 0 && !b.inFluid) return;
  var xBlocked = b.resting[0] !== 0;
  var zBlocked = b.resting[2] !== 0;
  if (!(xBlocked || zBlocked)) return;
  var ratio = Math.abs(dx2[0] / dx2[2]);
  var cutoff = 4;
  if (!xBlocked && ratio > cutoff) return;
  if (!zBlocked && ratio < 1 / cutoff) return;
  import_gl_vec311.default.add(targetPos, oldBox.base, dx2);
  var getVoxels = self.testSolid;
  (0, import_voxel_aabb_sweep2.default)(getVoxels, oldBox, dx2, function(dist2, axis, dir, vec) {
    if (axis === 1) vec[axis] = 0;
    else return true;
  });
  var y = b.aabb.base[1];
  var ydist = Math.floor(y + 1.001) - y;
  import_gl_vec311.default.set(upvec, 0, ydist, 0);
  var collided = false;
  (0, import_voxel_aabb_sweep2.default)(getVoxels, oldBox, upvec, function(dist2, axis, dir, vec) {
    collided = true;
    return true;
  });
  if (collided) return;
  import_gl_vec311.default.subtract(leftover, targetPos, oldBox.base);
  leftover[1] = 0;
  processCollisions(self, oldBox, leftover, tmpResting);
  if (xBlocked && !equals2(oldBox.base[0], targetPos[0])) return;
  if (zBlocked && !equals2(oldBox.base[2], targetPos[2])) return;
  cloneAABB(b.aabb, oldBox);
  b.resting[0] = tmpResting[0];
  b.resting[2] = tmpResting[2];
  if (b.onStep) b.onStep();
}
function bodyAsleep(self, body, dt, noGravity) {
  if (body._sleepFrameCount > 0) return false;
  if (noGravity) return true;
  var isResting = false;
  var gmult = 0.5 * dt * dt * body.gravityMultiplier;
  import_gl_vec311.default.scale(sleepVec, self.gravity, gmult);
  (0, import_voxel_aabb_sweep2.default)(self.testSolid, body.aabb, sleepVec, function() {
    isResting = true;
    return true;
  }, true);
  return isResting;
}
var sleepVec = import_gl_vec311.default.create();
function equals2(a2, b) {
  return Math.abs(a2 - b) < 1e-5;
}
function cloneAABB(tgt, src) {
  for (var i = 0; i < 3; i++) {
    tgt.base[i] = src.base[i];
    tgt.max[i] = src.max[i];
    tgt.vec[i] = src.vec[i];
  }
}
var sanityCheck2 = function(v) {
};
if (DEBUG2) sanityCheck2 = function(v) {
  if (isNaN(import_gl_vec311.default.length(v))) throw "Vector with NAN: " + v;
};

// ../../node_modules/noa-engine/src/lib/physics.js
var defaultOptions3 = {
  gravity: [0, -10, 0],
  airDrag: 0.1
};
var Physics2 = class extends Physics {
  /** 
   * @internal 
   * @param {import('../index').Engine} noa
  */
  constructor(noa, opts) {
    opts = Object.assign({}, defaultOptions3, opts);
    var world = noa.world;
    var solidLookup = noa.registry._solidityLookup;
    var fluidLookup = noa.registry._fluidityLookup;
    var offset = noa.worldOriginOffset;
    var blockGetter = (x, y, z) => {
      var id = world.getBlockID(x + offset[0], y + offset[1], z + offset[2]);
      return solidLookup[id];
    };
    var isFluidGetter = (x, y, z) => {
      var id = world.getBlockID(x + offset[0], y + offset[1], z + offset[2]);
      return fluidLookup[id];
    };
    super(opts, blockGetter, isFluidGetter);
  }
};

// ../../node_modules/noa-engine/src/lib/world.js
var import_events3 = __toESM(require_events());

// ../../node_modules/noa-engine/src/lib/chunk.js
var import_ndarray2 = __toESM(require_ndarray());
function Chunk(noa, requestID, ci, cj, ck, size, dataArray, fillVoxelID = -1) {
  this.noa = noa;
  this.isDisposed = false;
  this.userData = null;
  this.requestID = requestID;
  this.voxels = dataArray;
  this.i = ci;
  this.j = cj;
  this.k = ck;
  this.size = size;
  this.x = ci * size;
  this.y = cj * size;
  this.z = ck * size;
  this.pos = [this.x, this.y, this.z];
  this._terrainDirty = false;
  this._objectsDirty = false;
  this._terrainMeshes = [];
  noa._terrainMesher.initChunk(this);
  noa._objectMesher.initChunk(this);
  this._isFull = false;
  this._isEmpty = false;
  this._wholeLayerVoxel = Array(size).fill(-1);
  if (fillVoxelID >= 0) {
    this.voxels.data.fill(fillVoxelID, 0, this.voxels.size);
    this._wholeLayerVoxel.fill(fillVoxelID);
  }
  var narr = Array.from(Array(27), () => null);
  this._neighbors = (0, import_ndarray2.default)(narr, [3, 3, 3]).lo(1, 1, 1);
  this._neighbors.set(0, 0, 0, this);
  this._neighborCount = 0;
  this._timesMeshed = 0;
  this._blockHandlerLocs = new LocationQueue();
  scanVoxelData(this);
}
Chunk._createVoxelArray = function(size) {
  var arr = new Uint16Array(size * size * size);
  return (0, import_ndarray2.default)(arr, [size, size, size]);
};
Chunk.prototype._updateVoxelArray = function(dataArray, fillVoxelID = -1) {
  callAllBlockHandlers(this, "onUnload");
  this.noa._objectMesher.disposeChunk(this);
  this.noa._terrainMesher.disposeChunk(this);
  this.voxels = dataArray;
  this._terrainDirty = false;
  this._objectsDirty = false;
  this._blockHandlerLocs.empty();
  this.noa._objectMesher.initChunk(this);
  this.noa._terrainMesher.initChunk(this);
  if (fillVoxelID >= 0) {
    this._wholeLayerVoxel.fill(fillVoxelID);
  } else {
    this._wholeLayerVoxel.fill(-1);
  }
  scanVoxelData(this);
};
Chunk.prototype.get = function(i, j, k) {
  return this.voxels.get(i, j, k);
};
Chunk.prototype.getSolidityAt = function(i, j, k) {
  var solidLookup = this.noa.registry._solidityLookup;
  return solidLookup[this.voxels.get(i, j, k)];
};
Chunk.prototype.set = function(i, j, k, newID) {
  var oldID = this.voxels.get(i, j, k);
  if (newID === oldID) return;
  this.voxels.set(i, j, k, newID);
  var solidLookup = this.noa.registry._solidityLookup;
  var objectLookup = this.noa.registry._objectLookup;
  var opaqueLookup = this.noa.registry._opacityLookup;
  var handlerLookup = this.noa.registry._blockHandlerLookup;
  if (!opaqueLookup[newID]) this._isFull = false;
  if (newID !== 0) this._isEmpty = false;
  if (this._wholeLayerVoxel[j] !== newID) this._wholeLayerVoxel[j] = -1;
  var hold = handlerLookup[oldID];
  var hnew = handlerLookup[newID];
  if (hold) callBlockHandler(this, hold, "onUnset", i, j, k);
  if (hnew) {
    callBlockHandler(this, hnew, "onSet", i, j, k);
    this._blockHandlerLocs.add(i, j, k);
  } else {
    this._blockHandlerLocs.remove(i, j, k);
  }
  var objMesher = this.noa._objectMesher;
  var objOld = objectLookup[oldID];
  var objNew = objectLookup[newID];
  if (objOld) objMesher.setObjectBlock(this, 0, i, j, k);
  if (objNew) objMesher.setObjectBlock(this, newID, i, j, k);
  var solidityChanged = solidLookup[oldID] !== solidLookup[newID];
  var opacityChanged = opaqueLookup[oldID] !== opaqueLookup[newID];
  var wasTerrain = !objOld && oldID !== 0;
  var nowTerrain = !objNew && newID !== 0;
  if (objOld || objNew) this._objectsDirty = true;
  if (solidityChanged || opacityChanged || wasTerrain || nowTerrain) {
    this._terrainDirty = true;
  }
  if (this._terrainDirty || this._objectsDirty) {
    this.noa.world._queueChunkForRemesh(this);
  }
  if (solidityChanged || opacityChanged) {
    var edge = this.size - 1;
    var imin = i === 0 ? -1 : 0;
    var jmin = j === 0 ? -1 : 0;
    var kmin = k === 0 ? -1 : 0;
    var imax = i === edge ? 1 : 0;
    var jmax = j === edge ? 1 : 0;
    var kmax = k === edge ? 1 : 0;
    for (var ni = imin; ni <= imax; ni++) {
      for (var nj = jmin; nj <= jmax; nj++) {
        for (var nk = kmin; nk <= kmax; nk++) {
          if ((ni | nj | nk) === 0) continue;
          var nab = this._neighbors.get(ni, nj, nk);
          if (!nab) continue;
          nab._terrainDirty = true;
          this.noa.world._queueChunkForRemesh(nab);
        }
      }
    }
  }
};
function callBlockHandler(chunk, handlers, type, i, j, k) {
  var handler = handlers[type];
  if (!handler) return;
  handler(chunk.x + i, chunk.y + j, chunk.z + k);
}
Chunk.prototype.updateMeshes = function() {
  if (this._terrainDirty) {
    this.noa._terrainMesher.meshChunk(this);
    this._timesMeshed++;
    this._terrainDirty = false;
  }
  if (this._objectsDirty) {
    this.noa._objectMesher.buildObjectMeshes();
    this._objectsDirty = false;
  }
};
function scanVoxelData(chunk) {
  var voxels = chunk.voxels;
  var data = voxels.data;
  var len2 = voxels.shape[0];
  var opaqueLookup = chunk.noa.registry._opacityLookup;
  var handlerLookup = chunk.noa.registry._blockHandlerLookup;
  var objectLookup = chunk.noa.registry._objectLookup;
  var plainLookup = chunk.noa.registry._blockIsPlainLookup;
  var objMesher = chunk.noa._objectMesher;
  var fullyOpaque = true;
  var fullyAir = true;
  for (var j = 0; j < len2; ++j) {
    var layerID = chunk._wholeLayerVoxel[j];
    if (layerID >= 0 && !objMesher[layerID] && !handlerLookup[layerID]) {
      if (!opaqueLookup[layerID]) fullyOpaque = false;
      if (layerID !== 0) fullyAir = false;
      continue;
    }
    var constantID = voxels.get(0, j, 0);
    for (var i = 0; i < len2; ++i) {
      var index = voxels.index(i, j, 0);
      for (var k = 0; k < len2; ++k, ++index) {
        var id = data[index];
        if (constantID >= 0 && id !== constantID) constantID = -1;
        if (id === 0) {
          fullyOpaque = false;
          continue;
        }
        if (plainLookup[id]) {
          fullyAir = false;
          continue;
        }
        fullyOpaque = fullyOpaque && opaqueLookup[id];
        fullyAir = false;
        if (objectLookup[id]) {
          objMesher.setObjectBlock(chunk, id, i, j, k);
          chunk._objectsDirty = true;
        }
        var handlers = handlerLookup[id];
        if (handlers) {
          chunk._blockHandlerLocs.add(i, j, k);
          callBlockHandler(chunk, handlers, "onLoad", i, j, k);
        }
      }
    }
    if (constantID >= 0) chunk._wholeLayerVoxel[j] = constantID;
  }
  chunk._isFull = fullyOpaque;
  chunk._isEmpty = fullyAir;
  chunk._terrainDirty = !chunk._isEmpty;
}
Chunk.prototype.dispose = function() {
  callAllBlockHandlers(this, "onUnload");
  this._blockHandlerLocs.empty();
  this.noa._objectMesher.disposeChunk(this);
  this.noa._terrainMesher.disposeChunk(this);
  this.voxels.data = null;
  this.voxels = null;
  this._neighbors.data = null;
  this._neighbors = null;
  this.isDisposed = true;
};
function callAllBlockHandlers(chunk, type) {
  var voxels = chunk.voxels;
  var handlerLookup = chunk.noa.registry._blockHandlerLookup;
  chunk._blockHandlerLocs.arr.forEach(([i, j, k]) => {
    var id = voxels.get(i, j, k);
    callBlockHandler(chunk, handlerLookup[id], type, i, j, k);
  });
}

// ../../node_modules/noa-engine/src/lib/world.js
var PROFILE_EVERY2 = 0;
var PROFILE_QUEUES_EVERY = 0;
var defaultOptions4 = {
  chunkSize: 24,
  chunkAddDistance: [2, 2],
  // [horizontal, vertical]
  chunkRemoveDistance: [3, 3],
  // [horizontal, vertical]
  worldGenWhilePaused: false,
  manuallyControlChunkLoading: false
};
var World = class extends import_events3.default {
  /** @internal */
  constructor(noa, opts) {
    super();
    opts = Object.assign({}, defaultOptions4, opts);
    this.noa = noa;
    this.playerChunkLoaded = false;
    this.Chunk = Chunk;
    this.manuallyControlChunkLoading = !!opts.manuallyControlChunkLoading;
    this.chunkSortingDistFn = defaultSortDistance;
    this.minNeighborsToMesh = 6;
    this.worldGenWhilePaused = !!opts.worldGenWhilePaused;
    this.maxChunksPendingCreation = 50;
    this.maxChunksPendingMeshing = 50;
    this.maxProcessingPerTick = 5;
    this.maxProcessingPerRender = 3;
    this._chunkSize = opts.chunkSize;
    this._chunkAddDistance = [2, 2];
    this._chunkRemoveDistance = [3, 3];
    this._addDistanceFn = null;
    this._remDistanceFn = null;
    this._prevWorldName = "";
    this._prevPlayerChunkHash = 0;
    this._chunkAddSearchFrom = 0;
    this._prevSortingFn = null;
    this._sortMeshQueueEvery = 0;
    this._chunksKnown = new LocationQueue();
    this._chunksToRequest = new LocationQueue();
    this._chunksInvalidated = new LocationQueue();
    this._chunksToRemove = new LocationQueue();
    this._chunksPending = new LocationQueue();
    this._chunksToMesh = new LocationQueue();
    this._chunksToMeshFirst = new LocationQueue();
    this._chunksSortedLocs = new LocationQueue();
    this.setAddRemoveDistance(opts.chunkAddDistance, opts.chunkRemoveDistance);
    this._storage = new ChunkStorage();
    var cs = this._chunkSize;
    this._coordsToChunkIndexes = chunkCoordsToIndexesGeneral;
    this._coordsToChunkLocals = chunkCoordsToLocalsGeneral;
    var powerOfTwo = (cs & cs - 1) === 0;
    if (powerOfTwo) {
      this._coordShiftBits = Math.log2(cs) | 0;
      this._coordMask = cs - 1 | 0;
      this._coordsToChunkIndexes = chunkCoordsToIndexesPowerOfTwo;
      this._coordsToChunkLocals = chunkCoordsToLocalsPowerOfTwo;
    }
  }
};
World.prototype.getBlockID = function(x = 0, y = 0, z = 0) {
  var [ci, cj, ck] = this._coordsToChunkIndexes(x, y, z);
  var chunk = this._storage.getChunkByIndexes(ci, cj, ck);
  if (!chunk) return 0;
  var [i, j, k] = this._coordsToChunkLocals(x, y, z);
  return chunk.voxels.get(i, j, k);
};
World.prototype.getBlockSolidity = function(x = 0, y = 0, z = 0) {
  var [ci, cj, ck] = this._coordsToChunkIndexes(x, y, z);
  var chunk = this._storage.getChunkByIndexes(ci, cj, ck);
  if (!chunk) return false;
  var [i, j, k] = this._coordsToChunkLocals(x, y, z);
  return !!chunk.getSolidityAt(i, j, k);
};
World.prototype.getBlockOpacity = function(x = 0, y = 0, z = 0) {
  var id = this.getBlockID(x, y, z);
  return this.noa.registry.getBlockOpacity(id);
};
World.prototype.getBlockFluidity = function(x = 0, y = 0, z = 0) {
  var id = this.getBlockID(x, y, z);
  return this.noa.registry.getBlockFluidity(id);
};
World.prototype.getBlockProperties = function(x = 0, y = 0, z = 0) {
  var id = this.getBlockID(x, y, z);
  return this.noa.registry.getBlockProps(id);
};
World.prototype.setBlockID = function(id = 0, x = 0, y = 0, z = 0) {
  var [ci, cj, ck] = this._coordsToChunkIndexes(x, y, z);
  var chunk = this._storage.getChunkByIndexes(ci, cj, ck);
  if (!chunk) return;
  var [i, j, k] = this._coordsToChunkLocals(x, y, z);
  return chunk.set(i, j, k, id);
};
World.prototype.isBoxUnobstructed = function(box) {
  var base = box.base;
  var max2 = box.max;
  for (var i = Math.floor(base[0]); i < max2[0] + 1; i++) {
    for (var j = Math.floor(base[1]); j < max2[1] + 1; j++) {
      for (var k = Math.floor(base[2]); k < max2[2] + 1; k++) {
        if (this.getBlockSolidity(i, j, k)) return false;
      }
    }
  }
  return true;
};
World.prototype.setChunkData = function(id, array, userData = null, fillVoxelID = -1) {
  setChunkData(this, id, array, userData, fillVoxelID);
};
World.prototype.setAddRemoveDistance = function(addDist = 2, remDist = 3) {
  var addArr = Array.isArray(addDist) ? addDist : [addDist, addDist];
  var remArr = Array.isArray(remDist) ? remDist : [remDist, remDist];
  var minGap = 1;
  if (remArr[0] < addArr[0] + minGap) remArr[0] = addArr[0] + minGap;
  if (remArr[1] < addArr[1] + minGap) remArr[1] = addArr[1] + minGap;
  this._chunkAddDistance = addArr;
  this._chunkRemoveDistance = remArr;
  this._addDistanceFn = makeDistanceTestFunction(addArr[0], addArr[1]);
  this._remDistanceFn = makeDistanceTestFunction(remArr[0], remArr[1]);
  this._chunksSortedLocs.empty();
  for (var i = 0; i <= addArr[0]; i++) {
    for (var k = 0; k <= i; k++) {
      for (var j = 0; j <= addArr[1]; j++) {
        if (!this._addDistanceFn(i, j, k)) continue;
        this._chunksSortedLocs.add(i, j, k);
      }
    }
  }
  this._prevSortingFn = null;
  this._chunkAddSearchFrom = 0;
};
World.prototype.invalidateVoxelsInAABB = function(box) {
  invalidateChunksInBox(this, box);
};
World.prototype.manuallyLoadChunk = function(x = 0, y = 0, z = 0) {
  if (!this.manuallyControlChunkLoading) throw manualErr;
  var [i, j, k] = this._coordsToChunkIndexes(x, y, z);
  this._chunksKnown.add(i, j, k);
  this._chunksToRequest.add(i, j, k);
};
World.prototype.manuallyUnloadChunk = function(x = 0, y = 0, z = 0) {
  if (!this.manuallyControlChunkLoading) throw manualErr;
  var [i, j, k] = this._coordsToChunkIndexes(x, y, z);
  this._chunksToRemove.add(i, j, k);
  this._chunksToMesh.remove(i, j, k);
  this._chunksToRequest.remove(i, j, k);
  this._chunksToMeshFirst.remove(i, j, k);
};
var manualErr = "Set `noa.world.manuallyControlChunkLoading` if you need this API";
World.prototype.tick = function() {
  var tickStartTime = performance.now();
  var [ci, cj, ck] = getPlayerChunkIndexes(this);
  var chunkLocHash = locationHasher(ci, cj, ck);
  var changedChunks = chunkLocHash !== this._prevPlayerChunkHash;
  if (changedChunks) {
    this.emit("playerEnteredChunk", ci, cj, ck);
    this._prevPlayerChunkHash = chunkLocHash;
    this._chunkAddSearchFrom = 0;
  }
  if (this._prevWorldName !== this.noa.worldName) {
    if (!this.manuallyControlChunkLoading) {
      markAllChunksInvalid(this);
      this._chunkAddSearchFrom = 0;
      processRemoveQueue(this);
    }
    this._prevWorldName = this.noa.worldName;
  }
  profile_hook4("start");
  profile_queues_hook("start");
  if (!this.manuallyControlChunkLoading) {
    findDistantChunksToRemove(this, ci, cj, ck);
    profile_hook4("remQueue");
    findChunksToRequest(this, ci, cj, ck);
    profile_hook4("addQueue");
  }
  findChunksToMesh(this);
  var t = performance.now();
  var t1 = tickStartTime + (this.maxProcessingPerTick || 0);
  if (t < t1) t1 = t + 1;
  var done1 = false;
  var done2 = false;
  var done3 = false;
  while (t < t1) {
    if (!done1) {
      done1 = processRemoveQueue(this) || processRemoveQueue(this);
      profile_hook4("removes");
    }
    if (!done2) {
      done2 = processRequestQueue(this);
      profile_hook4("requests");
    }
    if (!done3) {
      done3 = processMeshingQueue(this, false);
      profile_hook4("meshes");
    }
    if (done1 && done2 && done3) break;
    t = performance.now();
  }
  var pChunk = this._storage.getChunkByIndexes(ci, cj, ck);
  this.playerChunkLoaded = !!pChunk;
  profile_queues_hook("end", this);
  profile_hook4("end");
};
World.prototype.render = function() {
  var t = performance.now();
  var t1 = t + this.maxProcessingPerRender;
  while (t < t1) {
    var done = processMeshingQueue(this, true);
    if (done) break;
    t = performance.now();
  }
};
World.prototype._getChunkByCoords = function(x = 0, y = 0, z = 0) {
  var [i, j, k] = this._coordsToChunkIndexes(x, y, z);
  return this._storage.getChunkByIndexes(i, j, k);
};
World.prototype._queueChunkForRemesh = function(chunk) {
  possiblyQueueChunkForMeshing(this, chunk);
};
function getPlayerChunkIndexes(world) {
  var [x, y, z] = world.noa.entities.getPosition(world.noa.playerEntity);
  return world._coordsToChunkIndexes(x, y, z);
}
function findChunksToRequest(world, ci, cj, ck) {
  var toRequest = world._chunksToRequest;
  var numQueued = toRequest.count();
  var maxQueued = 50;
  if (numQueued >= maxQueued) return;
  var sortDistFn = world.chunkSortingDistFn || defaultSortDistance;
  if (sortDistFn !== world._prevSortingFn) {
    sortQueueByDistanceFrom(world, world._chunksSortedLocs, 0, 0, 0, true);
    world._prevSortingFn = sortDistFn;
  }
  var locsArr = world._chunksSortedLocs.arr;
  var ix = world._chunkAddSearchFrom;
  var maxIter = Math.min(20, locsArr.length / 10);
  for (var ct = 0; ct < maxIter; ct++) {
    var [di, dj, dk] = locsArr[ix++ % locsArr.length];
    checkReflectedLocations(world, ci, cj, ck, di, dj, dk);
    if (toRequest.count() >= maxQueued) break;
  }
  if (world._chunksInvalidated.isEmpty()) {
    world._chunkAddSearchFrom = ix % locsArr.length;
  }
  sortQueueByDistanceFrom(world, toRequest, ci, cj, ck, false);
}
var checkReflectedLocations = (world, ci, cj, ck, i, j, k) => {
  checkOneLocation(world, ci + i, cj + j, ck + k);
  if (i !== k) checkOneLocation(world, ci + k, cj + j, ck + i);
  if (i > 0) checkReflectedLocations(world, ci, cj, ck, -i, j, k);
  if (j > 0) checkReflectedLocations(world, ci, cj, ck, i, -j, k);
  if (k > 0) checkReflectedLocations(world, ci, cj, ck, i, j, -k);
};
var checkOneLocation = (world, i, j, k) => {
  if (world._chunksKnown.includes(i, j, k)) return;
  world._chunksKnown.add(i, j, k);
  world._chunksToRequest.add(i, j, k, true);
};
function findDistantChunksToRemove(world, ci, cj, ck) {
  var distCheck = world._remDistanceFn;
  var toRemove = world._chunksToRemove;
  var numQueued = toRemove.count() + world._chunksInvalidated.count();
  var maxQueued = 50;
  if (numQueued >= maxQueued) return;
  var knownArr = world._chunksKnown.arr;
  if (knownArr.length === 0) return;
  var maxIter = Math.min(100, knownArr.length / 10);
  var found = false;
  for (var ct = 0; ct < maxIter; ct++) {
    var [i, j, k] = knownArr[removeCheckIndex++ % knownArr.length];
    if (toRemove.includes(i, j, k)) continue;
    if (distCheck(i - ci, j - cj, k - ck)) continue;
    world._chunksToRemove.add(i, j, k);
    world._chunksToRequest.remove(i, j, k);
    world._chunksToMesh.remove(i, j, k);
    world._chunksToMeshFirst.remove(i, j, k);
    found = true;
    numQueued++;
    if (numQueued > maxQueued) break;
  }
  removeCheckIndex = removeCheckIndex % knownArr.length;
  if (found) sortQueueByDistanceFrom(world, toRemove, ci, cj, ck);
}
var removeCheckIndex = 0;
function findChunksToMesh(world) {
  var maxQueued = 10;
  var numQueued = world._chunksToMesh.count() + world._chunksToMeshFirst.count();
  if (numQueued > maxQueued) return;
  var knownArr = world._chunksKnown.arr;
  var maxIter = Math.min(50, knownArr.length / 10);
  for (var ct = 0; ct < maxIter; ct++) {
    var [i, j, k] = knownArr[meshCheckIndex++ % knownArr.length];
    var chunk = world._storage.getChunkByIndexes(i, j, k);
    if (!chunk) continue;
    var res = possiblyQueueChunkForMeshing(world, chunk);
    if (res) numQueued++;
    if (numQueued > maxQueued) break;
  }
  meshCheckIndex %= knownArr.length;
}
var meshCheckIndex = 0;
function invalidateChunksInBox(world, box) {
  var min2 = world._coordsToChunkIndexes(box.base[0], box.base[1], box.base[2]);
  var max2 = world._coordsToChunkIndexes(box.max[0], box.max[1], box.max[2]);
  for (var i = 0; i < 3; i++) {
    if (!Number.isFinite(box.base[i])) min2[i] = box.base[i];
    if (!Number.isFinite(box.max[i])) max2[i] = box.max[i];
  }
  world._chunksKnown.forEach((loc) => {
    var [i2, j, k] = loc;
    if (i2 < min2[0] || i2 >= max2[0]) return;
    if (j < min2[1] || j >= max2[1]) return;
    if (k < min2[2] || k >= max2[2]) return;
    world._chunksInvalidated.add(i2, j, k);
    world._chunksToRemove.remove(i2, j, k);
    world._chunksToRequest.remove(i2, j, k);
    world._chunksToMesh.remove(i2, j, k);
    world._chunksToMeshFirst.remove(i2, j, k);
  });
}
function markAllChunksInvalid(world) {
  world._chunksInvalidated.copyFrom(world._chunksKnown);
  world._chunksToRemove.empty();
  world._chunksToRequest.empty();
  world._chunksToMesh.empty();
  world._chunksToMeshFirst.empty();
  sortQueueByDistanceFrom(world, world._chunksInvalidated);
}
function processRequestQueue(world) {
  var toRequest = world._chunksToRequest;
  if (toRequest.isEmpty()) return true;
  var pending = world._chunksPending.count();
  var toMesh = world._chunksToMesh.count();
  if (pending >= world.maxChunksPendingCreation) return true;
  if (toMesh >= world.maxChunksPendingMeshing) return true;
  var [i, j, k] = toRequest.pop();
  requestNewChunk(world, i, j, k);
  return toRequest.isEmpty();
}
function processRemoveQueue(world) {
  var queue = world._chunksInvalidated;
  if (queue.isEmpty()) queue = world._chunksToRemove;
  if (queue.isEmpty()) return true;
  var [i, j, k] = queue.pop();
  removeChunk(world, i, j, k);
  return queue.isEmpty();
}
function processMeshingQueue(world, firstOnly) {
  var queue = world._chunksToMeshFirst;
  if (queue.isEmpty() && !firstOnly) queue = world._chunksToMesh;
  if (queue.isEmpty()) return true;
  var [i, j, k] = queue.pop();
  if (world._chunksToRemove.includes(i, j, k)) return;
  var chunk = world._storage.getChunkByIndexes(i, j, k);
  if (chunk) doChunkRemesh(world, chunk);
}
function possiblyQueueChunkForMeshing(world, chunk) {
  if (!(chunk._terrainDirty || chunk._objectsDirty)) return false;
  if (chunk._neighborCount < chunk.minNeighborsToMesh) return false;
  if (world._chunksToMesh.includes(chunk.i, chunk.j, chunk.k)) return false;
  if (world._chunksToMeshFirst.includes(chunk.i, chunk.j, chunk.k)) return false;
  var queue = chunk._neighborCount === 26 ? world._chunksToMeshFirst : world._chunksToMesh;
  queue.add(chunk.i, chunk.j, chunk.k);
  world._sortMeshQueueEvery++;
  if (world._sortMeshQueueEvery > 20) {
    sortQueueByDistanceFrom(world, queue);
    world._sortMeshQueueEvery = 0;
  }
  return true;
}
function requestNewChunk(world, i, j, k) {
  var size = world._chunkSize;
  var dataArr = Chunk._createVoxelArray(world._chunkSize);
  var worldName = world.noa.worldName;
  var requestID = [i, j, k, worldName].join("|");
  var x = i * size;
  var y = j * size;
  var z = k * size;
  world._chunksPending.add(i, j, k);
  world.emit("worldDataNeeded", requestID, dataArr, x, y, z, worldName);
  profile_queues_hook("request");
}
function setChunkData(world, reqID, array, userData, fillVoxelID) {
  var arr = reqID.split("|");
  var i = parseInt(arr.shift());
  var j = parseInt(arr.shift());
  var k = parseInt(arr.shift());
  var worldName = arr.join("|");
  world._chunksPending.remove(i, j, k);
  if (worldName !== world.noa.worldName) return;
  if (!world._chunksKnown.includes(i, j, k)) return;
  if (world._chunksToRemove.includes(i, j, k)) return;
  var chunk = world._storage.getChunkByIndexes(i, j, k);
  if (!chunk) {
    var size = world._chunkSize;
    chunk = new Chunk(world.noa, reqID, i, j, k, size, array, fillVoxelID);
    world._storage.storeChunkByIndexes(i, j, k, chunk);
    chunk.userData = userData;
    world.noa.rendering.prepareChunkForRendering(chunk);
    world.emit("chunkAdded", chunk);
  } else {
    chunk._updateVoxelArray(array, fillVoxelID);
  }
  possiblyQueueChunkForMeshing(world, chunk);
  updateNeighborsOfChunk(world, i, j, k, chunk);
  profile_queues_hook("receive");
}
function removeChunk(world, i, j, k) {
  var chunk = world._storage.getChunkByIndexes(i, j, k);
  if (chunk) {
    world.emit("chunkBeingRemoved", chunk.requestID, chunk.voxels, chunk.userData);
    world.noa.rendering.disposeChunkForRendering(chunk);
    chunk.dispose();
    profile_queues_hook("dispose");
    updateNeighborsOfChunk(world, i, j, k, null);
  }
  world._storage.removeChunkByIndexes(i, j, k);
  world._chunksKnown.remove(i, j, k);
  world._chunksToMesh.remove(i, j, k);
  world._chunksToRemove.remove(i, j, k);
  world._chunksToMeshFirst.remove(i, j, k);
}
function doChunkRemesh(world, chunk) {
  world._chunksToMesh.remove(chunk.i, chunk.j, chunk.k);
  world._chunksToMeshFirst.remove(chunk.i, chunk.j, chunk.k);
  chunk.updateMeshes();
  profile_queues_hook("mesh");
}
function chunkCoordsToIndexesGeneral(x, y, z) {
  var cs = this._chunkSize;
  return [Math.floor(x / cs) | 0, Math.floor(y / cs) | 0, Math.floor(z / cs) | 0];
}
function chunkCoordsToLocalsGeneral(x, y, z) {
  var cs = this._chunkSize;
  var i = x % cs | 0;
  if (i < 0) i += cs;
  var j = y % cs | 0;
  if (j < 0) j += cs;
  var k = z % cs | 0;
  if (k < 0) k += cs;
  return [i, j, k];
}
function chunkCoordsToIndexesPowerOfTwo(x, y, z) {
  var shift = this._coordShiftBits;
  return [x >> shift | 0, y >> shift | 0, z >> shift | 0];
}
function chunkCoordsToLocalsPowerOfTwo(x, y, z) {
  var mask = this._coordMask;
  return [x & mask | 0, y & mask | 0, z & mask | 0];
}
function sortQueueByDistanceFrom(world, queue, pi, pj, pk, reverse = false) {
  var distFn = world.chunkSortingDistFn || defaultSortDistance;
  var localDist = (i, j, k) => distFn(pi - i, pj - j, pk - k);
  if (pi === void 0) {
    [pi, pj, pk] = getPlayerChunkIndexes(world);
  }
  queue.sortByDistance(localDist, reverse);
}
var defaultSortDistance = (i, j, k) => i * i + j * j + k * k;
function updateNeighborsOfChunk(world, ci, cj, ck, chunk) {
  var terrainChanged = !chunk || chunk && !chunk.isEmpty;
  for (var i = -1; i <= 1; i++) {
    for (var j = -1; j <= 1; j++) {
      for (var k = -1; k <= 1; k++) {
        if ((i | j | k) === 0) continue;
        var neighbor = world._storage.getChunkByIndexes(ci + i, cj + j, ck + k);
        if (!neighbor) continue;
        if (terrainChanged) neighbor._terrainDirty = true;
        if (chunk && !chunk._neighbors.get(i, j, k)) {
          chunk._neighborCount++;
          chunk._neighbors.set(i, j, k, neighbor);
        }
        var nabRef = neighbor._neighbors.get(-i, -j, -k);
        if (chunk && !nabRef) {
          neighbor._neighborCount++;
          neighbor._neighbors.set(-i, -j, -k, chunk);
          if (neighbor._neighborCount === 26) {
            possiblyQueueChunkForMeshing(world, neighbor);
          }
        }
        if (!chunk && nabRef) {
          neighbor._neighborCount--;
          neighbor._neighbors.set(-i, -j, -k, null);
        }
      }
    }
  }
}
function makeDistanceTestFunction(xsize, ysize) {
  var asq = xsize * xsize;
  var bsq = ysize * ysize;
  if (xsize === ysize) return (i, j, k) => i * i + j * j + k * k <= asq;
  if (xsize > ysize) return (i, j, k) => {
    if (Math.abs(j) > ysize) return false;
    return i * i + j * j + k * k <= asq;
  };
  return (i, j, k) => {
    var dxsq = i * i + k * k;
    if (dxsq > asq) return false;
    return dxsq + j * j <= bsq;
  };
}
World.prototype.report = function() {
  console.log("World report - playerChunkLoaded: ", this.playerChunkLoaded);
  _report(this, "  known:     ", this._chunksKnown.arr, true);
  _report(this, "  to request:", this._chunksToRequest.arr, 0);
  _report(this, "  to remove: ", this._chunksToRemove.arr, 0);
  _report(this, "  invalid:   ", this._chunksInvalidated.arr, 0);
  _report(this, "  creating:  ", this._chunksPending.arr, 0);
  _report(this, "  to mesh:   ", this._chunksToMesh.arr, 0);
  _report(this, "  mesh 1st:  ", this._chunksToMeshFirst.arr, 0);
};
function _report(world, name66, arr, ext) {
  var full = 0, empty = 0, exist = 0, surrounded = 0, remeshes = [];
  arr.forEach((loc) => {
    var chunk = world._storage.getChunkByIndexes(loc[0], loc[1], loc[2]);
    if (!chunk) return;
    exist++;
    remeshes.push(chunk._timesMeshed);
    if (chunk._isFull) full++;
    if (chunk._isEmpty) empty++;
    if (chunk._neighborCount === 26) surrounded++;
  });
  var out = arr.length.toString().padEnd(8);
  out += ("exist: " + exist).padEnd(12);
  out += ("full: " + full).padEnd(12);
  out += ("empty: " + empty).padEnd(12);
  out += ("surr: " + surrounded).padEnd(12);
  if (ext) {
    var sum = remeshes.reduce((acc, val) => acc + val, 0);
    var max2 = remeshes.reduce((acc, val) => Math.max(acc, val), 0);
    var min2 = remeshes.reduce((acc, val) => Math.min(acc, val), 0);
    out += "times meshed: avg " + (sum / exist).toFixed(2);
    out += "  max " + max2;
    out += "  min " + min2;
  }
  console.log(name66, out);
}
var profile_hook4 = makeProfileHook(PROFILE_EVERY2, "world ticks:", 1);
var profile_queues_hook = ((every) => {
  if (!(every > 0)) return () => {
  };
  var iter = 0;
  var counts = {};
  var queues = {};
  var started = performance.now();
  return function profile_queues_hook2(state, world) {
    if (state === "start") return;
    if (state !== "end") return counts[state] = (counts[state] || 0) + 1;
    queues.toreq = (queues.toreq || 0) + world._chunksToRequest.count();
    queues.toget = (queues.toget || 0) + world._chunksPending.count();
    queues.tomesh = (queues.tomesh || 0) + world._chunksToMesh.count() + world._chunksToMeshFirst.count();
    queues.tomesh1 = (queues.tomesh1 || 0) + world._chunksToMeshFirst.count();
    queues.torem = (queues.torem || 0) + world._chunksToRemove.count();
    if (++iter < every) return;
    var t = performance.now(), dt = t - started;
    var res = {};
    Object.keys(queues).forEach((k) => {
      var num = Math.round((queues[k] || 0) / iter);
      res[k] = `[${num}]`.padStart(5);
    });
    Object.keys(counts).forEach((k) => {
      var num = Math.round((counts[k] || 0) * 1e3 / dt);
      res[k] = ("" + num).padStart(3);
    });
    console.log(
      "chunk flow: ",
      `${res.toreq}-> ${res.request || 0} req/s  `,
      `${res.toget}-> ${res.receive || 0} got/s  `,
      `${res.tomesh}-> ${res.mesh || 0} mesh/s  `,
      `${res.torem}-> ${res.dispose || 0} rem/s  `,
      `(meshFirst: ${res.tomesh1.trim()})`
    );
    iter = 0;
    counts = {};
    queues = {};
    started = performance.now();
  };
})(PROFILE_QUEUES_EVERY);

// ../../node_modules/noa-engine/package.json
var package_default2 = {
  name: "noa-engine",
  version: "0.33.0",
  description: "Experimental voxel game engine",
  main: "src/index.js",
  typings: "dist/src/index.d.ts",
  files: [
    "/src",
    "/dist"
  ],
  scripts: {
    build: "npm run types; npm run docs",
    types: "tsc",
    docs: "typedoc"
  },
  author: "Andy Hall (https://fenomas.com)",
  license: "MIT",
  repository: {
    type: "git",
    url: "https://github.com/fenomas/noa.git"
  },
  bugs: {
    url: "https://github.com/fenomas/noa/issues"
  },
  dependencies: {
    "aabb-3d": "fenomas/aabb-3d",
    "box-intersect": "fenomas/box-intersect",
    "ent-comp": "^0.11.0",
    events: "^3.3.0",
    "fast-voxel-raycast": "^0.1.1",
    "game-inputs": "^0.8.0",
    "gl-vec3": "^1.1.3",
    "micro-game-shell": "^0.9.0",
    ndarray: "^1.0.19",
    "voxel-aabb-sweep": "^0.5.0",
    "voxel-physics-engine": "^0.13.0"
  },
  peerDependencies: {
    "@babylonjs/core": "^6.1.0"
  },
  devDependencies: {
    eslint: "^8.3.0",
    "js-beautify": "^1.14.0",
    typedoc: "^0.24.6",
    "typedoc-plugin-missing-exports": "^2.0.0",
    typescript: "^5.0.4"
  },
  keywords: [
    "voxel",
    "voxels",
    "game",
    "engine",
    "game-engine"
  ]
};

// ../../node_modules/noa-engine/src/index.js
var version2 = package_default2.version;
var PROFILE3 = 0;
var PROFILE_RENDER = 0;
var defaultOptions5 = {
  debug: false,
  silent: false,
  silentBabylon: false,
  playerHeight: 1.8,
  playerWidth: 0.6,
  playerStart: [0, 10, 0],
  playerAutoStep: false,
  playerShadowComponent: true,
  tickRate: 30,
  // ticks per second
  maxRenderRate: 0,
  // max FPS, 0 for uncapped 
  blockTestDistance: 10,
  stickyPointerLock: true,
  dragCameraOutsidePointerLock: true,
  stickyFullscreen: false,
  skipDefaultHighlighting: false,
  originRebaseDistance: 25
};
var Engine2 = class extends import_events4.EventEmitter {
  /**
   * The core Engine constructor uses the following options:
   * 
   * ```js
   * var defaultOptions = {
   *    debug: false,
   *    silent: false,
   *    playerHeight: 1.8,
   *    playerWidth: 0.6,
   *    playerStart: [0, 10, 0],
   *    playerAutoStep: false,
   *    playerShadowComponent: true,
   *    tickRate: 30,           // ticks per second
   *    maxRenderRate: 0,       // max FPS, 0 for uncapped 
   *    blockTestDistance: 10,
   *    stickyPointerLock: true,
   *    dragCameraOutsidePointerLock: true,
   *    stickyFullscreen: false,
   *    skipDefaultHighlighting: false,
   *    originRebaseDistance: 25,
   * }
   * ```
   * 
   * **Events:**
   *  + `tick => (dt)`  
   *    Tick update, `dt` is (fixed) tick duration in ms
   *  + `beforeRender => (dt)`  
   *    `dt` is the time (in ms) since the most recent tick
   *  + `afterRender => (dt)`  
   *    `dt` is the time (in ms) since the most recent tick
   *  + `targetBlockChanged => (blockInfo)`  
   *    Emitted each time the user's targeted world block changes
   *  + `addingTerrainMesh => (mesh)`  
   *    Alerts client about a terrain mesh being added to the scene
   *  + `removingTerrainMesh => (mesh)`  
   *    Alerts client before a terrain mesh is removed.
  */
  constructor(opts = {}) {
    super();
    opts = Object.assign({}, defaultOptions5, opts);
    this.version = version2;
    if (!opts.silent) {
      var debugstr = opts.debug ? " (debug)" : "";
      console.log(`noa-engine v${this.version}${debugstr}`);
    }
    this._paused = false;
    this._originRebaseDistance = opts.originRebaseDistance;
    this.worldOriginOffset = [0, 0, 0];
    this.positionInCurrentTick = 0;
    this.worldName = "default";
    this.timeScale = 1;
    this.container = new Container(this, opts);
    this.tickRate = this.container._shell.tickRate;
    Object.defineProperty(this, "tickRate", {
      get: () => this.container._shell.tickRate
    });
    this.maxRenderRate = this.container._shell.maxRenderRate;
    Object.defineProperty(this, "maxRenderRate", {
      get: () => this.container._shell.maxRenderRate,
      set: (v) => {
        this.container._shell.maxRenderRate = v || 0;
      }
    });
    this.inputs = new Inputs(this, opts, this.container.element);
    this.registry = new Registry(this, opts);
    this.world = new World(this, opts);
    var _consoleLog = console.log;
    if (opts.silentBabylon) console.log = () => {
    };
    this.rendering = new Rendering(this, opts, this.container.canvas);
    if (opts.silentBabylon) console.log = _consoleLog;
    this.physics = new Physics2(this, opts);
    this.entities = new Entities(this, opts);
    this.ents = this.entities;
    var ents = this.entities;
    this.playerEntity = ents.add(
      opts.playerStart,
      // starting location
      opts.playerWidth,
      opts.playerHeight,
      null,
      null,
      // no mesh for now, no meshOffset, 
      true,
      opts.playerShadowComponent
    );
    ents.addComponent(this.playerEntity, ents.names.collideTerrain);
    ents.addComponent(this.playerEntity, ents.names.collideEntities);
    var body = ents.getPhysics(this.playerEntity).body;
    body.gravityMultiplier = 2;
    body.autoStep = opts.playerAutoStep;
    ents.addComponent(this.playerEntity, ents.names.receivesInputs);
    ents.addComponent(this.playerEntity, ents.names.fadeOnZoom);
    ents.addComponent(this.playerEntity, ents.names.movement, {
      airJumps: 1
    });
    this.camera = new Camera2(this, opts);
    this.blockTestDistance = opts.blockTestDistance;
    this.blockTargetIdCheck = this.registry.getBlockSolidity;
    this.targetedBlock = null;
    if (!opts.skipDefaultHighlighting) {
      this.defaultBlockHighlightFunction = (tgt) => {
        if (tgt) {
          this.rendering.highlightBlockFace(true, tgt.position, tgt.normal);
        } else {
          this.rendering.highlightBlockFace(false);
        }
      };
      this.on("targetBlockChanged", this.defaultBlockHighlightFunction);
    }
    this._terrainMesher = new TerrainMesher(this);
    this._objectMesher = new ObjectMesher(this);
    this._targetedBlockDat = {
      blockID: 0,
      position: import_gl_vec312.default.create(),
      normal: import_gl_vec312.default.create(),
      adjacent: import_gl_vec312.default.create()
    };
    this._prevTargetHash = 0;
    this._pickPos = import_gl_vec312.default.create();
    this._pickResult = {
      _localPosition: import_gl_vec312.default.create(),
      position: [0, 0, 0],
      normal: [0, 0, 0]
    };
    if (opts.debug) {
      this.vec3 = import_gl_vec312.default;
      this.ndarray = import_ndarray3.default;
      ents.getMovement(1).airJumps = 999;
      var win = (
        /** @type {any} */
        window
      );
      win.noa = this;
      win.vec3 = import_gl_vec312.default;
      win.ndarray = import_ndarray3.default;
      win.scene = this.rendering.scene;
    }
    deprecateStuff(this);
  }
  /*
   *
   *
   *              Core Engine APIs
   *
   *
  */
  /**
   * Tick function, called by container module at a fixed timestep. 
   * Clients should not normally need to call this manually.
   * @internal
  */
  tick(dt) {
    dt *= this.timeScale || 1;
    if (this._paused) {
      if (this.world.worldGenWhilePaused) this.world.tick();
      return;
    }
    profile_hook5("start");
    checkWorldOffset(this);
    this.world.tick();
    profile_hook5("world");
    if (!this.world.playerChunkLoaded) {
      this.rendering.tick(dt);
      return;
    }
    this.physics.tick(dt);
    profile_hook5("physics");
    this._objectMesher.tick();
    this.rendering.tick(dt);
    profile_hook5("rendering");
    updateBlockTargets(this);
    profile_hook5("targets");
    this.entities.tick(dt);
    profile_hook5("entities");
    this.emit("tick", dt);
    profile_hook5("tick event");
    profile_hook5("end");
    var pst = this.inputs.pointerState;
    pst.scrollx = pst.scrolly = pst.scrollz = 0;
  }
  /**
   * Render function, called every animation frame. Emits #beforeRender(dt), #afterRender(dt) 
   * where dt is the time in ms *since the last tick*.
   * Clients should not normally need to call this manually.
   * @internal
  */
  render(dt, framePart) {
    dt *= this.timeScale || 1;
    this.positionInCurrentTick = framePart;
    if (this._paused) {
      if (this.world.worldGenWhilePaused) this.world.render();
      return;
    }
    profile_hook_render("start");
    this.camera.applyInputsToCamera();
    profile_hook_render("init");
    this.world.render();
    profile_hook_render("meshing");
    this.camera.updateBeforeEntityRenderSystems();
    this.entities.render(dt);
    this.camera.updateAfterEntityRenderSystems();
    profile_hook_render("entities");
    this.emit("beforeRender", dt);
    profile_hook_render("before render");
    this.rendering.render();
    this.rendering.postRender();
    profile_hook_render("render");
    this.emit("afterRender", dt);
    profile_hook_render("after render");
    profile_hook_render("end");
    this.inputs.pointerState.dx = this.inputs.pointerState.dy = 0;
  }
  /** Pausing the engine will also stop render/tick events, etc. */
  setPaused(paused = false) {
    this._paused = !!paused;
    if (!paused) {
      this.inputs.pointerState.dx = this.inputs.pointerState.dy = 0;
    }
  }
  /** 
   * Get the voxel ID at the specified position
  */
  getBlock(x, y = 0, z = 0) {
    if (x.length) return this.world.getBlockID(x[0], x[1], x[2]);
    return this.world.getBlockID(x, y, z);
  }
  /** 
   * Sets the voxel ID at the specified position. 
   * Does not check whether any entities are in the way! 
   */
  setBlock(id, x, y = 0, z = 0) {
    if (x.length) return this.world.setBlockID(id, x[0], x[1], x[2]);
    return this.world.setBlockID(id, x, y, z);
  }
  /**
   * Adds a block, unless there's an entity in the way.
  */
  addBlock(id, x, y = 0, z = 0) {
    if (x.length) {
      if (this.entities.isTerrainBlocked(x[0], x[1], x[2])) return;
      this.world.setBlockID(id, x[0], x[1], x[2]);
      return id;
    } else {
      if (this.entities.isTerrainBlocked(x, y, z)) return;
      this.world.setBlockID(id, x, y, z);
      return id;
    }
  }
  /*
   *              Rebasing local <-> global coords
  */
  /** 
   * Precisely converts a world position to the current internal 
   * local frame of reference.
   * 
   * See `/docs/positions.md` for more info.
   * 
   * Params: 
   *  * `global`: input position in global coords
   *  * `globalPrecise`: (optional) sub-voxel offset to the global position
   *  * `local`: output array which will receive the result
   */
  globalToLocal(global2, globalPrecise, local2) {
    var off = this.worldOriginOffset;
    if (globalPrecise) {
      for (var i = 0; i < 3; i++) {
        var coord = global2[i] - off[i];
        coord += globalPrecise[i];
        local2[i] = coord;
      }
      return local2;
    } else {
      return import_gl_vec312.default.subtract(local2, global2, off);
    }
  }
  /** 
   * Precisely converts a world position to the current internal 
   * local frame of reference.
   * 
   * See `/docs/positions.md` for more info.
   * 
   * Params: 
   *  * `local`: input array of local coords
   *  * `global`: output array which receives the result
   *  * `globalPrecise`: (optional) sub-voxel offset to the output global position
   * 
   * If both output arrays are passed in, `global` will get int values and 
   * `globalPrecise` will get fractional parts. If only one array is passed in,
   * `global` will get the whole output position.
  */
  localToGlobal(local2, global2, globalPrecise = null) {
    var off = this.worldOriginOffset;
    if (globalPrecise) {
      for (var i = 0; i < 3; i++) {
        var floored = Math.floor(local2[i]);
        global2[i] = floored + off[i];
        globalPrecise[i] = local2[i] - floored;
      }
      return global2;
    } else {
      return import_gl_vec312.default.add(global2, local2, off);
    }
  }
  /*
   *              Picking / raycasting
  */
  /**
   * Raycast through the world, returning a result object for any non-air block
   * 
   * See `/docs/positions.md` for info on working with precise positions.
   * 
   * @param {number[]} pos where to pick from (default: player's eye pos)
   * @param {number[]} dir direction to pick along (default: camera vector)
   * @param {number} dist pick distance (default: `noa.blockTestDistance`)
   * @param {(id:number) => boolean} blockTestFunction which voxel IDs can be picked (default: any solid voxel)
  */
  pick(pos = null, dir = null, dist2 = -1, blockTestFunction = null) {
    if (dist2 === 0) return null;
    var pickPos = this._pickPos;
    if (pos) {
      this.globalToLocal(pos, null, pickPos);
      pos = pickPos;
    }
    return this._localPick(pos, dir, dist2, blockTestFunction);
  }
  /**
   * @internal
   * Do a raycast in local coords. 
   * See `/docs/positions.md` for more info.
   * @param {number[]} pos where to pick from (default: player's eye pos)
   * @param {number[]} dir direction to pick along (default: camera vector)
   * @param {number} dist pick distance (default: `noa.blockTestDistance`)
   * @param {(id:number) => boolean} blockTestFunction which voxel IDs can be picked (default: any solid voxel)
   * @returns { null | {
   *      position: number[],
   *      normal: number[],
   *      _localPosition: number[],
   * }}
   */
  _localPick(pos = null, dir = null, dist2 = -1, blockTestFunction = null) {
    if (dist2 === 0) return null;
    var testFn = blockTestFunction || this.registry.getBlockSolidity;
    var world = this.world;
    var off = this.worldOriginOffset;
    var testVoxel = function(x, y, z) {
      var id = world.getBlockID(x + off[0], y + off[1], z + off[2]);
      return testFn(id);
    };
    if (!pos) pos = this.camera._localGetTargetPosition();
    dir = dir || this.camera.getDirection();
    dist2 = dist2 || -1;
    if (dist2 < 0) dist2 = this.blockTestDistance;
    var result = this._pickResult;
    var rpos = result._localPosition;
    var rnorm = result.normal;
    var hit = (0, import_fast_voxel_raycast.default)(testVoxel, pos, dir, dist2, rpos, rnorm);
    if (!hit) return null;
    import_gl_vec312.default.scaleAndAdd(rpos, rpos, rnorm, 0.01);
    this.localToGlobal(rpos, result.position);
    return result;
  }
};
function checkWorldOffset(noa) {
  var lpos = noa.ents.getPositionData(noa.playerEntity)._localPosition;
  var cutoff = noa._originRebaseDistance;
  if (import_gl_vec312.default.sqrLen(lpos) < cutoff * cutoff) return;
  var delta = [];
  for (var i = 0; i < 3; i++) {
    delta[i] = Math.floor(lpos[i]);
    noa.worldOriginOffset[i] += delta[i];
  }
  noa.rendering._rebaseOrigin(delta);
  noa.entities._rebaseOrigin(delta);
  noa._objectMesher._rebaseOrigin(delta);
}
function updateBlockTargets(noa) {
  var newhash = 0;
  var blockIdFn = noa.blockTargetIdCheck || noa.registry.getBlockSolidity;
  var result = noa._localPick(null, null, null, blockIdFn);
  if (result) {
    var dat = noa._targetedBlockDat;
    import_gl_vec312.default.floor(dat.adjacent, result.position);
    import_gl_vec312.default.copy(dat.normal, result.normal);
    import_gl_vec312.default.subtract(dat.position, dat.adjacent, dat.normal);
    dat.blockID = noa.world.getBlockID(dat.position[0], dat.position[1], dat.position[2]);
    noa.targetedBlock = dat;
    var pos = dat.position, norm = dat.normal;
    var x = locationHasher(pos[0] + dat.blockID, pos[1], pos[2]);
    x ^= locationHasher(norm[0], norm[1] + dat.blockID, norm[2]);
    newhash = x;
  } else {
    noa.targetedBlock = null;
  }
  if (newhash != noa._prevTargetHash) {
    noa.emit("targetBlockChanged", noa.targetedBlock);
    noa._prevTargetHash = newhash;
  }
}
function deprecateStuff(noa) {
  var ver = `0.27`;
  var dep = (loc, name66, msg) => {
    var throwFn = () => {
      throw `This property changed in ${ver} - ${msg}`;
    };
    Object.defineProperty(loc, name66, { get: throwFn, set: throwFn });
  };
  dep(noa, "getPlayerEyePosition", "to get the camera/player offset see API docs for `noa.camera.cameraTarget`");
  dep(noa, "setPlayerEyePosition", "to set the camera/player offset see API docs for `noa.camera.cameraTarget`");
  dep(noa, "getPlayerPosition", "use `noa.ents.getPosition(noa.playerEntity)` or similar");
  dep(noa, "getCameraVector", "use `noa.camera.getDirection`");
  dep(noa, "getPlayerMesh", "use `noa.ents.getMeshData(noa.playerEntity).mesh` or similar");
  dep(noa, "playerBody", "use `noa.ents.getPhysicsBody(noa.playerEntity)`");
  dep(noa.rendering, "zoomDistance", "use `noa.camera.zoomDistance`");
  dep(noa.rendering, "_currentZoom", "use `noa.camera.currentZoom`");
  dep(noa.rendering, "_cameraZoomSpeed", "use `noa.camera.zoomSpeed`");
  dep(noa.rendering, "getCameraVector", "use `noa.camera.getDirection`");
  dep(noa.rendering, "getCameraPosition", "use `noa.camera.getLocalPosition`");
  dep(noa.rendering, "getCameraRotation", "use `noa.camera.heading` and `noa.camera.pitch`");
  dep(noa.rendering, "setCameraRotation", "to customize camera behavior see API docs for `noa.camera`");
  ver = "0.28";
  dep(noa.rendering, "makeMeshInstance", "removed, use Babylon's `mesh.createInstance`");
  dep(noa.world, "_maxChunksPendingCreation", 'use `maxChunksPendingCreation` (no "_")');
  dep(noa.world, "_maxChunksPendingMeshing", 'use `maxChunksPendingMeshing` (no "_")');
  dep(noa.world, "_maxProcessingPerTick", 'use `maxProcessingPerTick` (no "_")');
  dep(noa.world, "_maxProcessingPerRender", 'use `maxProcessingPerRender` (no "_")');
  ver = "0.29";
  dep(noa, "_constants", "removed, voxel IDs are no longer packed with bit flags");
  ver = "0.30";
  dep(noa, "_tickRate", "tickRate is now at `noa.tickRate`");
  dep(noa.container, "_tickRate", "tickRate is now at `noa.tickRate`");
  ver = "0.31";
  dep(noa.world, "chunkSize", "effectively an internal, so changed to `_chunkSize`");
  dep(noa.world, "chunkAddDistance", "set this with `noa.world.setAddRemoveDistance`");
  dep(noa.world, "chunkRemoveDistance", "set this with `noa.world.setAddRemoveDistance`");
  ver = "0.33";
  dep(noa.rendering, "postMaterialCreationHook", "Removed - use mesh post-creation hook instead`");
}
var profile_hook5 = PROFILE3 > 0 ? makeProfileHook(PROFILE3, "tick   ") : () => {
};
var profile_hook_render = PROFILE_RENDER > 0 ? makeProfileHook(PROFILE_RENDER, "render ") : () => {
};
export {
  Engine2 as Engine
};
//# sourceMappingURL=noa-engine.js.map
